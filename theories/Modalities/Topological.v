(* -*- mode: coq; mode: visual-line -*- *)
Require Import HoTT.Basics HoTT.Types.
Require Import Extensions.
Require Import Modality Accessible Lex Nullification.

Local Open Scope path_scope.


(** * Topological localizations *)

(** A topological localization -- or, as we will say, a topological nullification -- is a nullification at a family of hprops, or more generally an accessible modality whose generators of accessibility are all hprops.  This is not quite the same as Lurie's definition: in Higher Topos Theory, a topological localization is an accessible *left exact* localization at a pullback-stable class generated by a set of monomorphisms.  "Pullback-stable class generated by" is roughly incorporated into our internal notion of accessibility, so the main new difference here is that when the generation is internal in this way, the localization at a family of hprops is *automatically* left exact. *)

Module Topological_Modalities_Theory
       (Os : Modalities) (Acc : Accessible_Modalities Os).

  Module Export Acc_Lex_Theory := Accessible_Lex_Modalities_Theory Os Acc.

  Notation Topological O := (forall i, IsHProp (acc_gen O i)).

  (** ** Topological modalities are lex *)

  (** We prove left-exactness by proving that the universe of modal types is modal.  Of course, this requires univalence. *)

  Global Instance lex_topological `{Univalence}
         (O : Modality) `{Topological O}
  : Lex O.
  Proof.
    apply lex_inO_typeO.
    refine (snd (inO_iff_isnull O _) _); intros i.
    refine (equiv_inverse (equiv_ooextendable_isequiv _ _) _).
    simple refine (isequiv_adjointify _ _ _ _); simpl.
    - intros B _.
      refine ((forall a, B a) ; _).
      exact _.
    - intros B.
      apply path_arrow; intros a.
      apply path_TypeO, path_universe_uncurried.
      unfold composeD; simpl.
      simple refine (equiv_adjointify _ _ _ _).
      + intros f. exact (f a).
      + intros b a'. exact (transport B (path_ishprop a a') b).
      + intros b.
        refine (transport2 B (path_contr _ 1) b).
      + intros f. apply path_forall; intros a'.
        exact (apD f _).
    - intros B.
      apply path_arrow; intros [].
      apply path_TypeO, path_universe_uncurried.
      unfold composeD; simpl.
      pose (e := isequiv_ooextendable _ _
                                      (fst (inO_iff_isnull O (B tt)) (inO_TypeO (B tt)) i)).
      unfold composeD in e; simpl in e.
      refine (_ oE (BuildEquiv _ _ _ e)^-1).
      exact (equiv_contr_forall _).
  Defined.

End Topological_Modalities_Theory.

(** In particular, a nullification at a family of hprops is topological and therefore lex. *)

Module Import Topological_Nullification_Theory :=
  Topological_Modalities_Theory
    Nullification_Modalities
    Accessible_Nullification.

(** It isn't necessary to declare these as global instances, since typeclass search can find them automatically.  But we want to state them explicitly here for exposition, so we make them local instances. *)
Local Instance topological_nullification
      (O : Nullification_Modality) `{forall i, IsHProp (unNul O i)}
: Topological O.
Proof.
  exact _.
Defined.

(** Note the hypothesis of [Univalence] required for this one.  It's unclear whether this is necessary or not in general; in one special case (open modalities) funext suffices.  But it's plausible that it would be necessary in general, because lex-ness of nullification is a statement about the path-spaces of a HIT, and characterizing those in any way usually requires some amount of univalence. *)
Local Instance lex_nullification `{Univalence}
      (O : Nullification_Modality) `{forall i, IsHProp (unNul O i)}
: Lex O.
Proof.
  exact _.
Defined.
