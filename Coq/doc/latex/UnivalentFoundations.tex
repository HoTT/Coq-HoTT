\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{coqdoc}
\usepackage{amsmath,amssymb}
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This file has been automatically generated with the command
%% coqdoc --latex --toc --utf8 --charset utf8 --interpolate -o doc/latex/UnivalentFoundations.tex Functions.v Paths.v Fibrations.v Contractible.v Equivalences.v FiberEquivalences.v Funext.v Univalence.v UnivalenceImpliesFunext.v UnivalenceAxiom.v HLevel.v Homotopy.v 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\coqlibrary{Functions}{Library }{Functions}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Functions.idmap}{idmap}{\coqdocdefinition{idmap}} \coqdocvar{A} := \coqdockw{fun} \coqdocvar{x} : \coqdocvar{A} \ensuremath{\Rightarrow} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Functions.compose}{compose}{\coqdocdefinition{compose}} \{\coqdocvar{A} \coqdocvar{B} \coqdocvar{C}\} (\coqdocvar{g} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{C}) (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{x} : \coqdocvar{A}) := \coqdocvar{g} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Functions.::x 'o' x}{"}{\coqdocnotation{"}}g 'o' f" := (\coqref{Functions.compose}{\coqdocdefinition{compose}} \coqdocvar{g} \coqdocvar{f}) (\coqdocvar{left} \coqdocvar{associativity}, \coqdoctac{at} \coqdocvar{level} 37).\coqdoceol
\end{coqdoccode}
\coqlibrary{Paths}{Library }{Paths}

\begin{coqdoccode}
\end{coqdoccode}
Basic homotopy-theoretic approach to paths. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Functions}{\coqdoclibrary{Functions}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{Paths.paths}{paths}{\coqdocinductive{paths}} \{\coqdocvar{A}\} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type} := \coqdef{Paths.idpath}{idpath}{\coqdocconstructor{idpath}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Paths.paths}{\coqdocinductive{paths}} \coqdocvar{x} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
We introduce notation \coqdocvar{x} $=$ \coqdocvar{y} for the space \coqref{Paths.paths}{\coqdocinductive{paths}} \coqdocvar{x} \coqdocvar{y} of paths
   from \coqdocvar{x} to \coqdocvar{y}. We can then write \coqdocvar{p} : \coqdocvar{x} $=$ \coqdocvar{y} to indicate that
   \coqdocvar{p} is a path from \coqdocvar{x} to \coqdocvar{y}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Paths.::x '==' x}{"}{\coqdocnotation{"}}x == y" := (\coqref{Paths.paths}{\coqdocinductive{paths}} \coqdocvar{x} \coqdocvar{y}) (\coqdoctac{at} \coqdocvar{level} 70).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The \coqdockw{Hint} \coqdockw{Resolve} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}@ line below means that Coq's \coqdoctac{auto}
   tactic will automatically perform \coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} if that leads to a
   successful solution of the current goal. For example if we ask it
   to construct a path \coqdocvar{x} $=$ \coqdocvar{x}, \coqdoctac{auto} will find the identity path
   \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}, thanks to the \coqdockw{Hint} \coqdockw{Resolve}.


   In general we should declare \coqdockw{Hint} \coqdockw{Resolve} on those theorems which
   are not very complicated but get used often to finish off
   proofs. Notice how we use the non-implicit version \coqref{Paths.idpath}{\coqdocconstructor{idpath}}@ (if we
   try \coqdockw{Hint} \coqdockw{Resolve} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} Coq complains that it cannot guess the
   value of the implicit argument \coqdocvariable{A}).  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint} \coqdockw{Resolve} @\coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following automated tactic applies induction on paths and then
    idpath. It can handle many easy statements.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{path\_induction} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}; \coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} [ \coqdocvar{p} : \coqdocvar{\_} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{\_}  \ensuremath{\vdash} \coqdocvar{\_} ] \ensuremath{\Rightarrow} \coqdoctac{induction} \coqdocvar{p}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvar{idtac}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
); \coqdoctac{auto}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
You can read the tactic definition as follows. We first perform
   \coqdoctac{intros} to move hypotheses into the context. Then we repeat while
   there is still progress: if there is a path \coqdocvar{p} in the context,
   apply induction to it, otherwise perform the \coqdocvar{idtac} which does
   nothing (and so no progress is made and we stop). After that, we
   perform an \coqdoctac{auto}.


   The notation  [... \ensuremath{\vdash} ... ]  is a pattern for contexts. To the
   left of the symbol \ensuremath{\vdash} we list hypotheses and to the right the
   goal. The underscore means "anything".


   In summary \coqdocvar{path\_induction} performs as many inductions on paths as
   it can, then it uses \coqdoctac{auto}.  \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
We now define the basic operations on paths, starting with
   concatenation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.concat}{concat}{\coqdocdefinition{concat}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}\} : (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) \ensuremath{\rightarrow} (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The concatenation of paths \coqdocvar{p} and \coqdocvar{q} is denoted as \coqdocvar{p} @ \coqdocvar{q}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Paths.::x '@' x}{"}{\coqdocnotation{"}}p @ q" := (\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdocvar{p} \coqdocvar{q}) (\coqdoctac{at} \coqdocvar{level} 60).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A definition like \coqref{Paths.concat}{\coqdocdefinition{concat}} can be used in two ways. The first and
   obvious way is as an operation which concatenates together two
   paths. The second use is a proof tactic when we want to construct a
   path \coqdocvar{x} $=$ \coqdocvar{z} as a concatenation of paths \coqdocvar{x} $=$ \coqdocvar{y} $=$ \coqdocvar{z}. This is
   done with \coqdoctac{apply} \coqref{Paths.concat}{\coqdocdefinition{concat}}@, see examples below. We will actually
   define a tactic \coqdocvar{path\_via} which uses \coqref{Paths.concat}{\coqdocdefinition{concat}} but is much smarter
   than just the direct application \coqdoctac{apply} \coqref{Paths.concat}{\coqdocdefinition{concat}}@. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Paths can be reversed. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.opposite}{opposite}{\coqdocdefinition{opposite}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} : (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Notation for the opposite of a path \coqdocvar{p} is ! \coqdocvar{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Paths.::'!' x}{"}{\coqdocnotation{"}}! p" := (\coqref{Paths.opposite}{\coqdocdefinition{opposite}} \coqdocvar{p}) (\coqdoctac{at} \coqdocvar{level} 50).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next we give names to the basic properties of concatenation of
   paths. Note that all statements are "up to a higher path", e.g.,
   the composition of \coqdocvar{p} and the identity path is not equal to \coqdocvar{p}
   but only connected to it with a path. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
The following lemmas say that up to higher paths, the paths form a
   1-groupoid. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.idpath left unit}{idpath\_left\_unit}{\coqdoclemma{idpath\_left\_unit}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.idpath right unit}{idpath\_right\_unit}{\coqdoclemma{idpath\_right\_unit}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{y}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.opposite right inverse}{opposite\_right\_inverse}{\coqdoclemma{opposite\_right\_inverse}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{0.50em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.opposite left inverse}{opposite\_left\_inverse}{\coqdoclemma{opposite\_left\_inverse}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.opposite concat}{opposite\_concat}{\coqdoclemma{opposite\_concat}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) : \coqref{Paths.::'!' x}{\coqdocnotation{!(}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}\coqref{Paths.::'!' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.opposite idpath}{opposite\_idpath}{\coqdoclemma{opposite\_idpath}} \coqdocvar{A} (\coqdocvar{x} : \coqdocvar{A}) : \coqref{Paths.::'!' x}{\coqdocnotation{!(}}\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}\coqref{Paths.::'!' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.opposite opposite}{opposite\_opposite}{\coqdoclemma{opposite\_opposite}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : \coqref{Paths.::'!' x}{\coqdocnotation{!(!}} \coqdocvar{p}\coqref{Paths.::'!' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat associativity}{concat\_associativity}{\coqdoclemma{concat\_associativity}} \coqdocvar{A} (\coqdocvar{w} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{w} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{r} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we move on to the 2-groupoidal structure of a type.
   Concatenation of 2-paths along 1-paths is just ordinary
   concatenation in a path type, but we need a new name and notation
   for concatenation of 2-paths along points. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.concat2}{concat2}{\coqdocdefinition{concat2}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}\} \{\coqdocvar{p} \coqdocvar{p'} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\} \{\coqdocvar{q} \coqdocvar{q'} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}\} :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p'}) \ensuremath{\rightarrow} (\coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q'}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p'} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q'}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Paths.::x '@@' x}{"}{\coqdocnotation{"}}p @@ q" := (\coqref{Paths.concat2}{\coqdocdefinition{concat2}} \coqdocvar{p} \coqdocvar{q}) (\coqdoctac{at} \coqdocvar{level} 60).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We also have whiskering operations. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.whisker right}{whisker\_right}{\coqdocdefinition{whisker\_right}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}\} \{\coqdocvar{p} \coqdocvar{p'} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\} (\coqdocvar{q} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p'}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p'} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.whisker left}{whisker\_left}{\coqdocdefinition{whisker\_left}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}\} \{\coqdocvar{q} \coqdocvar{q'} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q'}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q'}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.whisker right toid}{whisker\_right\_toid}{\coqdocdefinition{whisker\_right\_toid}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} \{\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}\} (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath left unit}{\coqdoclemma{idpath\_left\_unit}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.whisker right fromid}{whisker\_right\_fromid}{\coqdocdefinition{whisker\_right\_fromid}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} \{\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}\} (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}) \ensuremath{\rightarrow} (\coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Paths.idpath left unit}{\coqdoclemma{idpath\_left\_unit}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}}. \coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.whisker left toid}{whisker\_left\_toid}{\coqdocdefinition{whisker\_left\_toid}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} \{\coqdocvar{p} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\} (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{y}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath right unit}{\coqdoclemma{idpath\_right\_unit}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.whisker left fromid}{whisker\_left\_fromid}{\coqdocdefinition{whisker\_left\_fromid}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} \{\coqdocvar{p} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\} (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}) \ensuremath{\rightarrow} (\coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{y}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Paths.idpath right unit}{\coqdoclemma{idpath\_right\_unit}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}}. \coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The interchange law for whiskering. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.whisker interchange}{whisker\_interchange}{\coqdocdefinition{whisker\_interchange}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} \coqdocvar{p'} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} \coqdocvar{q'} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{a} : \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p'}) (\coqdocvar{b} : \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q'}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}} \coqdocvar{q} \coqdocvar{a}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}} \coqdocvar{p'} \coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}} \coqdocvar{p} \coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}} \coqdocvar{q'} \coqdocvar{a}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The interchange law for concatenation. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.concat2 interchange}{concat2\_interchange}{\coqdocdefinition{concat2\_interchange}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} \coqdocvar{p'} \coqdocvar{p''} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} \coqdocvar{q'} \coqdocvar{q''} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{a} : \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p'}) (\coqdocvar{b} : \coqdocvar{p'} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p''}) (\coqdocvar{c} : \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q'}) (\coqdocvar{d} : \coqdocvar{q'} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q''}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{a} \coqref{Paths.::x '@@' x}{\coqdocnotation{@@}} \coqdocvar{c}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{b} \coqref{Paths.::x '@@' x}{\coqdocnotation{@@}} \coqdocvar{d}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '@@' x}{\coqdocnotation{(}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{b}\coqref{Paths.::x '@@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@@' x}{\coqdocnotation{@@}} \coqref{Paths.::x '@@' x}{\coqdocnotation{(}}\coqdocvar{c} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{d}\coqref{Paths.::x '@@' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Taking opposites of 1-paths is functorial on 2-paths. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.opposite2}{opposite2}{\coqdocdefinition{opposite2}} \coqdocvar{A} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{p} \coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{a} : \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}) : (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we consider the application of functions to paths. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
A path \coqdocvar{p} : \coqdocvar{x} $=$ \coqdocvar{y} in a space \coqdocvariable{A} is mapped by \coqdocvariable{f} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdocvariable{B} to a
   path \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{f} \coqdocvar{p} : \coqdocvariable{f} \coqdocvar{x} $=$ \coqdocvariable{f} \coqdocvar{y} in \coqdocvariable{B}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.map}{map}{\coqdoclemma{map}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) : (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The next two lemmas state that \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{f} \coqdocvar{p} is "functorial" in the path \coqdocvar{p}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.idpath map}{idpath\_map}{\coqdoclemma{idpath\_map}} \coqdocvar{A} \coqdocvar{B} (\coqdocvar{x} : \coqdocvar{A}) (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) : \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat map}{concat\_map}{\coqdoclemma{concat\_map}} \coqdocvar{A} \coqdocvar{B} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{q}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.opposite map}{opposite\_map}{\coqdoclemma{opposite\_map}} \coqdocvar{A} \coqdocvar{B} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqdocvar{p}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is also the case that \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{f} \coqdocvar{p} is functorial in \coqdocvariable{f}.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.idmap map}{idmap\_map}{\coqdoclemma{idmap\_map}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : \coqref{Paths.map}{\coqdoclemma{map}} (\coqref{Functions.idmap}{\coqdocdefinition{idmap}} \coqdocvar{A}) \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.compose map}{compose\_map}{\coqdoclemma{compose\_map}} \coqdocvar{A} \coqdocvar{B} \coqdocvar{C} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{g} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{C}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.map}{\coqdoclemma{map}} (\coqdocvar{g} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{f}) \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can also map paths between paths. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.map2}{map2}{\coqdocdefinition{map2}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} \{\coqdocvar{p} \coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q} \ensuremath{\rightarrow} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{q})\coqdoceol
\coqdocindent{1.00em}
:= \coqref{Paths.map}{\coqdoclemma{map}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The type of "homotopies" between two functions \coqdocvariable{f} and \coqdocvariable{g} is
   \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{f} \coqdocvar{x} $=$ \coqdocvariable{g} \coqdocvar{x}.  These can be derived from "paths" between
   functions \coqdocvariable{f} $=$ \coqdocvariable{g}; the converse is function extensionality. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.happly}{happly}{\coqdocdefinition{happly}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{f} \coqdocvar{g} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}\} : (\coqdocvar{f} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g}) \ensuremath{\rightarrow} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} \coqdocvar{x}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{p} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Paths.map}{\coqdoclemma{map}} (\coqdockw{fun} \coqdocvar{h} \ensuremath{\Rightarrow} \coqdocvar{h} \coqdocvar{x}) \coqdocvar{p}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, \coqref{Paths.happly}{\coqdocdefinition{happly}} for dependent functions. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Paths.happly dep}{happly\_dep}{\coqdocdefinition{happly\_dep}} \{\coqdocvar{A}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{f} \coqdocvar{g} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}\} :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g}) \ensuremath{\rightarrow} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} \coqdocvar{x}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{p} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Paths.map}{\coqdoclemma{map}} (\coqdockw{fun} \coqdocvar{h} \ensuremath{\Rightarrow} \coqdocvar{h} \coqdocvar{x}) \coqdocvar{p}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We declare some more \coqdockw{Hint} \coqdockw{Resolve} hints, now in the "hint
   database" \coqdocvar{path\_hints}.  In general various hints (resolve,
   rewrite, unfold hints) can be grouped into "databases". This is
   necessary as sometimes different kinds of hints cannot be mixed,
   for example because they would cause a combinatorial explosion or
   rewriting cycles.


   A specific \coqdockw{Hint} \coqdockw{Resolve} database \coqdocvar{db} can be used with \coqdoctac{auto} \coqdockw{with} \coqdocvar{db}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint} \coqdockw{Resolve}\coqdoceol
\coqdocindent{1.00em}
@\coqref{Paths.idpath}{\coqdocconstructor{idpath}} @\coqref{Paths.opposite}{\coqdocdefinition{opposite}}\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.idpath left unit}{\coqdoclemma{idpath\_left\_unit}} \coqref{Paths.idpath right unit}{\coqdoclemma{idpath\_right\_unit}}\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.opposite right inverse}{\coqdoclemma{opposite\_right\_inverse}} \coqref{Paths.opposite left inverse}{\coqdoclemma{opposite\_left\_inverse}}\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.opposite concat}{\coqdoclemma{opposite\_concat}} \coqref{Paths.opposite idpath}{\coqdoclemma{opposite\_idpath}} \coqref{Paths.opposite opposite}{\coqdoclemma{opposite\_opposite}}\coqdoceol
\coqdocindent{1.00em}
@\coqref{Paths.concat2}{\coqdocdefinition{concat2}}\coqdoceol
\coqdocindent{1.00em}
@\coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}} @\coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}}\coqdoceol
\coqdocindent{1.00em}
@\coqref{Paths.whisker right toid}{\coqdocdefinition{whisker\_right\_toid}} @\coqref{Paths.whisker right fromid}{\coqdocdefinition{whisker\_right\_fromid}}\coqdoceol
\coqdocindent{1.00em}
@\coqref{Paths.whisker left toid}{\coqdocdefinition{whisker\_left\_toid}} @\coqref{Paths.whisker left fromid}{\coqdocdefinition{whisker\_left\_fromid}}\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.opposite2}{\coqdocdefinition{opposite2}}\coqdoceol
\coqdocindent{1.00em}
@\coqref{Paths.map}{\coqdoclemma{map}} \coqref{Paths.idpath map}{\coqdoclemma{idpath\_map}} \coqref{Paths.concat map}{\coqdoclemma{concat\_map}} \coqref{Paths.idmap map}{\coqdoclemma{idmap\_map}} \coqref{Paths.compose map}{\coqdoclemma{compose\_map}} \coqref{Paths.opposite map}{\coqdoclemma{opposite\_map}}\coqdoceol
\coqdocindent{1.00em}
@\coqref{Paths.map2}{\coqdocdefinition{map2}}\coqdoceol
\coqdocindent{0.50em}
: \coqdocvar{path\_hints}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can add more hints to the database later. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
For some reason, \coqdoctac{apply} \coqref{Paths.happly}{\coqdocdefinition{happly}} and \coqdoctac{apply} \coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} often seem
   to fail unification.  This tactic does the work that I think they
   should be doing. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{apply\_happly} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{f'} ?\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{g'} ?\coqdocvar{x} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{first} [\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{apply} @\coqref{Paths.happly}{\coqdocdefinition{happly}} \coqdockw{with} (\coqdocvar{f} := \coqdocvar{f'}) (\coqdocvar{g} := \coqdocvar{g'})\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdoctac{apply} @\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} \coqdockw{with} (\coqdocvar{f} := \coqdocvar{f'}) (\coqdocvar{g} := \coqdocvar{g'})\coqdoceol
\coqdocindent{3.00em}
]\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following tactic is intended to be applied when we want to
   find a path between two expressions which are largely the same, but
   differ in the value of some subexpression.  Therefore, it does its
   best to "peel off" all the parts of both sides that are the same,
   repeatedly, until only the "core" bit of difference is left.  Then
   it performs an \coqdoctac{auto} using the \coqdocvar{path\_hints} database. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{path\_simplify} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} \coqdocvar{first} [\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdoctac{apply} \coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdoctac{apply} @\coqref{Paths.map}{\coqdoclemma{map}}\coqdoceol
\coqdocindent{2.00em}
]; \coqdoctac{auto} \coqdockw{with} \coqdocvar{path\_hints}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following variant allows the caller to supply an additional
   lemma to be tried (for instance, if the caller expects the core
   difference to be resolvable by using a particular lemma). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{path\_simplify'} \coqdocvar{lem} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} \coqdocvar{first} [\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdoctac{apply} \coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdoctac{apply} @\coqref{Paths.map}{\coqdoclemma{map}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdoctac{apply} \coqdocvar{lem}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}; \coqdoctac{apply} \coqdocvar{lem}\coqdoceol
\coqdocindent{2.00em}
]; \coqdoctac{auto} \coqdockw{with} \coqdocvar{path\_hints}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
These tactics are used to construct a path \coqdocvar{a} $=$ \coqdocvar{b} as a
   composition of paths \coqdocvar{a} $=$ \coqdocvar{x} and \coqdocvar{x} $=$ \coqdocvar{b}.  They then apply
   \coqdocvar{path\_simplify} to both paths, along with possibly an additional
   lemma supplied by the user. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{path\_via} \coqdocvar{mid} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{mid}); \coqdocvar{path\_simplify}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{lem} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{mid}); \coqdocvar{path\_simplify'} \coqdocvar{lem}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This variant does not call path\_simplify. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{path\_via'} \coqdocvar{mid} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{mid}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here are some tactics for reassociating concatenations.  The
   tactic \coqdocvar{associate\_right} associates both source and target of the
   goal all the way to the right, and dually for \coqdocvar{associate\_left}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{associate\_right\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::x '@' x}{\coqdocnotation{(?}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{c} ] \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{2.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{b} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{c}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}] \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{associate\_right} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{associate\_right\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{associate\_right\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{associate\_left\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{context} \coqdocvar{cxt} [ ?\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(?}}\coqdocvar{b} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{c}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{2.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{c}] \coqdoctac{in}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{associate\_left} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{associate\_left\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{associate\_left\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This tactic unwhiskers by paths on both sides, reassociating as
   necessary. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{unwhisker} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_left};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} \coqdoctac{apply} \coqref{Paths.whisker right}{\coqdocdefinition{whisker\_right}};\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_right};\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} \coqdoctac{apply} \coqref{Paths.whisker left}{\coqdocdefinition{whisker\_left}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here are some tactics for eliminating identities.  The tactic
   \coqdocvar{cancel\_units} tries to remove all identity paths and functions
   from both source and target of the goal. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_units\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.idpath}{\coqdocconstructor{idpath}} ?\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{p} ] \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[\coqdocvar{p}] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{idpath\_left\_unit}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ ?\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} ?\coqdocvar{a} ] \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[\coqdocvar{p}] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{idpath\_right\_unit}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} ?\coqdocvar{x}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[\coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{idpath\_map}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} (\coqref{Functions.idmap}{\coqdocdefinition{idmap}} \coqdocvar{\_}) ?\coqdocvar{p} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[\coqdocvar{p}] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{idmap\_map}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{(}}\coqref{Paths.idpath}{\coqdocconstructor{idpath}} ?\coqdocvar{a}\coqref{Paths.::'!' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{a}] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_idpath}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_units} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{cancel\_units\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{cancel\_units\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And some tactics for eliminating matched pairs of opposites. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
This is an auxiliary tactic which performs one step of a
   reassociation of \coqdocvar{s} (which is the source or target of a path) so
   as to get !\coqdocvar{p} to be closer to being concatenated on the left with
   something irreducible.  If there is more than one copy of !\coqdocvar{p} in
   \coqdocvar{s}, then this tactic finds the first one which is concatenated on
   the left with anything (irreducible or not), or if there is no such
   occurrence of !\coqdocvar{p}, then finds the first one overall.  If this !\coqdocvar{p}
   is already concatenated on the left with something irreducible,
   then if that something is a \coqdocvar{p}, it cancels them.  If that
   something is not a \coqdocvar{p}, then it fails.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{partly\_cancel\_left\_opposite\_of\_in} \coqdocvar{p} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdocvar{\_} ?\coqdocvar{trg} \coqdocvar{\_} \coqdocvar{\_} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}) \coqdocvar{p} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{trg} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_left\_inverse}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(?}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{a}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{b} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{\_} ] \ensuremath{\Rightarrow} \coqdoctac{fail} 1\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::x '@' x}{\coqdocnotation{(?}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{b} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ ?\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(?}}\coqdocvar{b} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end};\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This tactic simply calls the previous one for the source and the
   target, repeatedly, until it can no longer make progress.
   \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_left\_opposite\_of} \coqdocvar{p} := \coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [\coqdoceol
\coqdocindent{5.00em}
\coqdocvar{partly\_cancel\_left\_opposite\_of\_in} \coqdocvar{p} \coqdocvar{s}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{partly\_cancel\_left\_opposite\_of\_in} \coqdocvar{p} \coqdocvar{t}\coqdoceol
\coqdocindent{3.00em}
]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now the same thing on the right \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{partly\_cancel\_right\_opposite\_of\_in} \coqdocvar{p} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdocvar{\_} ?\coqdocvar{src} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{p} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{src} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_right\_inverse}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::x '@' x}{\coqdocnotation{(?}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{b} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{\_} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} ] \ensuremath{\Rightarrow} \coqdoctac{fail} 1\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ ?\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{b} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{a}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{b} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt}[ \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{a} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{b}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_associativity}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end};\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_right\_opposite\_of} \coqdocvar{p} := \coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [\coqdoceol
\coqdocindent{5.00em}
\coqdocvar{partly\_cancel\_right\_opposite\_of\_in} \coqdocvar{p} \coqdocvar{s}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{partly\_cancel\_right\_opposite\_of\_in} \coqdocvar{p} \coqdocvar{t}\coqdoceol
\coqdocindent{3.00em}
]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This tactic tries to cancel !\coqdocvar{p} on both the left and the right. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_opposite\_of} \coqdocvar{p} :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_left\_opposite\_of} \coqdocvar{p};\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_right\_opposite\_of} \coqdocvar{p}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This tactic looks in \coqdocvar{s} for an opposite of anything, and for the
   first one it finds, it tries to cancel it on both sides.  \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_opposites\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!(?}}\coqdocvar{p}\coqref{Paths.::'!' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow} \coqdocvar{cancel\_opposite\_of} \coqdocvar{p}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Finally, this tactic repeats the previous one as long as it gets
   us somewhere.  This is most often the easiest of these tactics to
   call in an interactive proof.


   This tactic is not the be-all and end-all of opposite-canceling,
   however; it only works until it runs into an opposite that it can't
   cancel.  It can get stymied by something like !\coqdocvar{p} @ !\coqdocvar{q} @ \coqdocvar{q}, which
   should simplify to !\coqdocvar{p}, but the tactic simply tries to cancel
   !\coqdocvar{p}, makes no progress, and stops.  In such a situation one must
   call \coqdocvar{cancel\_opposite\_of} \coqdocvar{q} directly (or figure out how to write a
   smarter tactic!).  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_opposites} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{cancel\_opposites\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{cancel\_opposites\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we have a sequence of fairly boring tactics, each of which
   corresponds to a simple lemma.  Each of these tactics repeatedly
   looks for occurrences, in either the source or target of the goal,
   of something whose form can be changed by the lemma in question,
   then calls \coqdocvar{path\_using} to change it.


   For each lemma the basic tactic is called \coqdocvar{do\_LEMMA}.  If the lemma
   can sensibly be applied in two directions, there is also an
   \coqdocvar{undo\_LEMMA} tactic.  \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Tactics for \coqref{Paths.opposite opposite}{\coqdoclemma{opposite\_opposite}} \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_opposite\_opposite\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{(!}} \coqref{Paths.::'!' x}{\coqdocnotation{?}}\coqdocvar{p}\coqref{Paths.::'!' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{p} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_opposite}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_opposite\_opposite} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{do\_opposite\_opposite\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{do\_opposite\_opposite\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Tactics for \coqref{Paths.opposite map}{\coqdoclemma{opposite\_map}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{apply\_opposite\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f'} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{?}}\coqdocvar{p'}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f'} ?\coqdocvar{p'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.opposite map}{\coqdoclemma{opposite\_map}} \coqdockw{with} (\coqdocvar{f} := \coqdocvar{f'}) (\coqdocvar{p} := \coqdocvar{p'})\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f'} ?\coqdocvar{p'} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f'} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{?}}\coqdocvar{p'}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Paths.opposite map}{\coqdoclemma{opposite\_map}} \coqdockw{with} (\coqdocvar{f} := \coqdocvar{f'}) (\coqdocvar{p} := \coqdocvar{p'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_opposite\_map\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{?}}\coqdocvar{p}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_map}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_opposite\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{do\_opposite\_map\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{do\_opposite\_map\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
); \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_opposite\_map\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f} ?\coqdocvar{p}\coqref{Paths.::'!' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqdocvar{p}) ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_map}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_opposite\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{undo\_opposite\_map\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{undo\_opposite\_map\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
); \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Tactics for \coqref{Paths.opposite concat}{\coqdoclemma{opposite\_concat}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_opposite\_concat\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{?}}\coqdocvar{p}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{?}}\coqdocvar{q}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{(}}\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p}\coqref{Paths.::'!' x}{\coqdocnotation{)}} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_concat}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_opposite\_concat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{do\_opposite\_concat\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{do\_opposite\_concat\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
); \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_opposite\_concat\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{(?}}\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{p}\coqref{Paths.::'!' x}{\coqdocnotation{)}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqdocvar{p}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqdocvar{q}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{opposite\_concat}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_opposite\_concat} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{undo\_opposite\_concat\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{undo\_opposite\_concat\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
); \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Tactics for \coqref{Paths.compose map}{\coqdoclemma{compose\_map}}.  As with \coqref{Paths.happly}{\coqdocdefinition{happly}}, \coqdoctac{apply} \coqref{Paths.compose map}{\coqdoclemma{compose\_map}}
   often fail to unify, so we define a separate tactic. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{apply\_compose\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} \coqref{Paths.map}{\coqdoclemma{map}} (?\coqdocvar{g'} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{?}}\coqdocvar{f'}) ?\coqdocvar{p'} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{g'} (\coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f'} ?\coqdocvar{p'}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.compose map}{\coqdoclemma{compose\_map}} \coqdockw{with} (\coqdocvar{g} := \coqdocvar{g'}) (\coqdocvar{f} := \coqdocvar{f'}) (\coqdocvar{p} := \coqdocvar{p'})\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{g'} (\coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f'} ?\coqdocvar{p'}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.map}{\coqdoclemma{map}} (?\coqdocvar{g'} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{?}}\coqdocvar{f'}) ?\coqdocvar{p'} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}; \coqdoctac{apply} \coqref{Paths.compose map}{\coqdoclemma{compose\_map}} \coqdockw{with} (\coqdocvar{g} := \coqdocvar{g'}) (\coqdocvar{f} := \coqdocvar{f'}) (\coqdocvar{p} := \coqdocvar{p'})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_compose\_map\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} (?\coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{?}}\coqdocvar{g}) ?\coqdocvar{p} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} \coqdocvar{p}) ] \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{path\_via} \coqdocvar{mid}; \coqdoctac{try} \coqdocvar{apply\_compose\_map}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_compose\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{do\_compose\_map\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{do\_compose\_map\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_compose\_map\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f} (\coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{g} ?\coqdocvar{p}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} (\coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{g}) \coqdocvar{p} ] \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{path\_via} \coqdocvar{mid}; \coqdoctac{try} \coqdocvar{apply\_compose\_map}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_compose\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{undo\_compose\_map\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{undo\_compose\_map\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Tactics for \coqref{Paths.concat map}{\coqdoclemma{concat\_map}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_concat\_map\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f} (?\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{q}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{q} ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_map}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{do\_concat\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{do\_concat\_map\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{do\_concat\_map\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_concat\_map\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f} ?\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} ?\coqdocvar{f} ?\coqdocvar{q} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}) ] \coqdoctac{in} \coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{concat\_map}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_concat\_map} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{undo\_concat\_map\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{undo\_concat\_map\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we return to proving lemmas about paths.
   We show that homotopies are natural with respect to paths in the domain. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.homotopy naturality}{homotopy\_naturality}{\coqdoclemma{homotopy\_naturality}} \coqdocvar{A} \coqdocvar{B} (\coqdocvar{f} \coqdocvar{g} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{p} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} \coqdocvar{x}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p} \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} \coqdocvar{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint} \coqdockw{Resolve} \coqref{Paths.homotopy naturality}{\coqdoclemma{homotopy\_naturality}} : \coqdocvar{path\_hints}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.homotopy naturality toid}{homotopy\_naturality\_toid}{\coqdoclemma{homotopy\_naturality\_toid}} \coqdocvar{A} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}) (\coqdocvar{p} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p} \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint} \coqdockw{Resolve} \coqref{Paths.homotopy naturality toid}{\coqdoclemma{homotopy\_naturality\_toid}} : \coqdocvar{path\_hints}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.homotopy naturality fromid}{homotopy\_naturality\_fromid}{\coqdoclemma{homotopy\_naturality\_fromid}} \coqdocvar{A} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}) (\coqdocvar{p} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f} \coqdocvar{x}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p} \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint} \coqdockw{Resolve} \coqref{Paths.homotopy naturality fromid}{\coqdoclemma{homotopy\_naturality\_fromid}} : \coqdocvar{path\_hints}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Cancellability of concatenation on both sides. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat cancel right}{concat\_cancel\_right}{\coqdoclemma{concat\_cancel\_right}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} \coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{r} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) : (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat cancel left}{concat\_cancel\_left}{\coqdoclemma{concat\_cancel\_left}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} \coqdocvar{r} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) : (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}) \ensuremath{\rightarrow} (\coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If a function is homotopic to the identity, then that homotopy
   makes it a "well-pointed" endofunctor in the following sense. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.htoid well pointed}{htoid\_well\_pointed}{\coqdoclemma{htoid\_well\_pointed}} \coqdocvar{A} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}) (\coqdocvar{p} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) (\coqdocvar{x} : \coqdocvar{A}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqdocvar{p} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{f} \coqdocvar{p} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.concat cancel right}{\coqdoclemma{concat\_cancel\_right}} \coqdockw{with} (\coqdocvar{r} := \coqdocvar{p} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.homotopy naturality toid}{\coqdoclemma{homotopy\_naturality\_toid}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Mates \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat moveright onright}{concat\_moveright\_onright}{\coqdoclemma{concat\_moveright\_onright}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{r} : \coqdocvar{z} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_left}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{moveright\_onright} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{r} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{q}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.concat moveright onright}{\coqdoclemma{concat\_moveright\_onright}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{r} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{q}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{\_} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}); \coqdoctac{apply} \coqref{Paths.concat moveright onright}{\coqdoclemma{concat\_moveright\_onright}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}; \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat moveleft onright}{concat\_moveleft\_onright}{\coqdoclemma{concat\_moveleft\_onright}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) (\coqdocvar{r} : \coqdocvar{z} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_left}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{moveleft\_onright} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{r}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.concat moveleft onright}{\coqdoclemma{concat\_moveleft\_onright}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{r}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{\_} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{r}); \coqdoctac{apply} \coqref{Paths.concat moveleft onright}{\coqdoclemma{concat\_moveleft\_onright}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}; \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat moveleft onleft}{concat\_moveleft\_onleft}{\coqdoclemma{concat\_moveleft\_onleft}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) (\coqdocvar{r} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) :\coqdoceol
\coqdocindent{1.00em}
(\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_right}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{moveleft\_onleft} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{q}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.concat moveleft onleft}{\coqdoclemma{concat\_moveleft\_onleft}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{r}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{\_}); \coqdoctac{apply} \coqref{Paths.concat moveleft onleft}{\coqdoclemma{concat\_moveleft\_onleft}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}; \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Paths.concat moveright onleft}{concat\_moveright\_onleft}{\coqdoclemma{concat\_moveright\_onleft}} \coqdocvar{A} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) (\coqdocvar{q} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) (\coqdocvar{r} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}) \ensuremath{\rightarrow} (\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{a}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{r}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_right}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{moveright\_onleft} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{?}}\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{q}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.concat moveright onleft}{\coqdoclemma{concat\_moveright\_onleft}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{r} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{q}) \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{\_}); \coqdoctac{apply} \coqref{Paths.concat moveright onleft}{\coqdoclemma{concat\_moveright\_onleft}}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}; \coqdocvar{do\_opposite\_opposite}.\coqdoceol
\end{coqdoccode}
\coqlibrary{Fibrations}{Library }{Fibrations}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Paths}{\coqdoclibrary{Paths}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In homotopy type theory, We think of elements of \coqdockw{Type} as spaces
   or homotopy types, while a type family \coqdocvariable{P} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdockw{Type} corresponds
   to a fibration whose base is \coqdocvariable{A} and whose fiber over \coqdocvar{x} is \coqdocvariable{P} \coqdocvar{x}.


   From such a \coqdocvariable{P} we can build a total space over the base space \coqdocvariable{A}
   so that the fiber over \coqdocvar{x} : \coqdocvariable{A} is \coqdocvariable{P} \coqdocvar{x}.  This is just Coq's
   dependent sum construction, written as \{\coqdocvar{x} : \coqdocvariable{A} \& \coqdocvariable{P} \coqdocvar{x}\}.  The
   elements of \{\coqdocvar{x} : \coqdocvariable{A} \& \coqdocvariable{P} \coqdocvar{x}\} are pairs, written \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvariable{P} \coqdocvar{x} \coqdocvar{y} in
   Coq, where \coqdocvar{x} : \coqdocvariable{A} and \coqdocvar{y} : \coqdocvariable{P} \coqdocvar{x}.


   The primitive notation for dependent sum is \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P}.  Note,
   though, that in the absence of definitional eta expansion, this is
   not actually identical with \{\coqdocvar{x} : \coqdocvariable{A} \& \coqdocvariable{P} \coqdocvar{x}\}, since the latter
   desugars to \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdockw{fun}( \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvariable{P} \coqdocvar{x}).


   Finally, the base and fiber components of a point in the total
   space are extracted with \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} and \coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}}. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
We can also define more familiar homotopy-looking aliases for all
   of these functions. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Fibrations.::'(' x ';' x ')'}{"}{\coqdocnotation{"}}( x  ; y )" := (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Fibrations.pr1}{pr1}{\coqdocabbreviation{pr1}} := (@\coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{\_} \coqdocvar{\_}).\coqdoceol
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Fibrations.pr2}{pr2}{\coqdocabbreviation{pr2}} := (@\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{\_} \coqdocvar{\_}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An element of \coqref{Fibrations.section}{\coqdocdefinition{section}} \coqdocvariable{P} is a global section of fibration \coqdocvariable{P}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Fibrations.section}{section}{\coqdocdefinition{section}} \{\coqdocvar{A}\} (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) := \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{A}, \coqdocvar{P} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We now study how paths interact with fibrations.  The most basic
   fact is that we can transport points in the fibers along paths in
   the base space.  This is actually a special case of the
   \coqref{Paths.paths rect}{\coqdocdefinition{paths\_rect}} induction principle in which the fibration \coqdocvariable{P} does
   not depend on paths in the base space but rather just on points of
   the base space. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Fibrations.transport}{transport}{\coqdoclemma{transport}} \{\coqdocvar{A}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : \coqdocvar{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvar{P} \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A homotopy fiber for a map \coqdocvariable{f} at \coqdocvar{y} is the space of paths of the
   form \coqdocvariable{f} \coqdocvar{x} $=$ \coqdocvar{y}.
   \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Fibrations.hfiber}{hfiber}{\coqdocdefinition{hfiber}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{y} : \coqdocvar{B}) := \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{A} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We prove a lemma that explains how to transport a point in the
   homotopy fiber along a path in the domain of the map. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.transport hfiber}{transport\_hfiber}{\coqdoclemma{transport\_hfiber}} \coqdocvar{A} \coqdocvar{B} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{z} : \coqdocvar{B}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) \coqdocvar{p} \coqdocvar{q} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::'!' x}{\coqdocnotation{!(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p}\coqref{Paths.::'!' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following lemma tells us how to construct a path in the total space from
   a path in the base space and a path in the fiber. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.total path}{total\_path}{\coqdoclemma{total\_path}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P}) (\coqdocvar{p} : \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
(\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} (\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{x} \coqdockw{as} [\coqdocvar{x} \coqdocvar{H}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{y} \coqdockw{as} [\coqdocvar{y} \coqdocvar{G}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \ensuremath{\times} \ensuremath{\vdash} \ensuremath{\times}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Conversely, a path in the total space can be projected down to the base. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Fibrations.base path}{base\_path}{\coqdocdefinition{base\_path}} \{\coqdocvar{A}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{u} \coqdocvar{v} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P}\} :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{u} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{v}) \ensuremath{\rightarrow} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{u} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{v}) :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.map}{\coqdoclemma{map}} \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And similarly to the fiber.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Fibrations.fiber path}{fiber\_path}{\coqdocdefinition{fiber\_path}} \{\coqdocvar{A}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{u} \coqdocvar{v} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} : \coqdocvar{u} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{v}) : (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{p}) (\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{u}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{v}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And these operations are inverses.  See \coqref{Equivalences.total paths equiv}{\coqdoclemma{total\_paths\_equiv}}, later
   on, for a more precise statement. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.total path reconstruction}{total\_path\_reconstruction}{\coqdoclemma{total\_path\_reconstruction}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} (\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{p}) (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} \coqdocvar{p}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.base total path}{base\_total\_path}{\coqdoclemma{base\_total\_path}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} : \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{y}) (\coqdocvar{q} : \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} (\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q})\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{x} \coqdockw{as} [\coqdocvar{x} \coqdocvar{H}]. \coqdoctac{destruct} \coqdocvar{y} \coqdockw{as} [\coqdocvar{y} \coqdocvar{K}]. \coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{p}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{q}. \coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.fiber total path}{fiber\_total\_path}{\coqdoclemma{fiber\_total\_path}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} : \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{y}) (\coqdocvar{q} : \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} (\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdockw{fun} \coqdocvar{p'} : \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p'} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{y})\coqdoceol
\coqdocindent{1.00em}
(\coqref{Fibrations.base total path}{\coqdoclemma{base\_total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q}) (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} (\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q}))\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{x} \coqdockw{as} [\coqdocvar{x} \coqdocvar{H}]. \coqdoctac{destruct} \coqdocvar{y} \coqdockw{as} [\coqdocvar{y} \coqdocvar{K}]. \coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{p}. \coqdoctac{induction} \coqdocvar{p}. \coqdoctac{simpl} \coqdoctac{in} \coqdocvar{q}. \coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This lemma tells us how to extract a commutative triangle in the
   base from a path in the homotopy fiber. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.hfiber triangle}{hfiber\_triangle}{\coqdoclemma{hfiber\_triangle}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}\} \{\coqdocvar{z} : \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqref{Fibrations.hfiber}{\coqdocdefinition{hfiber}} \coqdocvar{f} \coqdocvar{z}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{p})\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{y}\coqref{Paths.::x '@' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{x}\coqref{Paths.::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{base\_path}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Transporting a path along another path is equivalent to
   concatenating the two paths. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.trans is concat}{trans\_is\_concat}{\coqdoclemma{trans\_is\_concat}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{q} \coqdocvar{p}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.trans is concat opp}{trans\_is\_concat\_opp}{\coqdoclemma{trans\_is\_concat\_opp}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdockw{fun} \coqdocvar{x'} \ensuremath{\Rightarrow} (\coqdocvar{x'} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z})) \coqdocvar{p} \coqdocvar{q}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Transporting along a concatenation is transporting twice. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.trans concat}{trans\_concat}{\coqdoclemma{trans\_concat}} \{\coqdocvar{A}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) (\coqdocvar{z} : \coqdocvar{P} \coqdocvar{x}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}) \coqdocvar{z} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{q} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} \coqdocvar{z}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Transporting commutes with pulling back along a map. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.map trans}{map\_trans}{\coqdoclemma{map\_trans}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{P} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{z} : \coqdocvar{P} (\coqdocvar{f} \coqdocvar{x})) :\coqdoceol
\coqdocindent{0.50em}
\coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{P} (\coqdocvar{f} \coqdocvar{x}))) \coqdocvar{p} \coqdocvar{z}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p}) \coqdocvar{z}\coqref{Paths.::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And also with applying fiberwise functions. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.trans map}{trans\_map}{\coqdoclemma{trans\_map}} \{\coqdocvar{A}\} \{\coqdocvar{P} \coqdocvar{Q} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvar{Q} \coqdocvar{x}) (\coqdocvar{z} : \coqdocvar{P} \coqdocvar{x}) :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{f} \coqdocvar{y} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} \coqdocvar{z}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} (\coqdocvar{f} \coqdocvar{x} \coqdocvar{z})\coqref{Paths.::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A version of \coqref{Paths.map}{\coqdoclemma{map}} for dependent functions. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.map dep}{map\_dep}{\coqdoclemma{map\_dep}} \{\coqdocvar{A}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}) (\coqdocvar{p}: \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} (\coqdocvar{f} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f} \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.trans trivial}{trans\_trivial}{\coqdoclemma{trans\_trivial}} \{\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{z} : \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{B}) \coqdocvar{p} \coqdocvar{z} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.map dep trivial}{map\_dep\_trivial}{\coqdoclemma{map\_dep\_trivial}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{p}: \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}):\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.map dep}{\coqdoclemma{map\_dep}} \coqdocvar{f} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.trans trivial}{\coqdoclemma{trans\_trivial}} \coqdocvar{p} (\coqdocvar{f} \coqdocvar{x}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.map twovar}{map\_twovar}{\coqdoclemma{map\_twovar}} \{\coqdocvar{A} : \coqdockw{Type}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{B} : \coqdockw{Type}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} \{\coqdocvar{a} : \coqdocvar{P} \coqdocvar{x}\} \{\coqdocvar{b} : \coqdocvar{P} \coqdocvar{y}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{A}, \coqdocvar{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{q} : \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} \coqdocvar{a} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{b}) :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{f} \coqdocvar{x} \coqdocvar{a} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f} \coqdocvar{y} \coqdocvar{b}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{P} \coqdocvar{B} \coqdocvar{x} \coqdocvar{y} \coqdocvar{a} \coqdocvar{b} \coqdocvar{f} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Fibrations.total path2}{total\_path2}{\coqdoclemma{total\_path2}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{p} \coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{r} : \coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{q}) :\coqdoceol
\coqdocindent{1.00em}
(\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdockw{fun} \coqdocvar{s} \ensuremath{\Rightarrow} \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{s} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{y}\coqref{Paths.::x '==' x}{\coqdocnotation{)}}) \coqdocvar{r} (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} \coqdocvar{p}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} \coqdocvar{q}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q} \coqdocvar{r} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} (\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{p}) (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} \coqdocvar{p})) ;\coqdoceol
\coqdocindent{1.00em}
[ \coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Fibrations.total path reconstruction}{\coqdoclemma{total\_path\_reconstruction}} \ensuremath{|} ].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} (\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{q}) (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} \coqdocvar{q})) ;\coqdoceol
\coqdocindent{1.00em}
[ \ensuremath{|} \coqdoctac{apply} \coqref{Fibrations.total path reconstruction}{\coqdoclemma{total\_path\_reconstruction}} ].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Fibrations.map twovar}{\coqdoclemma{map\_twovar}} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{f} := \coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y})\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{p} := \coqdocvar{r}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\end{coqdoccode}
\coqlibrary{Contractible}{Library }{Contractible}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Paths}{\coqdoclibrary{Paths}} \coqref{Fibrations}{\coqdoclibrary{Fibrations}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A space \coqdocvariable{A} is contractible if there is a point \coqdocvar{x} : \coqdocvariable{A} and a
   (pointwise) homotopy connecting the identity on \coqdocvariable{A} to the constant
   map at \coqdocvar{x}.  Thus an element of \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvariable{A} is a pair whose
   first component is a point \coqdocvar{x} and the second component is a
   pointwise retraction of \coqdocvariable{A} to \coqdocvar{x}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Contractible.is contr}{is\_contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A} := \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{A} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdockw{\ensuremath{\forall}} \coqdocvar{y} : \coqdocvar{A}, \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
If a space is contractible, then any two points in it are
   connected by a path in a canonical way. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Contractible.contr path}{contr\_path}{\coqdoclemma{contr\_path}} \{\coqdocvar{A}\} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) : (\coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A}) \ensuremath{\rightarrow} (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} (\coqdocvar{z},\coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} \coqdocvar{z}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Similarly, any two parallel paths in a contractible space are homotopic.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Contractible.contr path2}{contr\_path2}{\coqdoclemma{contr\_path2}} \{\coqdocvar{A}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{p} \coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) : (\coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A}) \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{ctr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{ctr} \coqdockw{as} (\coqdocvar{c}, \coqdocvar{ret}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{ret} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{ret} \coqdocvar{y}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveleft\_onright}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveright\_onleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Fibrations.trans is concat opp}{\coqdoclemma{trans\_is\_concat\_opp}} \coqdocvar{p} (\coqdocvar{ret} \coqdocvar{x})  \coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Fibrations.map dep}{\coqdoclemma{map\_dep}} \coqdocvar{ret} \coqdocvar{p} ).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveright\_onright}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveleft\_onleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Fibrations.trans is concat opp}{\coqdoclemma{trans\_is\_concat\_opp}} \coqdocvar{q} (\coqdocvar{ret} \coqdocvar{x})  \coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Fibrations.map dep}{\coqdoclemma{map\_dep}} \coqdocvar{ret} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It follows that any space of paths in a contractible space is contractible. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Contractible.contr pathcontr}{contr\_pathcontr}{\coqdoclemma{contr\_pathcontr}} \{\coqdocvar{A}\} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) : \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{ctr}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqref{Contractible.contr path}{\coqdoclemma{contr\_path}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{ctr}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path2}{\coqdoclemma{contr\_path2}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The total space of any based path space is contractible. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Contractible.pathspace contr}{pathspace\_contr}{\coqdoclemma{pathspace\_contr}} \{\coqdocvar{X}\} (\coqdocvar{x}:\coqdocvar{X}) : \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} (\coqref{Paths.paths}{\coqdocinductive{paths}} \coqdocvar{x})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [\coqdocvar{y} \coqdocvar{p}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Contractible.pathspace contr'}{pathspace\_contr'}{\coqdoclemma{pathspace\_contr'}} \{\coqdocvar{X}\} (\coqdocvar{x}:\coqdocvar{X}) : \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}}\coqdocvar{X}  \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}}  \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [\coqdocvar{y} \coqdocvar{p}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The unit type is contractible. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Contractible.unit contr}{unit\_contr}{\coqdoclemma{unit\_contr}} : \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqexternalref{unit}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{unit}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqexternalref{tt}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{tt}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint} \coqdockw{Resolve} \coqref{Contractible.unit contr}{\coqdoclemma{unit\_contr}}.\coqdoceol
\end{coqdoccode}
\coqlibrary{Equivalences}{Library }{Equivalences}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Paths}{\coqdoclibrary{Paths}} \coqref{Fibrations}{\coqdoclibrary{Fibrations}} \coqref{Contractible}{\coqdoclibrary{Contractible}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
An equivalence is a map whose homotopy fibers are contractible. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.is equiv}{is\_equiv}{\coqdocdefinition{is\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) := \coqdockw{\ensuremath{\forall}} \coqdocvar{y} : \coqdocvar{B}, \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqref{Fibrations.hfiber}{\coqdocdefinition{hfiber}} \coqdocvar{f} \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\coqref{Equivalences.equiv}{\coqdocdefinition{equiv}} \coqdocvariable{A} \coqdocvariable{B} is the space of equivalences from \coqdocvariable{A} to \coqdocvariable{B}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.equiv}{equiv}{\coqdocdefinition{equiv}} \coqdocvar{A} \coqdocvar{B} := \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{w} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{w} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Equivalences.::x '<x7E>' x}{"}{\coqdocnotation{"}}A <\~{}> B" := (\coqref{Equivalences.equiv}{\coqdocdefinition{equiv}} \coqdocvar{A} \coqdocvar{B}) (\coqdoctac{at} \coqdocvar{level} 55).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Strictly speaking, an element \coqdocvar{w} of \coqdocvariable{A} $\overset{\sim}{\longrightarrow}$ \coqdocvariable{B} is a \textit{pair}
   consisting of a map \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{w} and the proof \coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} \coqdocvar{w} that it is
   an equivalence. Thus, in order to apply \coqdocvar{w} to \coqdocvar{x} we must write
   \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{w} \coqdocvar{x}. Coq is able to do this automatically if we declare
   that \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} is a \textit{coercion} from \coqref{Equivalences.equiv}{\coqdocdefinition{equiv}} \coqdocvariable{A} \coqdocvariable{B} to \coqdocvariable{A} \ensuremath{\rightarrow} \coqdocvariable{B}. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.equiv coerce to function}{equiv\_coerce\_to\_function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{A} \coqdocvar{B} (\coqdocvar{w} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) : (\coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B})\coqdoceol
\coqdocindent{1.00em}
:= \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{w}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Coercion} \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} : \coqdocvar{equiv} >-> \coqdocvar{Funclass}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is a tactic which helps us prove that a homotopy fiber is
   contractible.  This will be useful for showing that maps are
   equivalences. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{contract\_hfiber} \coqdocvar{y} \coqdocvar{p} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} [ \ensuremath{\vdash} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (@\coqref{Fibrations.hfiber}{\coqdocdefinition{hfiber}} \coqdocvar{\_} \coqdocvar{\_} ?\coqdocvar{f} ?\coqdocvar{x}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{eexists} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} \coqdocvar{z} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{z} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) \coqdocvar{y} \coqdocvar{p});\coqdoceol
\coqdocindent{4.00em}
\coqdockw{let} \coqdocvar{z} := \coqdoctac{fresh} "z" \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{let} \coqdocvar{q} := \coqdoctac{fresh} "q" \coqdoctac{in}\coqdoceol
\coqdocindent{5.00em}
\coqdoctac{intros} [\coqdocvar{z} \coqdocvar{q}]\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Let us explain the tactic. It accepts two arguments \coqdocvar{y} and \coqdocvar{p}
   and attempts to contract a homotopy fiber to \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \coqdocvar{y} \coqdocvar{p}. It
   first looks for a goal of the form \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqref{Fibrations.hfiber}{\coqdocdefinition{hfiber}}( \coqdocvariable{f} \coqdocvar{x}), where
   the question marks in \coqdocvariable{f}? and ?\coqdocvar{x} are pattern variables that Coq
   should match against the actual values. If the goal is found, then
   we use \coqdocvar{eexists} to specify that the center of retraction is at the
   element \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \coqdocvar{y} \coqdocvar{p} of hfiber provided by the user. After that
   we generate some fresh names and perfrom intros. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
The identity map is an equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.idequiv}{idequiv}{\coqdocdefinition{idequiv}} \coqdocvar{A} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqref{Functions.idmap}{\coqdocdefinition{idmap}} \coqdocvar{A}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{contract\_hfiber} \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdockw{with} (\coqdocvar{p} := \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{compute} \coqdoctac{in} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
From an equivalence from \coqdocvar{U} to \coqdocvar{V} we can extract a map in the
   inverse direction. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.inverse}{inverse}{\coqdocdefinition{inverse}} \{\coqdocvar{U} \coqdocvar{V}\} (\coqdocvar{w} : \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V}) : (\coqdocvar{V} \ensuremath{\rightarrow} \coqdocvar{U}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} ((\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{w}) \coqdocvar{y})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Equivalences.::x 'x5E-1'}{"}{\coqdocnotation{"}}w \^{}-1" := (\coqref{Equivalences.inverse}{\coqdocdefinition{inverse}} \coqdocvar{w}) (\coqdoctac{at} \coqdocvar{level} 40).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The extracted map in the inverse direction is actually an inverse
   (up to homotopy, of course). \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.inverse is section}{inverse\_is\_section}{\coqdocdefinition{inverse\_is\_section}} \{\coqdocvar{U} \coqdocvar{V}\} (\coqdocvar{w} : \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V}) \coqdocvar{y} : \coqdocvar{w} (\coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{y}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} ((\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{w}) \coqdocvar{y})).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.inverse is retraction}{inverse\_is\_retraction}{\coqdocdefinition{inverse\_is\_retraction}} \{\coqdocvar{U} \coqdocvar{V}\} (\coqdocvar{w} : \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V}) \coqdocvar{x} : \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{w} \coqdocvar{x})\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} ((\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{w}) (\coqdocvar{w} \coqdocvar{x})) \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{w} \coqdocvar{x})\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here are some tactics to use for canceling inverses, and for
   introducing them. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_inverses\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} ?\coqdocvar{w} (?\coqdocvar{w} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} ?\coqdocvar{x}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{x} ] \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{inverse\_is\_section}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ ?\coqdocvar{w} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} ?\coqdocvar{w} ?\coqdocvar{x}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{x} ] \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{path\_using} \coqdocvar{mid} \coqdocvar{inverse\_is\_retraction}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{cancel\_inverses} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow} \coqdocvar{first} [ \coqdocvar{cancel\_inverses\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{cancel\_inverses\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{expand\_inverse\_src} \coqdocvar{w} \coqdocvar{x} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{x} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdocvar{first} [\coqdoceol
\coqdocindent{6.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{w} (\coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{x}) ] \coqdoctac{in}\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{path\_via'} \coqdocvar{mid};\coqdoceol
\coqdocindent{7.00em}
[ \coqdocvar{path\_simplify'} \coqdocvar{inverse\_is\_section} \ensuremath{|} ]\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|}\coqdoceol
\coqdocindent{6.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{w} \coqdocvar{x}) ] \coqdoctac{in}\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{path\_via'} \coqdocvar{mid};\coqdoceol
\coqdocindent{7.00em}
[ \coqdocvar{path\_simplify'} \coqdocvar{inverse\_is\_retraction} \ensuremath{|} ]\coqdoceol
\coqdocindent{5.00em}
]\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{expand\_inverse\_trg} \coqdocvar{w} \coqdocvar{x} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{4.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{x} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{5.00em}
\coqdocvar{first} [\coqdoceol
\coqdocindent{6.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{w} (\coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{x}) ] \coqdoctac{in}\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{path\_via'} \coqdocvar{mid};\coqdoceol
\coqdocindent{7.00em}
[ \ensuremath{|} \coqdocvar{path\_simplify'} \coqdocvar{inverse\_is\_section} ]\coqdoceol
\coqdocindent{6.00em}
\ensuremath{|}\coqdoceol
\coqdocindent{6.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{w} \coqdocvar{x}) ] \coqdoctac{in}\coqdoceol
\coqdocindent{7.00em}
\coqdocvar{path\_via'} \coqdocvar{mid};\coqdoceol
\coqdocindent{7.00em}
[ \ensuremath{|} \coqdocvar{path\_simplify'} \coqdocvar{inverse\_is\_retraction} ]\coqdoceol
\coqdocindent{5.00em}
]\coqdoceol
\coqdocindent{3.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
These tactics change between goals of the form \coqdocvar{w} \coqdocvar{x} $=$ \coqdocvar{y} and the
   form \coqdocvar{x} $=$ \coqdocvar{w}$^{-1}$ \coqdocvar{y}, and dually. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{equiv\_moveright} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} ?\coqdocvar{w} ?\coqdocvar{a} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{b} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{w} (\coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{b}));\coqdoceol
\coqdocindent{4.00em}
[ \coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}} \ensuremath{|} \coqdoctac{apply} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} ]\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} (?\coqdocvar{w} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}) ?\coqdocvar{a} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{b} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{w} \coqdocvar{b}));\coqdoceol
\coqdocindent{4.00em}
[ \coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}} \ensuremath{|} \coqdoctac{apply} \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} ]\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{equiv\_moveleft} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{a} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} ?\coqdocvar{w} ?\coqdocvar{b} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{w} (\coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{a}));\coqdoceol
\coqdocindent{4.00em}
[ \coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \ensuremath{|} \coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}} ]\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{a} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} (?\coqdocvar{w} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}) ?\coqdocvar{b} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdockw{with} (\coqdocvar{y} := \coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{w} \coqdocvar{a}));\coqdoceol
\coqdocindent{4.00em}
[ \coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \ensuremath{|} \coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}} ]\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is one of the "triangle identities" for the preceeding two
   homotopies.  (It doesn't look like a triangle since we've inverted
   one of the homotopies.) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.inverse triangle}{inverse\_triangle}{\coqdocdefinition{inverse\_triangle}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{w} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) \coqdocvar{x} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{w} (\coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvar{w} \coqdocvar{x})\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvar{w} (\coqdocvar{w} \coqdocvar{x})\coqref{Paths.::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{inverse\_is\_retraction}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_opposite\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{Paths.concat}{\coqdocdefinition{concat}} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Paths.idpath right unit}{\coqdoclemma{idpath\_right\_unit}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{\_})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveright\_onleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Fibrations.hfiber triangle}{\coqdoclemma{hfiber\_triangle}} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{w} (\coqdocvar{w} \coqdocvar{x})) \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{\_}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Equivalences are "injective on paths". \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.equiv injective}{equiv\_injective}{\coqdoclemma{equiv\_injective}} \coqdocvar{U} \coqdocvar{V} (\coqdocvar{w} : \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V}) \coqdocvar{x} \coqdocvar{y} : (\coqdocvar{w} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{w} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{U} \coqdocvar{V} \coqdocvar{w} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_src} \coqdocvar{w} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{equiv\_moveright}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Anything contractible is equivalent to the unit type. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.contr equiv unit}{contr\_equiv\_unit}{\coqdoclemma{contr\_equiv\_unit}} (\coqdocvar{A} : \coqdockw{Type}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A} \ensuremath{\rightarrow} (\coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqexternalref{unit}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{unit}}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{tt}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{tt}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}. \coqdoctac{destruct} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{contract\_hfiber} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{H}) (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqexternalref{tt}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{tt}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdockw{with} (\coqdocvar{p} := \coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{H} \coqdocvar{z}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path2}{\coqdoclemma{contr\_path2}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And conversely, anything equivalent to a contractible type is
   contractible. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.contr equiv contr}{contr\_equiv\_contr}{\coqdoclemma{contr\_equiv\_contr}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{B}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{Acontr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{Acontr}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{equiv\_moveleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The free path space of a type is equivalent to the type itself. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.free path space}{free\_path\_space}{\coqdocdefinition{free\_path\_space}} \coqdocvar{A} := \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{xy} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{A} \coqexternalref{:type scope:x '*' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{A} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqexternalref{fst}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{fst}} \coqdocvar{xy} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{snd}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{xy}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.free path source}{free\_path\_source}{\coqdocdefinition{free\_path\_source}} \coqdocvar{A} : \coqref{Equivalences.free path space}{\coqdocdefinition{free\_path\_space}} \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{p} \ensuremath{\Rightarrow} \coqexternalref{fst}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{fst}} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{p})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{eexists} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} (\coqdocvar{xy} : \coqdocvar{A} \coqexternalref{:type scope:x '*' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{A}) \ensuremath{\Rightarrow} \coqexternalref{fst}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{fst}} \coqdocvar{xy} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{snd}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{xy}) \coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{)}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})) \coqdocvar{\_}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [[[\coqdocvar{u} \coqdocvar{v}] \coqdocvar{p}] \coqdocvar{q}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \ensuremath{\times} \ensuremath{\vdash} \ensuremath{\times}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q} \coqdockw{as} [\coqdocvar{a}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [\coqdocvar{b}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.free path target}{free\_path\_target}{\coqdocdefinition{free\_path\_target}} \coqdocvar{A} : \coqref{Equivalences.free path space}{\coqdocdefinition{free\_path\_space}} \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{p} \ensuremath{\Rightarrow} \coqexternalref{snd}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{snd}} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{p})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{eexists} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} (\coqdocvar{xy} : \coqdocvar{A} \coqexternalref{:type scope:x '*' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}} \coqdocvar{A}) \ensuremath{\Rightarrow} \coqexternalref{fst}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{fst}} \coqdocvar{xy} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{snd}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{xy}) \coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{,}}\coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{)}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})) \coqdocvar{\_}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [[[\coqdocvar{u} \coqdocvar{v}] \coqdocvar{p}] \coqdocvar{q}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl} \coqdoctac{in} \ensuremath{\times} \ensuremath{\vdash} \ensuremath{\times}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q} \coqdockw{as} [\coqdocvar{a}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{p} \coqdockw{as} [\coqdocvar{b}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We have proven that every equivalence has an inverse up to
    homotopy.  In fact, having an inverse up to homotopy is also
    enough to characterize a map as being an equivalence.  However,
    the data of an inverse up to homotopy is not equivalent to the
    data in \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} unless we add one more piece of coherence data.
    This is a homotopy version of the category-theoretic notion of
    "adjoint equivalence". \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.is adjoint equiv}{is\_adjoint\_equiv}{\coqdocdefinition{is\_adjoint\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{g} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{A} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{is\_section} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdockw{\ensuremath{\forall}} \coqdocvar{y}, \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{f} (\coqdocvar{g} \coqdocvar{y})\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}}\coqdoceol
\coqdocindent{3.00em}
\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{is\_retraction} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{g} (\coqdocvar{f} \coqdocvar{x})\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqdocvar{is\_retraction} \coqdocvar{x})\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x})\coqref{Paths.::x '==' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{5.00em}
\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}\}\}}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.is equiv to adjoint}{is\_equiv\_to\_adjoint}{\coqdocdefinition{is\_equiv\_to\_adjoint}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f}: \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{E} : \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f}) : \coqref{Equivalences.is adjoint equiv}{\coqdocdefinition{is\_adjoint\_equiv}} \coqdocvar{f} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{let} \coqdocvar{w} := \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{f} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{E}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}} \coqdoctac{in}\coqdoceol
\coqdocindent{2.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{w}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvar{w}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvar{w} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Equivalences.inverse triangle}{\coqdocdefinition{inverse\_triangle}} \coqdocvar{w}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)))}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.adjoint equiv}{adjoint\_equiv}{\coqdocdefinition{adjoint\_equiv}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) := \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{f}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}  \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}}  \coqref{Equivalences.is adjoint equiv}{\coqdocdefinition{is\_adjoint\_equiv}} \coqdocvar{f} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Equivalences.is adjoint to equiv}{is\_adjoint\_to\_equiv}{\coqdoclemma{is\_adjoint\_to\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f}: \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) : \coqref{Equivalences.is adjoint equiv}{\coqdocdefinition{is\_adjoint\_equiv}} \coqdocvar{f} \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} [\coqdocvar{g} [\coqdocvar{is\_section} [\coqdocvar{is\_retraction} \coqdocvar{triangle}]]].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{contract\_hfiber} (\coqdocvar{g} \coqdocvar{y}) (\coqdocvar{is\_section} \coqdocvar{y}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{\_}\coqdoceol
\coqdocindent{2.00em}
(\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y})\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \coqdocvar{z} \coqdocvar{q})\coqdoceol
\coqdocindent{2.00em}
(\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} (\coqdocvar{g} \coqdocvar{y}) (\coqdocvar{is\_section} \coqdocvar{y}))\coqdoceol
\coqdocindent{2.00em}
(\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_retraction} \coqdocvar{z} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} \coqdocvar{q}\coqref{Paths.::x '@' x}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.::'!' x}{\coqdocnotation{!(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_retraction} \coqdocvar{z} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} \coqdocvar{q})\coqref{Paths.::'!' x}{\coqdocnotation{)}} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Fibrations.transport hfiber}{\coqdoclemma{transport\_hfiber}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_concat\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_opposite\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{undo\_opposite\_concat}.\coqdoceol
\end{coqdoccode}
Here is where we use triangle. \begin{coqdoccode}
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} \coqdocvar{q}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{z}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\end{coqdoccode}
Now it's just naturality of 'is\_section'. \begin{coqdoccode}
\coqdocindent{1.00em}
\coqdocvar{associate\_right}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveright\_onleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{undo\_compose\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Paths.homotopy naturality toid}{\coqdoclemma{homotopy\_naturality\_toid}} \coqdockw{with} (\coqdocvar{f} := \coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{g}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Probably equiv\_to\_adjoint and adjoint\_to\_equiv are actually
   inverse equivalences, at least if we assume function
   extensionality. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.equiv pointwise idmap}{equiv\_pointwise\_idmap}{\coqdoclemma{equiv\_pointwise\_idmap}} \coqdocvar{A} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A}) (\coqdocvar{p} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) : \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.is adjoint to equiv}{\coqdoclemma{is\_adjoint\_to\_equiv}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqref{Functions.idmap}{\coqdocdefinition{idmap}} \coqdocvar{A}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.htoid well pointed}{\coqdoclemma{htoid\_well\_pointed}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A central fact about adjoint equivalences is that any "incoherent"
   equivalence can be improved to an adjoint equivalence by changing
   one of the natural isomorphisms.  We now prove a corresponding
   result in homotopy type theory.  The proof is exactly the same as
   the usual proof for adjoint equivalences in 2-category theory.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.adjointify}{adjointify}{\coqdocdefinition{adjointify}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{g} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{A}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{y}, \coqdocvar{f} (\coqdocvar{g} \coqdocvar{y}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{g} (\coqdocvar{f} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x} ) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is adjoint equiv}{\coqdocdefinition{is\_adjoint\_equiv}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{g} \coqdocvar{is\_section} \coqdocvar{is\_retraction}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{is\_retraction'} := \coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{(}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_retraction} \coqdocvar{x}))\coqref{Paths.::x '@' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{g} (\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x}))\coqref{Paths.::x '@' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{is\_retraction} \coqdocvar{x}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{is\_section}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{is\_retraction'}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\end{coqdoccode}
Now we just play with naturality until things cancel. \begin{coqdoccode}
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{is\_retraction'}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_concat\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{undo\_compose\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveleft\_onleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_left}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x})  \coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.map}{\coqdoclemma{map}} (\coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{g}) (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_retraction} \coqdocvar{x}))\coqdoceol
\coqdocindent{2.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.map}{\coqdoclemma{map}} (\coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{g}) (\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x}))\coqref{Paths.::x '@' x}{\coqdocnotation{)}}  \coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqdocvar{is\_retraction} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{unwhisker}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_compose\_map}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_retraction} \coqdocvar{x})  \coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_section} (\coqdocvar{f} (\coqdocvar{g} (\coqdocvar{f} \coqdocvar{x})))\coqref{Paths.::x '@' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{2.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.map}{\coqdoclemma{map}} (\coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{g}) (\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x}))  \coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqdocvar{is\_retraction} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{unwhisker}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, (\coqref{Paths.homotopy naturality fromid}{\coqdoclemma{homotopy\_naturality\_fromid}} \coqdocvar{B} \coqdocvar{\_} (\coqdockw{fun} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_section} \coqdocvar{y})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_retraction} \coqdocvar{x})  \coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x})\coqref{Paths.::x '@' x}{\coqdocnotation{))}}\coqdoceol
\coqdocindent{2.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{@}}  \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{f} (\coqdocvar{is\_retraction} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{unwhisker}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, (\coqref{Paths.homotopy naturality fromid}{\coqdoclemma{homotopy\_naturality\_fromid}} \coqdocvar{B} \coqdocvar{\_} (\coqdockw{fun} \coqdocvar{y} \ensuremath{\Rightarrow} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{is\_section} \coqdocvar{y})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_opposite\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_right\_opposite\_of} (\coqdocvar{is\_section} (\coqdocvar{f} \coqdocvar{x})).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Therefore, "any homotopy equivalence is an equivalence." \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.hequiv is equiv}{hequiv\_is\_equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{g} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{A})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{is\_section} : \coqdockw{\ensuremath{\forall}} \coqdocvar{y}, \coqdocvar{f} (\coqdocvar{g} \coqdocvar{y}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) (\coqdocvar{is\_retraction} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{g} (\coqdocvar{f} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f} := \coqref{Equivalences.is adjoint to equiv}{\coqdoclemma{is\_adjoint\_to\_equiv}} \coqdocvar{f} (\coqref{Equivalences.adjointify}{\coqdocdefinition{adjointify}} \coqdocvar{f} \coqdocvar{g} \coqdocvar{is\_section} \coqdocvar{is\_retraction}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
All sorts of nice things follow from this theorem. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
The inverse of an equivalence is an equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.equiv inverse}{equiv\_inverse}{\coqdoclemma{equiv\_inverse}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) : \coqdocvar{B} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} (\coqref{Equivalences.is equiv to adjoint}{\coqdocdefinition{is\_equiv\_to\_adjoint}} \coqdocvar{f} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{f})) \coqdockw{as} [\coqdocvar{g} [\coqdocvar{is\_section} [\coqdocvar{is\_retraction} \coqdocvar{triangle}]]].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdocvar{g} \coqdocvar{f} \coqdocvar{is\_retraction} \coqdocvar{is\_section}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Anything homotopic to an equivalence is an equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.equiv homotopic}{equiv\_homotopic}{\coqdoclemma{equiv\_homotopic}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} \coqdocvar{g} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} \coqdocvar{x}) \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{g} \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{g'} \coqdocvar{p} \coqdocvar{geq}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{g} := \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{g'} \coqdocvar{geq} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqdocvar{g}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_trg} \coqdocvar{g} \coqdocvar{y}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{equiv\_moveright}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And the 2-out-of-3 property for equivalences. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.equiv compose}{equiv\_compose}{\coqdocdefinition{equiv\_compose}} \{\coqdocvar{A} \coqdocvar{B} \coqdocvar{C}\} (\coqdocvar{f} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) (\coqdocvar{g} : \coqdocvar{B} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{C}) : (\coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{C}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdocvar{g} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{f}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqref{Functions.::x 'o' x}{\coqdocnotation{(}}\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}\coqref{Functions.::x 'o' x}{\coqdocnotation{)}} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{(}}\coqdocvar{g}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}\coqref{Functions.::x 'o' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_trg} \coqdocvar{g} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_trg} \coqdocvar{f} (\coqdocvar{g}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{y}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_trg} \coqdocvar{f} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_trg} \coqdocvar{g} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.equiv cancel right}{equiv\_cancel\_right}{\coqdocdefinition{equiv\_cancel\_right}} \{\coqdocvar{A} \coqdocvar{B} \coqdocvar{C}\} (\coqdocvar{f} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) (\coqdocvar{g} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdocvar{C}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvar{g} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{f}) \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{g}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{C} \coqdocvar{f} \coqdocvar{g} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{gof} := (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} (\coqdocvar{g} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{f}) \coqdocvar{H}) : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{C}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{(}}\coqdocvar{gof}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}\coqref{Functions.::x 'o' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_trg} \coqdocvar{gof} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{change} (\coqdocvar{f} (\coqdocvar{gof}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{g} \coqdocvar{x})) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{equiv\_moveright}; \coqdocvar{equiv\_moveright}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{change} (\coqdocvar{g} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} (\coqdocvar{f} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{x}))).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_inverses}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.equiv cancel left}{equiv\_cancel\_left}{\coqdocdefinition{equiv\_cancel\_left}} \{\coqdocvar{A} \coqdocvar{B} \coqdocvar{C}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{g} : \coqdocvar{B} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{C}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvar{g} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{f}) \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{C} \coqdocvar{f} \coqdocvar{g} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{gof} := \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} (\coqdocvar{g} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{f}) \coqdocvar{H} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{C}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqdocvar{gof}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{g}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_trg} \coqdocvar{g} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{expand\_inverse\_src} \coqdocvar{g} (\coqdocvar{f} ((\coqref{Functions.::x 'o' x}{\coqdocnotation{(}}\coqdocvar{gof} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}\coqref{Functions.::x 'o' x}{\coqdocnotation{)}} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{g}) \coqdocvar{y})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{gof} ((\coqdocvar{gof}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{g} \coqdocvar{y})))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{gof}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{gof} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.contr contr equiv}{contr\_contr\_equiv}{\coqdocdefinition{contr\_contr\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{B} \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{Acontr} \coqdocvar{Bcontr}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.equiv cancel left}{\coqdocdefinition{equiv\_cancel\_left}} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
(\coqdocvar{g} := \coqref{Equivalences.contr equiv unit}{\coqdoclemma{contr\_equiv\_unit}} \coqdocvar{B} \coqdocvar{Bcontr}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqref{Equivalences.contr equiv unit}{\coqdoclemma{contr\_equiv\_unit}} \coqdocvar{A} \coqdocvar{Acontr})).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The action of an equivalence on paths is an equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Equivalences.equiv map inv}{equiv\_map\_inv}{\coqdoclemma{equiv\_map\_inv}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{f} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f} \coqdocvar{y}) \ensuremath{\rightarrow} (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{x} \coqdocvar{y} \coqdocvar{f} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{f} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via'} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvar{f} \coqdocvar{y})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Equivalences.equiv map is equiv}{equiv\_map\_is\_equiv}{\coqdoclemma{equiv\_map\_is\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{f} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{A} \coqdocvar{B} \coqdocvar{x} \coqdocvar{y} \coqdocvar{f}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{x} \coqdocvar{y} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqref{Equivalences.equiv map inv}{\coqdoclemma{equiv\_map\_inv}} \coqdocvar{f}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{equiv\_map\_inv}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_concat\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{do\_opposite\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveright\_onleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{undo\_compose\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.map}{\coqdoclemma{map}} (\coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{(}}\coqdocvar{f} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}\coqref{Functions.::x 'o' x}{\coqdocnotation{)}}) \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvar{f} (\coqdocvar{f} \coqdocvar{y})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse triangle}{\coqdocdefinition{inverse\_triangle}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvar{f} (\coqdocvar{f} \coqdocvar{x}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.homotopy naturality toid}{\coqdoclemma{homotopy\_naturality\_toid}} \coqdockw{with} (\coqdocvar{f} := \coqdocvar{f} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Functions.::x 'o' x}{\coqdocnotation{(}}\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}\coqref{Functions.::x 'o' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Equivalences.inverse triangle}{\coqdocdefinition{inverse\_triangle}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{equiv\_map\_inv}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{moveright\_onleft}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{undo\_compose\_map}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.homotopy naturality toid}{\coqdoclemma{homotopy\_naturality\_toid}} \coqdockw{with} (\coqdocvar{f} := \coqref{Functions.::x 'o' x}{\coqdocnotation{(}}\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}\coqref{Functions.::x 'o' x}{\coqdocnotation{)}} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{f}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.equiv map equiv}{equiv\_map\_equiv}{\coqdocdefinition{equiv\_map\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} \{\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}\} (\coqdocvar{f} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f} \coqdocvar{y}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}@\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{A} \coqdocvar{B} \coqdocvar{x} \coqdocvar{y} \coqdocvar{f} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Equivalences.equiv map is equiv}{\coqdoclemma{equiv\_map\_is\_equiv}} \coqdocvar{f}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Path-concatenation is an equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.concat is equiv left}{concat\_is\_equiv\_left}{\coqdoclemma{concat\_is\_equiv\_left}} \{\coqdocvar{A}\} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdockw{fun} \coqdocvar{q}: \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z} \ensuremath{\Rightarrow} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := @\coqref{Paths.concat}{\coqdocdefinition{concat}} \coqdocvar{A} \coqdocvar{y} \coqdocvar{x} \coqdocvar{z} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_left}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_left}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.concat equiv left}{concat\_equiv\_left}{\coqdocdefinition{concat\_equiv\_left}} \{\coqdocvar{A}\} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{q}: \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z} \ensuremath{\Rightarrow} \coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q}  \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}}  \coqref{Equivalences.concat is equiv left}{\coqdoclemma{concat\_is\_equiv\_left}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Equivalences.concat is equiv right}{concat\_is\_equiv\_right}{\coqdoclemma{concat\_is\_equiv\_right}} \{\coqdocvar{A}\} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdockw{fun} \coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqdockw{fun} \coqdocvar{r} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z} \ensuremath{\Rightarrow} \coqdocvar{r} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_right}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{associate\_right}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.concat equiv right}{concat\_equiv\_right}{\coqdocdefinition{concat\_equiv\_right}} \{\coqdocvar{A}\} (\coqdocvar{x} \coqdocvar{y} \coqdocvar{z} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{z}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{q}: \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p}  \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}}  \coqref{Equivalences.concat is equiv right}{\coqdoclemma{concat\_is\_equiv\_right}} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z} \coqdocvar{p}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And we can characterize the path types of the total space of a
   fibration, up to equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Equivalences.total paths equiv}{total\_paths\_equiv}{\coqdoclemma{total\_paths\_equiv}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{p} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{r} \ensuremath{\Rightarrow} \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} \coqdocvar{p} \ensuremath{\Rightarrow} \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{y}) (\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{r}) (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} \coqdocvar{r})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{eapply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{instantiate} (1 := \coqdockw{fun} \coqdocvar{pq} \ensuremath{\Rightarrow} \coqdockw{let} (\coqdocvar{p},\coqdocvar{q}) := \coqdocvar{pq} \coqdoctac{in} \coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [\coqdocvar{p} \coqdocvar{q}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{eapply} \coqref{Fibrations.total path}{\coqdoclemma{total\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{instantiate} (1 := \coqref{Fibrations.base total path}{\coqdoclemma{base\_total\_path}} \coqdocvar{A} \coqdocvar{P} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Fibrations.fiber total path}{\coqdoclemma{fiber\_total\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{r}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Fibrations.total path reconstruction}{\coqdoclemma{total\_path\_reconstruction}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Andr Joyal suggested the following definition of equivalences,
   and to call it "h-isomorphism". \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Equivalences.is hiso}{is\_hiso}{\coqdocdefinition{is\_hiso}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) :=\coqdoceol
\coqdocindent{1.00em}
( \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{g} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{B}\ensuremath{\rightarrow}\coqdocvar{A}  \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}}  \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{g} (\coqdocvar{f} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}} \coqexternalref{:type scope:x '*' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{\ensuremath{\times}}}\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{h} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{B}\ensuremath{\rightarrow}\coqdocvar{A}  \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}}  \coqdockw{\ensuremath{\forall}} \coqdocvar{y}, \coqdocvar{f} (\coqdocvar{h} \coqdocvar{y}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}} )\%\coqdocvar{type}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Equivalences.equiv to hiso}{equiv\_to\_hiso}{\coqdoclemma{equiv\_to\_hiso}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqref{Equivalences.equiv}{\coqdocdefinition{equiv}} \coqdocvar{A} \coqdocvar{B}) : \coqref{Equivalences.is hiso}{\coqdocdefinition{is\_hiso}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{split}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Equivalences.hiso to equiv}{hiso\_to\_equiv}{\coqdoclemma{hiso\_to\_equiv}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) : \coqref{Equivalences.is hiso}{\coqdocdefinition{is\_hiso}} \coqdocvar{f} \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvar{f}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{H} \coqdockw{as} ((\coqdocvar{g}, \coqdocvar{is\_retraction}), (\coqdocvar{h}, \coqdocvar{is\_section})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{eapply} \coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{instantiate} (1 := \coqdocvar{g}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{f} (\coqdocvar{h} \coqdocvar{y})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqdocvar{g} (\coqdocvar{f} (\coqdocvar{h} (\coqdocvar{y})))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Of course, the harder part is showing that is\_hiso is a proposition. \begin{coqdoccode}
\end{coqdoccode}
\coqlibrary{FiberEquivalences}{Library }{FiberEquivalences}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Fibrations}{\coqdoclibrary{Fibrations}} \coqref{Equivalences}{\coqdoclibrary{Equivalences}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The map on total spaces induced by a map of fibrations \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{FiberEquivalences.total map}{total\_map}{\coqdocdefinition{total\_map}} \{\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{Q} : \coqdocvar{B} \ensuremath{\rightarrow} \coqdockw{Type}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) (\coqdocvar{g} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqdocvar{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvar{Q} (\coqdocvar{f} \coqdocvar{x})) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{P} \ensuremath{\rightarrow} \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvar{Q}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{P} \coqdocvar{Q} \coqdocvar{f} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdocvar{f} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqdocvar{g} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We first consider maps between fibrations over the same base
   space.  The theorem is that such a map induces an equivalence on
   total spaces if and only if it is an equivalence on all fibers. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Section} \coqdef{FiberEquivalences.FiberMap}{FiberMap}{\coqdocsection{FiberMap}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.FiberMap.A}{A}{\coqdocvariable{A}} : \coqdockw{Type}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variables} \coqdef{FiberEquivalences.FiberMap.P}{P}{\coqdocvariable{P}} \coqdef{FiberEquivalences.FiberMap.Q}{Q}{\coqdocvariable{Q}} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdockw{Type}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.FiberMap.g}{g}{\coqdocvariable{g}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvariable{Q} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.tg}{tg}{\coqdocvariable{tg}} := \coqref{FiberEquivalences.total map}{\coqdocdefinition{total\_map}} (\coqref{Functions.idmap}{\coqdocdefinition{idmap}} \coqdocvariable{A}) \coqdocvariable{g}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.tg is fiberwise}{tg\_is\_fiberwise}{\coqdocvariable{tg\_is\_fiberwise}} (\coqdocvar{z} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P}) : \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{z} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} (\coqdocvariable{tg} \coqdocvar{z}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.tg isg onfibers}{tg\_isg\_onfibers}{\coqdocvariable{tg\_isg\_onfibers}} (\coqdocvar{z} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P}) :\coqdoceol
\coqdocindent{2.00em}
\coqdocvariable{g} \coqdocvar{\_} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvariable{tg\_is\_fiberwise} \coqdocvar{z}) (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{z})) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqdocvariable{tg} \coqdocvar{z}).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.tg isfib onpaths}{tg\_isfib\_onpaths}{\coqdocvariable{tg\_isfib\_onpaths}} (\coqdocvar{z} \coqdocvar{w} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P}) (\coqdocvar{p} : \coqdocvar{z} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{w}) :\coqdoceol
\coqdocindent{2.00em}
\coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvariable{tg\_is\_fiberwise} \coqdocvar{z} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{tg} \coqdocvar{p}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvariable{tg\_is\_fiberwise} \coqdocvar{w}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{destruct} \coqdocvar{x}. \coqdoctac{simpl}. \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Section} \coqdef{FiberEquivalences.FiberMap.TotalIsEquiv}{TotalIsEquiv}{\coqdocsection{TotalIsEquiv}}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Hypothesis} \coqdef{FiberEquivalences.FiberMap.TotalIsEquiv.tot iseqv}{tot\_iseqv}{\coqdocvariable{tot\_iseqv}} : \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvariable{tg}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.TotalIsEquiv.tot eqv}{tot\_eqv}{\coqdocvariable{tot\_eqv}} : \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} := \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{tg} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvariable{tot\_iseqv}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.TotalIsEquiv.ginv}{ginv}{\coqdocvariable{ginv}} (\coqdocvar{x}:\coqdocvariable{A}) (\coqdocvar{y}: \coqdocvariable{Q} \coqdocvar{x}) : \coqdocvariable{P} \coqdocvar{x}.\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{set} (\coqdocvar{inv1} := \coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} ((\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}) \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{tot\_eqv} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvariable{tg\_is\_fiberwise} ((\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}) \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Theorem} \coqdef{FiberEquivalences.fiber is equiv}{fiber\_is\_equiv}{\coqdoclemma{fiber\_is\_equiv}} (\coqdocvar{x}:\coqdocvariable{A}) : \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvariable{g} \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} \coqdocvar{x}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{set} (\coqdocvar{is\_section} := \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{tot\_eqv}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{set} (\coqdocvar{is\_retraction} := \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvariable{tot\_eqv}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{set} (\coqdocvar{triangle} := \coqref{Equivalences.inverse triangle}{\coqdocdefinition{inverse\_triangle}} \coqdocvariable{tot\_eqv}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqdocvariable{ginv} \coqdocvar{x}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdocvariable{Q})\coqdoceol
\coqdocindent{4.00em}
(\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqdocvar{is\_section} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))\coqdoceol
\coqdocindent{4.00em}
(\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqdocvariable{tot\_eqv} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})))).\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}}\coqdoceol
\coqdocindent{4.00em}
(\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqdocvar{is\_section} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))\coqdoceol
\coqdocindent{4.00em}
(\coqdocvariable{g} \coqdocvar{\_} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvariable{tg\_is\_fiberwise} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))\coqdoceol
\coqdocindent{5.00em}
(\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Fibrations.trans map}{\coqdoclemma{trans\_map}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{exact} (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} (\coqdocvar{is\_section} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \coqdocvar{x} \coqdocvar{y}))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{tg} (\coqdocvar{is\_retraction} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})))\coqdoceol
\coqdocindent{3.00em}
(\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvariable{tg\_is\_fiberwise} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{))}}))\coqdoceol
\coqdocindent{4.00em}
(\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{))}})))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{unfold} \coqdocvar{ginv}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.happly}{\coqdocdefinition{happly}}, \coqref{Paths.map}{\coqdoclemma{map}}, \coqref{Paths.map}{\coqdoclemma{map}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqdocvar{triangle}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}}\coqdoceol
\coqdocindent{4.00em}
(\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqdocvar{is\_retraction} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))\coqdoceol
\coqdocindent{4.00em}
(\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{))}}))).\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}}\coqdoceol
\coqdocindent{4.00em}
(\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvariable{tg\_is\_fiberwise} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{))}})\coqref{Paths.::x '@' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{5.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{tg} (\coqdocvar{is\_retraction} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}))\coqref{Paths.::x '@' x}{\coqdocnotation{)}})\coqdoceol
\coqdocindent{4.00em}
(\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} ((\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}) \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{))}}))).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Fibrations.trans concat}{\coqdoclemma{trans\_concat}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Paths.happly}{\coqdocdefinition{happly}}, \coqref{Paths.map}{\coqdoclemma{map}}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqdocvariable{tg\_is\_fiberwise} (\coqdocvariable{tot\_eqv}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{))}}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}}\coqdoceol
\coqdocindent{4.00em}
\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{tg} (\coqdocvar{is\_retraction} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})) \coqref{Paths.::x '@' x}{\coqdocnotation{@}}\coqdoceol
\coqdocindent{4.00em}
\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvariable{tg\_is\_fiberwise} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{y}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{exact} (\coqref{Fibrations.fiber path}{\coqdocdefinition{fiber\_path}} (\coqdocvar{is\_retraction} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \coqdocvar{x} \coqdocvar{y}))).\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Definition} \coqdef{FiberEquivalences.fiber equiv}{fiber\_equiv}{\coqdocdefinition{fiber\_equiv}} (\coqdocvar{x}:\coqdocvariable{A}) : \coqdocvariable{P} \coqdocvar{x} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvariable{Q} \coqdocvar{x} :=\coqdoceol
\coqdocindent{3.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{FiberEquivalences.fiber is equiv}{\coqdoclemma{fiber\_is\_equiv}} \coqdocvar{x}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{End} \coqref{FiberEquivalences.FiberMap.TotalIsEquiv}{\coqdocsection{TotalIsEquiv}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Section} \coqdef{FiberEquivalences.FiberMap.FiberIsEquiv}{FiberIsEquiv}{\coqdocsection{FiberIsEquiv}}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Hypothesis} \coqdef{FiberEquivalences.FiberMap.FiberIsEquiv.fiber iseqv}{fiber\_iseqv}{\coqdocvariable{fiber\_iseqv}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvariable{g} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.FiberIsEquiv.fiber eqv}{fiber\_eqv}{\coqdocvariable{fiber\_eqv}} \coqdocvar{x} : \coqdocvariable{P} \coqdocvar{x} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvariable{Q} \coqdocvar{x} := \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvariable{fiber\_iseqv} \coqdocvar{x}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FiberMap.FiberIsEquiv.total inv}{total\_inv}{\coqdocvariable{total\_inv}} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q} \ensuremath{\rightarrow} \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P}.\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{x}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} (\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{(}}\coqdocvariable{fiber\_eqv} \coqdocvar{x}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{)\^{}-1}}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Theorem} \coqdef{FiberEquivalences.total is equiv}{total\_is\_equiv}{\coqdoclemma{total\_is\_equiv}} : \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvariable{tg}.\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{eapply} \coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{instantiate} (1 := \coqdocvariable{total\_inv}).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{eapply} \coqref{Fibrations.total path}{\coqdoclemma{total\_path}}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{instantiate} (1 := \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}).\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqdocvariable{fiber\_eqv} \coqdocvar{x} ((\coqdocvariable{fiber\_eqv} \coqdocvar{x} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}) \coqdocvar{y})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{eapply} \coqref{Fibrations.total path}{\coqdoclemma{total\_path}}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{instantiate} (1 := \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}).\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{path\_via} (\coqdocvariable{fiber\_eqv} \coqdocvar{x} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} (\coqdocvariable{fiber\_eqv} \coqdocvar{x} \coqdocvar{y})).\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}}.\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Definition} \coqdef{FiberEquivalences.total equiv}{total\_equiv}{\coqdocdefinition{total\_equiv}} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q} :=\coqdoceol
\coqdocindent{3.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{tg} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{FiberEquivalences.total is equiv}{\coqdoclemma{total\_is\_equiv}}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{End} \coqref{FiberEquivalences.FiberMap.FiberIsEquiv}{\coqdocsection{FiberIsEquiv}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{FiberEquivalences.FiberMap}{\coqdocsection{FiberMap}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.fiber equiv}{\coqdocdefinition{fiber\_equiv}} [\coqdocvar{A}].\coqdoceol
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.fiber is equiv}{\coqdoclemma{fiber\_is\_equiv}} [\coqdocvar{A}].\coqdoceol
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.total equiv}{\coqdocdefinition{total\_equiv}} [\coqdocvar{A}].\coqdoceol
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.total is equiv}{\coqdoclemma{total\_is\_equiv}} [\coqdocvar{A}].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Next we consider a fibration over one space and its pullback along
   a map from another base space.  The theorem is that if the map we
   pull back along is an equivalence, so is the induced map on total
   spaces. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Section} \coqdef{FiberEquivalences.PullbackMap}{PullbackMap}{\coqdocsection{PullbackMap}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Variables} \coqdef{FiberEquivalences.PullbackMap.A}{A}{\coqdocvariable{A}} \coqdef{FiberEquivalences.PullbackMap.B}{B}{\coqdocvariable{B}} : \coqdockw{Type}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.PullbackMap.Q}{Q}{\coqdocvariable{Q}} : \coqdocvariable{B} \ensuremath{\rightarrow} \coqdockw{Type}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.PullbackMap.f}{f}{\coqdocvariable{f}} : \coqdocvariable{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvariable{B}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.PullbackMap.pbQ}{pbQ}{\coqdocvariable{pbQ}} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdockw{Type} := \coqdocvariable{Q} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvariable{f}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.PullbackMap.g}{g}{\coqdocvariable{g}} (\coqdocvar{x}:\coqdocvariable{A}) : \coqdocvariable{pbQ} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvariable{Q} (\coqdocvariable{f} \coqdocvar{x}) := \coqref{Functions.idmap}{\coqdocdefinition{idmap}} (\coqdocvariable{Q} (\coqdocvariable{f} \coqdocvar{x})).\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.PullbackMap.tg}{tg}{\coqdocvariable{tg}} := \coqref{FiberEquivalences.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{f} \coqdocvariable{g}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.PullbackMap.tginv}{tginv}{\coqdocvariable{tginv}} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q} \ensuremath{\rightarrow} \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{pbQ}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{z}].\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdocvariable{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} \coqdocvar{x})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Theorem} \coqdef{FiberEquivalences.pullback total is equiv}{pullback\_total\_is\_equiv}{\coqdoclemma{pullback\_total\_is\_equiv}} : \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvariable{tg}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqdocvariable{tginv}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{z}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdockw{with} (\coqdocvar{p} := \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} \coqdocvar{x} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} \coqdocvar{x}) \coqdocvar{z}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Fibrations.trans concat}{\coqdoclemma{trans\_concat}}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}) \coqdocvar{z}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} @\coqref{Paths.map}{\coqdoclemma{map}} \coqdockw{with} (\coqdocvar{f} := \coqdockw{fun} \coqdocvar{p} \ensuremath{\Rightarrow} \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} \coqdocvar{z}).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{cancel\_opposites}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{z}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdockw{with} (\coqdocvar{p} := \coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvariable{f} \coqdocvar{x}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{f} (\coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvariable{f} \coqdocvar{x}))\coqdoceol
\coqdocindent{2.50em}
(\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} (\coqdocvariable{f} \coqdocvar{x})) \coqdocvar{z})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Fibrations.map trans}{\coqdoclemma{map\_trans}}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} (\coqdocvariable{f} \coqdocvar{x}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{f} (\coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvariable{f} \coqdocvar{x})) \coqdocvar{z}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Fibrations.trans concat}{\coqdoclemma{trans\_concat}}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvariable{f} \coqdocvar{x})) \coqdocvar{z}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{p} : \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} (\coqdocvariable{f} \coqdocvar{x}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{f} (\coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvariable{f} \coqdocvar{x})\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvariable{f} \coqdocvar{x})).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{moveright\_onleft}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse triangle}{\coqdocdefinition{inverse\_triangle}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{exact} (@\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} \coqdocvariable{f} (\coqdocvariable{f} \coqdocvar{x}) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqref{Paths.map}{\coqdoclemma{map}} \coqdocvariable{f} (\coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} \coqdocvariable{f} \coqdocvar{x}))\coqdoceol
\coqdocindent{3.00em}
(\coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvariable{f} \coqdocvar{x}))\coqdoceol
\coqdocindent{3.00em}
(\coqdockw{fun} \coqdocvar{p} \ensuremath{\Rightarrow} \coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} \coqdocvar{z}) \coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{FiberEquivalences.pullback total equiv}{pullback\_total\_equiv}{\coqdocdefinition{pullback\_total\_equiv}} : \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{pbQ} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q} :=\coqdoceol
\coqdocindent{2.00em}
\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{\_} \coqdocvariable{tg} \coqref{FiberEquivalences.pullback total is equiv}{\coqdoclemma{pullback\_total\_is\_equiv}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{FiberEquivalences.PullbackMap}{\coqdocsection{PullbackMap}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.pullback total is equiv}{\coqdoclemma{pullback\_total\_is\_equiv}} [\coqdocvar{A} \coqdocvar{B}].\coqdoceol
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.pullback total equiv}{\coqdocdefinition{pullback\_total\_equiv}} [\coqdocvar{A} \coqdocvar{B}].\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Finally, we can put these together to prove that given a map of
   fibrations lying over an equivalence of base spaces, the induced
   map on total spaces is an equivalence if and only if the map on
   each fiber is an equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Section} \coqdef{FiberEquivalences.FibrationMap}{FibrationMap}{\coqdocsection{FibrationMap}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Variables} \coqdef{FiberEquivalences.FibrationMap.A}{A}{\coqdocvariable{A}} \coqdef{FiberEquivalences.FibrationMap.B}{B}{\coqdocvariable{B}} : \coqdockw{Type}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.FibrationMap.P}{P}{\coqdocvariable{P}} : \coqdocvariable{A} \ensuremath{\rightarrow} \coqdockw{Type}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.FibrationMap.Q}{Q}{\coqdocvariable{Q}} : \coqdocvariable{B} \ensuremath{\rightarrow} \coqdockw{Type}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.FibrationMap.f}{f}{\coqdocvariable{f}} : \coqdocvariable{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvariable{B}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdef{FiberEquivalences.FibrationMap.g}{g}{\coqdocvariable{g}} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvariable{A}, \coqdocvariable{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvariable{Q} (\coqdocvariable{f} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FibrationMap.tg}{tg}{\coqdocvariable{tg}} := \coqref{FiberEquivalences.total map}{\coqdocdefinition{total\_map}} \coqdocvariable{f} \coqdocvariable{g}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FibrationMap.pbQ}{pbQ}{\coqdocvariable{pbQ}} := \coqdocvariable{Q} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvariable{f}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FibrationMap.pbg}{pbg}{\coqdocvariable{pbg}} (\coqdocvar{x} : \coqdocvariable{A}) : \coqdocvariable{P} \coqdocvar{x} \ensuremath{\rightarrow} \coqdocvariable{pbQ} \coqdocvar{x} := \coqdocvariable{g} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Theorem} \coqdef{FiberEquivalences.fibseq fiber is equiv}{fibseq\_fiber\_is\_equiv}{\coqdoclemma{fibseq\_fiber\_is\_equiv}} :\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvariable{tg} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvariable{g} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{set} (\coqdocvar{pbmap\_equiv} := \coqref{FiberEquivalences.pullback total is equiv}{\coqdoclemma{pullback\_total\_is\_equiv}} \coqdocvariable{Q} \coqdocvariable{f}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{FiberEquivalences.fiber is equiv}{\coqdoclemma{fiber\_is\_equiv}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} @\coqref{Equivalences.equiv cancel left}{\coqdocdefinition{equiv\_cancel\_left}} \coqdockw{with} (\coqdocvar{C} := \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q}) (\coqdocvar{g} := \coqref{FiberEquivalences.pullback total equiv}{\coqdocdefinition{pullback\_total\_equiv}} \coqdocvariable{Q} \coqdocvariable{f}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} @\coqref{Equivalences.equiv homotopic}{\coqdoclemma{equiv\_homotopic}} \coqdockw{with} (\coqdocvar{g} := \coqdocvariable{tg}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{FiberEquivalences.fibseq fiber equiv}{fibseq\_fiber\_equiv}{\coqdocdefinition{fibseq\_fiber\_equiv}} :\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvariable{tg} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvariable{P} \coqdocvar{x} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvariable{Q} (\coqdocvariable{f} \coqdocvar{x}) :=\coqdoceol
\coqdocindent{3.00em}
\coqdockw{fun} \coqdocvar{H} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{g} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{FiberEquivalences.fibseq fiber is equiv}{\coqdoclemma{fibseq\_fiber\_is\_equiv}} \coqdocvar{H} \coqdocvar{x}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Let} \coqdef{FiberEquivalences.FibrationMap.fibseq a totalequiv}{fibseq\_a\_totalequiv}{\coqdocvariable{fibseq\_a\_totalequiv}} :\coqdoceol
\coqdocindent{2.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvariable{g} \coqdocvar{x})) \ensuremath{\rightarrow} (\coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q}).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} @\coqref{Equivalences.equiv compose}{\coqdocdefinition{equiv\_compose}} \coqdockw{with} (\coqdocvar{B} := \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{pbQ}).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{\ensuremath{\exists}} (\coqref{FiberEquivalences.total map}{\coqdocdefinition{total\_map}} (\coqref{Functions.idmap}{\coqdocdefinition{idmap}} \coqdocvariable{A}) \coqdocvariable{pbg}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} @\coqref{FiberEquivalences.total is equiv}{\coqdoclemma{total\_is\_equiv}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{FiberEquivalences.pullback total equiv}{\coqdocdefinition{pullback\_total\_equiv}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Theorem} \coqdef{FiberEquivalences.fibseq total is equiv}{fibseq\_total\_is\_equiv}{\coqdoclemma{fibseq\_total\_is\_equiv}} :\coqdoceol
\coqdocindent{2.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvariable{g} \coqdocvar{x})) \ensuremath{\rightarrow} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} \coqdocvariable{tg}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} @\coqref{Equivalences.equiv homotopic}{\coqdoclemma{equiv\_homotopic}} \coqdockw{with} (\coqdocvar{g} := \coqdocvariable{fibseq\_a\_totalequiv} \coqdocvar{H}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} [\coqdocvar{x} \coqdocvar{y}].\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{exact} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqdocvariable{fibseq\_a\_totalequiv} \coqdocvar{H})).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{FiberEquivalences.fibseq total equiv}{fibseq\_total\_equiv}{\coqdocdefinition{fibseq\_total\_equiv}} :\coqdoceol
\coqdocindent{2.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (\coqdocvariable{g} \coqdocvar{x})) \ensuremath{\rightarrow} (\coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{P} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqexternalref{sigT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocinductive{sigT}} \coqdocvariable{Q}) :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{fun} \coqdocvar{H} \ensuremath{\Rightarrow} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvariable{tg} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{FiberEquivalences.fibseq total is equiv}{\coqdoclemma{fibseq\_total\_is\_equiv}} \coqdocvar{H}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{FiberEquivalences.FibrationMap}{\coqdocsection{FibrationMap}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.fibseq fiber is equiv}{\coqdoclemma{fibseq\_fiber\_is\_equiv}} [\coqdocvar{A} \coqdocvar{B}].\coqdoceol
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.fibseq fiber equiv}{\coqdocdefinition{fibseq\_fiber\_equiv}} [\coqdocvar{A} \coqdocvar{B}].\coqdoceol
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.fibseq total is equiv}{\coqdoclemma{fibseq\_total\_is\_equiv}} [\coqdocvar{A} \coqdocvar{B}].\coqdoceol
\coqdocnoindent
\coqdockw{Implicit Arguments} \coqref{FiberEquivalences.fibseq total equiv}{\coqdocdefinition{fibseq\_total\_equiv}} [\coqdocvar{A} \coqdocvar{B}].\coqdoceol
\end{coqdoccode}
\coqlibrary{Funext}{Library }{Funext}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Fibrations}{\coqdoclibrary{Fibrations}} \coqref{Contractible}{\coqdoclibrary{Contractible}} \coqref{Equivalences}{\coqdoclibrary{Equivalences}} \coqref{FiberEquivalences}{\coqdoclibrary{FiberEquivalences}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Much of the content here is closely related to Richard Garners paper On the strength of dependent products.  We use different terminology in places, but recall his for comparison. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Naive functional extensionality}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
The simplest notion we call naive functional extensionality.
   This is what a type theorist would probably write down when
   thinking of types as sets and identity types as equalities: it says
   that if two functions are equal pointwise, then they are equal.  It
   comes in both ordinary and dependent versions. 


   From an HoTT point of view, the type of \textit{extensional equality} or \textit{pointwise equality} between two functions can also be seen as the type of \textit{homotopies} between them. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.ext dep eq}{ext\_dep\_eq}{\coqdocdefinition{ext\_dep\_eq}} \{\coqdocvar{X}\} \{\coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Type}\} (\coqdocvar{f} \coqdocvar{g} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x})\coqdoceol
\coqdocindent{1.00em}
:= \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{X}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdocvar{Notation }\coqdef{Funext.::x '===' x}{"}{\coqdocnotation{"}}f === g" := (\coqref{Funext.ext dep eq}{\coqdocdefinition{ext\_dep\_eq}} \coqdocvar{f} \coqdocvar{g}) (\coqdoctac{at} \coqdocvar{level} 50).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.funext statement}{funext\_statement}{\coqdocdefinition{funext\_statement}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}) (\coqdocvar{f} \coqdocvar{g}: \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y}), \coqdocvar{f} \coqref{Funext.::x '===' x}{\coqdocnotation{===}} \coqdocvar{g} \ensuremath{\rightarrow} \coqdocvar{f} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.funext dep statement}{funext\_dep\_statement}{\coqdocdefinition{funext\_dep\_statement}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{f} \coqdocvar{g} : \coqref{Fibrations.section}{\coqdocdefinition{section}} \coqdocvar{P}), \coqdocvar{f} \coqref{Funext.::x '===' x}{\coqdocnotation{===}} \coqdocvar{g} \ensuremath{\rightarrow} (\coqdocvar{f} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g}).\coqdoceol
\end{coqdoccode}
This is the rule Pi-ext in Garner. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
However, there are clearly going to be problems with this in the
   homotopy world, since being equal is not merely a property, but
   being equipped with a path is structure.  We should expect some
   sort of coherence or canonicity of the path from f to g relating it
   to the pointwise homotopy we started with.  


   There are (at least) two natural computation principles one might consider.  The first fits with thinking of \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}} as an \textit{eliminator}: it tells us what happens if we apply \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}} to a term of canonical form. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.funext comp1 statement}{funext\_comp1\_statement}{\coqdocdefinition{funext\_comp1\_statement}} (\coqdocvar{funext} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}})\coqdoceol
\coqdocindent{1.00em}
:= (\coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f}, \coqdocvar{funext} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{f} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{f}).\coqdoceol
\end{coqdoccode}
A propositional form of Garners Pi-ext-comp. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Does this rule follow automatically?  Yes and no.  Given a witness \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}}, this does not necessarily hold for \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}} itself; but we can always find a better witness which it does hold: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.funext correction}{funext\_correction}{\coqdocdefinition{funext\_correction}} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}}\coqdoceol
\coqdocindent{1.00em}
:= (\coqdockw{fun} \coqdocvar{funext} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdockw{fun} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g} \coqdocvar{h} \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{6.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{(}}\coqdocvar{funext} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g} \coqdocvar{h}\coqref{Paths.::x '@' x}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{5.00em}
\coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdoceol
\coqdocindent{6.00em}
\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.::'!' x}{\coqdocnotation{(}}\coqdocvar{funext} \coqdocvar{X} \coqdocvar{P} \coqdocvar{g} \coqdocvar{g} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{g} \coqdocvar{x}))\coqref{Paths.::'!' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.funext correction comp1}{funext\_correction\_comp1}{\coqdoclemma{funext\_correction\_comp1}} :\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{funext} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}}),\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.funext comp1 statement}{\coqdocdefinition{funext\_comp1\_statement}} (\coqref{Funext.funext correction}{\coqdocdefinition{funext\_correction}} \coqdocvar{funext}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{funext\_comp1\_statement}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{funext\_correction}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto} \coqdockw{with} \coqdocvar{path\_hints}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
On the other hand, if we think of \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}} as more like a \textit{1-dimensional constructor} for Pi-types,  we can be led to the following rule, telling us what happens to it under the destructor for Pi-types, function application (bumped up to dimension 1 via happly): \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.funext comp2 statement}{funext\_comp2\_statement}{\coqdocdefinition{funext\_comp2\_statement}} (\coqdocvar{funext} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}})\coqdoceol
\coqdocindent{1.00em}
:= (\coqdockw{\ensuremath{\forall}} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g} \coqdocvar{p} \coqdocvar{x},\coqdoceol
\coqdocindent{3.00em}
\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} (\coqdocvar{funext} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g} \coqdocvar{p}) \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqdocvar{x}).\coqdoceol
\end{coqdoccode}
Pi-ext-app in Garner. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Does this rule follow automatically?  *Yes*, and in fact for a given witness \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}}, its equivalent to \coqref{Funext.funext comp1 statement}{\coqdocdefinition{funext\_comp1\_statement}} above.  However, this seems quite non-trivial to prove; it will follow eventually from the comparision with contractible functional extensionality.  So we leave this for now, and will return to it later. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Strong functional extensionality}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Alternatively, a natural way to state a homotopically good notion of function
   extensionality is to observe that there is a canonical map in the
   other direction, taking paths between functions to pointwise
   homotopies.  We can thus just ask for that map to be an
   equivalence.  We call this strong functional extensionality.  Of
   course, it also comes in ordinary and dependent versions.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.strong funext statement}{strong\_funext\_statement}{\coqdocdefinition{strong\_funext\_statement}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} \coqdocvar{Y} : \coqdockw{Type}) (\coqdocvar{f} \coqdocvar{g} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y}), \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Paths.happly}{\coqdocdefinition{happly}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.strong funext dep statement}{strong\_funext\_dep\_statement}{\coqdocdefinition{strong\_funext\_dep\_statement}} : \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{f} \coqdocvar{g} : \coqref{Fibrations.section}{\coqdocdefinition{section}} \coqdocvar{P}),\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Of course, strong functional extensionality implies naive
   functional extensionality, along with both computation rules. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.strong to naive funext}{strong\_to\_naive\_funext}{\coqdoclemma{strong\_to\_naive\_funext}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.strong funext statement}{\coqdocdefinition{strong\_funext\_statement}} \ensuremath{\rightarrow} \coqref{Funext.funext statement}{\coqdocdefinition{funext\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}@\coqref{Paths.happly}{\coqdocdefinition{happly}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}  \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}}  \coqdocvar{H} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.strong funext compute}{strong\_funext\_compute}{\coqdoclemma{strong\_funext\_compute}}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{strong\_funext} : \coqref{Funext.strong funext statement}{\coqdocdefinition{strong\_funext\_statement}})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{X} \coqdocvar{Y}:\coqdockw{Type}) (\coqdocvar{f} \coqdocvar{g} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdocvar{Y}) (\coqdocvar{p} : \coqdocvar{f} \coqref{Funext.::x '===' x}{\coqdocnotation{===}} \coqdocvar{g}) (\coqdocvar{x} : \coqdocvar{X}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Paths.happly}{\coqdocdefinition{happly}} (\coqref{Funext.strong to naive funext}{\coqdoclemma{strong\_to\_naive\_funext}} \coqdocvar{strong\_funext} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{p}) \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} \coqdocvar{x}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{strong\_to\_naive\_funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{inverse}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} (\coqdocvar{strong\_funext} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqdocvar{p}))) \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.strong to naive funext dep}{strong\_to\_naive\_funext\_dep}{\coqdoclemma{strong\_to\_naive\_funext\_dep}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}@\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{H} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.strong funext dep comp1}{strong\_funext\_dep\_comp1}{\coqdoclemma{strong\_funext\_dep\_comp1}}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{strong\_funext\_dep} : \coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}})\coqdoceol
\coqdocnoindent
: \coqref{Funext.funext comp1 statement}{\coqdocdefinition{funext\_comp1\_statement}} (\coqref{Funext.strong to naive funext dep}{\coqdoclemma{strong\_to\_naive\_funext\_dep}} \coqdocvar{strong\_funext\_dep}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{funext\_comp1\_statement}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{strong\_to\_naive\_funext\_dep}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{inverse}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{strong\_funext\_dep\_statement} \coqdoctac{in} \ensuremath{\times}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (@\coqref{Fibrations.base path}{\coqdocdefinition{base\_path}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} (\coqdocvar{strong\_funext\_dep} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{f} (\coqdockw{fun} \coqdocvar{x} : \coqdocvar{X} \ensuremath{\Rightarrow} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})))) \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{f}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{\_}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqdocvar{strong\_funext\_dep} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{f} (\coqdockw{fun} \coqdocvar{x} : \coqdocvar{X} \ensuremath{\Rightarrow} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})))).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.strong funext dep comp2}{strong\_funext\_dep\_comp2}{\coqdoclemma{strong\_funext\_dep\_comp2}}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{strong\_funext\_dep} : \coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}})\coqdoceol
\coqdocindent{1.00em}
: \coqref{Funext.funext comp2 statement}{\coqdocdefinition{funext\_comp2\_statement}} (\coqref{Funext.strong to naive funext dep}{\coqdoclemma{strong\_to\_naive\_funext\_dep}} \coqdocvar{strong\_funext\_dep}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{funext\_comp2\_statement}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{strong\_to\_naive\_funext\_dep}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{inverse}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} (\coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} (\coqdocvar{strong\_funext\_dep} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g} \coqdocvar{p}))) \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.strong funext dep compute}{strong\_funext\_dep\_compute}{\coqdocdefinition{strong\_funext\_dep\_compute}} := \coqref{Funext.strong funext dep comp2}{\coqdoclemma{strong\_funext\_dep\_comp2}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Conversely, does naive functional extensionality imply the strong form?  Assuming \textit{both} computation rules, this is not hard to show: \coqdocvar{comp1} says that \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}} gives a left inverse to \coqref{Paths.happly}{\coqdocdefinition{happly}}, \coqdocvar{comp2} that it gives a right inverse. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.funext both comps to strong}{funext\_both\_comps\_to\_strong}{\coqdoclemma{funext\_both\_comps\_to\_strong}}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{funext} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{funext\_comp1} : \coqref{Funext.funext comp1 statement}{\coqdocdefinition{funext\_comp1\_statement}} \coqdocvar{funext})\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{funext\_comp2} : \coqref{Funext.funext comp2 statement}{\coqdocdefinition{funext\_comp2\_statement}} \coqdocvar{funext})\coqdoceol
\coqdocnoindent
: \coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{unfold} \coqdocvar{strong\_funext\_dep\_statement}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} (\coqdocvar{funext} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f} \coqdocvar{g})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{h\_fg}. \coqdoctac{apply} \coqdocvar{funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}. \coqdoctac{apply} (\coqdocvar{funext\_comp2} \coqdocvar{X} \coqdocvar{P}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{p}. \coqdoctac{destruct} \coqdocvar{p}. \coqdoctac{apply} \coqdocvar{funext\_comp1}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
But can we do better, getting to strong functional extensionality from just naive functional extensionality alone?  At first the prospects don't look good; naive functional extensionality provides us with paths, but doesnt tell us anything about the behaviour of those paths under elimination, so it seems unlikely that it would be an inverse to \coqref{Paths.happly}{\coqdocdefinition{happly}}.


   However, it turns out that we can do it!  Its easiest to go via another extensionality statement: \textit{contractible functional extensionality}, \coqref{Funext.contr funext statement}{\coqdocdefinition{contr\_funext\_statement}} below.  Before that, though, we need a quick technical digression on eta rules. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Eta rules and tactics}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Another (very) weak type of functional extensionality is the
   (propositional) eta rule, which is implied by naive functional
   extensionality. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.eta}{eta}{\coqdocdefinition{eta}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.eta statement}{eta\_statement}{\coqdocdefinition{eta\_statement}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{A} \coqdocvar{B}:\coqdockw{Type}) (\coqdocvar{f} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}), \coqref{Funext.eta}{\coqdocdefinition{eta}} \coqdocvar{f} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.naive funext implies eta}{naive\_funext\_implies\_eta}{\coqdoclemma{naive\_funext\_implies\_eta}} : \coqref{Funext.funext statement}{\coqdocdefinition{funext\_statement}} \ensuremath{\rightarrow} \coqref{Funext.eta statement}{\coqdocdefinition{eta\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{funext} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is the dependent version. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.eta dep}{eta\_dep}{\coqdocdefinition{eta\_dep}} \{\coqdocvar{A}\} \{\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} (\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.eta dep statement}{eta\_dep\_statement}{\coqdocdefinition{eta\_dep\_statement}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{A}:\coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}), \coqref{Funext.eta dep}{\coqdocdefinition{eta\_dep}} \coqdocvar{f} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.naive funext dep implies eta}{naive\_funext\_dep\_implies\_eta}{\coqdoclemma{naive\_funext\_dep\_implies\_eta}} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{funext\_dep} \coqdocvar{A} \coqdocvar{P} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{funext\_dep}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A mini form of the main theorem (naive => strong) is that
   the eta rule implies directly that the eta map is an
   equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.eta is equiv}{eta\_is\_equiv}{\coqdoclemma{eta\_is\_equiv}} : \coqref{Funext.eta statement}{\coqdocdefinition{eta\_statement}} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}),\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Funext.eta}{\coqdocdefinition{eta}} \coqdocvar{A} \coqdocvar{B}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{A} \coqdocvar{B}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.equiv pointwise idmap}{\coqdoclemma{equiv\_pointwise\_idmap}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.eta equiv}{eta\_equiv}{\coqdocdefinition{eta\_equiv}} (\coqdocvar{Heta} : \coqref{Funext.eta statement}{\coqdocdefinition{eta\_statement}}) (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{B}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Funext.eta}{\coqdocdefinition{eta}} \coqdocvar{A} \coqdocvar{B}) (\coqref{Funext.eta is equiv}{\coqdoclemma{eta\_is\_equiv}} \coqdocvar{Heta} \coqdocvar{A} \coqdocvar{B}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And the dependent version. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.eta dep is equiv}{eta\_dep\_is\_equiv}{\coqdoclemma{eta\_dep\_is\_equiv}} : \coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} (\coqdocvar{A}:\coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}),\coqdoceol
\coqdocindent{1.50em}
\coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Funext.eta dep}{\coqdocdefinition{eta\_dep}} \coqdocvar{A} \coqdocvar{P}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{A} \coqdocvar{P}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.equiv pointwise idmap}{\coqdoclemma{equiv\_pointwise\_idmap}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.eta dep equiv}{eta\_dep\_equiv}{\coqdocdefinition{eta\_dep\_equiv}} (\coqdocvar{Heta} : \coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}}) (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} :=\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Funext.eta dep}{\coqdocdefinition{eta\_dep}} \coqdocvar{A} \coqdocvar{P}) (\coqref{Funext.eta dep is equiv}{\coqdoclemma{eta\_dep\_is\_equiv}} \coqdocvar{Heta} \coqdocvar{A} \coqdocvar{P}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Some tactics for working with eta-expansion.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{eta\_intro} \coqdocvar{f} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} [ \coqdocvar{eta\_rule} : \coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}} \ensuremath{\vdash} \coqdockw{\ensuremath{\forall}} (\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{\_}, \coqdocvar{\_}), @?\coqdocvar{Q} \coqdocvar{f}] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{intro} \coqdocvar{f};\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} (@\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{\_} \coqdocvar{Q} \coqdocvar{\_} \coqdocvar{\_} (\coqdocvar{eta\_rule} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f}));\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{unfold} \coqdocvar{eta\_dep}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} \coqdockw{\ensuremath{\forall}} \coqdocvar{f}, @?\coqdocvar{Q} \coqdocvar{f} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{eta\_rule} := \coqdoctac{fresh} "eta\_rule" \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{intro} \coqdocvar{f};\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{cut} \coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}}; \coqdoceol
\coqdocindent{4.00em}
\coqdoceol
\coqdocindent{5.00em}
[ \coqdoctac{intro} \coqdocvar{eta\_rule};\coqdoceol
\coqdocindent{6.00em}
\coqdoctac{apply} (@\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{\_} \coqdocvar{Q} \coqdocvar{\_} \coqdocvar{\_} (\coqdocvar{eta\_rule} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{f}));\coqdoceol
\coqdocindent{6.00em}
\coqdoctac{unfold} \coqdocvar{eta\_dep} \coqdoceol
\coqdocindent{5.00em}
\ensuremath{|} \coqdoctac{try} \coqdoctac{auto} ]\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \ensuremath{\vdash} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{idtac} "Goal not quantified over a function; cannot eta-introduce."\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{eta\_expand} \coqdocvar{f} := \coqdoceol
\coqdocindent{1.00em}
\coqdocvar{revert} \coqdoctac{dependent} \coqdocvar{f};\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{eta\_intro} \coqdocvar{f}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Possible improvements to these tactics:

\begin{itemize}
\item  At end of \coqdocvar{eta\_expand}, reintroduce any other hypotheses generalized at the beginning of it.

\item  Make \coqdocvar{eta\_expand} work without reverting and re-introducing \coqdocvariable{f}?  

\item  In particular, it would be really nice if some form of it could work for arbitrary terms, not just variables; I tried using variations of \coqdockw{match} \coqdocvar{goal} \coqdockw{with} \ensuremath{\vdash} \coqdocvariable{Q}@? \coqdocvariable{f} to do this, but couldnt get it to work.

\item  Write plural versions of these tactics, so one can write i.e. \coqdocvar{eta\_intros} \coqdocvariable{f} \coqdocvariable{g} \coqdocvar{h} to abbreviate \coqdocvar{eta\_intro} \coqdocvariable{f}; \coqdocvar{eta\_intro} \coqdocvariable{g}; \coqdocvar{eta\_intro} \coqdocvar{h}.

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Now were equipped to tackle the main theorem. \begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Contractible functional extensionality, and the proof of strong from naive.}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
We start by considering yet another version of functional extensionality: that given a function \coqdocvariable{f}, the space of functions together with a homotopy to \coqdocvariable{f} is contractible.  For the sake of cleaner terms, we give a slightly more specific statement than just \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (): \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.contr funext statement}{contr\_funext\_statement}{\coqdocdefinition{contr\_funext\_statement}} :=\coqdoceol
\coqdocindent{2.50em}
\coqdockw{\ensuremath{\forall}} \coqdocvar{A} (\coqdocvar{B} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqdocvar{B} \coqdocvar{x}),\coqdoceol
\coqdocindent{2.50em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{g} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqdocvar{B} \coqdocvar{x})  (\coqdocvar{h} : \coqdocvar{f} \coqref{Funext.::x '===' x}{\coqdocnotation{===}} \coqdocvar{g}),\coqdoceol
\coqdocindent{2.50em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{g} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{h}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} \coqdocvar{g} \ensuremath{\Rightarrow} \coqdocvar{f} \coqref{Funext.::x '===' x}{\coqdocnotation{===}} \coqdocvar{g}) \coqdocvar{f} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x}))\coqref{Paths.::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The analogous statement with paths in place of homotopies is, of course, always true.  (Id recalled it being in the library somewhere, but I cant find it now?) \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.contract cone}{contract\_cone}{\coqdoclemma{contract\_cone}} \{\coqdocvar{A}\} \{\coqdocvar{x}:\coqdocvar{A}\} (\coqdocvar{yp} : \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}}\coqdocvar{A} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}})\coqdoceol
\coqdocindent{1.00em}
: \coqdocvar{yp} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{yp} \coqdockw{as} [\coqdocvar{y} \coqdocvar{p}]. \coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now, by naive extensionality, the product of all these cones is again contractible: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.contract product of cones from naive funext}{contract\_product\_of\_cones\_from\_naive\_funext}{\coqdoclemma{contract\_product\_of\_cones\_from\_naive\_funext}}\coqdoceol
\coqdocindent{1.00em}
\{\coqdocvar{A}\} \{\coqdocvar{B} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqdocvar{B} \coqdocvar{x}\}\coqdoceol
\coqdocindent{1.00em}
: \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{gh} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}}\coqdocvar{B} \coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{gh} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdockw{fun} \coqdocvar{x}:\coqdocvar{A} \ensuremath{\Rightarrow} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}} \coqdocvar{f} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{))}} \coqref{Paths.::x '==' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{funext} \coqdocvar{gh}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{funext}. \coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.contract cone}{\coqdoclemma{contract\_cone}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
But the type of functions homotopic to \coqdocvariable{f} is an up-to-eta-expansion retract of this product of cones.  So, we define this retraction: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.pair fun to fun pair}{pair\_fun\_to\_fun\_pair}{\coqdoclemma{pair\_fun\_to\_fun\_pair}} \coqdoceol
\coqdocindent{1.00em}
\{\coqdocvar{A}\} \{\coqdocvar{B} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqdocvar{B} \coqdocvar{x}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{gh} : \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{g} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{A}, \coqdocvar{B} \coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{A}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} \coqdocvar{x}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}})\coqdoceol
\coqdocindent{1.00em}
: \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:(}}\coqdocvar{B} \coqdocvar{x}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{)}} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqdockw{match} \coqdocvar{gh} \coqdockw{with}\coqdoceol
\coqdocindent{5.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{g} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{h}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} (\coqdockw{fun} \coqdocvar{x}:\coqdocvar{A} \ensuremath{\Rightarrow} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{g} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{h} \coqdocvar{x}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}) \coqdockw{end} ).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.fun pair to pair fun}{fun\_pair\_to\_pair\_fun}{\coqdoclemma{fun\_pair\_to\_pair\_fun}} \coqdoceol
\coqdocindent{1.00em}
\{\coqdocvar{A}\} \{\coqdocvar{B} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqdocvar{B} \coqdocvar{x}\}\coqdoceol
\coqdocindent{1.00em}
(\coqdocvar{k} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:(}}\coqdocvar{B} \coqdocvar{x}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{)}} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}})\coqdoceol
\coqdocindent{1.00em}
: \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{g} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{A}, \coqdocvar{B} \coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{A}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{g} \coqdocvar{x}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{x}:\coqdocvar{A} \ensuremath{\Rightarrow} \coqdockw{match} (\coqdocvar{k} \coqdocvar{x}) \coqdockw{with} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{gx} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{\_}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}} \ensuremath{\Rightarrow} \coqdocvar{gx} \coqdockw{end}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}. \coqdoctac{destruct} (\coqdocvar{k} \coqdocvar{x}) \coqdockw{as} [\coqdocvar{gx} \coqdocvar{hx}]. \coqdoctac{exact} \coqdocvar{hx}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
and now we have all the ingredients for proving contractible funext from naive funext (or alternatively from weak funext + dependent eta): \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.naive to contr funext}{naive\_to\_contr\_funext}{\coqdoclemma{naive\_to\_contr\_funext}}\coqdoceol
\coqdocindent{1.00em}
: \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{\rightarrow} \coqref{Funext.contr funext statement}{\coqdocdefinition{contr\_funext\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{contr\_funext\_statement}. \coqdoctac{intros} \coqdocvar{A} \coqdocvar{B}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{eta\_intro} \coqdocvar{f}. \coqdocvar{eta\_intro} \coqdocvar{g}. \coqdocvar{eta\_intro} \coqdocvar{h}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Funext.fun pair to pair fun}{\coqdoclemma{fun\_pair\_to\_pair\_fun}} (\coqref{Funext.pair fun to fun pair}{\coqdoclemma{pair\_fun\_to\_fun\_pair}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{g} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{h}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (@\coqref{Funext.fun pair to pair fun}{\coqdoclemma{fun\_pair\_to\_pair\_fun}} \coqdocvar{\_} \coqdocvar{\_} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{x}) (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.contract product of cones from naive funext}{\coqdoclemma{contract\_product\_of\_cones\_from\_naive\_funext}}. \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.naive funext dep implies eta}{\coqdoclemma{naive\_funext\_dep\_implies\_eta}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.contr funext to comp2}{contr\_funext\_to\_comp2}{\coqdoclemma{contr\_funext\_to\_comp2}} (\coqdocvar{funext} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}})\coqdoceol
\coqdocindent{1.00em}
: (\coqref{Funext.funext comp1 statement}{\coqdocdefinition{funext\_comp1\_statement}} \coqdocvar{funext})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\rightarrow} \coqref{Funext.contr funext statement}{\coqdocdefinition{contr\_funext\_statement}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{\rightarrow} (\coqref{Funext.funext comp2 statement}{\coqdocdefinition{funext\_comp2\_statement}} \coqdocvar{funext}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{funext\_comp1} \coqdocvar{contr\_funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{funext\_comp2\_statement}. \coqdoctac{intros} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g} \coqdocvar{h}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (@\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{\_} \coqdoceol
\coqdocindent{5.50em}
(\coqdockw{fun} (\coqdocvar{g0h0} : \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{g} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqref{Fibrations.section}{\coqdocdefinition{section}} \coqdocvar{P} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{f} \coqref{Funext.::x '===' x}{\coqdocnotation{===}} \coqdocvar{g} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}) \coqdoceol
\coqdocindent{7.00em}
\ensuremath{\Rightarrow} \coqdockw{match} \coqdocvar{g0h0} \coqdockw{with} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{g0}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}}\coqdocvar{h0}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}\coqdoceol
\coqdocindent{7.00em}
\ensuremath{\Rightarrow} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{X}, \coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} (\coqdocvar{funext} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g0} \coqdocvar{h0}) \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{h0} \coqdocvar{x}) \coqdockw{end})\coqdoceol
\coqdocindent{6.00em}
(\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} \coqdocvar{g} \ensuremath{\Rightarrow} \coqdocvar{f} \coqref{Funext.::x '===' x}{\coqdocnotation{===}} \coqdocvar{g}) \coqdocvar{f} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})))\coqdoceol
\coqdocindent{6.00em}
\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{g} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{h}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{symmetry}. \coqdoctac{apply} \coqdocvar{contr\_funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{clear} \coqdocvar{g} \coqdocvar{h}. \coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{f}) \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{apply\_happly}. \coqdocvar{path\_simplify}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{funext\_comp1}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.funext comp1 to comp2}{funext\_comp1\_to\_comp2}{\coqdoclemma{funext\_comp1\_to\_comp2}} (\coqdocvar{funext} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}})\coqdoceol
\coqdocindent{1.00em}
: (\coqref{Funext.funext comp1 statement}{\coqdocdefinition{funext\_comp1\_statement}} \coqdocvar{funext}) \ensuremath{\rightarrow} (\coqref{Funext.funext comp2 statement}{\coqdocdefinition{funext\_comp2\_statement}} \coqdocvar{funext}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{funext\_comp1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.contr funext to comp2}{\coqdoclemma{contr\_funext\_to\_comp2}}; \coqdoctac{auto}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.naive to contr funext}{\coqdoclemma{naive\_to\_contr\_funext}}; \coqdoctac{auto}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.funext correction comp2}{funext\_correction\_comp2}{\coqdoclemma{funext\_correction\_comp2}} (\coqdocvar{funext} : \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}})\coqdoceol
\coqdocindent{1.00em}
: \coqref{Funext.funext comp2 statement}{\coqdocdefinition{funext\_comp2\_statement}} (\coqref{Funext.funext correction}{\coqdocdefinition{funext\_correction}} \coqdocvar{funext}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.funext comp1 to comp2}{\coqdoclemma{funext\_comp1\_to\_comp2}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.funext correction comp1}{\coqdoclemma{funext\_correction\_comp1}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.naive to strong funext}{naive\_to\_strong\_funext}{\coqdoclemma{naive\_to\_strong\_funext}}\coqdoceol
\coqdocindent{1.00em}
: \coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{Funext.funext both comps to strong}{\coqdoclemma{funext\_both\_comps\_to\_strong}} (\coqref{Funext.funext correction}{\coqdocdefinition{funext\_correction}} \coqdocvar{funext})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.funext correction comp1}{\coqdoclemma{funext\_correction\_comp1}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.funext correction comp2}{\coqdoclemma{funext\_correction\_comp2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Alternatively, we can show strong funext entirely from contractible funext, without ever invoking naive: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.contr to strong funext}{contr\_to\_strong\_funext}{\coqdoclemma{contr\_to\_strong\_funext}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.contr funext statement}{\coqdocdefinition{contr\_funext\_statement}} \ensuremath{\rightarrow} \coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{contr\_funext} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{A} := \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{P} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{Q} := (\coqdockw{fun} \coqdocvar{h} \ensuremath{\Rightarrow} \coqdocvar{f} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{h}) : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{R} := (\coqdockw{fun} \coqdocvar{h} \ensuremath{\Rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{h} \coqdocvar{x}) : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{fibhap} := (@\coqref{Paths.happly dep}{\coqdocdefinition{happly\_dep}} \coqdocvar{X} \coqdocvar{P} \coqdocvar{f}) : \coqdockw{\ensuremath{\forall}} \coqdocvar{h}, \coqdocvar{Q} \coqdocvar{h} \ensuremath{\rightarrow} \coqdocvar{R} \coqdocvar{h}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{FiberEquivalences.fiber is equiv}{\coqdoclemma{fiber\_is\_equiv}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{fibhap}). \coqdoctac{clear} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.contr contr equiv}{\coqdocdefinition{contr\_contr\_equiv}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.pathspace contr'}{\coqdoclemma{pathspace\_contr'}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{is\_contr}. \coqdocvar{\ensuremath{\exists}} (\coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} \coqdocvar{R} \coqdocvar{f} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x}))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [\coqdocvar{g} \coqdocvar{h}]. \coqdoctac{apply} \coqdocvar{contr\_funext}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Weak functional extensionality}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Inspection of the proof of \coqref{Funext.naive to contr funext}{\coqdoclemma{naive\_to\_contr\_funext}} shows that it only uses functional extensionality via two simpler statements: \coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}}, and the fact that a product of contractible types is contractible.


  This latter statement is interesting in its own right; we call it \textit{weak functional extensionality}.  


  Among other things, it can be seen from the model category point of view as saying that the dependent product functor preserves trivial fibrations, which is exactly (the non-trivial part of) whats needed to make pullback/dependent-product a Quillen adjunction! \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Funext.weak funext statement}{weak\_funext\_statement}{\coqdocdefinition{weak\_funext\_statement}} := \coqdockw{\ensuremath{\forall}} (\coqdocvar{X} : \coqdockw{Type}) (\coqdocvar{P} : \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Type}),\coqdoceol
\coqdocindent{1.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{X}, \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqdocvar{P} \coqdocvar{x})) \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x} : \coqdocvar{X}, \coqdocvar{P} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
It is easy to see that naive dependent functional extensionality
   implies weak functional extensionality. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.funext dep to weak}{funext\_dep\_to\_weak}{\coqdoclemma{funext\_dep\_to\_weak}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.weak funext statement}{\coqdocdefinition{weak\_funext\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{X} \coqdocvar{P} \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} (\coqdocvar{H1} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{f}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{p} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{x}:\coqdocvar{X}) (\coqdocvar{y}:\coqdocvar{P} \coqdocvar{x}), \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}(\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} (\coqdocvar{H1} \coqdocvar{x})) \coqdocvar{x}\coqref{Paths.::x '==' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}. \coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}, \coqdocvar{H1}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}. \coqdoctac{intro} \coqdocvar{x}. \coqdoctac{apply} \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we can give an alternative form of the main theorem: the fact that weak functional extensionality implies *strong* (dependent) functional extensionality, at least in the presence of the dependent eta rule. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Funext.is contr product of cones from weak funext}{is\_contr\_product\_of\_cones\_from\_weak\_funext}{\coqdoclemma{is\_contr\_product\_of\_cones\_from\_weak\_funext}}\coqdoceol
\coqdocindent{1.00em}
\{\coqdocvar{A}\} \{\coqdocvar{B} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}\} \{\coqdocvar{f} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqdocvar{B} \coqdocvar{x}\}\coqdoceol
\coqdocindent{1.00em}
: \coqref{Funext.weak funext statement}{\coqdocdefinition{weak\_funext\_statement}} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{A}, \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}}\coqdocvar{B} \coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{weak\_funext}. \coqdoctac{apply} \coqdocvar{weak\_funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}. \coqdocvar{\ensuremath{\exists}} (\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}} : \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\{}}\coqdocvar{y} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{:}} \coqdocvar{B} \coqdocvar{x} \coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\&}} \coqdocvar{f} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\coqexternalref{:type scope:'x7B' x ':' x 'x26' x 'x7D'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocnotation{\}}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} [\coqdocvar{y} \coqdocvar{p}]. \coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can now essentially repeat the proof of \coqref{Funext.naive to contr funext}{\coqdoclemma{naive\_to\_contr\_funext}}: \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.weak plus eta to contr funext}{weak\_plus\_eta\_to\_contr\_funext}{\coqdoclemma{weak\_plus\_eta\_to\_contr\_funext}}\coqdoceol
\coqdocindent{1.00em}
: \coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.weak funext statement}{\coqdocdefinition{weak\_funext\_statement}} \ensuremath{\rightarrow} \coqref{Funext.contr funext statement}{\coqdocdefinition{contr\_funext\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{eta\_dep} \coqdocvar{weak\_funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{contr\_funext\_statement}. \coqdoctac{intros} \coqdocvar{A} \coqdocvar{B}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{eta\_intro} \coqdocvar{f}. \coqdocvar{eta\_intro} \coqdocvar{g}. \coqdocvar{eta\_intro} \coqdocvar{h}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Funext.fun pair to pair fun}{\coqdoclemma{fun\_pair\_to\_pair\_fun}} (\coqref{Funext.pair fun to fun pair}{\coqdoclemma{pair\_fun\_to\_fun\_pair}} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{g} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvar{h}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (@\coqref{Funext.fun pair to pair fun}{\coqdoclemma{fun\_pair\_to\_pair\_fun}} \coqdocvar{\_} \coqdocvar{\_} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{f} \coqdocvar{x}) (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvar{x} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x})\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.is contr product of cones from weak funext}{\coqdoclemma{is\_contr\_product\_of\_cones\_from\_weak\_funext}}. \coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.weak to strong funext dep}{weak\_to\_strong\_funext\_dep}{\coqdoclemma{weak\_to\_strong\_funext\_dep}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.eta dep statement}{\coqdocdefinition{eta\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.weak funext statement}{\coqdocdefinition{weak\_funext\_statement}} \ensuremath{\rightarrow} \coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{eta\_dep} \coqdocvar{weak\_funext}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.contr to strong funext}{\coqdoclemma{contr\_to\_strong\_funext}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Funext.weak plus eta to contr funext}{\coqdoclemma{weak\_plus\_eta\_to\_contr\_funext}}; \coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Therefore, all of the following are equivalent, in their dependent forms:

\begin{itemize}
\item  naive functional extensionality;

\item  naive functional extensionality with either or both comp rules;

\item  strong functional extensionality;

\item  contractible functional extensionality;

\item  weak functional extensionality + dependent eta. 
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Comparing dependent and non-dependent forms.}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
We also observe that for both strong and naive functional
   extensionality, the dependent version implies the non-dependent
   version.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.strong funext dep to nondep}{strong\_funext\_dep\_to\_nondep}{\coqdoclemma{strong\_funext\_dep\_to\_nondep}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.strong funext statement}{\coqdocdefinition{strong\_funext\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqdocvar{H} \coqdocvar{X} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{Y}) \coqdocvar{f} \coqdocvar{g}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{Funext.funext dep to nondep}{funext\_dep\_to\_nondep}{\coqdoclemma{funext\_dep\_to\_nondep}} :\coqdoceol
\coqdocindent{1.00em}
\coqref{Funext.funext dep statement}{\coqdocdefinition{funext\_dep\_statement}} \ensuremath{\rightarrow} \coqref{Funext.funext statement}{\coqdocdefinition{funext\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{X} \coqdocvar{Y} \coqdocvar{f} \coqdocvar{g}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqdocvar{H} \coqdocvar{X} (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{Y}) \coqdocvar{f} \coqdocvar{g}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
One can prove similar things for the other variants considered.  Can we go the other way, for any of the variants? \begin{coqdoccode}
\end{coqdoccode}
\coqlibrary{Univalence}{Library }{Univalence}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqref{Paths}{\coqdoclibrary{Paths}} \coqref{Fibrations}{\coqdoclibrary{Fibrations}} \coqref{Contractible}{\coqdoclibrary{Contractible}} \coqref{Equivalences}{\coqdoclibrary{Equivalences}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Every path between spaces gives an equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Univalence.path to equiv}{path\_to\_equiv}{\coqdocdefinition{path\_to\_equiv}} \{\coqdocvar{U} \coqdocvar{V}\} : (\coqdocvar{U} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{V}) \ensuremath{\rightarrow} (\coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{U} \coqdocvar{V}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.idequiv}{\coqdocdefinition{idequiv}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This is functorial in the appropriate sense. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Univalence.path to equiv map}{path\_to\_equiv\_map}{\coqdoclemma{path\_to\_equiv\_map}} \{\coqdocvar{A}\} (\coqdocvar{P} : \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} (\coqref{Paths.map}{\coqdoclemma{map}} \coqdocvar{P} \coqdocvar{p})) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdocvar{P}) \coqdocvar{p}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Univalence.concat to compose}{concat\_to\_compose}{\coqdoclemma{concat\_to\_compose}} \{\coqdocvar{A} \coqdocvar{B} \coqdocvar{C}\} (\coqdocvar{p} : \coqdocvar{A} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{B}) (\coqdocvar{q} : \coqdocvar{B} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{C}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} \coqdocvar{q} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} (\coqdocvar{p} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{q})).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_concat\_to\_compose\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}  \coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} ?\coqdocvar{p}) \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} ?\coqdocvar{q}) ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} (\coqdocvar{q} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{p})) ] \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{path\_via} \coqdocvar{mid};\coqdoceol
\coqdocindent{4.00em}
[ \coqdoctac{repeat} \coqdocvar{first} [ \coqdoctac{apply} \coqref{Paths.happly}{\coqdocdefinition{happly}} \ensuremath{|} \coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}} \ensuremath{|} \coqdoctac{apply} \coqref{Univalence.concat to compose}{\coqdoclemma{concat\_to\_compose}} ] \ensuremath{|} ] \coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_concat\_to\_compose} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{first} [ \coqdocvar{undo\_concat\_to\_compose\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{undo\_concat\_to\_compose\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{Univalence.opposite to inverse}{opposite\_to\_inverse}{\coqdoclemma{opposite\_to\_inverse}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{p} : \coqdocvar{A} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{B}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{(}}\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} \coqdocvar{p}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{)\^{}-1}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} (\coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_induction}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_opposite\_to\_inverse\_in} \coqdocvar{s} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{s} \coqdockw{with}  \coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{(}}\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} ?\coqdocvar{p}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{)}} \coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} ] \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdockw{let} \coqdocvar{mid} := \coqdocvar{context} \coqdocvar{cxt} [ \coqref{Equivalences.equiv coerce to function}{\coqdocdefinition{equiv\_coerce\_to\_function}} \coqdocvar{\_} \coqdocvar{\_} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqdocvar{p})) ] \coqdoctac{in}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{path\_via} \coqdocvar{mid};\coqdoceol
\coqdocindent{4.00em}
[ \coqdoctac{repeat} \coqdoctac{apply} \coqref{Paths.map}{\coqdoclemma{map}}; \coqdoctac{apply} \coqref{Univalence.opposite to inverse}{\coqdoclemma{opposite\_to\_inverse}} \ensuremath{|} ]\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Ltac} \coqdocvar{undo\_opposite\_to\_inverse} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{repeat} \coqdoctac{progress} (\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocvar{goal} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\ensuremath{|} \ensuremath{\vdash} ?\coqdocvar{s} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{?}}\coqdocvar{t} \ensuremath{\Rightarrow}\coqdoceol
\coqdocindent{4.00em}
\coqdocvar{first} [ \coqdocvar{undo\_opposite\_to\_inverse\_in} \coqdocvar{s} \ensuremath{|} \coqdocvar{undo\_opposite\_to\_inverse\_in} \coqdocvar{t} ]\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The statement of the univalence axiom. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{Univalence.univalence statement}{univalence\_statement}{\coqdocdefinition{univalence\_statement}} := \coqdockw{\ensuremath{\forall}} (\coqdocvar{U} \coqdocvar{V} : \coqdockw{Type}), \coqref{Equivalences.is equiv}{\coqdocdefinition{is\_equiv}} (@\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} \coqdocvar{U} \coqdocvar{V}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Section} \coqdef{Univalence.Univalence}{Univalence}{\coqdocsection{Univalence}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Hypothesis} \coqdef{Univalence.Univalence.univalence}{univalence}{\coqdocvariable{univalence}} : \coqref{Univalence.univalence statement}{\coqdocdefinition{univalence\_statement}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{Univalence.path to equiv equiv}{path\_to\_equiv\_equiv}{\coqdocdefinition{path\_to\_equiv\_equiv}} (\coqdocvar{U} \coqdocvar{V} : \coqdockw{Type}) := \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{(}}@\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} \coqdocvar{U} \coqdocvar{V} \coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{;}} \coqdocvariable{univalence} \coqdocvar{U} \coqdocvar{V}\coqref{Fibrations.::'(' x ';' x ')'}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Assuming univalence, every equivalence yields a path. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{Univalence.equiv to path}{equiv\_to\_path}{\coqdocdefinition{equiv\_to\_path}} \{\coqdocvar{U} \coqdocvar{V}\} : \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V} \ensuremath{\rightarrow} \coqdocvar{U} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{V} :=\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.inverse}{\coqdocdefinition{inverse}} (\coqref{Univalence.path to equiv equiv}{\coqdocdefinition{path\_to\_equiv\_equiv}} \coqdocvar{U} \coqdocvar{V}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The map \coqref{UnivalenceAxiom.equiv to path}{\coqdocdefinition{equiv\_to\_path}} is a section of \coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}}. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{Univalence.equiv to path section}{equiv\_to\_path\_section}{\coqdocdefinition{equiv\_to\_path\_section}} \coqdocvar{U} \coqdocvar{V} :\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{w} : \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V}), \coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} (\coqref{Univalence.equiv to path}{\coqdocdefinition{equiv\_to\_path}} \coqdocvar{w}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{w} :=\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}} (\coqref{Univalence.path to equiv equiv}{\coqdocdefinition{path\_to\_equiv\_equiv}} \coqdocvar{U} \coqdocvar{V}).\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{Univalence.equiv to path retraction}{equiv\_to\_path\_retraction}{\coqdocdefinition{equiv\_to\_path\_retraction}} \coqdocvar{U} \coqdocvar{V} :\coqdoceol
\coqdocindent{2.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqdocvar{U} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{V}), \coqref{Univalence.equiv to path}{\coqdocdefinition{equiv\_to\_path}} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} \coqdocvar{p}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{p} :=\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.inverse is retraction}{\coqdocdefinition{inverse\_is\_retraction}} (\coqref{Univalence.path to equiv equiv}{\coqdocdefinition{path\_to\_equiv\_equiv}} \coqdocvar{U} \coqdocvar{V}).\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{Univalence.equiv to path triangle}{equiv\_to\_path\_triangle}{\coqdocdefinition{equiv\_to\_path\_triangle}} \coqdocvar{U} \coqdocvar{V} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{p} : \coqdocvar{U} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{V}),\coqdoceol
\coqdocindent{3.00em}
\coqref{Paths.map}{\coqdoclemma{map}} \coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} (\coqref{Univalence.equiv to path retraction}{\coqdocdefinition{equiv\_to\_path\_retraction}} \coqdocvar{U} \coqdocvar{V} \coqdocvar{p}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Univalence.equiv to path section}{\coqdocdefinition{equiv\_to\_path\_section}} \coqdocvar{U} \coqdocvar{V} (\coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}} \coqdocvar{p}) :=\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.inverse triangle}{\coqdocdefinition{inverse\_triangle}} (\coqref{Univalence.path to equiv equiv}{\coqdocdefinition{path\_to\_equiv\_equiv}} \coqdocvar{U} \coqdocvar{V}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We can do better than \coqref{UnivalenceAxiom.equiv to path}{\coqdocdefinition{equiv\_to\_path}}: we can turn a fibration
     fibered over equivalences to one fiberered over paths. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Definition} \coqdef{Univalence.pred equiv to path}{pred\_equiv\_to\_path}{\coqdocdefinition{pred\_equiv\_to\_path}} \coqdocvar{U} \coqdocvar{V} : (\coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V} \ensuremath{\rightarrow} \coqdockw{Type}) \ensuremath{\rightarrow} (\coqdocvar{U} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{V} \ensuremath{\rightarrow} \coqdockw{Type}).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{U} \coqdocvar{V}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{Q} \coqdocvar{p}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{Q}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Univalence.path to equiv}{\coqdocdefinition{path\_to\_equiv}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{exact} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The following theorem is of central importance. Just like there
     is an induction principle for paths, there is a corresponding one
     for equivalences. In the proof we use \coqref{Univalence.pred equiv to path}{\coqdocdefinition{pred\_equiv\_to\_path}} to
     transport the predicate \coqdocvariable{P} of equivalences to a predicate \coqdocvar{P'}
     on paths. Then we use path induction and transport back to \coqdocvariable{P}. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Theorem} \coqdef{Univalence.equiv induction}{equiv\_induction}{\coqdoclemma{equiv\_induction}} (\coqdocvar{P} : \coqdockw{\ensuremath{\forall}} \coqdocvar{U} \coqdocvar{V}, \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V} \ensuremath{\rightarrow} \coqdockw{Type}) :\coqdoceol
\coqdocindent{2.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{T}, \coqdocvar{P} \coqdocvar{T} \coqdocvar{T} (\coqref{Equivalences.idequiv}{\coqdocdefinition{idequiv}} \coqdocvar{T})) \ensuremath{\rightarrow} (\coqdockw{\ensuremath{\forall}} \coqdocvar{U} \coqdocvar{V} (\coqdocvar{w} : \coqdocvar{U} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{V}), \coqdocvar{P} \coqdocvar{U} \coqdocvar{V} \coqdocvar{w}).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{P}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{r}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{pose} (\coqdocvar{P'} := (\coqdockw{fun} \coqdocvar{U} \coqdocvar{V} \ensuremath{\Rightarrow} \coqref{Univalence.pred equiv to path}{\coqdocdefinition{pred\_equiv\_to\_path}} \coqdocvar{U} \coqdocvar{V} (\coqdocvar{P} \coqdocvar{U} \coqdocvar{V}))).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{r'} : \coqdockw{\ensuremath{\forall}} \coqdocvar{T} : \coqdockw{Type}, \coqdocvar{P'} \coqdocvar{T} \coqdocvar{T} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{T})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{T}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{exact} (\coqdocvar{r} \coqdocvar{T}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{U} \coqdocvar{V} \coqdocvar{w}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqref{Univalence.equiv to path section}{\coqdocdefinition{equiv\_to\_path\_section}} \coqdocvar{\_} \coqdocvar{\_} \coqdocvar{w})).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{exact} (\coqref{Paths.paths rect}{\coqdocdefinition{paths\_rect}} \coqdocvar{\_} \coqdocvar{P'} \coqdocvar{r'} \coqdocvar{U} \coqdocvar{V} (\coqref{Univalence.equiv to path}{\coqdocdefinition{equiv\_to\_path}} \coqdocvar{w})).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{Univalence.Univalence}{\coqdocsection{Univalence}}.\coqdoceol
\end{coqdoccode}
\coqlibrary{UnivalenceImpliesFunext}{Library }{UnivalenceImpliesFunext}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqref{Paths}{\coqdoclibrary{Paths}} \coqref{Fibrations}{\coqdoclibrary{Fibrations}} \coqref{Contractible}{\coqdoclibrary{Contractible}} \coqref{Equivalences}{\coqdoclibrary{Equivalences}} \coqref{Univalence}{\coqdoclibrary{Univalence}} \coqref{Funext}{\coqdoclibrary{Funext}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here we prove that univalence implies function extensionality.  We
   keep this file separate from the statements of Univalence and
   Funext, since it has a tendency to produce universe
   inconsistencies.  With truly polymorphic universes this ought not
   to be a problem.


   Since this file makes the point that univalence implies funext,
   further development can avoid including this file and simply assume
   function extensionality as an axiom alongside univalence, in the
   knowledge that it is actually no additional requirement. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Section} \coqdef{UnivalenceImpliesFunext.UnivalenceImpliesFunext}{UnivalenceImpliesFunext}{\coqdocsection{UnivalenceImpliesFunext}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Hypothesis} \coqdef{UnivalenceImpliesFunext.UnivalenceImpliesFunext.univalence}{univalence}{\coqdocvariable{univalence}} : \coqref{Univalence.univalence statement}{\coqdocdefinition{univalence\_statement}}.\coqdoceol
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Hypothesis} \coqdef{UnivalenceImpliesFunext.UnivalenceImpliesFunext.eta rule}{eta\_rule}{\coqdocvariable{eta\_rule}} : \coqref{Funext.eta statement}{\coqdocdefinition{eta\_statement}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Exponentiation preserves equivalences, i.e., if \coqdocvar{w} is an
     equivalence then so is post-composition by \coqdocvar{w}. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Theorem} \coqdef{UnivalenceImpliesFunext.equiv exponential}{equiv\_exponential}{\coqdoclemma{equiv\_exponential}} : \coqdockw{\ensuremath{\forall}} \{\coqdocvar{A} \coqdocvar{B}\} (\coqdocvar{w} : \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) \coqdocvar{C},\coqdoceol
\coqdocindent{2.00em}
\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{C} \ensuremath{\rightarrow} \coqdocvar{A}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{C} \ensuremath{\rightarrow} \coqdocvar{B}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{w} \coqdocvar{C}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{h} \ensuremath{\Rightarrow} \coqdocvar{w} \coqref{Functions.::x 'o' x}{\coqdocnotation{$\circ$}} \coqdocvar{h}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{generalize} \coqdocvar{A} \coqdocvar{B} \coqdocvar{w}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Univalence.equiv induction}{\coqdoclemma{equiv\_induction}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{D}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} (\coqexternalref{projT2}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT2}} (\coqref{Funext.eta equiv}{\coqdocdefinition{eta\_equiv}} \coqdocvariable{eta\_rule} \coqdocvar{C} \coqdocvar{D})).\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
We are ready to prove functional extensionality, starting with the
     naive non-dependent version. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Theorem} \coqdef{UnivalenceImpliesFunext.univalence implies funext}{univalence\_implies\_funext}{\coqdoclemma{univalence\_implies\_funext}} : \coqref{Funext.funext statement}{\coqdocdefinition{funext\_statement}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{g} \coqdocvar{p}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Equivalences.equiv injective}{\coqdoclemma{equiv\_injective}} \coqdockw{with} (\coqdocvar{w} := \coqref{Funext.eta equiv}{\coqdocdefinition{eta\_equiv}} \coqdocvariable{eta\_rule} \coqdocvar{A} \coqdocvar{B}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{pose} (\coqdocvar{d} := \coqdockw{fun} \coqdocvar{x} : \coqdocvar{A} \ensuremath{\Rightarrow} \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} \coqdocvar{xy} \ensuremath{\Rightarrow} \coqexternalref{fst}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{fst}} \coqdocvar{xy} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{snd}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{xy}) \coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{f} \coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{)}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqdocvar{f} \coqdocvar{x}))).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{pose} (\coqdocvar{e} := \coqdockw{fun} \coqdocvar{x} : \coqdocvar{A} \ensuremath{\Rightarrow} \coqexternalref{existT}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocconstructor{existT}} (\coqdockw{fun} \coqdocvar{xy} \ensuremath{\Rightarrow} \coqexternalref{fst}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{fst}} \coqdocvar{xy} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{snd}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocdefinition{snd}} \coqdocvar{xy}) \coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{f} \coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{,}} \coqdocvar{g} \coqdocvar{x}\coqexternalref{:core scope:'(' x ',' x ',' '..' ',' x ')'}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{)}} (\coqdocvar{p} \coqdocvar{x})).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{pose} (\coqdocvar{src\_compose} := \coqref{UnivalenceImpliesFunext.equiv exponential}{\coqdoclemma{equiv\_exponential}} (\coqref{Equivalences.free path source}{\coqdocdefinition{free\_path\_source}} \coqdocvar{B}) \coqdocvar{A}).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{pose} (\coqdocvar{trg\_compose} := \coqref{UnivalenceImpliesFunext.equiv exponential}{\coqdoclemma{equiv\_exponential}} (\coqref{Equivalences.free path target}{\coqdocdefinition{free\_path\_target}} \coqdocvar{B}) \coqdocvar{A}).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_via} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{trg\_compose} \coqdocvar{e}).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{path\_via} (\coqexternalref{projT1}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Specif}{\coqdocdefinition{projT1}} \coqdocvar{trg\_compose} \coqdocvar{d}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Equivalences.equiv injective}{\coqdoclemma{equiv\_injective}} \coqdockw{with} (\coqdocvar{w} := \coqdocvar{src\_compose}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now we use this to prove weak funext, which as we know implies
     (with dependent eta) also the strong dependent funext. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdockw{Theorem} \coqdef{UnivalenceImpliesFunext.univalence implies weak funext}{univalence\_implies\_weak\_funext}{\coqdoclemma{univalence\_implies\_weak\_funext}} : \coqref{Funext.weak funext statement}{\coqdocdefinition{weak\_funext\_statement}}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{P} \coqdocvar{allcontr}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{eqpt} : @\coqref{Paths.paths}{\coqdocinductive{paths}} (\coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Type}) (\coqdockw{fun} \coqdocvar{x} \ensuremath{\Rightarrow} \coqexternalref{unit}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{unit}}) \coqdocvar{P}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{UnivalenceImpliesFunext.univalence implies funext}{\coqdoclemma{univalence\_implies\_funext}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Univalence.equiv to path}{\coqdocdefinition{equiv\_to\_path}}, \coqref{Equivalences.contr equiv unit}{\coqdoclemma{contr\_equiv\_unit}}, \coqdocvar{allcontr}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{contrunit} : \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}:\coqdocvar{X}, \coqexternalref{unit}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{unit}})).\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{\ensuremath{\exists}} (\coqdockw{fun} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqexternalref{tt}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{tt}}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{f}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqref{UnivalenceImpliesFunext.univalence implies funext}{\coqdoclemma{univalence\_implies\_funext}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{alltt} : \coqdockw{\ensuremath{\forall}} \coqdocvar{y}:\coqexternalref{unit}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{unit}}, \coqdocvar{y} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{tt}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{tt}}).\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{induction} \coqdocvar{y}; \coqdoctac{apply} \coqref{Paths.idpath}{\coqdocconstructor{idpath}}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{alltt}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{exact} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdockw{fun} \coqdocvar{Q}: \coqdocvar{X} \ensuremath{\rightarrow} \coqdockw{Type} \ensuremath{\Rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{Q} \coqdocvar{x})) \coqdocvar{eqpt} \coqdocvar{contrunit}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{End} \coqref{UnivalenceImpliesFunext.UnivalenceImpliesFunext}{\coqdocsection{UnivalenceImpliesFunext}}.\coqdoceol
\end{coqdoccode}
\coqlibrary{UnivalenceAxiom}{Library }{UnivalenceAxiom}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqref{Paths}{\coqdoclibrary{Paths}} \coqref{Univalence}{\coqdoclibrary{Univalence}} \coqref{Funext}{\coqdoclibrary{Funext}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This file asserts univalence as a global axiom, along with its
   basic consequences, including function extensionality.  Since the
   proof that univalence implies funext has a tendency to create
   universe inconsistencies, we actually assume funext as a separate
   axiom rather than actually deriving it from univalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{UnivalenceAxiom.univalence}{univalence}{\coqdocaxiom{univalence}} : \coqref{Univalence.univalence statement}{\coqdocdefinition{univalence\_statement}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Set} \coqdockw{Implicit} \coqdocvar{Arguments}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.equiv to path}{equiv\_to\_path}{\coqdocdefinition{equiv\_to\_path}} := @\coqref{Univalence.equiv to path}{\coqdocdefinition{equiv\_to\_path}} \coqref{UnivalenceAxiom.univalence}{\coqdocaxiom{univalence}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.equiv to path section}{equiv\_to\_path\_section}{\coqdocdefinition{equiv\_to\_path\_section}} := @\coqref{Univalence.equiv to path section}{\coqdocdefinition{equiv\_to\_path\_section}} \coqref{UnivalenceAxiom.univalence}{\coqdocaxiom{univalence}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.equiv to path retraction}{equiv\_to\_path\_retraction}{\coqdocdefinition{equiv\_to\_path\_retraction}} := @\coqref{Univalence.equiv to path retraction}{\coqdocdefinition{equiv\_to\_path\_retraction}} \coqref{UnivalenceAxiom.univalence}{\coqdocaxiom{univalence}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.equiv to path triangle}{equiv\_to\_path\_triangle}{\coqdocdefinition{equiv\_to\_path\_triangle}} := @\coqref{Univalence.equiv to path triangle}{\coqdocdefinition{equiv\_to\_path\_triangle}} \coqref{UnivalenceAxiom.univalence}{\coqdocaxiom{univalence}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.equiv induction}{equiv\_induction}{\coqdocdefinition{equiv\_induction}} := @\coqref{Univalence.equiv induction}{\coqdoclemma{equiv\_induction}} \coqref{UnivalenceAxiom.univalence}{\coqdocaxiom{univalence}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{UnivalenceAxiom.strong funext dep}{strong\_funext\_dep}{\coqdocaxiom{strong\_funext\_dep}} : \coqref{Funext.strong funext dep statement}{\coqdocdefinition{strong\_funext\_dep\_statement}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.strong funext}{strong\_funext}{\coqdocdefinition{strong\_funext}} := \coqref{Funext.strong funext dep to nondep}{\coqdoclemma{strong\_funext\_dep\_to\_nondep}} \coqref{UnivalenceAxiom.strong funext dep}{\coqdocaxiom{strong\_funext\_dep}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.funext dep}{funext\_dep}{\coqdocdefinition{funext\_dep}} := \coqref{Funext.strong to naive funext dep}{\coqdoclemma{strong\_to\_naive\_funext\_dep}} \coqref{UnivalenceAxiom.strong funext dep}{\coqdocaxiom{strong\_funext\_dep}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.funext}{funext}{\coqdocdefinition{funext}} := \coqref{Funext.strong to naive funext}{\coqdoclemma{strong\_to\_naive\_funext}} \coqref{UnivalenceAxiom.strong funext}{\coqdocdefinition{strong\_funext}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.weak funext}{weak\_funext}{\coqdocdefinition{weak\_funext}} := \coqref{Funext.funext dep to weak}{\coqdoclemma{funext\_dep\_to\_weak}} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.funext dep compute}{funext\_dep\_compute}{\coqdocdefinition{funext\_dep\_compute}} := \coqref{Funext.strong funext dep compute}{\coqdocdefinition{strong\_funext\_dep\_compute}} \coqref{UnivalenceAxiom.strong funext dep}{\coqdocaxiom{strong\_funext\_dep}}.\coqdoceol
\coqdocnoindent
\coqdockw{Definition} \coqdef{UnivalenceAxiom.funext compute}{funext\_compute}{\coqdocdefinition{funext\_compute}} := \coqref{Funext.strong funext compute}{\coqdoclemma{strong\_funext\_compute}} \coqref{UnivalenceAxiom.strong funext}{\coqdocdefinition{strong\_funext}}.\coqdoceol
\end{coqdoccode}
\coqlibrary{HLevel}{Library }{HLevel}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqref{Paths}{\coqdoclibrary{Paths}} \coqref{Fibrations}{\coqdoclibrary{Fibrations}} \coqref{Contractible}{\coqdoclibrary{Contractible}} \coqref{Equivalences}{\coqdoclibrary{Equivalences}} \coqref{Funext}{\coqdoclibrary{Funext}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Import} \coqref{UnivalenceAxiom}{\coqdoclibrary{UnivalenceAxiom}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
For compatibility with Coq 8.2. \begin{coqdoccode}
\coqdocnoindent
\coqdockw{Unset} \coqdocvar{Automatic} \coqdocvar{Introduction}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Some more stuff about contractibility. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.contr contr}{contr\_contr}{\coqdoclemma{contr\_contr}} \{\coqdocvar{X}\} : \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{X} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{X}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{ctr1}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{ctr1}. \coqdoctac{intros} \coqdocvar{ctr2}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Fibrations.total path}{\coqdoclemma{total\_path}} \coqdockw{with} (\coqdocvar{p} := \coqref{Fibrations.pr2}{\coqdocabbreviation{pr2}} \coqdocvar{ctr1} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} \coqdocvar{ctr2})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path2}{\coqdoclemma{contr\_path2}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
H-levels. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{HLevel.is hlevel}{is\_hlevel}{\coqdocdefinition{is\_hlevel}} (\coqdocvar{n} : \coqexternalref{nat}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{nat}}) : \coqdockw{Type} \ensuremath{\rightarrow} \coqdockw{Type} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{n} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} 0 \ensuremath{\Rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqexternalref{S}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n'} \ensuremath{\Rightarrow} \coqdockw{fun} \coqdocvar{X} \ensuremath{\Rightarrow} \coqdockw{\ensuremath{\forall}} (\coqdocvar{x} \coqdocvar{y}:\coqdocvar{X}), \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} \coqdocvar{n'} (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.hlevel inhabited contr}{hlevel\_inhabited\_contr}{\coqdoclemma{hlevel\_inhabited\_contr}} \{\coqdocvar{n} \coqdocvar{X}\} : \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} \coqdocvar{n} \coqdocvar{X} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} (\coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} \coqdocvar{n} \coqdocvar{X}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{X}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.contr contr}{\coqdoclemma{contr\_contr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{X}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.weak funext}{\coqdocdefinition{weak\_funext}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.weak funext}{\coqdocdefinition{weak\_funext}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{IHn}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
H-levels are increasing with n. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.hlevel succ}{hlevel\_succ}{\coqdoclemma{hlevel\_succ}} \{\coqdocvar{n} \coqdocvar{X}\} : \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} \coqdocvar{n} \coqdocvar{X} \ensuremath{\rightarrow} \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} (\coqexternalref{S}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{S}} \coqdocvar{n}) \coqdocvar{X}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{H} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr pathcontr}{\coqdoclemma{contr\_pathcontr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{X} \coqdocvar{H} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{IHn}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
H-level is preserved under equivalence. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.hlevel equiv}{hlevel\_equiv}{\coqdoclemma{hlevel\_equiv}} \{\coqdocvar{n} \coqdocvar{A} \coqdocvar{B}\} : (\coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqdocvar{B}) \ensuremath{\rightarrow} \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} \coqdocvar{n} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} \coqdocvar{n} \coqdocvar{B}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{n}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.contr equiv contr}{\coqdoclemma{contr\_equiv\_contr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{B} \coqdocvar{f} \coqdocvar{H} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{IHn} \coqdockw{with} (\coqdocvar{A} := \coqdocvar{f} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.concat equiv left}{\coqdocdefinition{concat\_equiv\_left}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{IHn} \coqdockw{with} (\coqdocvar{A} := \coqdocvar{f} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{f} (\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{y})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.concat equiv right}{\coqdocdefinition{concat\_equiv\_right}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.inverse is section}{\coqdocdefinition{inverse\_is\_section}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{IHn} \coqdockw{with} (\coqdocvar{A} := \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{x}\coqref{Paths.::x '==' x}{\coqdocnotation{)}} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.::x '==' x}{\coqdocnotation{(}}\coqdocvar{f}\coqref{Equivalences.::x 'x5E-1'}{\coqdocnotation{$^{-1}$}} \coqdocvar{y}\coqref{Paths.::x '==' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.equiv map equiv}{\coqdocdefinition{equiv\_map\_equiv}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Propositions are of h-level 1. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.is prop}{is\_prop}{\coqdocdefinition{is\_prop}} := \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} 1.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Here is an alternate characterization of propositions. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.prop inhabited contr}{prop\_inhabited\_contr}{\coqdoclemma{prop\_inhabited\_contr}} \{\coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{H} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.inhabited contr isprop}{inhabited\_contr\_isprop}{\coqdoclemma{inhabited\_contr\_isprop}} \{\coqdocvar{A}\} : (\coqdocvar{A} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A}) \ensuremath{\rightarrow} \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{H} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr pathcontr}{\coqdoclemma{contr\_pathcontr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.hlevel isprop}{hlevel\_isprop}{\coqdoclemma{hlevel\_isprop}} \{\coqdocvar{n} \coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} (\coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} \coqdocvar{n} \coqdocvar{A}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{n} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.inhabited contr isprop}{\coqdoclemma{inhabited\_contr\_isprop}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.hlevel inhabited contr}{\coqdoclemma{hlevel\_inhabited\_contr}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.isprop isprop}{isprop\_isprop}{\coqdocdefinition{isprop\_isprop}} \{\coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} (\coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} \coqdocvar{A}) := \coqref{HLevel.hlevel isprop}{\coqdoclemma{hlevel\_isprop}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.prop equiv inhabited contr}{prop\_equiv\_inhabited\_contr}{\coqdoclemma{prop\_equiv\_inhabited\_contr}} \{\coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdocvar{A} \ensuremath{\rightarrow} \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqref{HLevel.prop inhabited contr}{\coqdoclemma{prop\_inhabited\_contr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqref{HLevel.inhabited contr isprop}{\coqdoclemma{inhabited\_contr\_isprop}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{prop\_inhabited\_contr}, \coqdocvar{inhabited\_contr\_isprop}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext}{\coqdocdefinition{funext}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.contr contr}{\coqdoclemma{contr\_contr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqdocvar{H} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{prop\_inhabited\_contr}, \coqdocvar{inhabited\_contr\_isprop}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.contr contr}{\coqdoclemma{contr\_contr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqdocvar{H} \coqdocvar{x} \coqdocvar{y}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
And another one. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.prop path}{prop\_path}{\coqdoclemma{prop\_path}} \{\coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}), \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{unfold} \coqdocvar{is\_prop}. \coqdoctac{simpl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqref{Fibrations.pr1}{\coqdocabbreviation{pr1}} (\coqdocvar{H} \coqdocvar{x} \coqdocvar{y})).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.allpath prop}{allpath\_prop}{\coqdoclemma{allpath\_prop}} \{\coqdocvar{A}\} : (\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}), \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) \ensuremath{\rightarrow} \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{H} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{K} : \coqref{Contractible.is contr}{\coqdocdefinition{is\_contr}} \coqdocvar{A}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqdocvar{x}. \coqdoctac{intro} \coqdocvar{y'}. \coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr pathcontr}{\coqdoclemma{contr\_pathcontr}}. \coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.prop equiv allpath}{prop\_equiv\_allpath}{\coqdoclemma{prop\_equiv\_allpath}} \{\coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}), \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqref{HLevel.prop path}{\coqdoclemma{prop\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqref{HLevel.allpath prop}{\coqdoclemma{allpath\_prop}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{HLevel.allpath prop}{\coqdoclemma{allpath\_prop}} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.contr contr}{\coqdoclemma{contr\_contr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Sets are of h-level 2. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.is set}{is\_set}{\coqdocdefinition{is\_set}} := \coqref{HLevel.is hlevel}{\coqdocdefinition{is\_hlevel}} 2.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A type is a set if and only if it satisfies Axiom K. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.axiomK}{axiomK}{\coqdocdefinition{axiomK}} \coqdocvar{A} := \coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}), \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.isset implies axiomK}{isset\_implies\_axiomK}{\coqdocdefinition{isset\_implies\_axiomK}} \{\coqdocvar{A}\} : \coqref{HLevel.is set}{\coqdocdefinition{is\_set}} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{HLevel.axiomK}{\coqdocdefinition{axiomK}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{H} \coqdocvar{x} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.axiomK implies isset}{axiomK\_implies\_isset}{\coqdocdefinition{axiomK\_implies\_isset}} \{\coqdocvar{A}\} : \coqref{HLevel.axiomK}{\coqdocdefinition{axiomK}} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{HLevel.is set}{\coqdocdefinition{is\_set}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{H} \coqdocvar{x} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.allpath prop}{\coqdoclemma{allpath\_prop}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.isset equiv axiomK}{isset\_equiv\_axiomK}{\coqdoclemma{isset\_equiv\_axiomK}} \{\coqdocvar{A}\} :\coqdoceol
\coqdocindent{1.00em}
\coqref{HLevel.is set}{\coqdocdefinition{is\_set}} \coqdocvar{A} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{$\overset{\sim}{\longrightarrow}$}} \coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} : \coqdocvar{A}) (\coqdocvar{p} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x}), \coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}\coqref{Equivalences.::x '<x7E>' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{\ensuremath{\exists}} \coqref{HLevel.isset implies axiomK}{\coqdocdefinition{isset\_implies\_axiomK}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{Equivalences.hequiv is equiv}{\coqdocdefinition{hequiv\_is\_equiv}} \coqdockw{with} (\coqdocvar{g} := \coqref{HLevel.axiomK implies isset}{\coqdocdefinition{axiomK\_implies\_isset}}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} (\coqref{HLevel.axiomK implies isset}{\coqdocdefinition{axiomK\_implies\_isset}} \coqdocvar{H}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{x}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{UnivalenceAxiom.funext dep}{\coqdocdefinition{funext\_dep}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{y}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.prop path}{\coqdoclemma{prop\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.isprop isprop}{\coqdocdefinition{isprop\_isprop}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.isset isprop}{isset\_isprop}{\coqdocdefinition{isset\_isprop}} \{\coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} (\coqref{HLevel.is set}{\coqdocdefinition{is\_set}} \coqdocvar{A}) := \coqref{HLevel.hlevel isprop}{\coqdoclemma{hlevel\_isprop}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.axiomK isprop}{axiomK\_isprop}{\coqdoclemma{axiomK\_isprop}} \{\coqdocvar{A}\} : \coqref{HLevel.is prop}{\coqdocdefinition{is\_prop}} (\coqref{HLevel.axiomK}{\coqdocdefinition{axiomK}} \coqdocvar{A}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{A}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} @\coqref{HLevel.hlevel equiv}{\coqdoclemma{hlevel\_equiv}} \coqdockw{with} (\coqdocvar{A} := \coqref{HLevel.is set}{\coqdocdefinition{is\_set}} \coqdocvar{A}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.isset equiv axiomK}{\coqdoclemma{isset\_equiv\_axiomK}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.hlevel isprop}{\coqdoclemma{hlevel\_isprop}}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.set path2}{set\_path2}{\coqdoclemma{set\_path2}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} \coqdocvar{q} : \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{HLevel.is set}{\coqdocdefinition{is\_set}} \coqdocvar{A} \ensuremath{\rightarrow} (\coqdocvar{p} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{q}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{x} \coqdocvar{y} \coqdocvar{p} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Contractible.contr path}{\coqdoclemma{contr\_path}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.prop inhabited contr}{\coqdoclemma{prop\_inhabited\_contr}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cbv}. \coqdocvar{cbv} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Recall that axiom K says that any self-path is homotopic to the
   identity path.  In particular, the identity path is homotopic to
   itself.  The following lemma says that the endo-homotopy of the
   identity path thus specified is in fact (homotopic to) its identity
   homotopy (whew!).  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{HLevel.axiomK idpath}{axiomK\_idpath}{\coqdoclemma{axiomK\_idpath}} (\coqdocvar{A} : \coqdockw{Type}) (\coqdocvar{x} : \coqdocvar{A}) (\coqdocvar{K} : \coqref{HLevel.axiomK}{\coqdocdefinition{axiomK}} \coqdocvar{A}) :\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{K} \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}) \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{qq} := \coqref{Fibrations.map dep}{\coqdoclemma{map\_dep}} (\coqdocvar{K} \coqdocvar{x}) (\coqdocvar{K} \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}))).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{q2} := \coqref{Paths.::'!' x}{\coqdocnotation{!}}\coqref{Fibrations.trans is concat opp}{\coqdoclemma{trans\_is\_concat\_opp}} (\coqdocvar{K} \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})) (\coqdocvar{K} \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})) \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{qq}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.::'!' x}{\coqdocnotation{!!}} \coqdocvar{K} \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Paths.::'!' x}{\coqdocnotation{!}} \coqref{Paths.idpath}{\coqdocconstructor{idpath}} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.concat cancel right}{\coqdoclemma{concat\_cancel\_right}} \coqdockw{with} (\coqdocvar{r} := \coqdocvar{K} \coqdocvar{x} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x})).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{cancel\_units}.\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Any type with "decidable equality" is a set. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.decidable paths}{decidable\_paths}{\coqdocdefinition{decidable\_paths}} (\coqdocvar{A} : \coqdockw{Type}) :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{\ensuremath{\forall}} (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}), \coqexternalref{:type scope:x '+' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{(}}\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}\coqexternalref{:type scope:x '+' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{)}} \coqexternalref{:type scope:x '+' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{+}} \coqexternalref{:type scope:x '+' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{(}}(\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) \ensuremath{\rightarrow} \coqexternalref{Empty set}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{Empty\_set}}\coqexternalref{:type scope:x '+' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{HLevel.inl injective}{inl\_injective}{\coqdocdefinition{inl\_injective}} (\coqdocvar{A} \coqdocvar{B} : \coqdockw{Type}) (\coqdocvar{x} \coqdocvar{y} : \coqdocvar{A}) (\coqdocvar{p} : \coqexternalref{inl}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{B} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqexternalref{inl}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{B} \coqdocvar{y}) : (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{y}) :=\coqdoceol
\coqdocindent{1.00em}
\coqref{Fibrations.transport}{\coqdoclemma{transport}} (\coqdocvar{P} := \coqdockw{fun} (\coqdocvar{s}:\coqdocvar{A}\coqexternalref{:type scope:x '+' x}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocnotation{+}}\coqdocvar{B}) \ensuremath{\Rightarrow} \coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdockw{match} \coqdocvar{s} \coqdockw{with} \coqexternalref{inl}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{inl}} \coqdocvar{a} \ensuremath{\Rightarrow} \coqdocvar{a} \ensuremath{|} \coqexternalref{inr}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{inr}} \coqdocvar{b} \ensuremath{\Rightarrow} \coqdocvar{x} \coqdockw{end}) \coqdocvar{p} (\coqref{Paths.idpath}{\coqdocconstructor{idpath}} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdef{HLevel.decidable isset}{decidable\_isset}{\coqdoclemma{decidable\_isset}} (\coqdocvar{A} : \coqdockw{Type}) :\coqdoceol
\coqdocindent{1.00em}
\coqref{HLevel.decidable paths}{\coqdocdefinition{decidable\_paths}} \coqdocvar{A} \ensuremath{\rightarrow} \coqref{HLevel.is set}{\coqdocdefinition{is\_set}} \coqdocvar{A}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{A} \coqdocvar{d}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.axiomK implies isset}{\coqdocdefinition{axiomK\_implies\_isset}}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{x} \coqdocvar{p}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{q} := \coqdocvar{d} \coqdocvar{x} \coqdocvar{x}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{qp} := \coqref{Fibrations.map dep}{\coqdoclemma{map\_dep}} (\coqdocvar{d} \coqdocvar{x}) \coqdocvar{p}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{fold} \coqdocvar{q} \coqdoctac{in} \coqdocvar{qp}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{generalize} \coqdocvar{qp}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{clear} \coqdocvar{qp}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{destruct} \coqdocvar{q} \coqdockw{as} [\coqdocvar{q} \ensuremath{|} \coqdocvar{q'}].\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intro} \coqdocvar{qp0}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.concat cancel left}{\coqdoclemma{concat\_cancel\_left}} \coqdockw{with} (\coqdocvar{p} := \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} (\coqref{Fibrations.transport}{\coqdoclemma{transport}} \coqdocvar{p} \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{Paths.opposite}{\coqdocdefinition{opposite}}, \coqref{Fibrations.trans is concat}{\coqdoclemma{trans\_is\_concat}}.\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{path\_via} \coqdocvar{q}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{set} (\coqdocvar{qp1} := \coqref{Fibrations.trans map}{\coqdoclemma{trans\_map}} \coqdocvar{p} (\coqdockw{fun} (\coqdocvar{x0}:\coqdocvar{A}) \ensuremath{\Rightarrow} \coqexternalref{inl}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocconstructor{inl}}  (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x0} \ensuremath{\rightarrow} \coqexternalref{Empty set}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{Empty\_set}})) \coqdocvar{q}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqref{HLevel.inl injective}{\coqdocdefinition{inl\_injective}} \coqdockw{with} (\coqdocvar{B} := (\coqdocvar{x} \coqref{Paths.::x '==' x}{\coqdocnotation{$=$}} \coqdocvar{x} \ensuremath{\rightarrow} \coqexternalref{Empty set}{http://coq.inria.fr/distrib/8.3pl1/stdlib/Coq.Init.Datatypes}{\coqdocinductive{Empty\_set}})).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{exact} (\coqdocvar{qp1} \coqref{Paths.::x '@' x}{\coqdocnotation{@}} \coqdocvar{qp0}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{induction} (\coqdocvar{q'} \coqdocvar{p}).\coqdoceol
\coqdocnoindent
\coqdockw{Defined}.\coqdoceol
\end{coqdoccode}
\coqlibrary{Homotopy}{Library }{Homotopy}

\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Paths}{\coqdoclibrary{Paths}} \coqref{Fibrations}{\coqdoclibrary{Fibrations}} \coqref{Contractible}{\coqdoclibrary{Contractible}} \coqref{Equivalences}{\coqdoclibrary{Equivalences}} \coqref{FiberEquivalences}{\coqdoclibrary{FiberEquivalences}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{Funext}{\coqdoclibrary{Funext}} \coqref{Univalence}{\coqdoclibrary{Univalence}} \coqref{UnivalenceAxiom}{\coqdoclibrary{UnivalenceAxiom}}.\coqdoceol
\coqdocnoindent
\coqdockw{Require} \coqdockw{Export} \coqref{HLevel}{\coqdoclibrary{HLevel}}.\coqdoceol
\end{coqdoccode}
\end{document}
