<html>
<head>
<title>Cover.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for Cover.v</h1>

<div class="code" title="File: Cover.v
Line: 1
Time: 0.094s">
<div class="time" style="width: 100%"></div>
<pre>From HoTT Require Import Basics Types HFiber Truncations.Core Truncations.SeparatedTrunc Pointed
  Modalities.ReflectiveSubuniverse.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 2
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope pointed_scope.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 4
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** * [O]-connected covers *)

(** Given a reflective subuniverse [O], for any type [X] and [x : O X], the [O]-connected cover of [X] at [x] is the fibre of [to O X] at [x]. *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 8
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition O_cover@{u} `{O : ReflectiveSubuniverse@{u}}
  (X : Type@{u}) (x : O X) : Type@{u}
  := hfiber (to O _) x.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 10
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The "[O]-connected" cover is in fact [O]-connected when [O] is a modality, using [isconnected_hfiber_conn_map]. Since Coq can infer this using typeclasses, we don't restate it here. *)

(** Characterization of paths in [O_cover] is given by [equiv_path_hfiber]. *)

(* If [x] is an actual point of [X], then the connected cover is pointed. *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition O_pcover@{u} (O : ReflectiveSubuniverse@{u})
  (X : Type@{u}) (x : X) : pType@{u}
  := pfiber@{u u u} (pto O [X,x]).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 18
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Covers commute with products *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 20
Time: 0.003s">
<div class="time" style="width: 3.1914893617021%"></div>
<pre>Definition O_pcover_prod `{O : ReflectiveSubuniverse} {X Y : pType@{u}}
  : O_pcover O (X * Y) pt &lt;~&gt;* [(O_pcover O X pt) * (O_pcover O Y pt), _].</pre>
</div>
<div class="code" title="File: Cover.v
Line: 21
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 22
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  srapply Build_pEquiv'.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 23
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  {</pre>
</div>
<div class="code" title="File: Cover.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> refine (_ oE equiv_functor_sigma_id _).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 24
Time: 0.001s">
<div class="time" style="width: 1.063829787234%"></div>
<pre>
    2: intro; napply equiv_path_O_prod.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    napply equiv_sigma_prod_prod.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: Cover.v
Line: 26
Time: 0.007s">
<div class="time" style="width: 7.4468085106383%"></div>
<pre>
  napply path_prod; cbn.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 27
Time: 0.004s">
<div class="time" style="width: 4.2553191489362%"></div>
<pre>
  all: snapply path_sigma'.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 28
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  1,3: exact idpath.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 29
Time: 0.001s">
<div class="time" style="width: 1.063829787234%"></div>
<pre>
  all: cbn.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 30
Time: 0.004s">
<div class="time" style="width: 4.2553191489362%"></div>
<pre>
  all: by rewrite concat_p1, concat_Vp.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 31
Time: 0.022s">
<div class="time" style="width: 23.404255319149%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 32
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Functoriality of [O_cover] *)

(** Given [X] and [x : O X], any map [f : X -&gt; Y] out of [X] induces a map [O_cover X x -&gt; O_cover Y (O_functor O f x)]. *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 36
Time: 0.001s">
<div class="time" style="width: 1.063829787234%"></div>
<pre>Definition functor_O_cover@{u v} `{O : ReflectiveSubuniverse} {X Y : Type@{u}}
  (f : X -&gt; Y) (x : O X) : O_cover@{u} X x -&gt; O_cover@{u} Y (O_functor O f x)
  := functor_hfiber (f:=to O _) (g:=to O _)
       (h:=f) (k:=O_functor O f) (to_O_natural O f) x.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 39
Time: 0.052s">
<div class="time" style="width: 55.31914893617%"></div>
<pre>

Definition equiv_functor_O_cover `{O : ReflectiveSubuniverse}
  {X Y : Type} (f : X -&gt; Y) `{IsEquiv _ _ f} (x : O X)
  : O_cover X x &lt;~&gt; O_cover Y (O_functor O f x)
  := Build_Equiv _ _ (functor_O_cover f x) _.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 44
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** *** Pointed functoriality *)

</pre>
</div>
<div class="code" title="File: Cover.v
Line: 47
Time: 0.002s">
<div class="time" style="width: 2.1276595744681%"></div>
<pre>Definition pfunctor_O_pcover `{O : ReflectiveSubuniverse} {X Y : pType}
  (f : X -&gt;* Y) : O_pcover O X pt -&gt;* O_pcover O Y pt
  := functor_pfiber (pto_O_natural O f).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 49
Time: 0.026s">
<div class="time" style="width: 27.659574468085%"></div>
<pre>

Definition pequiv_pfunctor_O_pcover `{O : ReflectiveSubuniverse} {X Y : pType}
  (f : X -&gt;* Y) `{IsEquiv _ _ f} : O_pcover O X pt &lt;~&gt;* O_pcover O Y pt
  := Build_pEquiv (pfunctor_O_pcover f) _.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** In the case of truncations, [ptr_natural] gives a better proof of pointedness. *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 55
Time: 0.001s">
<div class="time" style="width: 1.063829787234%"></div>
<pre>Definition pfunctor_pTr_pcover `{n : trunc_index} {X Y : pType}
  (f : X -&gt;* Y) : O_pcover (Tr n) X pt -&gt;* O_pcover (Tr n) Y pt
  := functor_pfiber (ptr_natural n f).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 57
Time: 0.012s">
<div class="time" style="width: 12.765957446809%"></div>
<pre>

Definition pequiv_pfunctor_pTr_pcover `{n : trunc_index}
  {X Y : pType} (f : X -&gt;* Y) `{IsEquiv _ _ f}
  : O_pcover (Tr n) X pt &lt;~&gt;* O_pcover (Tr n) Y pt
  := Build_pEquiv (pfunctor_pTr_pcover f) _.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


(** * Components *)

(** Path components are given by specializing to [O] being set-truncation. *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition comp := O_cover (O:=Tr 0).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 67
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Definition pcomp := O_pcover (Tr 0).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 68
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Definition pfunctor_pcomp {X Y : pType} := @pfunctor_pTr_pcover (-1) X Y.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 70
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Definition pequiv_pfunctor_pcomp {X Y : pType}
  := @pequiv_pfunctor_pTr_pcover (-1) X Y.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 72
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** If a property holds at a given point, then it holds for the whole component. This yields equivalences like the following: *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 74
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_comp_property `{Univalence} {X : Type} (x : X)
  (P : X -&gt; Type) `{forall x, IsHProp (P x)} (Px : P x)
  : comp (sig P) (tr (x; Px)) &lt;~&gt; comp X (tr x).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 76
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 77
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  unfold comp, O_cover, hfiber.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 78
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> simpl.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 78
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  refine (_ oE (equiv_sigma_assoc _ _)^-1).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 79
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply equiv_functor_sigma_id; intro y.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 80
Time: 0.004s">
<div class="time" style="width: 4.2553191489362%"></div>
<pre>
  apply equiv_iff_hprop.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 81
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Cover.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros [py q].</pre>
</div>
<div class="code" title="File: Cover.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exact (ap (Trunc_functor _ pr1) q).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 83
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: Cover.v
Line: 84
Time: 0.002s">
<div class="time" style="width: 2.1276595744681%"></div>
<pre> refine (equiv_ind (equiv_path_Tr _ _) _ _).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 84
Time: 0.004s">
<div class="time" style="width: 4.2553191489362%"></div>
<pre>
    apply Trunc_rec; intros p; induction p.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exact (Px; idpath).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 86
Time: 0.002s">
<div class="time" style="width: 2.1276595744681%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 87
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** For example, we may take components of equivalences among underlying maps. *)</pre>
</div>
<div class="code" title="File: Cover.v
Line: 89
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_comp_equiv_map `{Univalence} {A B : Type} (e : A &lt;~&gt; B)
  : comp (A &lt;~&gt; B) (tr e) &lt;~&gt; comp (A -&gt; B) (tr (equiv_fun e)).</pre>
</div>
<div class="code" title="File: Cover.v
Line: 90
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 91
Time: 0.002s">
<div class="time" style="width: 2.1276595744681%"></div>
<pre>
  refine (_ oE equiv_functor_O_cover (issig_equiv _ _)^-1 _); cbn.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 92
Time: 0.002s">
<div class="time" style="width: 2.1276595744681%"></div>
<pre>
  rapply equiv_comp_property.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 93
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: Cover.v
Line: 95
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>


</pre>
</div>
</body>
</html>

