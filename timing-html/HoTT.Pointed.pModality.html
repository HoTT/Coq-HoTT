<html>
<head>
<title>pModality.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for pModality.v</h1>

<div class="code" title="File: pModality.v
Line: 1
Time: 0.109s">
<div class="time" style="width: 100%"></div>
<pre>From HoTT Require Import Basics Types ReflectiveSubuniverse Pointed.Core.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 1
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Local Open Scope pointed_scope.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 3
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** * Modalities, reflective subuniverses and pointed types *)

(** So far, everything is about general reflective subuniverses, but in the future results about modalities can be placed here as well. *)

</pre>
</div>
<div class="code" title="File: pModality.v
Line: 8
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre>#[export] Instance ispointed_O `{O : ReflectiveSubuniverse} (X : Type)
  `{IsPointed X} : IsPointed (O X) := to O _ (point X).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 9
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre>

Definition pto (O : ReflectiveSubuniverse@{u}) (X : pType@{u})
  : X -&gt;* [O X, _]
  := Build_pMap (to O X) idpath.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 13
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** If [A] is already [O]-local, then Coq knows that [pto] is an equivalence, so we can simply define: *)</pre>
</div>
<div class="code" title="File: pModality.v
Line: 15
Time: 0.004s">
<div class="time" style="width: 3.6697247706422%"></div>
<pre>Definition pequiv_pto `{O : ReflectiveSubuniverse} {X : pType} `{In O X}
  : X &lt;~&gt;* [O X, _] := Build_pEquiv (pto O X) _.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Applying [O_rec] to a pointed map yields a pointed map. *)</pre>
</div>
<div class="code" title="File: pModality.v
Line: 18
Time: 0.003s">
<div class="time" style="width: 2.7522935779817%"></div>
<pre>Definition pO_rec `{O : ReflectiveSubuniverse} {X Y : pType}
  `{In O Y} (f : X -&gt;* Y) : [O X, _] -&gt;* Y
  := Build_pMap (O_rec f) (O_rec_beta _ _ @ point_eq f).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 20
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre>

Definition pO_rec_beta `{O : ReflectiveSubuniverse} {X Y : pType}
  `{In O Y} (f : X -&gt;* Y)
  : pO_rec f o* pto O X ==* f.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 24
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 25
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre>
  srapply Build_pHomotopy.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  1: napply O_rec_beta.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  cbn.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 28
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply moveL_pV.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  exact (concat_1p _)^.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 30
Time: 0.003s">
<div class="time" style="width: 2.7522935779817%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A pointed version of the universal property. *)</pre>
</div>
<div class="code" title="File: pModality.v
Line: 33
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre>Definition pequiv_o_pto_O `{Funext}
  (O : ReflectiveSubuniverse) (P Q : pType) `{In O Q}
  : ([O P, _] -&gt;** Q) &lt;~&gt;* (P -&gt;** Q).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 35
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 36
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snapply Build_pEquiv.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 37
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (* We could just use the map [e] defined in the next bullet, but we want Coq to immediately unfold the underlying map to this. *)
 </pre>
</div>
<div class="code" title="File: pModality.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: pModality.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact (Build_pMap (fun f =&gt; f o* pto O P) 1).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  (* We'll give an equivalence that definitionally has the same underlying map. *)
 </pre>
</div>
<div class="code" title="File: pModality.v
Line: 41
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>-</pre>
</div>
<div class="code" title="File: pModality.v
Line: 41
Time: 0.011s">
<div class="time" style="width: 10.091743119266%"></div>
<pre> transparent assert (e : (([O P, _] -&gt;* Q) &lt;~&gt; (P -&gt;* Q))).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 41
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    +</pre>
</div>
<div class="code" title="File: pModality.v
Line: 42
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre> refine (issig_pmap P Q oE _ oE (issig_pmap [O P, _] Q)^-1%equiv).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 42
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      snapply equiv_functor_sigma'.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 43
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      *</pre>
</div>
<div class="code" title="File: pModality.v
Line: 44
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre> rapply equiv_o_to_O.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 44
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      *</pre>
</div>
<div class="code" title="File: pModality.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intro f; cbn.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      (* [reflexivity] works here, but then the underlying map won't agree definitionally with precomposition by [pto P], since pointed composition inserts a reflexivity path here. *)
     </pre>
</div>
<div class="code" title="File: pModality.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>apply (equiv_concat_l 1).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 47
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    +</pre>
</div>
<div class="code" title="File: pModality.v
Line: 48
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact (equiv_isequiv e).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 48
Time: 0.002s">
<div class="time" style="width: 1.8348623853211%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 49
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** ** Pointed functoriality *)

</pre>
</div>
<div class="code" title="File: pModality.v
Line: 52
Time: 0.002s">
<div class="time" style="width: 1.8348623853211%"></div>
<pre>Definition O_pfunctor `(O : ReflectiveSubuniverse) {X Y : pType}
  (f : X -&gt;* Y) : [O X, _] -&gt;* [O Y, _]
  := pO_rec (pto O Y o* f).</pre>
</div>
<div class="code" title="File: pModality.v
Line: 54
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Coq knows that [O_pfunctor O f] is an equivalence whenever [f] is. *)</pre>
</div>
<div class="code" title="File: pModality.v
Line: 56
Time: 0.006s">
<div class="time" style="width: 5.5045871559633%"></div>
<pre>Definition equiv_O_pfunctor `(O : ReflectiveSubuniverse) {X Y : pType}
  (f : X -&gt;* Y) `{IsEquiv _ _ f} : [O X, _] &lt;~&gt;* [O Y, _]
  := Build_pEquiv (O_pfunctor O f) _.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 58
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Pointed naturality of [O_pfunctor]. *)</pre>
</div>
<div class="code" title="File: pModality.v
Line: 60
Time: 0.001s">
<div class="time" style="width: 0.91743119266055%"></div>
<pre>Definition pto_O_natural `(O : ReflectiveSubuniverse) {X Y : pType}
  (f : X -&gt;* Y) : O_pfunctor O f o* pto O X ==* pto O Y o* f.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  napply pO_rec_beta.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 63
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 64
Time: 0.002s">
<div class="time" style="width: 1.8348623853211%"></div>
<pre>

Definition pequiv_O_inverts `(O : ReflectiveSubuniverse) {X Y : pType}
  (f : X -&gt;* Y) `{O_inverts O f}
  : [O X, _] &lt;~&gt;* [O Y, _]
  := Build_pEquiv (O_pfunctor O f) _.</pre>
</div>
<div class="code" title="File: pModality.v
Line: 70
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

</pre>
</div>
</body>
</html>

