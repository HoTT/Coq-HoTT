<html>
<head>
<title>IdentitySystems.v</title>
<style>
.time {
  background-color: #ffaaaa;
  height: 100%;
  z-index: -1;
  position: absolute;
}
.code {
  z-index: 0;
  position: relative;
  border-style: solid;
  border-color: transparent;
  border-width: 1px;
}
.code:hover {
  border-style: solid;
  border-color: black;
  border-width: 1px;
}
pre {
  margin: 1px;
}
</style>
</head>
<body>
<h1>Timings for IdentitySystems.v</h1>

<div class="code" title="File: IdentitySystems.v
Line: 1
Time: 0.028s">
<div class="time" style="width: 100%"></div>
<pre>From HoTT Require Import Basics.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 1
Time: 0.004s">
<div class="time" style="width: 14.285714285714%"></div>
<pre>
Require Import Types.Sigma Types.Equiv Types.Paths.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 2
Time: 0.002s">
<div class="time" style="width: 7.1428571428571%"></div>
<pre>
Require Import HoTT.Tactics.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 3
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** * Characterization of identity types by identity systems *)

(** See Homotopy/EncodeDecode.v for a related characterization of identity types. *)

(** To avoid dependencies coming from Pointed.Core, we will write out some of the definitions found there. Let [A : Type], together with a distinguished base point [a0 : A]. A pointed type family is a type family [R : A -&gt; Type], together with a distinguished point [r0 : R a0]. A pointed type family [(R; r0)] is called an identity system if it satisfies the J-rule. Given a pointed type family [(R; r0)], the fundamental theorem of identity systems (Theorem 5.8.2 from the HoTT Book) tells us that the following are equivalent: (i) an identity system structure on [(R; r0)], (ii) homotopy contractibility of the space of pointed type family maps from [(R; r0)] to any pointed type family [(S; s0)], (iii) transport along [R] being an equivalence, and (iv) the total space of [R] being contractible. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 9
Time: 0.002s">
<div class="time" style="width: 7.1428571428571%"></div>
<pre>Class IsIdentitySystem {A : Type} {a0 : A} (R : A -&gt; Type) (r0 : R a0) := {
    idsys_ind (D : forall a : A, R a -&gt; Type) (d : D a0 r0) (a : A) (r : R a)
      : D a r;
    idsys_ind_beta (D : forall a : A, R a -&gt; Type) (d : D a0 r0)
      : idsys_ind D d a0 r0 = d
  }.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 14
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The mapping space between two pointed type families over the same pointed type is a family of maps that preserves the distinguished points. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 16
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition pfamMap {A : Type} {a0 : A} (R S : A -&gt; Type) (r0 : R a0) (s0 : S a0)
  := {f : forall a : A, R a -&gt; S a &amp; f a0 r0 = s0}.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 17
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A pointed homotopy between maps of pointed type families is a family of homotopies that is pointed in the fiber over [a0]. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 19
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>Definition pfammap_homotopy {A : Type} {a0 : A} {R S : A -&gt; Type} {r0 : R a0} {s0 : S a0}
  (f g : pfamMap R S r0 s0)
  := { p : forall a : A, pr1 f a == pr1 g a &amp; p a0 r0 = pr2 f @ (pr2 g)^}.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 21
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

Instance reflexive_pfammap_homotopy {A : Type} {a0 : A}
  {R S : A -&gt; Type} {r0 : R a0} {s0 : S a0}
  : Reflexive (pfammap_homotopy (r0:=r0) (s0:=s0)).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 25
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 26
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intro g.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 27
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snrefine (_;_).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 28
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact (fun _ _ =&gt; idpath).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 29
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 30
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> cbn; symmetry.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 30
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exact (concat_pV _).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 31
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 32
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** We weaken part (ii) of Theorem 5.8.2. Instead of requiring that the mapping space is contractible, we will only require it to be homotopy contractible, i.e. it is inhabited and there is a homotopy between every map and the chosen map. This allows us to avoid function extensionality. Given that a pointed type family [(R; r0)] is an identity system, then the mapping space of pointed type families from [(R; r0)] to any [(S; s0)] is homotopy contractible. This is a weak form of Theorem 5.8.2, (i) implies (ii). *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 34
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition homocontr_pfammap_identitysystem {A : Type} {a0 : A}
  (R : A -&gt; Type) (r0 : R a0) `{!IsIdentitySystem R r0}
  (S : A -&gt; Type) (s0 : S a0)
  : exists f : pfamMap R S r0 s0, forall g, pfammap_homotopy f g.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 37
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 38
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (to_S := idsys_ind (fun a _ =&gt; S a) s0).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 39
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose proof (to_S_beta := idsys_ind_beta (fun a _ =&gt; S a) s0).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 40
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snrefine ((to_S; to_S_beta); _).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 41
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intro g.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 42
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  exists (idsys_ind (fun a r =&gt; to_S a r = pr1 g a r) (to_S_beta @ (pr2 g)^)).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 43
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snapply idsys_ind_beta.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 44
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 45
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** If a pointed type family [(R; r0)] has homotopy contractible mapping spaces in the sense above, then [fun p =&gt; transport R p r0] is a fiberwise equivalence. This is a strong form of Theorem 5.8.2, (ii) implies (iii). *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 47
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>Definition equiv_path_homocontr_pfammap {A : Type} {a0 : A}
  (R : A -&gt; Type) (r0 : R a0)
  (H : forall S : A -&gt; Type, forall s0 : S a0,
    exists f : pfamMap R S r0 s0, forall g, pfammap_homotopy f g)
  (a : A)
  : IsEquiv (fun p : a0 = a =&gt; transport R p r0).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 52
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 53
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (inv := (H (fun a =&gt; a0 = a) 1).1.1).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 54
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose proof (inv_beta := (H (fun a =&gt; a0 = a) 1).1.2); cbn in inv_beta.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 55
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snapply (isequiv_adjointify _ (inv a)); cbn.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 56
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> destruct (H R r0) as [[f fp] h].</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 57
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    pose proof (h' := fun g =&gt; (h g).1 a); cbn in h'; clear h fp.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 58
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    (* Both sides are the underlying maps of [pfammap]s, so [h'] says that both are homotopic to [f a]. *)
   </pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 60
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>transitivity (f a).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 60
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    +</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> symmetry.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 61
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      nrefine (h' (fun _ _ =&gt; transport R (inv _ _) r0; _)).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 62
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exact (ap (fun x =&gt; transport R x r0) inv_beta).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 63
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    +</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 64
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact (h' (_; idpath)).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 64
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 65
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> by intros [].</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 65
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 66
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Given that some type family [R] is fiberwise equivalent to identity types based at [a0], then the total space [sig R] is contractible. This is a stronger form of Theorem 5.8.2, (iii) implies (iv). *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 68
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition contr_sigma_equiv_path {A : Type} {a0 : A}
  (R : A -&gt; Type) (f : forall a, (a0 = a) &lt;~&gt; R a)
  : Contr (sig R).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 70
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 71
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>
  rapply contr_equiv'.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 72
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  1: exact (equiv_functor_sigma_id f).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 73
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply contr_basedpaths.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 74
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 75
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Any pointed type family [(R; r0)] with contractible total space is an identity system. This is Theorem 5.8.2, (iv) implies (i). *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 77
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition identitysystem_contr_sigma {A : Type} {a0 : A} (R : A -&gt; Type)
  (r0 : R a0) {C : Contr (sig R)}
  : IsIdentitySystem R r0.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 79
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 80
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snapply Build_IsIdentitySystem.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 81
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros D d0 a r.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 82
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    exact (transport (fun ar : sig R =&gt; D (pr1 ar) (pr2 ar))
             (path_contr (a0; r0) (a; r)) d0).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 84
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros D d0; cbn; unfold path_contr.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 85
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    napply (transport2 _ (concat_Vp _)).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 86
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 87
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** Assuming function extensionality, pointed homotopy contractible fiberwise mapping spaces of pointed type families are contractible. We thus obtain the proper statement of Theorem 5.8.2. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 89
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>Definition contr_pfammap_homocontr `{Funext} {A : Type} {a0 : A}
  (R : A -&gt; Type) (r0 : R a0)
  (S : A -&gt; Type) (s0 : S a0)
  (fH : exists f : pfamMap R S r0 s0, forall g, pfammap_homotopy f g)
  : Contr (pfamMap R S r0 s0).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 93
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 94
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snapply Build_Contr.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 95
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact fH.1.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 96
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 97
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intro g.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 97
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    snapply path_sigma; cbn.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 98
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    +</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 99
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> funext a.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 99
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      napply path_forall.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 100
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exact ((fH.2 g).1 a).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 101
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
    +</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 102
Time: 0.004s">
<div class="time" style="width: 14.285714285714%"></div>
<pre> transport_path_forall_hammer.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 102
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      lhs napply transport_paths_l.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 103
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      napply moveR_Vp.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 104
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      napply moveL_pM.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 105
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      symmetry.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 106
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
      exact (fH.2 g).2.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 107
Time: 0.005s">
<div class="time" style="width: 17.857142857143%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 108
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The fiberwise mapping spaces of pointed type families are pointed homotopy contractible if they are contractible. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 110
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>Definition homocontr_pfammap_contr {A : Type} {a0 : A}
  (R : A -&gt; Type) (r0 : R a0)
  (S : A -&gt; Type) (s0 : S a0)
  (cp : Contr (pfamMap R S r0 s0))
  : exists f : pfamMap R S r0 s0, forall g, pfammap_homotopy f g.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 114
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 115
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  snrefine (_;_).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 116
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> exact (@center _ cp).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 117
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  -</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 118
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intro g.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 118
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>
    by destruct (@contr _ cp g).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 119
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 120
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** The fundamental theorem of identity systems is now proven. It is useful to write down some of the composite implications. Given an identity system [(R; r0)], transporting the point [r0] induces a fiberwise equivalence between the based path type [a0 = x] and [R x]. This is Theorem 5.8.2 (i) implies (iii). *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 122
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Instance isequiv_transport_identitysystem {A : Type} {a0 : A}
  (R : A -&gt; Type) (r0 : R a0) `{!IsIdentitySystem _ r0} (a : A)
  : IsEquiv (fun p : a0 = a =&gt; transport R p r0).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 124
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 125
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  napply equiv_path_homocontr_pfammap.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 126
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  by napply homocontr_pfammap_identitysystem.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 127
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 128
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>

Definition equiv_transport_identitysystem {A : Type} {a0 : A}
  (R : A -&gt; Type) (r0 : R a0) `{!IsIdentitySystem _ r0} (a : A)
  : (a0 = a) &lt;~&gt; R a
  := Build_Equiv _ _ (fun p =&gt; transport R p r0) _.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 133
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** A more general version of Theorem 5.8.2 (iii) implies (i) is proven in Basics/Equivalences.v as [equiv_path_ind]. The original statement is recovered if [e] is assumed to be [fun p =&gt; transport R p r0]. *)

(** Theorem 5.8.2, (iv) implies (iii), can be proven with a nice method due to Rijke. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 137
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_path_from_contr {A : Type} (a : A) (P : A -&gt; Type)
  (Prefl : P a)
  (cp : Contr {y:A &amp; P y} )
  (b : A)
  : P b &lt;~&gt; a = b.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 141
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 142
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply equiv_inverse.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 143
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>
  srefine (Build_Equiv _ _ _ _).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 144
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  {</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 145
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> intros []; exact Prefl.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 145
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre> }</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 145
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  revert b; apply isequiv_from_functor_sigma.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 146
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  rapply isequiv_contr_contr.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 147
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 148
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This is another result for characterizing the path types of [A] when given an equivalence [e : B &lt;~&gt; A], such as an [issig] lemma for [A]. It can help Coq to deduce the type family [P] if [revert] is used to move [a0] and [a1] into the goal, if needed. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 150
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_path_along_equiv {A B : Type} {P : A -&gt; A -&gt; Type}
  (e : B &lt;~&gt; A)
  (K : forall b0 b1 : B, P (e b0) (e b1) &lt;~&gt; b0 = b1)
  : forall a0 a1 : A, P a0 a1 &lt;~&gt; a0 = a1.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 153
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 154
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  equiv_intros e b0 b1.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 155
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  nrefine (_ oE K b0 b1).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 156
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply equiv_ap'.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 157
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 158
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This simply combines the two previous results, a common idiom. Again, it can help Coq to deduce the type family [P] if [revert] is used to move [a0] and [a1] into the goal, if needed. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 160
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Definition equiv_path_issig_contr {A B : Type} {P : A -&gt; A -&gt; Type}
  (e : B &lt;~&gt; A)
  (Prefl : forall b, P (e b) (e b))
  (cp : forall b1, Contr {b2 : B &amp; P (e b1) (e b2)})
  : forall a0 a1 : A, P a0 a1 &lt;~&gt; a0 = a1.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 164
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 165
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply (equiv_path_along_equiv e).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 166
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intro a0.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 167
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  srapply equiv_path_from_contr.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 168
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply Prefl.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 169
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 170
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** After [equiv_path_issig_contr], we are left showing the contractibility of a sigma-type whose base and fibers are large nested sigma-types of the same depth.  Moreover, we expect that the types appearing in those two large nested sigma-types "pair up" to form contractible based "path-types".  The following lemma "peels off" the first such pair, whose contractibility can often be found with typeclass search.  The remaining contractibility goal is then simplified by substituting the center of contraction of that first based "path-type", or more precisely a *specific* center that may or may not be the one given by the contractibility instance; the latter freedom sometimes makes things faster and simpler. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 172
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>Definition contr_sigma_sigma (A : Type) (B : A -&gt; Type)
  (C : A -&gt; Type) (D : forall a, B a -&gt; C a -&gt; Type)
  {cac : Contr {x:A &amp; C x} }
  (a : A) (c : C a)
  {ccd : Contr {y:B a &amp; D a y c } }
  : Contr {ab : {x:A &amp; B x} &amp; {y:C ab.1 &amp; D ab.1 ab.2 y} }.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 177
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
Proof.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 178
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (d := (center {y:B a &amp; D a y c}).2).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 179
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  set (b := (center {y:B a &amp; D a y c}).1) in *.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 180
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  apply (Build_Contr _ ((a;b);(c;d))).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 181
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  intros [[a' b'] [c' d']]; cbn in *.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 182
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (ac' := (a';c')).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 183
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  pose (bd' := (b';d') : {y:B ac'.1 &amp; D ac'.1 y ac'.2}).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 184
Time: 0.001s">
<div class="time" style="width: 3.5714285714286%"></div>
<pre>
  change (((a;b);(c;d)) = ((ac'.1;bd'.1);(ac'.2;bd'.2))
          :&gt; {ab : {x:A &amp; B x} &amp; {y:C ab.1 &amp; D ab.1 ab.2 y} }).</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 186
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  clearbody ac' bd'; clear a' b' c' d'.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 187
Time: 0.002s">
<div class="time" style="width: 7.1428571428571%"></div>
<pre>
  destruct (@path_contr {x:A &amp; C x} _ (a;c) ac').</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 188
Time: 0.002s">
<div class="time" style="width: 7.1428571428571%"></div>
<pre>
  destruct (@path_contr {y:B a &amp; D a y c} _ (b;d) bd').</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 189
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>
  reflexivity.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 190
Time: 0.003s">
<div class="time" style="width: 10.714285714286%"></div>
<pre>
Defined.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 191
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** This tactic just applies the previous lemma, using a match to figure out the appropriate type families so the user doesn't have to specify them. *)</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 193
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>Ltac contr_sigsig a c :=
  match goal with
  | [ |- Contr (@sig (@sig ?A ?B) (fun ab =&gt; @sig (@?C ab) (@?D ab))) ] =&gt;
    (* The lemma only applies when C depends only on the first component of ab, so we need to factor it somehow through pr1. *)
    let C' := fresh in
    transparent assert (C' : {C' : A -&gt; Type &amp; forall ab, C' ab.1 = C ab});
    [ eexists; intros ab; reflexivity
    | nrefine (contr_sigma_sigma A B C'.1 (fun a b =&gt; D (a;b)) a c);
      (** In practice, usually the first [Contr] hypothesis can be found by typeclass search, so we try that.  But we don't try on the second one, since often it can't be, and trying can be slow. *)
      [ try exact _ | subst C' ] ]
  end.</pre>
</div>
<div class="code" title="File: IdentitySystems.v
Line: 204
Time: 0s">
<div class="time" style="width: 0%"></div>
<pre>

(** For examples of the use of this tactic, see for instance [Factorization] and [Idempotents]. *)

</pre>
</div>
</body>
</html>

