<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Theory.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Tactics Basics.PathGroupoids Basics.Trunc
  Basics.Equivalences Basics.Decidable Basics.Iff.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Paths Types.Unit Types.Prod Types.Sigma Types.Sum
  Types.Empty Types.Option.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Spaces.List.Core Spaces.Nat.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Theory of Lists and List Operations *)</span>

<span class="sd">(** In this file we collect lemmas about lists and their operations. We don&#39;t include those in [List.Core] so that file can stay lightweight on dependencies. *)</span>

<span class="sd">(** We generally try to keep the order the same as the concepts appeared in [List.Core]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Length *)</span>

<span class="sd">(** A list of length zero must be the empty list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1"><span class="kn">Definition</span> <span class="nf">length_0</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">H</span> : length l = <span class="mi">0</span>)
  : l = nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk3"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length nil = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) = <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="theory-v-chk4"><hr></label><div class="goal-conclusion">a :: l = nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length nil = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil = nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Concatenation *)</span>

<span class="sd">(** Concatenating the empty list on the right is the identity. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk7"><span class="kn">Definition</span> <span class="nf">app_nil</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A)
  : l ++ nil = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l ++ nil = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l ++ nil = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk9"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil ++ nil = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l ++ nil = l</span></span></span><br></div><label class="goal-separator" for="theory-v-chka"><hr></label><div class="goal-conclusion">(a :: l) ++ nil = a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l ++ nil = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a :: l) ++ nil = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Associativity of list concatenation. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc"><span class="kn">Definition</span> <span class="nf">app_assoc</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A)
  : app x (app y z) = app (app x y) z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ++ y ++ z = (x ++ y) ++ z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ++ y ++ z = (x ++ y) ++ z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke"><span class="nb">induction</span> x <span class="kr">as</span> [|a x IHx] <span class="kr">in</span> |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil ++ y ++ z = (nil ++ y) ++ z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>x ++ y ++ z = (x ++ y) ++ z</span></span></span><br></div><label class="goal-separator" for="theory-v-chkf"><hr></label><div class="goal-conclusion">(a :: x) ++ y ++ z = ((a :: x) ++ y) ++ z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil ++ y ++ z = (nil ++ y) ++ z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span>x ++ y ++ z = (x ++ y) ++ z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a :: x) ++ y ++ z = ((a :: x) ++ y) ++ z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (cons a) IHx).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The type of lists has a monoidal structure given by concatenation. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk12"><span class="kn">Definition</span> <span class="nf">list_pentagon</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A)
  : app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z
    = ap (<span class="kr">fun</span> <span class="nv">l</span> =&gt; w ++ l) (app_assoc x y z)
    @ app_assoc w (x ++ y) z
    @ ap (<span class="kr">fun</span> <span class="nv">l</span> =&gt; l ++ z) (app_assoc w x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z =
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @
 app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z =
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @
 app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk14"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @
 app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk15"><span class="nb">induction</span> w <span class="kr">as</span> [|? w IHw] <span class="kr">in</span> x, y, z |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; nil ++ l) (app_assoc x y z) @
 app_assoc nil (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc nil x y) =
app_assoc nil x (y ++ z) @ app_assoc (nil ++ x) y z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><label class="goal-separator" for="theory-v-chk16"><hr></label><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; (a :: w) ++ l)
   (app_assoc x y z) @ app_assoc (a :: w) (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc (a :: w) x y) =
app_assoc (a :: w) x (y ++ z) @
app_assoc ((a :: w) ++ x) y z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; nil ++ l) (app_assoc x y z) @
 app_assoc nil (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc nil x y) =
app_assoc nil x (y ++ z) @ app_assoc (nil ++ x) y z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk18"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap idmap (app_assoc x y z) @ <span class="mi">1</span>) @ <span class="mi">1</span> =
<span class="mi">1</span> @ app_assoc x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk19"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap idmap (app_assoc x y z) @ <span class="mi">1</span> = app_assoc x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap idmap (app_assoc x y z) = app_assoc x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; (a :: w) ++ l)
   (app_assoc x y z) @ app_assoc (a :: w) (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc (a :: w) x y) =
app_assoc (a :: w) x (y ++ z) @
app_assoc ((a :: w) ++ x) y z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) @
 ap (cons a) (app_assoc w (x ++ y) z)) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z)
  (ap (cons a) (app_assoc w x y)) =
ap (cons a) (app_assoc w x (y ++ z)) @
ap (cons a) (app_assoc (w ++ x) y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d">rhs_V napply ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) @
 ap (cons a) (app_assoc w (x ++ y) z)) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z)
  (ap (cons a) (app_assoc w x y)) =
ap (cons a)
  (app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e">rhs_V <span class="bp">exact</span> (ap (ap (cons a)) (IHw x y z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) @
 ap (cons a) (app_assoc w (x ++ y) z)) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z)
  (ap (cons a) (app_assoc w x y)) =
ap (cons a)
  ((ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @
    app_assoc w (x ++ y) z) @
   ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f">rhs napply ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) @
 ap (cons a) (app_assoc w (x ++ y) z)) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z)
  (ap (cons a) (app_assoc w x y)) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @
   app_assoc w (x ++ y) z) @
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk20">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) @
ap (cons a) (app_assoc w (x ++ y) z) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @
   app_assoc w (x ++ y) z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><label class="goal-separator" for="theory-v-chk21"><hr></label><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z)
  (ap (cons a) (app_assoc w x y)) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk22">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) @
ap (cons a) (app_assoc w (x ++ y) z) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @
   app_assoc w (x ++ y) z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk23">rhs napply ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) @
ap (cons a) (app_assoc w (x ++ y) z) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z)) @
ap (cons a) (app_assoc w (x ++ y) z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk24">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; a :: w ++ l) (app_assoc x y z) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_compose.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk25">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z)
  (ap (cons a) (app_assoc w x y)) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk26">lhs_V napply ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>w, x, y, z</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : list A,
(ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; w ++ l) (app_assoc x y z) @ app_assoc w (x ++ y) z) @
ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y) =
app_assoc w x (y ++ z) @ app_assoc (w ++ x) y z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : list A =&gt; (a :: x) ++ z) (app_assoc w x y) =
ap (cons a)
  (ap (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt; l ++ z) (app_assoc w x y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply (ap_compose (<span class="kr">fun</span> <span class="nv">l</span> =&gt; l ++ z)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of a concatenated list is the sum of the lengths of the two lists. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk27"><span class="kn">Definition</span> <span class="nf">length_app</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A)
  : length (l ++ l&#39;) = length l + length l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (l ++ l&#39;) = length l + length l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (l ++ l&#39;) = length l + length l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk29"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="nb">using</span> list_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (nil ++ l&#39;) = length nil + length l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>length (l ++ l&#39;) = length l + length l&#39;</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2a"><hr></label><div class="goal-conclusion">length ((a :: l) ++ l&#39;) = length (a :: l) + length l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>length (l ++ l&#39;) = length l + length l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length ((a :: l) ++ l&#39;) = length (a :: l) + length l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>length (l ++ l&#39;) = length l + length l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(length (l ++ l&#39;)).+<span class="mi">1</span> = (length l + length l&#39;).+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap S IHl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element of a concatenated list is equivalently either in the first list or in the second list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d"><span class="kn">Definition</span> <span class="nf">equiv_inlist_app</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">x</span> : A)
  : InList x l + InList x l&#39; &lt;~&gt; InList x (l ++ l&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l + InList x l&#39; &lt;~&gt; InList x (l ++ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l + InList x l&#39; &lt;~&gt; InList x (l ++ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x nil + InList x l&#39; &lt;~&gt; InList x (nil ++ l&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l + InList x l&#39; &lt;~&gt; InList x (l ++ l&#39;)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk30"><hr></label><div class="goal-conclusion">InList x (a :: l) + InList x l&#39; &lt;~&gt;
InList x ((a :: l) ++ l&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x nil + InList x l&#39; &lt;~&gt; InList x (nil ++ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sum_empty_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l + InList x l&#39; &lt;~&gt; InList x (l ++ l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l) + InList x l&#39; &lt;~&gt;
InList x ((a :: l) ++ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk33"><span class="nb">cbn</span>; nrefine (_ oE equiv_sum_assoc _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l + InList x l&#39; &lt;~&gt; InList x (l ++ l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) + (InList x l + InList x l&#39;) &lt;~&gt;
(a = x) + InList x (l ++ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_functor_sum_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Folding *)</span>

<span class="sd">(** A left fold over a concatenated list is equivalent to folding over the first followed by folding over the second. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk34"><span class="kn">Lemma</span> <span class="nf">fold_left_app</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B -&gt; A) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list B) (<span class="nv">i</span> : A)
  : fold_left f (l ++ l&#39;) i = fold_left f l&#39; (fold_left f l i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_left f (l ++ l&#39;) i =
fold_left f l&#39; (fold_left f l i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_left f (l ++ l&#39;) i =
fold_left f l&#39; (fold_left f l i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk36"><span class="nb">induction</span> l <span class="kr">in</span> i |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_left f (nil ++ l&#39;) i =
fold_left f l&#39; (fold_left f nil i)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : A, fold_left f (l ++ l&#39;) i = fold_left f l&#39; (fold_left f l i)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk37"><hr></label><div class="goal-conclusion">fold_left f ((a :: l) ++ l&#39;) i =
fold_left f l&#39; (fold_left f (a :: l) i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk38"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : A, fold_left f (l ++ l&#39;) i = fold_left f l&#39; (fold_left f l i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_left f ((a :: l) ++ l&#39;) i =
fold_left f l&#39; (fold_left f (a :: l) i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A right fold over a concatenated list is equivalent to folding over the second followed by folding over the first. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk39"><span class="kn">Lemma</span> <span class="nf">fold_right_app</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A -&gt; A) (<span class="nv">i</span> : A) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list B)
  : fold_right f i (l ++ l&#39;) = fold_right f (fold_right f i l&#39;) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_right f i (l ++ l&#39;) =
fold_right f (fold_right f i l&#39;) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_right f i (l ++ l&#39;) =
fold_right f (fold_right f i l&#39;) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk3b"><span class="nb">induction</span> l <span class="kr">in</span> i |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_right f i (nil ++ l&#39;) =
fold_right f (fold_right f i l&#39;) nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : A, fold_right f i (l ++ l&#39;) = fold_right f (fold_right f i l&#39;) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk3c"><hr></label><div class="goal-conclusion">fold_right f i ((a :: l) ++ l&#39;) =
fold_right f (fold_right f i l&#39;) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk3d"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : A, fold_right f i (l ++ l&#39;) = fold_right f (fold_right f i l&#39;) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fold_right f i ((a :: l) ++ l&#39;) =
fold_right f (fold_right f i l&#39;) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (f a) (IHl _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Maps *)</span>

<span class="sd">(** The length of a mapped list is the same as the length of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk3e"><span class="kn">Definition</span> <span class="nf">length_list_map</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A)
  : length (list_map f l) = length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map f l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map f l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk40"><span class="nb">induction</span> l <span class="kr">as</span> [|x l IHl] <span class="nb">using</span> list_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map f nil) = length nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>length (list_map f l) = length l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk41"><hr></label><div class="goal-conclusion">length (list_map f (x :: l)) = length (x :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk42">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map f nil) = length nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>length (list_map f l) = length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map f (x :: l)) = length (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk44"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>length (list_map f l) = length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(length (list_map f l)).+<span class="mi">1</span> = (length l).+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap S IHl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A function applied to an element of a list is an element of the mapped list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk45"><span class="kn">Definition</span> <span class="nf">inlist_map</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A)
  : InList x l -&gt; InList (f x) (list_map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l -&gt; InList (f x) (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l -&gt; InList (f x) (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk47">simple_list_induction l y l IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x nil -&gt; InList (f x) (list_map f nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk48"><hr></label><div class="goal-conclusion">InList x (y :: l) -&gt;
InList (f x) (list_map f (y :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk49"><span class="mi">1</span>: <span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (y :: l) -&gt;
InList (f x) (list_map f (y :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk4a"><span class="nb">intros</span> [p | i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (f x) (list_map f (y :: l))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk4b"><hr></label><div class="goal-conclusion">InList (f x) (list_map f (y :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (f x) (list_map f (y :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk4d"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y = f x</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap f p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk4e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (f x) (list_map f (y :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk4f"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; InList (f x) (list_map f l)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (f x) (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IHl i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element of a mapped list is equal to the function applied to some element of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk50"><span class="kn">Definition</span> <span class="nf">inlist_map&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : B)
  : InList x (list_map f l) -&gt; { y : A &amp; prod (f y = x) (InList y l) }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_map f l) -&gt;
{y : A &amp; ((f y = x) * InList y l)%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_map f l) -&gt;
{y : A &amp; ((f y = x) * InList y l)%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk52"><span class="nb">induction</span> l <span class="kr">as</span> [|y l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_map f nil) -&gt;
{y : A &amp; ((f y = x) * InList y nil)%type}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l) -&gt; {y : A &amp; ((f y = x) * InList y l)%type}</span></span></span><br></div><label class="goal-separator" for="theory-v-chk53"><hr></label><div class="goal-conclusion">InList x (list_map f (y :: l)) -&gt;
{y0 : A &amp; ((f y0 = x) * InList y0 (y :: l))%type}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk54"><span class="mi">1</span>: <span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l) -&gt; {y : A &amp; ((f y = x) * InList y l)%type}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_map f (y :: l)) -&gt;
{y0 : A &amp; ((f y0 = x) * InList y0 (y :: l))%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk55"><span class="nb">intros</span> [p | i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l) -&gt; {y : A &amp; ((f y = x) * InList y l)%type}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp; ((f y0 = x) * InList y0 (y :: l))%type}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l) -&gt; {y : A &amp; ((f y = x) * InList y l)%type}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk56"><hr></label><div class="goal-conclusion">{y0 : A &amp; ((f y0 = x) * InList y0 (y :: l))%type}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk57">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l) -&gt; {y : A &amp; ((f y = x) * InList y l)%type}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp; ((f y0 = x) * InList y0 (y :: l))%type}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (y; (p, inl idpath)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l) -&gt; {y : A &amp; ((f y = x) * InList y l)%type}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp; ((f y0 = x) * InList y0 (y :: l))%type}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk59"><span class="nb">destruct</span> (IHl i) <span class="kr">as</span> [y&#39; [p i&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l) -&gt; {y : A &amp; ((f y = x) * InList y l)%type}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map f l)</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f y&#39; = x</span></span></span><br><span><var>i'</var><span class="hyp-type"><b>: </b><span>InList y&#39; l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp; ((f y0 = x) * InList y0 (y :: l))%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (y&#39;; (p, inr i&#39;)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Mapping a function over a concatenated list is the concatenation of the mapped lists. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk5a"><span class="kn">Definition</span> <span class="nf">list_map_app</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A)
  : list_map f (l ++ l&#39;) = list_map f l ++ list_map f l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (l ++ l&#39;) = list_map f l ++ list_map f l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (l ++ l&#39;) = list_map f l ++ list_map f l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk5c"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (nil ++ l&#39;) =
list_map f nil ++ list_map f l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map f (l ++ l&#39;) = list_map f l ++ list_map f l&#39;</span></span></span><br></div><label class="goal-separator" for="theory-v-chk5d"><hr></label><div class="goal-conclusion">list_map f ((a :: l) ++ l&#39;) =
list_map f (a :: l) ++ list_map f l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk5e"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map f (l ++ l&#39;) = list_map f l ++ list_map f l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f ((a :: l) ++ l&#39;) =
list_map f (a :: l) ++ list_map f l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A function that acts as the identity on the elements of a list is the identity on the mapped list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk5f"><span class="kn">Lemma</span> <span class="nf">list_map_id</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; A) (<span class="nv">l</span> : list A)
  (<span class="nv">Hf</span> : <span class="kr">forall</span> <span class="nv">x</span>, InList x l -&gt; f x = x)
  :  list_map f l = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk61"><span class="nb">induction</span> l <span class="kr">as</span> [|x l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x nil -&gt; f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f nil = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk62"><hr></label><div class="goal-conclusion">list_map f (x :: l) = x :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x nil -&gt; f x = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f nil = nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (x :: l) = x :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk65"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x :: list_map f l = x :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk66">napply ap011.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk67"><hr></label><div class="goal-conclusion">list_map f l = l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk68">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hf _ (inl idpath)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk69">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f l = l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk6a"><span class="nb">apply</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk6b"><span class="nb">intros</span> y Hy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk6c"><span class="nb">apply</span> Hf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; f x0 = x0</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; f x = x) -&gt; list_map f l = l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [list_map] of a composition is the composition of the maps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk6d"><span class="kn">Definition</span> <span class="nf">list_map_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C) (<span class="nv">l</span> : list A)
  : list_map (<span class="kr">fun</span> <span class="nv">x</span> =&gt; g (f x)) l = list_map g (list_map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) l =
list_map g (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) l =
list_map g (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk6f"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) nil =
list_map g (list_map f nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) l = list_map g (list_map f l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk70"><hr></label><div class="goal-conclusion">list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) (a :: l) =
list_map g (list_map f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk71"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) l = list_map g (list_map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) (a :: l) =
list_map g (list_map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: generalize as max *)</span>
<span class="sd">(** The length of a [list_map2] is the same as the length of the original lists. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk72"><span class="kn">Definition</span> <span class="nf">length_list_map2</span>@{i j k|} {A : <span class="kt">Type</span>@{i}} {B : <span class="kt">Type</span>@{j}} {C : <span class="kt">Type</span>@{k}}
  (f : A -&gt; B -&gt; C) defl defr l1 l2
  : length l1 = length l2
    -&gt; length (list_map2 f defl defr l1 l2) = length l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) = length l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) = length l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk74"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l1 = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr l1 l2) = length l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk75"><span class="nb">induction</span> l1 <span class="kr">as</span> [|x l1 IHl1] <span class="kr">in</span> l2, p |- * <span class="nb">using</span> list_ind@{i j}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr nil l2) = length nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length l2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) =
length l1</span></span></span><br></div><label class="goal-separator" for="theory-v-chk76"><hr></label><div class="goal-conclusion">length (list_map2 f defl defr (x :: l1) l2) =
length (x :: l1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk77">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr nil l2) = length nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk78"><span class="nb">destruct</span> l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr nil nil) = length nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk79"><hr></label><div class="goal-conclusion">length (list_map2 f defl defr nil (b :: l2)) =
length nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk7a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr nil nil) = length nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk7b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr nil (b :: l2)) =
length nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk7c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length l2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) =
length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr (x :: l1) l2) =
length (x :: l1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk7d"><span class="nb">destruct</span> l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length nil</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) =
length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr (x :: l1) nil) =
length (x :: l1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (b :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) =
length l1</span></span></span><br></div><label class="goal-separator" for="theory-v-chk7e"><hr></label><div class="goal-conclusion">length (list_map2 f defl defr (x :: l1) (b :: l2)) =
length (x :: l1)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk7f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length nil</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) =
length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr (x :: l1) nil) =
length (x :: l1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk80">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (b :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) =
length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr (x :: l1) (b :: l2)) =
length (x :: l1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk81"><span class="nb">cbn</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (b :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
length (list_map2 f defl defr l1 l2) =
length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_map2 f defl defr l1 l2) = length l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHl1, path_nat_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element of a [list_map2] is the result of applying the function to some elements of the original lists. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk82"><span class="kn">Definition</span> <span class="nf">inlist_map2</span>@{i j k u | i &lt;= u, j &lt;= u, k &lt;= u}
  {A : <span class="kt">Type</span>@{i}} {B : <span class="kt">Type</span>@{j}} {C : <span class="kt">Type</span>@{k}}
  (f : A -&gt; B -&gt; C) defl defr l1 l2 x
  : InList x (list_map2 f defl defr l1 l2) -&gt; length l1 = length l2
    -&gt; { y : A &amp; { z : B &amp;
                        prod@{k u} ((f y z) = x) (InList y l1 * InList z l2) } }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk84"><span class="nb">intros</span> H p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l1 = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk85"><span class="nb">induction</span> l1 <span class="kr">as</span> [|y l1 IHl1] <span class="kr">in</span> l2, x, H, p |- * <span class="nb">using</span> list_ind@{i u}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr nil l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y nil * InList z l2))%type}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr (y :: l1) l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length l2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><label class="goal-separator" for="theory-v-chk86"><hr></label><div class="goal-conclusion">{y0 : A &amp;
{z : B &amp;
((f y0 z = x) * (InList y0 (y :: l1) * InList z l2))%type}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk87">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr nil l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y nil * InList z l2))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk88"><span class="nb">destruct</span> l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr nil nil)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y nil * InList z nil))%type}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr nil (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk89"><hr></label><div class="goal-conclusion">{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y nil * InList z (b :: l2)))%type}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk8a"><span class="mi">1</span>: <span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr nil (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y nil * InList z (b :: l2)))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk8b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr (y :: l1) l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length l2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp;
{z : B &amp;
((f y0 z = x) * (InList y0 (y :: l1) * InList z l2))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk8c"><span class="nb">destruct</span> l2 <span class="kr">as</span> [| z].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr (y :: l1) nil)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length nil</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp;
{z : B &amp;
((f y0 z = x) * (InList y0 (y :: l1) * InList z nil))%type}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x
  (list_map2 f defl defr (y :: l1) (z :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><label class="goal-separator" for="theory-v-chk8d"><hr></label><div class="goal-conclusion">{y0 : A &amp;
{z0 : B &amp;
((f y0 z0 = x) *
 (InList y0 (y :: l1) * InList z0 (z :: l2)))%type}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk8e"><span class="mi">1</span>: <span class="nb">inversion</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x
  (list_map2 f defl defr (y :: l1) (z :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp;
{z0 : B &amp;
((f y0 z0 = x) *
 (InList y0 (y :: l1) * InList z0 (z :: l2)))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk8f"><span class="nb">destruct</span> H <span class="kr">as</span> [q | i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y z = x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp;
{z0 : B &amp;
((f y0 z0 = x) *
 (InList y0 (y :: l1) * InList z0 (z :: l2)))%type}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><label class="goal-separator" for="theory-v-chk90"><hr></label><div class="goal-conclusion">{y0 : A &amp;
{z0 : B &amp;
((f y0 z0 = x) *
 (InList y0 (y :: l1) * InList z0 (z :: l2)))%type}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk91"><span class="mi">1</span>: <span class="bp">exact</span> (y; z; (q, (inl idpath, inl idpath))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp;
{z0 : B &amp;
((f y0 z0 = x) *
 (InList y0 (y :: l1) * InList z0 (z :: l2)))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk92"><span class="nb">destruct</span> (IHl1 l2 x i) <span class="kr">as</span> [y&#39; [z&#39; [q [r s]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 = length l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y&#39; z&#39; = x</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>InList y&#39; l1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>InList z&#39; l2</span></span></span><br></div><label class="goal-separator" for="theory-v-chk93"><hr></label><div class="goal-conclusion">{y0 : A &amp;
{z0 : B &amp;
((f y0 z0 = x) *
 (InList y0 (y :: l1) * InList z0 (z :: l2)))%type}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk94"><span class="mi">1</span>: <span class="nb">apply</span> path_nat_succ, p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (y :: l1) = length (z :: l2)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">x</span> : C),
InList x (list_map2 f defl defr l1 l2) -&gt;
length l1 = length l2 -&gt;
{y : A &amp;
{z : B &amp;
((f y z = x) * (InList y l1 * InList z l2))%type}}</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y&#39; z&#39; = x</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>InList y&#39; l1</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>InList z&#39; l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{y0 : A &amp;
{z0 : B &amp;
((f y0 z0 = x) *
 (InList y0 (y :: l1) * InList z0 (z :: l2)))%type}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (y&#39;; z&#39;; (q, (inr r, inr s))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [list_map2] is a [list_map] if the first list is a repeated value. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk95"><span class="kn">Definition</span> <span class="nf">list_map2_repeat_l</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">x</span> : A) <span class="nv">l</span> {<span class="nv">defl</span> <span class="nv">defr</span>}
  : list_map2 f defl defr (<span class="kp">repeat</span> x (length l)) l = list_map (f x) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr (<span class="kp">repeat</span> x (length l)) l =
list_map (f x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr (<span class="kp">repeat</span> x (length l)) l =
list_map (f x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk97"><span class="nb">induction</span> l <span class="kr">as</span> [|y l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr (<span class="kp">repeat</span> x (length nil)) nil =
list_map (f x) nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk98" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map2 f defl defr (<span class="kp">repeat</span> x (length l)) l =
list_map (f x) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk98"><hr></label><div class="goal-conclusion">list_map2 f defl defr (<span class="kp">repeat</span> x (length (y :: l)))
  (y :: l) = list_map (f x) (y :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk99">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr (<span class="kp">repeat</span> x (length nil)) nil =
list_map (f x) nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk9a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map2 f defl defr (<span class="kp">repeat</span> x (length l)) l =
list_map (f x) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr (<span class="kp">repeat</span> x (length (y :: l)))
  (y :: l) = list_map (f x) (y :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [list_map2] is a [list_map] if the second list is a repeated value. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk9b"><span class="kn">Definition</span> <span class="nf">list_map2_repeat_r</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">y</span> : B) <span class="nv">l</span> {<span class="nv">defl</span> <span class="nv">defr</span>}
  : list_map2 f defl defr l (<span class="kp">repeat</span> y (length l)) = list_map (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x y) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr l (<span class="kp">repeat</span> y (length l)) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk9c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr l (<span class="kp">repeat</span> y (length l)) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk9d"><span class="nb">induction</span> l <span class="kr">as</span> [|x l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr nil (<span class="kp">repeat</span> y (length nil)) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk9e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map2 f defl defr l (<span class="kp">repeat</span> y (length l)) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk9e"><hr></label><div class="goal-conclusion">list_map2 f defl defr (x :: l)
  (<span class="kp">repeat</span> y (length (x :: l))) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) (x :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk9f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr nil (<span class="kp">repeat</span> y (length nil)) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_map2 f defl defr l (<span class="kp">repeat</span> y (length l)) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map2 f defl defr (x :: l)
  (<span class="kp">repeat</span> y (length (x :: l))) =
list_map (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x y) (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Reversal *)</span>

<span class="sd">(** The length of [reverse_acc] is the sum of the lengths of the two lists. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka1"><span class="kn">Definition</span> <span class="nf">length_reverse_acc</span>@{i|} {A : <span class="kt">Type</span>@{i}} (acc l : list A)
  : length (reverse_acc acc l) = length acc + length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (reverse_acc acc l) = length acc + length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (reverse_acc acc l) = length acc + length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka3"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length acc + length l = length (reverse_acc acc l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka4"><span class="nb">induction</span> l <span class="kr">as</span> [|x l IHl] <span class="kr">in</span> acc |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length acc + length nil = length (reverse_acc acc nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chka5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">acc</span> : list A, length acc + length l = length (reverse_acc acc l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chka5"><hr></label><div class="goal-conclusion">length acc + length (x :: l) =
length (reverse_acc acc (x :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length acc + length nil = length (reverse_acc acc nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> nat_add_zero_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">acc</span> : list A, length acc + length l = length (reverse_acc acc l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length acc + length (x :: l) =
length (reverse_acc acc (x :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka8">rhs_V napply IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">acc</span> : list A, length acc + length l = length (reverse_acc acc l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length acc + length (x :: l) =
length (x :: acc) + length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> nat_add_succ_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of [reverse] is the same as the length of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chka9"><span class="kn">Definition</span> <span class="nf">length_reverse</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A)
  : length (reverse l) = length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (reverse l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (reverse l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply length_reverse_acc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [list_map] of a [reverse_acc] is the [reverse_acc] of the [list_map] of the two lists. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkab"><span class="kn">Definition</span> <span class="nf">list_map_reverse_acc</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A)
  : list_map f (reverse_acc l&#39; l) = reverse_acc (list_map f l&#39;) (list_map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (reverse_acc l&#39; l) =
reverse_acc (list_map f l&#39;) (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (reverse_acc l&#39; l) =
reverse_acc (list_map f l&#39;) (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkad"><span class="nb">revert</span> l&#39;; simple_list_induction l a l IHl; <span class="nb">intro</span> l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (reverse_acc l&#39; nil) =
reverse_acc (list_map f l&#39;) (list_map f nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A,
list_map f (reverse_acc l&#39; l) = reverse_acc (list_map f l&#39;) (list_map f l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="theory-v-chkae"><hr></label><div class="goal-conclusion">list_map f (reverse_acc l&#39; (a :: l)) =
reverse_acc (list_map f l&#39;) (list_map f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkaf"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A,
list_map f (reverse_acc l&#39; l) = reverse_acc (list_map f l&#39;) (list_map f l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (reverse_acc l&#39; (a :: l)) =
reverse_acc (list_map f l&#39;) (list_map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [list_map] of a reversed list is the reversed [list_map]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb0"><span class="kn">Definition</span> <span class="nf">list_map_reverse</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A)
  : list_map f (reverse l) = reverse (list_map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (reverse l) = reverse (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map f (reverse l) = reverse (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply list_map_reverse_acc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [reverse_acc] is the same as concatenating the reversed list with the accumulator. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb2"><span class="kn">Definition</span> <span class="nf">reverse_acc_cons</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A)
  : reverse_acc l&#39; l = reverse l ++ l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse_acc l&#39; l = reverse l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse_acc l&#39; l = reverse l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb4"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> l&#39; |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse_acc l&#39; nil = reverse nil ++ l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse_acc l&#39; l = reverse l ++ l&#39;</span></span></span><br></div><label class="goal-separator" for="theory-v-chkb5"><hr></label><div class="goal-conclusion">reverse_acc l&#39; (a :: l) = reverse (a :: l) ++ l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb6"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse_acc l&#39; l = reverse l ++ l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse_acc l&#39; (a :: l) = reverse (a :: l) ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb7">lhs napply IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse_acc l&#39; l = reverse l ++ l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse l ++ a :: l&#39; = reverse (a :: l) ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb8">lhs napply (app_assoc _ [a]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse_acc l&#39; l = reverse l ++ l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(reverse l ++ [a]) ++ l&#39; = reverse (a :: l) ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkb9">f_ap; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse_acc l&#39; l = reverse l ++ l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: l) = reverse l ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [reverse] of a [cons] is the concatenation of the [reverse] with the head. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkba"><span class="kn">Definition</span> <span class="nf">reverse_cons</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A)
  : reverse (a :: l) = reverse l ++ [a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: l) = reverse l ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: l) = reverse l ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkbc"><span class="nb">induction</span> l <span class="kr">as</span> [|b l IHl] <span class="kr">in</span> a |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse [a] = reverse nil ++ [a]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, reverse (a :: l) = reverse l ++ [a]</span></span></span><br></div><label class="goal-separator" for="theory-v-chkbd"><hr></label><div class="goal-conclusion">reverse (a :: b :: l) = reverse (b :: l) ++ [a]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkbe"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, reverse (a :: l) = reverse l ++ [a]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: b :: l) = reverse (b :: l) ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkbf"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, reverse (a :: l) = reverse l ++ [a]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: b :: l) = (reverse l ++ [b]) ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc0"><span class="nb">rewrite</span> &lt;- app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, reverse (a :: l) = reverse l ++ [a]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: b :: l) = reverse l ++ [b] ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="nb">apply</span> reverse_acc_cons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [reverse] of a concatenated list is the concatenation of the reversed lists in reverse order. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc1"><span class="kn">Definition</span> <span class="nf">reverse_app</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A)
  : reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc3"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> l&#39; |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (nil ++ l&#39;) = reverse l&#39; ++ reverse nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><label class="goal-separator" for="theory-v-chkc4"><hr></label><div class="goal-conclusion">reverse ((a :: l) ++ l&#39;) =
reverse l&#39; ++ reverse (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc5"><span class="mi">1</span>: <span class="nb">symmetry</span>; <span class="nb">apply</span> app_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse ((a :: l) ++ l&#39;) =
reverse l&#39; ++ reverse (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: l ++ l&#39;) =
reverse l&#39; ++ reverse (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc7">lhs napply reverse_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (l ++ l&#39;) ++ [a] =
reverse l&#39; ++ reverse (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkc8">rhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (l ++ l&#39;) ++ [a] = reverse l&#39; ++ <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><label class="goal-separator" for="theory-v-chkc9"><hr></label><div class="goal-conclusion">reverse (a :: l) = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkca"><span class="mi">2</span>: napply reverse_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (l ++ l&#39;) ++ [a] =
reverse l&#39; ++ reverse l ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkcb">rhs napply app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (l ++ l&#39;) ++ [a] =
(reverse l&#39; ++ reverse l) ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkcc">napply (ap (<span class="kr">fun</span> <span class="nv">l</span> =&gt; l ++ [a])).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l&#39;</span> : list A, reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (l ++ l&#39;) = reverse l&#39; ++ reverse l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IHl l&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [reverse] is involutive. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkcd"><span class="kn">Definition</span> <span class="nf">reverse_reverse</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A)
  : reverse (reverse l) = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (reverse l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (reverse l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkcf"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (reverse nil) = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkd0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>reverse (reverse l) = l</span></span></span><br></div><label class="goal-separator" for="theory-v-chkd0"><hr></label><div class="goal-conclusion">reverse (reverse (a :: l)) = a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd1"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>reverse (reverse l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (reverse (a :: l)) = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd2">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>reverse (reverse l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (a :: l) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>reverse (reverse l) = l</span></span></span><br></div><label class="goal-separator" for="theory-v-chkd3"><hr></label><div class="goal-conclusion">reverse <span class="nl">?Goal</span> = a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd4"><span class="mi">1</span>: napply reverse_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>reverse (reverse l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse (reverse l ++ [a]) = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd5">lhs napply reverse_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>reverse (reverse l) = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse [a] ++ reverse (reverse l) = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ IHl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Getting elements *)</span>

<span class="sd">(** A variant of [nth] that returns an element of the list and a proof that it is the [n]-th element. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd6"><span class="kn">Definition</span> <span class="nf">nth_lt</span>@{i|} {A : <span class="kt">Type</span>@{i}} (l : list A) (n : nat)
  (H : n &lt; length l)
  : { x : A &amp; nth l n = Some x }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; nth l n = Some x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; nth l n = Some x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkd8"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHa] <span class="kr">in</span> n, H |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; nth nil n = Some x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; length l -&gt; {x : A &amp; nth l n = Some x}</span></span></span><br></div><label class="goal-separator" for="theory-v-chkd9"><hr></label><div class="goal-conclusion">{x : A &amp; nth (a :: l) n = Some x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkda"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; length l -&gt; {x : A &amp; nth l n = Some x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; nth (a :: l) n = Some x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkdb"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; length l -&gt; {x : A &amp; nth l n = Some x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; nth (a :: l) <span class="mi">0</span> = Some x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkdc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; length l -&gt; {x : A &amp; nth l n = Some x}</span></span></span><br></div><label class="goal-separator" for="theory-v-chkdc"><hr></label><div class="goal-conclusion">{x : A &amp; nth (a :: l) n.+<span class="mi">1</span> = Some x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkdd"><span class="mi">1</span>: <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; length l -&gt; {x : A &amp; nth l n = Some x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; nth (a :: l) n.+<span class="mi">1</span> = Some x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkde"><span class="nb">apply</span> IHa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; length l -&gt; {x : A &amp; nth l n = Some x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkdf"><span class="nb">apply</span> leq_pred&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt; length l -&gt; {x : A &amp; nth l n = Some x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">2</span> &lt;= (length l).+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A variant of [nth] that always returns an element when we know that the index is in the list. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">nth&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l) : A
  := pr1 (nth_lt l n H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element doesn&#39;t depend on the proof that [n &lt; length l]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke0"><span class="kn">Definition</span> <span class="nf">nth&#39;_nth&#39;</span> {<span class="nv">A</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> <span class="nv">H&#39;</span> : n &lt; length l)
  : nth&#39; l n H = nth&#39; l n H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H, H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; l n H = nth&#39; l n H&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H, H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; l n H = nth&#39; l n H&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Two equal lists have the same elements in the same positions. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke2"><span class="kn">Definition</span> <span class="nf">nth&#39;_path_list</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">l1</span> <span class="nv">l2</span> : list A}
  (<span class="nv">p</span> : l1 = l2) {<span class="nv">n</span> : nat} (<span class="nv">Hn1</span> : n &lt; length l1) (<span class="nv">Hn2</span> : n &lt; length l2)
  : nth&#39; l1 n Hn1 = nth&#39; l2 n Hn2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>l1 = l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length l1</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; l1 n Hn1 = nth&#39; l2 n Hn2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>l1 = l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn1</var><span class="hyp-type"><b>: </b><span>n &lt; length l1</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; l1 n Hn1 = nth&#39; l2 n Hn2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke4"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn1, Hn2</var><span class="hyp-type"><b>: </b><span>n &lt; length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; l1 n Hn1 = nth&#39; l1 n Hn2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> nth&#39;_nth&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element of a list is in the list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke5"><span class="kn">Definition</span> <span class="nf">inlist_nth&#39;</span>@{i|} {A : <span class="kt">Type</span>@{i}} (l : list A) (n : nat)
  (H : n &lt; length l)
  : InList (nth&#39; l n H) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (nth&#39; l n H) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (nth&#39; l n H) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke7"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHa] <span class="kr">in</span> n, H |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (nth&#39; nil n H) nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chke8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l), InList (nth&#39; l n H) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chke8"><hr></label><div class="goal-conclusion">InList (nth&#39; (a :: l) n H) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chke9"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l), InList (nth&#39; l n H) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (nth&#39; (a :: l) n H) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkea"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l), InList (nth&#39; l n H) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (nth&#39; (a :: l) <span class="mi">0</span> H) (a :: l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkeb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l), InList (nth&#39; l n H) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chkeb"><hr></label><div class="goal-conclusion">InList (nth&#39; (a :: l) n.+<span class="mi">1</span> H) (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkec"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l), InList (nth&#39; l n H) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (nth&#39; (a :: l) n.+<span class="mi">1</span> H) (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chked"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l), InList (nth&#39; l n H) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList (nth&#39; (a :: l) n.+<span class="mi">1</span> H) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element of a list is the same as the one given by [nth]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkee"><span class="kn">Definition</span> <span class="nf">nth_nth&#39;</span> {<span class="nv">A</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l)
  : nth l n = Some (nth&#39; l n H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth l n = Some (nth&#39; l n H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkef"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth l n = Some (nth&#39; l n H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (nth_lt l n H).<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element of a [cons] indexed at [n.+1] is the same as the [nth&#39;] element of the tail indexed at [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf0"><span class="kn">Definition</span> <span class="nf">nth&#39;_cons</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A)
  (<span class="nv">H</span> : n &lt; length l) (<span class="nv">H&#39;</span> : n.+<span class="mi">1</span> &lt; length (x :: l))
  : nth&#39; (x :: l) n.+<span class="mi">1</span> H&#39; = nth&#39; l n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (x :: l) n.+<span class="mi">1</span> H&#39; = nth&#39; l n H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (x :: l) n.+<span class="mi">1</span> H&#39; = nth&#39; l n H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf2"><span class="nb">apply</span> isinj_some.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (nth&#39; (x :: l) n.+<span class="mi">1</span> H&#39;) = Some (nth&#39; l n H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf3">nrefine (_^ @ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> = Some (nth&#39; (x :: l) n.+<span class="mi">1</span> H&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkf4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (x :: l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chkf4"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> = <span class="nl">?Goal</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="theory-v-chkf5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (x :: l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chkf5"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = Some (nth&#39; l n H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf6"><span class="mi">1</span>,<span class="mi">3</span>: rapply nth_nth&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (x :: l) n.+<span class="mi">1</span> = nth l n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39; n] element of a concatenated list [l ++ l&#39;] where [n &lt; length l] is the [nth&#39;] element of [l]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf7"><span class="kn">Definition</span> <span class="nf">nth&#39;_app</span>@{i|} {A : <span class="kt">Type</span>@{i}} (l l&#39; : list A) (n : nat)
  (H : n &lt; length l) (H&#39; : n &lt; length (l ++ l&#39;))
  : nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (l ++ l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkf9"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> l&#39;, n, H, H&#39; |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (nil ++ l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (nil ++ l&#39;) n H&#39; = nth&#39; nil n H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkfa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length ((a :: l) ++ l&#39;)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l)
(<span class="nv">H&#39;</span> : n &lt; length (l ++ l&#39;)), nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H</span></span></span><br></div><label class="goal-separator" for="theory-v-chkfa"><hr></label><div class="goal-conclusion">nth&#39; ((a :: l) ++ l&#39;) n H&#39; = nth&#39; (a :: l) n H</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkfb"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length ((a :: l) ++ l&#39;)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l)
(<span class="nv">H&#39;</span> : n &lt; length (l ++ l&#39;)), nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; ((a :: l) ++ l&#39;) n H&#39; = nth&#39; (a :: l) n H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkfc"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length ((a :: l) ++ l&#39;)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l)
(<span class="nv">H&#39;</span> : n &lt; length (l ++ l&#39;)), nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; ((a :: l) ++ l&#39;) <span class="mi">0</span> H&#39; = nth&#39; (a :: l) <span class="mi">0</span> H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chkfd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length ((a :: l) ++ l&#39;)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l)
(<span class="nv">H&#39;</span> : n &lt; length (l ++ l&#39;)), nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H</span></span></span><br></div><label class="goal-separator" for="theory-v-chkfd"><hr></label><div class="goal-conclusion">nth&#39; ((a :: l) ++ l&#39;) n.+<span class="mi">1</span> H&#39; = nth&#39; (a :: l) n.+<span class="mi">1</span> H</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkfe"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length ((a :: l) ++ l&#39;)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l)
(<span class="nv">H&#39;</span> : n &lt; length (l ++ l&#39;)), nth&#39; (l ++ l&#39;) n H&#39; = nth&#39; l n H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; ((a :: l) ++ l&#39;) n.+<span class="mi">1</span> H&#39; = nth&#39; (a :: l) n.+<span class="mi">1</span> H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The index of an element in a list is the [n] such that the [nth&#39;] element is the element. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chkff"><span class="kn">Definition</span> <span class="nf">index_of</span>@{i|} {A : <span class="kt">Type</span>@{i}} (l : list A) (x : A)
  : InList x l
    -&gt; sig@{<span class="kt">Set</span> i} (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; { H : n &lt; length l &amp; nth&#39; l n H = x }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l -&gt;
{n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk100"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l -&gt;
{n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk101"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x nil -&gt;
{n : nat &amp; {H : n &lt; length nil &amp; nth&#39; nil n H = x}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk102" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br></div><label class="goal-separator" for="theory-v-chk102"><hr></label><div class="goal-conclusion">InList x (a :: l) -&gt;
{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk103"><span class="mi">1</span>: <span class="nb">intros</span> x&#39;; <span class="nb">destruct</span> x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l) -&gt;
{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk104"><span class="nb">intros</span> [| i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk105" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk105"><hr></label><div class="goal-conclusion">{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk106">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk107"><span class="nb">revert</span> a p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
a = x -&gt;
{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk108">snapply paths_ind_r@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">_</span> : y = x) =&gt;
 {n : nat &amp;
 {H : n &lt; length (y :: l) &amp; nth&#39; (y :: l) n H = x}}) x
  <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk109">snrefine (exist@{i i} _ <span class="mi">0</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
 {H : n &lt; length (x :: l) &amp; nth&#39; (x :: l) n H = x}) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk10a">snrefine (exist _ _ idpath).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; length (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk10b"><span class="nb">apply</span> leq_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
(<span class="kr">fix</span> length (A : <span class="kt">Type</span>) (l : list A) {<span class="kr">struct</span> l} :
     nat :=
   <span class="kr">match</span> l <span class="kr">with</span>
   | nil =&gt; <span class="mi">0</span>
   | _ :: l0 =&gt; (length A l0).+<span class="mi">1</span>
   <span class="kr">end</span>) A l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk10c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk10d"><span class="nb">destruct</span> (IHl i) <span class="kr">as</span> [n [H H&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>nth&#39; l n H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp;
{H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk10e">snrefine (exist@{i i} _ n.+<span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>nth&#39; l n H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
 {H : n &lt; length (a :: l) &amp; nth&#39; (a :: l) n H = x})
  n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk10f">snrefine (_; _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>nth&#39; l n H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt; (length l).+<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk110" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>nth&#39; l n H = x</span></span></span><br></div><label class="goal-separator" for="theory-v-chk110"><hr></label><div class="goal-conclusion">nth&#39; (a :: l) n.+<span class="mi">1</span> <span class="nl">?Goal</span> = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk111"><span class="mi">1</span>: <span class="nb">apply</span> leq_succ, H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>nth&#39; l n H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (a :: l) n.+<span class="mi">1</span> (leq_succ H) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk112"><span class="nb">refine</span> (_ @ H&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x l -&gt; {n : nat &amp; {H : n &lt; length l &amp; nth&#39; l n H = x}}</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList x l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>nth&#39; l n H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (a :: l) n.+<span class="mi">1</span> (leq_succ H) = nth&#39; l n H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> nth&#39;_cons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth] element of a map is the function applied optionally to the [nth] element of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk113"><span class="kn">Definition</span> <span class="nf">nth_list_map</span>@{i j|} {A : <span class="kt">Type</span>@{i}} {B : <span class="kt">Type</span>@{j}}
  (f : A -&gt; B) (l : list A) (n : nat)
  : nth (list_map f l) n = functor_option f (nth l n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (list_map f l) n = functor_option f (nth l n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk114"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (list_map f l) n = functor_option f (nth l n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk115"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> n |- * <span class="nb">using</span> list_ind@{i j}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (list_map f nil) n = functor_option f (nth nil n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, nth (list_map f l) n = functor_option f (nth l n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk116"><hr></label><div class="goal-conclusion">nth (list_map f (a :: l)) n =
functor_option f (nth (a :: l) n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk117"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, nth (list_map f l) n = functor_option f (nth l n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (list_map f (a :: l)) n =
functor_option f (nth (a :: l) n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk118"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, nth (list_map f l) n = functor_option f (nth l n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (list_map f (a :: l)) <span class="mi">0</span> =
functor_option f (nth (a :: l) <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, nth (list_map f l) n = functor_option f (nth l n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk119"><hr></label><div class="goal-conclusion">nth (list_map f (a :: l)) n.+<span class="mi">1</span> =
functor_option f (nth (a :: l) n.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk11a"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, nth (list_map f l) n = functor_option f (nth l n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (list_map f (a :: l)) n.+<span class="mi">1</span> =
functor_option f (nth (a :: l) n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element of a [list_map] is the function applied to the [nth&#39;] element of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk11b"><span class="kn">Definition</span> <span class="nf">nth&#39;_list_map</span>@{i j|} {A : <span class="kt">Type</span>@{i}} {B : <span class="kt">Type</span>@{j}}
  (f : A -&gt; B) (l : list A) (n : nat) (H : n &lt; length l)
  (H&#39; : n &lt; length (list_map f l))
  : nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk11c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk11d"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> n, H, H&#39; |- * <span class="nb">using</span> list_ind@{i j}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map f nil)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_map f nil) n H&#39; = f (nth&#39; nil n H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk11e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map f (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l) (<span class="nv">H&#39;</span> : n &lt; length (list_map f l)),
nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk11e"><hr></label><div class="goal-conclusion">nth&#39; (list_map f (a :: l)) n H&#39; =
f (nth&#39; (a :: l) n H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk11f"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map f (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l) (<span class="nv">H&#39;</span> : n &lt; length (list_map f l)),
nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_map f (a :: l)) n H&#39; =
f (nth&#39; (a :: l) n H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk120"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (list_map f (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l) (<span class="nv">H&#39;</span> : n &lt; length (list_map f l)),
nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_map f (a :: l)) <span class="mi">0</span> H&#39; =
f (nth&#39; (a :: l) <span class="mi">0</span> H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk121" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (list_map f (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l) (<span class="nv">H&#39;</span> : n &lt; length (list_map f l)),
nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk121"><hr></label><div class="goal-conclusion">nth&#39; (list_map f (a :: l)) n.+<span class="mi">1</span> H&#39; =
f (nth&#39; (a :: l) n.+<span class="mi">1</span> H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk122"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (list_map f (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l) (<span class="nv">H&#39;</span> : n &lt; length (list_map f l)),
nth&#39; (list_map f l) n H&#39; = f (nth&#39; l n H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_map f (a :: l)) n.+<span class="mi">1</span> H&#39; =
f (nth&#39; (a :: l) n.+<span class="mi">1</span> H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element of a [list_map2] is the function applied to the [nth&#39;] elements of the original lists. The length of the two lists is required to be the same. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk123"><span class="kn">Definition</span> <span class="nf">nth&#39;_list_map2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">l1</span> : list A) (<span class="nv">l2</span> : list B)
  (<span class="nv">n</span> : nat) <span class="nv">defl</span> <span class="nv">defr</span> (<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
  (<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2))
  (<span class="nv">p</span> : length l1 = length l2)
  : f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) = nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l1</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l1 = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk124"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l1</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr l1 l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l1 = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk125"><span class="nb">revert</span> l2 n defl defr H H&#39; H&#39;&#39; p;
    simple_list_induction l1 a l1 IHl1;
    <span class="nb">intros</span> l2 n defl defr H H&#39; H&#39;&#39; p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr nil l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; nil n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr nil l2) n H&#39;&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk126" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr (a :: l1) l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length l2</span></span></span><br></div><label class="goal-separator" for="theory-v-chk126"><hr></label><div class="goal-conclusion">f (nth&#39; (a :: l1) n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) l2) n H&#39;&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk127">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr nil l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; nil n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr nil l2) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk128"><span class="nb">destruct</span> l2 <span class="kr">as</span> [|b l2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H, H'</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr nil nil)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; nil n H) (nth&#39; nil n H&#39;) =
nth&#39; (list_map2 f defl defr nil nil) n H&#39;&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk129" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr nil (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk129"><hr></label><div class="goal-conclusion">f (nth&#39; nil n H) (nth&#39; (b :: l2) n H&#39;) =
nth&#39; (list_map2 f defl defr nil (b :: l2)) n H&#39;&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk12a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H, H'</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr nil nil)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; nil n H) (nth&#39; nil n H&#39;) =
nth&#39; (list_map2 f defl defr nil nil) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (not_lt_zero_r _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk12b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr nil (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; nil n H) (nth&#39; (b :: l2) n H&#39;) =
nth&#39; (list_map2 f defl defr nil (b :: l2)) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk12c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length l2</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr (a :: l1) l2)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; (a :: l1) n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) l2) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk12d"><span class="nb">destruct</span> l2 <span class="kr">as</span> [|b l2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr (a :: l1) nil)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; (a :: l1) n H) (nth&#39; nil n H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) nil) n H&#39;&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk12e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk12e"><hr></label><div class="goal-conclusion">f (nth&#39; (a :: l1) n H) (nth&#39; (b :: l2) n H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) (b :: l2)) n H&#39;&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk12f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt; length (list_map2 f defl defr (a :: l1) nil)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; (a :: l1) n H) (nth&#39; nil n H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) nil) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk130">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; (a :: l1) n H) (nth&#39; (b :: l2) n H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) (b :: l2)) n H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk131"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; (a :: l1) <span class="mi">0</span> H) (nth&#39; (b :: l2) <span class="mi">0</span> H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) (b :: l2)) <span class="mi">0</span> H&#39;&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk132" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk132"><hr></label><div class="goal-conclusion">f (nth&#39; (a :: l1) n.+<span class="mi">1</span> H) (nth&#39; (b :: l2) n.+<span class="mi">1</span> H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) (b :: l2)) n.+<span class="mi">1</span>
  H&#39;&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk133">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; (a :: l1) <span class="mi">0</span> H) (nth&#39; (b :: l2) <span class="mi">0</span> H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) (b :: l2)) <span class="mi">0</span> H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk134">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; (a :: l1) n.+<span class="mi">1</span> H) (nth&#39; (b :: l2) n.+<span class="mi">1</span> H&#39;) =
nth&#39; (list_map2 f defl defr (a :: l1) (b :: l2)) n.+<span class="mi">1</span>
  H&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk135"><span class="nb">erewrite</span> <span class="mi">3</span> nth&#39;_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nth&#39; l1 n (leq_pred&#39; H)) (nth&#39; l2 n (leq_pred&#39; H&#39;)) =
nth&#39;
  ((<span class="kr">fix</span> list_map2
      (A B C : <span class="kt">Type</span>) (f : A -&gt; B -&gt; C)
      (def_l : list A -&gt; list C)
      (def_r : list B -&gt; list C) 
      (l1 : list A) (l2 : list B) {<span class="kr">struct</span> l1} :
        list C :=
      <span class="kr">match</span> l1 <span class="kr">with</span>
      | nil =&gt;
          <span class="kr">match</span> l2 <span class="kr">with</span>
          | nil =&gt; nil
          | _ :: _ =&gt; def_r l2
          <span class="kr">end</span>
      | x :: l3 =&gt;
          <span class="kr">match</span> l2 <span class="kr">with</span>
          | nil =&gt; def_l l1
          | y :: l4 =&gt;
              f x y
              :: list_map2 A B C f def_l def_r l3 l4
          <span class="kr">end</span>
      <span class="kr">end</span>) A B C f defl defr l1 l2) n 
  (leq_pred&#39; H&#39;&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk136"><span class="nb">apply</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l2</span> : list B) (<span class="nv">n</span> : nat)
(<span class="nv">defl</span> : list A -&gt; list C)
(<span class="nv">defr</span> : list B -&gt; list C) 
(<span class="nv">H</span> : n &lt; length l1) (<span class="nv">H&#39;</span> : n &lt; length l2)
(<span class="nv">H&#39;&#39;</span> : n &lt; length (list_map2 f defl defr l1 l2)),
length l1 = length l2 -&gt;
f (nth&#39; l1 n H) (nth&#39; l2 n H&#39;) =
nth&#39; (list_map2 f defl defr l1 l2) n H&#39;&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>defl</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>defr</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l1)</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (b :: l2)</span></span></span><br><span><var>H''</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;
length
  (list_map2 f defl defr (a :: l1) (b :: l2))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l1) = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 = length l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> path_nat_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element of a [repeat] is the repeated value. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk137"><span class="kn">Definition</span> <span class="nf">nth&#39;_repeat</span>@{i|} {A : <span class="kt">Type</span>@{i}} (x : A) (i n : nat)
  (H : i &lt; length (<span class="kp">repeat</span> x n))
  : nth&#39; (<span class="kp">repeat</span> x n) i H = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (<span class="kp">repeat</span> x n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x n) i H = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk138"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (<span class="kp">repeat</span> x n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x n) i H = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk139"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn] <span class="kr">in</span> i, H |- * <span class="nb">using</span> nat_ind@{i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (<span class="kp">repeat</span> x <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x <span class="mi">0</span>) i H = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk13a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (<span class="kp">repeat</span> x n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : nat) (<span class="nv">H</span> : i &lt; length (<span class="kp">repeat</span> x n)), nth&#39; (<span class="kp">repeat</span> x n) i H = x</span></span></span><br></div><label class="goal-separator" for="theory-v-chk13a"><hr></label><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) i H = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk13b"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (<span class="kp">repeat</span> x n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : nat) (<span class="nv">H</span> : i &lt; length (<span class="kp">repeat</span> x n)), nth&#39; (<span class="kp">repeat</span> x n) i H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) i H = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk13c"><span class="nb">destruct</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (<span class="kp">repeat</span> x n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : nat) (<span class="nv">H</span> : i &lt; length (<span class="kp">repeat</span> x n)), nth&#39; (<span class="kp">repeat</span> x n) i H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) <span class="mi">0</span> H = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; length (<span class="kp">repeat</span> x n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : nat) (<span class="nv">H</span> : i &lt; length (<span class="kp">repeat</span> x n)), nth&#39; (<span class="kp">repeat</span> x n) i H = x</span></span></span><br></div><label class="goal-separator" for="theory-v-chk13d"><hr></label><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) i.+<span class="mi">1</span> H = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk13e"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; length (<span class="kp">repeat</span> x n.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : nat) (<span class="nv">H</span> : i &lt; length (<span class="kp">repeat</span> x n)), nth&#39; (<span class="kp">repeat</span> x n) i H = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) i.+<span class="mi">1</span> H = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Two lists are equal if their [nth&#39;] elements are equal. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk13f"><span class="kn">Definition</span> <span class="nf">path_list_nth&#39;</span>@{i|} {A : <span class="kt">Type</span>@{i}} (l l&#39; : list A)
  (p : length l = length l&#39;)
  : (<span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">H</span> : n &lt; length l), nth&#39; l n H = nth&#39; l&#39; n (p # H))
    -&gt; l = l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l = length l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
 nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt;
l = l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk140"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l = length l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
 nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt;
l = l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk141"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l = length l&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk142"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> l&#39;, p, H |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length nil),
nth&#39; nil n H = nth&#39; l&#39; n (transport (lt n) p H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil = l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length l&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; l&#39; n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><label class="goal-separator" for="theory-v-chk143"><hr></label><div class="goal-conclusion">a :: l = l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk144">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length nil),
nth&#39; nil n H = nth&#39; l&#39; n (transport (lt n) p H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil = l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk145"><span class="nb">destruct</span> l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length nil),
nth&#39; nil n H = nth&#39; nil n (transport (lt n) p H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk146" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (a :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length nil),
nth&#39; nil n H =
nth&#39; (a :: l&#39;) n (transport (lt n) p H)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk146"><hr></label><div class="goal-conclusion">nil = a :: l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk147">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length nil),
nth&#39; nil n H = nth&#39; nil n (transport (lt n) p H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil = nil</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk148">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (a :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length nil),
nth&#39; nil n H =
nth&#39; (a :: l&#39;) n (transport (lt n) p H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nil = a :: l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk149">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length l&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; l&#39; n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk14a"><span class="nb">destruct</span> l&#39; <span class="kr">as</span> [|a&#39; l&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length nil</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; nil n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk14b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><label class="goal-separator" for="theory-v-chk14b"><hr></label><div class="goal-conclusion">a :: l = a&#39; :: l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk14c"><span class="mi">1</span>: <span class="bp">discriminate</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a&#39; :: l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk14d">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = a&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk14e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><label class="goal-separator" for="theory-v-chk14e"><hr></label><div class="goal-conclusion">l = l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk14f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H <span class="mi">0</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk150">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk151">snapply IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l = length l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk152" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><label class="goal-separator" for="theory-v-chk152"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H0</span> : n &lt; length l),
nth&#39; l n H0 = nth&#39; l&#39; n (transport (lt n) <span class="nl">?p</span> H0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk153"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">apply</span> path_nat_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H =
nth&#39; l&#39; n
  (transport (lt n)
     (path_nat_succ (length l) (length l&#39;) p) H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk154"><span class="nb">intros</span> n Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; l n Hn =
nth&#39; l&#39; n
  (transport (lt n)
     (path_nat_succ (length l) (length l&#39;) p) Hn)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk155">snrefine ((nth&#39;_cons l n a Hn _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt; length (a :: l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk156" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk156"><hr></label><div class="goal-conclusion">nth&#39; (a :: l) n.+<span class="mi">1</span> <span class="nl">?H&#39;</span> =
nth&#39; l&#39; n
  (transport (lt n)
     (path_nat_succ (length l) (length l&#39;) p) Hn)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk157"><span class="mi">1</span>: <span class="nb">apply</span> leq_succ, Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (a :: l) n.+<span class="mi">1</span> (leq_succ Hn) =
nth&#39; l&#39; n
  (transport (lt n)
     (path_nat_succ (length l) (length l&#39;) p) Hn)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk158">lhs napply H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (a :: l) = length (a&#39; :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length (a :: l)),
nth&#39; (a :: l) n H =
nth&#39; (a&#39; :: l&#39;) n (transport (lt n) p H)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">p</span> : length l = length l&#39;),
(<span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">H</span> : n &lt; length l),
nth&#39; l n H = nth&#39; l&#39; n (transport (lt n) p H)) -&gt; l = l&#39;</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (a&#39; :: l&#39;) n.+<span class="mi">1</span>
  (transport (lt n.+<span class="mi">1</span>) p (leq_succ Hn)) =
nth&#39; l&#39; n
  (transport (lt n)
     (path_nat_succ (length l) (length l&#39;) p) Hn)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply nth&#39;_cons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth n] element of a concatenated list [l ++ l&#39;] where [n &lt; length l] is the [nth] element of [l]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk159"><span class="kn">Definition</span> <span class="nf">nth_app</span>@{i|} {A : <span class="kt">Type</span>@{i}} (l l&#39; : list A) (n : nat)
  (H : n &lt; length l)
  : nth (l ++ l&#39;) n = nth l n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (l ++ l&#39;) n = nth l n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk15a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (l ++ l&#39;) n = nth l n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk15b"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> l&#39;, n, H |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (nil ++ l&#39;) n = nth nil n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk15c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat), n &lt; length l -&gt; nth (l ++ l&#39;) n = nth l n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk15c"><hr></label><div class="goal-conclusion">nth ((a :: l) ++ l&#39;) n = nth (a :: l) n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk15d"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat), n &lt; length l -&gt; nth (l ++ l&#39;) n = nth l n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth ((a :: l) ++ l&#39;) n = nth (a :: l) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk15e"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; length (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat), n &lt; length l -&gt; nth (l ++ l&#39;) n = nth l n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth ((a :: l) ++ l&#39;) <span class="mi">0</span> = nth (a :: l) <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk15f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat), n &lt; length l -&gt; nth (l ++ l&#39;) n = nth l n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk15f"><hr></label><div class="goal-conclusion">nth ((a :: l) ++ l&#39;) n.+<span class="mi">1</span> = nth (a :: l) n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk160"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt; length (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">l&#39;</span> : list A) (<span class="nv">n</span> : nat), n &lt; length l -&gt; nth (l ++ l&#39;) n = nth l n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth ((a :: l) ++ l&#39;) n.+<span class="mi">1</span> = nth (a :: l) n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHl, leq_pred&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth i] element where [pred (length l) = i] is the last element of the list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk161"><span class="kn">Definition</span> <span class="nf">nth_last</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">i</span> : nat) (<span class="nv">p</span> : nat_pred (length l) = i)
  : nth l i = <span class="nb">last</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat_pred (length l) = i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth l i = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk162"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>nat_pred (length l) = i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth l i = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk163"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth l (nat_pred (length l)) = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk164"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth nil (nat_pred (length nil)) = <span class="nb">last</span> nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk165" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth l (nat_pred (length l)) = <span class="nb">last</span> l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk165"><hr></label><div class="goal-conclusion">nth (a :: l) (nat_pred (length (a :: l))) =
<span class="nb">last</span> (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk166"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth l (nat_pred (length l)) = <span class="nb">last</span> l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (a :: l) (nat_pred (length (a :: l))) =
<span class="nb">last</span> (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk167"><span class="nb">destruct</span> l <span class="kr">as</span> [|b l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth nil (nat_pred (length nil)) = <span class="nb">last</span> nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth [a] (nat_pred (length [a])) = <span class="nb">last</span> [a]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth (b :: l) (nat_pred (length (b :: l))) = <span class="nb">last</span> (b :: l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk168"><hr></label><div class="goal-conclusion">nth (a :: b :: l) (nat_pred (length (a :: b :: l))) =
<span class="nb">last</span> (a :: b :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk169"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth (b :: l) (nat_pred (length (b :: l))) = <span class="nb">last</span> (b :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (a :: b :: l) (nat_pred (length (a :: b :: l))) =
<span class="nb">last</span> (a :: b :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">exact</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The last element of a list with an element appended is the appended element. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk16a"><span class="kn">Definition</span> <span class="nf">last_app</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A)
  : <span class="nb">last</span> (l ++ [x]) = Some x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (l ++ [x]) = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk16b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (l ++ [x]) = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk16c"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> x |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (nil ++ [x]) = Some x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk16d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, <span class="nb">last</span> (l ++ [x]) = Some x</span></span></span><br></div><label class="goal-separator" for="theory-v-chk16d"><hr></label><div class="goal-conclusion"><span class="nb">last</span> ((a :: l) ++ [x]) = Some x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk16e"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, <span class="nb">last</span> (l ++ [x]) = Some x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> ((a :: l) ++ [x]) = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk16f"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, <span class="nb">last</span> (nil ++ [x]) = Some x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> ([a] ++ [x]) = Some x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk170" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, <span class="nb">last</span> ((a0 :: l) ++ [x]) = Some x</span></span></span><br></div><label class="goal-separator" for="theory-v-chk170"><hr></label><div class="goal-conclusion"><span class="nb">last</span> ((a :: a0 :: l) ++ [x]) = Some x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk171"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, <span class="nb">last</span> ((a0 :: l) ++ [x]) = Some x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> ((a :: a0 :: l) ++ [x]) = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk172"><span class="kn">Definition</span> <span class="nf">nth&#39;_last_app</span>@{i|} {A : <span class="kt">Type</span>@{i}} (l : list A) (a : A)
  (H : length l &lt; length (l ++ [a]))
  : nth&#39; (l ++ [a]) (length l) H = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt; length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (l ++ [a]) (length l) H = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk173"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt; length (l ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (l ++ [a]) (length l) H = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk174"><span class="nb">revert</span> a H; simple_list_induction l a&#39; l IHl; <span class="nb">intros</span> a H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length nil &lt; length (nil ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (nil ++ [a]) (length nil) H = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk175" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">H</span> : length l &lt; length (l ++ [a])),
nth&#39; (l ++ [a]) (length l) H = a</span></span></span><br><span><var>a', a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a&#39; :: l) &lt; length ((a&#39; :: l) ++ [a])</span></span></span><br></div><label class="goal-separator" for="theory-v-chk175"><hr></label><div class="goal-conclusion">nth&#39; ((a&#39; :: l) ++ [a]) (length (a&#39; :: l)) H = a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk176"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">H</span> : length l &lt; length (l ++ [a])),
nth&#39; (l ++ [a]) (length l) H = a</span></span></span><br><span><var>a', a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a&#39; :: l) &lt; length ((a&#39; :: l) ++ [a])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; ((a&#39; :: l) ++ [a]) (length (a&#39; :: l)) H = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Removing elements *)</span>

<span class="sd">(** These functions allow surgery to be performed on a given list. *)</span>

<span class="sd">(** *** Drop *)</span>

<span class="sd">(** [drop n l] removes the first [n] elements of [l]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">drop</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) : list A :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; l
  | n.+<span class="mi">1</span> =&gt; drop n (tail l)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [drop] of zero elements is the identity, by definition. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">drop_0</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) : drop <span class="mi">0</span> l = l := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [drop] of one element is the tail of the list, by definition. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">drop_1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) : drop <span class="mi">1</span> l = tail l := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [drop] of the empty list is the empty list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk177"><span class="kn">Definition</span> <span class="nf">drop_nil</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat)
  : drop n (@nil A) = nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n nil = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk178"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n nil = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [drop] of [n] elements with [length l &lt;= n] is the empty list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk179"><span class="kn">Definition</span> <span class="nf">drop_length_leq</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (l : list A)
  (H : length l &lt;= n)
  : drop n l = nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n l = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk17a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n l = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk17b"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> H, n |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length nil &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n nil = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk17c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; drop n l = nil</span></span></span><br></div><label class="goal-separator" for="theory-v-chk17c"><hr></label><div class="goal-conclusion">drop n (a :: l) = nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk17d"><span class="mi">1</span>: <span class="nb">apply</span> drop_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; drop n l = nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n (a :: l) = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk17e"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= <span class="mi">0</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; drop n l = nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop <span class="mi">0</span> (a :: l) = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk17f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n.+<span class="mi">1</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; drop n l = nil</span></span></span><br></div><label class="goal-separator" for="theory-v-chk17f"><hr></label><div class="goal-conclusion">drop n.+<span class="mi">1</span> (a :: l) = nil</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk180"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n.+<span class="mi">1</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; drop n l = nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n.+<span class="mi">1</span> (a :: l) = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk181"><span class="nb">cbn</span>; <span class="nb">apply</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n.+<span class="mi">1</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; drop n l = nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk182"><span class="nb">apply</span> leq_pred&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n.+<span class="mi">1</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; drop n l = nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(length l).+<span class="mi">1</span> &lt;= n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of a [drop n] is the length of the original list minus [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk183"><span class="kn">Definition</span> <span class="nf">length_drop</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (l : list A)
  : length (drop n l) = length l - n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (drop n l) = length l - n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk184"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (drop n l) = length l - n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk185"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> n |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (drop n nil) = length nil - n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk186" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (drop n l) = length l - n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk186"><hr></label><div class="goal-conclusion">length (drop n (a :: l)) = length (a :: l) - n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk187"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">rewrite</span> drop_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (drop n l) = length l - n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (drop n (a :: l)) = length (a :: l) - n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk188"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (drop n l) = length l - n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (drop <span class="mi">0</span> (a :: l)) = length (a :: l) - <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk189" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (drop n l) = length l - n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk189"><hr></label><div class="goal-conclusion">length (drop n.+<span class="mi">1</span> (a :: l)) = length (a :: l) - n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk18a"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (drop n l) = length l - n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (drop n.+<span class="mi">1</span> (a :: l)) = length (a :: l) - n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IHl n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element of a [drop] is an element of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk18b"><span class="kn">Definition</span> <span class="nf">drop_inlist</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (l : list A) (x : A)
  : InList x (drop n l) -&gt; InList x l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (drop n l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk18c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (drop n l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk18d"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (drop n l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk18e"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> n, H, x |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (drop n nil)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk18f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (drop n (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (drop n l) -&gt; InList x l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk18f"><hr></label><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk190"><span class="mi">1</span>: <span class="nb">rewrite</span> drop_nil <span class="kr">in</span> H; <span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (drop n (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (drop n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk191"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (drop <span class="mi">0</span> (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (drop n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk192" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (drop n.+<span class="mi">1</span> (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (drop n l) -&gt; InList x l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk192"><hr></label><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk193"><span class="mi">1</span>: <span class="bp">exact</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (drop n.+<span class="mi">1</span> (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (drop n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="bp">exact</span> (IHl _ _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Take *)</span>

<span class="sd">(** [take n l] keeps the first [n] elements of [l] and returns [l] if [n &gt;= length l]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">take</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) : list A :=
  <span class="kr">match</span> n, l <span class="kr">with</span>
  | n.+<span class="mi">1</span>, x :: l =&gt; x :: take n l
  | _, _ =&gt; nil
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [take] of zero elements is the empty list, by definition. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">take_0</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) : take <span class="mi">0</span> l = nil := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [take] of the empty list is the empty list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk194"><span class="kn">Definition</span> <span class="nf">take_nil</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) : take n (@nil A) = nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n nil = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk195"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n nil = nil</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [take] of [n] elements with [length l &lt;= n] is the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk196"><span class="kn">Definition</span> <span class="nf">take_length_leq</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (l : list A)
  (H : length l &lt;= n)
  : take n l = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk197"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk198"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> H, n |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length nil &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n nil = nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk199" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; take n l = l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk199"><hr></label><div class="goal-conclusion">take n (a :: l) = a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk19a"><span class="mi">1</span>: <span class="nb">apply</span> take_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; take n l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n (a :: l) = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk19b"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= <span class="mi">0</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; take n l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take <span class="mi">0</span> (a :: l) = a :: l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk19c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n.+<span class="mi">1</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; take n l = l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk19c"><hr></label><div class="goal-conclusion">take n.+<span class="mi">1</span> (a :: l) = a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk19d"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n.+<span class="mi">1</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; take n l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> (a :: l) = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk19e"><span class="nb">cbn</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length (a :: l) &lt;= n.+<span class="mi">1</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length l &lt;= n -&gt; take n l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHl, leq_pred&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of a [take n] is the minimum of [n] and the length of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk19f"><span class="kn">Definition</span> <span class="nf">length_take</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (l : list A)
  : length (take n l) = nat_min n (length l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n l) = nat_min n (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n l) = nat_min n (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a1"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> n |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n nil) = nat_min n (length nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (take n l) = nat_min n (length l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1a2"><hr></label><div class="goal-conclusion">length (take n (a :: l)) = nat_min n (length (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n nil) = nat_min n (length nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a4"><span class="nb">rewrite</span> take_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length nil = nat_min n (length nil)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a5"><span class="nb">rewrite</span> nat_min_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length nil = length nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1a6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1a6"><hr></label><div class="goal-conclusion">length nil &lt;= n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a7"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length nil &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (take n l) = nat_min n (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n (a :: l)) = nat_min n (length (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1a9"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (take n l) = nat_min n (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take <span class="mi">0</span> (a :: l)) = nat_min <span class="mi">0</span> (length (a :: l))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1aa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (take n l) = nat_min n (length l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1aa"><hr></label><div class="goal-conclusion">length (take n.+<span class="mi">1</span> (a :: l)) =
nat_min n.+<span class="mi">1</span> (length (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ab"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, length (take n l) = nat_min n (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n.+<span class="mi">1</span> (a :: l)) =
nat_min n.+<span class="mi">1</span> (length (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of a [take] is less than or equal to the length of the list. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">length_take_leq</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">n</span> : nat} (<span class="nv">l</span> : list A)
  : length (take n l) &lt;= length l
  := transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x &lt;= length l) (length_take n l)^ (leq_nat_min_r _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element of a [take] is an element of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ac"><span class="kn">Definition</span> <span class="nf">take_inlist</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (l : list A) (x : A)
  : InList x (take n l) -&gt; InList x l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (take n l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (take n l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ae"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1af"><span class="nb">induction</span> l <span class="kr">as</span> [|a l IHl] <span class="kr">in</span> n, H, x |- * <span class="nb">using</span> list_ind@{i i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n nil)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1b0"><hr></label><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b1"><span class="mi">1</span>: <span class="nb">rewrite</span> take_nil <span class="kr">in</span> H; <span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b2"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take <span class="mi">0</span> (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n.+<span class="mi">1</span> (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1b3"><hr></label><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take <span class="mi">0</span> (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b5"><span class="nb">cbn</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Empty</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n.+<span class="mi">1</span> (a :: l))</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b7"><span class="nb">destruct</span> H <span class="kr">as</span> [-&gt; | H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (x :: l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1b8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1b8"><hr></label><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1b9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x (take n l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A), InList x (take n l) -&gt; InList x l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="bp">exact</span> (IHl _ _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Applying a [take] twice with [m] and [n] is the same as applying it once with [nat_min m n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1bb"><span class="kn">Definition</span> <span class="nf">take_take_min</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">m</span> <span class="nv">n</span> : nat} (<span class="nv">l</span> : list A)
  : take n (take m l) = take (nat_min n m) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n (take m l) = take (nat_min n m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1bc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n (take m l) = take (nat_min n m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1bd"><span class="nb">induction</span> n <span class="kr">in</span> m, l |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take <span class="mi">0</span> (take m l) = take (nat_min <span class="mi">0</span> m) l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1be"><hr></label><div class="goal-conclusion">take n.+<span class="mi">1</span> (take m l) = take (nat_min n.+<span class="mi">1</span> m) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1bf"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> (take m l) = take (nat_min n.+<span class="mi">1</span> m) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c0"><span class="nb">destruct</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> (take <span class="mi">0</span> l) = take (nat_min n.+<span class="mi">1</span> <span class="mi">0</span>) l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1c1"><hr></label><div class="goal-conclusion">take n.+<span class="mi">1</span> (take m.+<span class="mi">1</span> l) = take (nat_min n.+<span class="mi">1</span> m.+<span class="mi">1</span>) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c2"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> (take m.+<span class="mi">1</span> l) = take (nat_min n.+<span class="mi">1</span> m.+<span class="mi">1</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c3"><span class="nb">destruct</span> l <span class="kr">as</span> [|a l&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> (take m.+<span class="mi">1</span> nil) =
take (nat_min n.+<span class="mi">1</span> m.+<span class="mi">1</span>) nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1c4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1c4"><hr></label><div class="goal-conclusion">take n.+<span class="mi">1</span> (take m.+<span class="mi">1</span> (a :: l&#39;)) =
take (nat_min n.+<span class="mi">1</span> m.+<span class="mi">1</span>) (a :: l&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c5"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">rewrite</span> !take_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> (take m.+<span class="mi">1</span> (a :: l&#39;)) =
take (nat_min n.+<span class="mi">1</span> m.+<span class="mi">1</span>) (a :: l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A), take n (take m l) = take (nat_min n m) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: take n (take m l&#39;) = a :: take (nat_min n m) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [take] is commutative in [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c7"><span class="kn">Definition</span> <span class="nf">take_comm</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">m</span> <span class="nv">n</span> : nat} (<span class="nv">l</span> : list A)
  : take n (take m l) = take m (take n l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n (take m l) = take m (take n l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n (take m l) = take m (take n l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !take_take_min, nat_min_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [take n] does not change under concatenation if [n] is less than or equal to the length of the first list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1c9"><span class="kn">Definition</span> <span class="nf">take_app</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">n</span> : nat} (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">hn</span> : n &lt;= length l1)
  : take n l1 = take n (l1 ++ l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n &lt;= length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n l1 = take n (l1 ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n &lt;= length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n l1 = take n (l1 ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1cb"><span class="nb">induction</span> n <span class="kr">in</span> l1, l2, hn |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take <span class="mi">0</span> l1 = take <span class="mi">0</span> (l1 ++ l2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1cc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= length l1</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, n &lt;= length l1 -&gt; take n l1 = take n (l1 ++ l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1cc"><hr></label><div class="goal-conclusion">take n.+<span class="mi">1</span> l1 = take n.+<span class="mi">1</span> (l1 ++ l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1cd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= length l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take <span class="mi">0</span> l1 = take <span class="mi">0</span> (l1 ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= length l1</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, n &lt;= length l1 -&gt; take n l1 = take n (l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> l1 = take n.+<span class="mi">1</span> (l1 ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1cf"><span class="nb">destruct</span> l1 <span class="kr">as</span> [|a l1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= length nil</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, n &lt;= length l1 -&gt; take n l1 = take n (l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> nil = take n.+<span class="mi">1</span> (nil ++ l2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1d0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= length (a :: l1)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, n &lt;= length l1 -&gt; take n l1 = take n (l1 ++ l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1d0"><hr></label><div class="goal-conclusion">take n.+<span class="mi">1</span> (a :: l1) = take n.+<span class="mi">1</span> ((a :: l1) ++ l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= length nil</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, n &lt;= length l1 -&gt; take n l1 = take n (l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> nil = take n.+<span class="mi">1</span> (nil ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span> (not_lt_zero_r _ hn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= length (a :: l1)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, n &lt;= length l1 -&gt; take n l1 = take n (l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n.+<span class="mi">1</span> (a :: l1) = take n.+<span class="mi">1</span> ((a :: l1) ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>hn</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &lt;= length (a :: l1)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, n &lt;= length l1 -&gt; take n l1 = take n (l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: take n l1 = a :: take n (l1 ++ l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, IHn, leq_pred&#39;, hn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Remove *)</span>

<span class="sd">(** [remove n l] removes the [n]-th element of [l]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">remove</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) : list A
  := take n l ++ drop n.+<span class="mi">1</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Removing the first element of a list is the tail of the list. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">remove_0</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) : remove <span class="mi">0</span> l = tail l := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Removing the [n]-th element of a list with [length l &lt;= n] is the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d4"><span class="kn">Definition</span> <span class="nf">remove_length_leq</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A)
  (<span class="nv">H</span> : length l &lt;= n)
  : remove n l = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">remove n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">remove n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d6"><span class="nb">unfold</span> remove.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n l ++ drop n.+<span class="mi">1</span> l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d7"><span class="nb">rewrite</span> take_length_leq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l ++ drop n.+<span class="mi">1</span> l = l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1d8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1d8"><hr></label><div class="goal-conclusion">length l &lt;= n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1d9"><span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l ++ drop n.+<span class="mi">1</span> l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1da"><span class="nb">rewrite</span> drop_length_leq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l ++ nil = l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1db" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1db"><hr></label><div class="goal-conclusion">length l &lt;= n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1dc"><span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>length l &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l ++ nil = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> app_nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of a [remove n] is the length of the original list minus one. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1dd"><span class="kn">Definition</span> <span class="nf">length_remove</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (l : list A)
  (H : n &lt; length l)
  : length (remove n l) = nat_pred (length l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (remove n l) = nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1de"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (remove n l) = nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1df"><span class="nb">unfold</span> remove.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n l ++ drop n.+<span class="mi">1</span> l) = nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e0"><span class="nb">rewrite</span> length_app@{i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (take n l) + length (drop n.+<span class="mi">1</span> l) =
nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e1"><span class="nb">rewrite</span> length_take.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_min n (length l) + length (drop n.+<span class="mi">1</span> l) =
nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e2"><span class="nb">rewrite</span> length_drop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_min n (length l) + (length l - n.+<span class="mi">1</span>) =
nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e3"><span class="nb">rewrite</span> nat_min_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + (length l - n.+<span class="mi">1</span>) = nat_pred (length l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1e4"><hr></label><div class="goal-conclusion">n &lt;= length l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e5"><span class="mi">2</span>: <span class="bp">exact</span> (leq_trans _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + (length l - n.+<span class="mi">1</span>) = nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e6"><span class="nb">rewrite</span> &lt;- nat_sub_l_add_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + length l - n.+<span class="mi">1</span> = nat_pred (length l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1e7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1e7"><hr></label><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= length l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e8"><span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + length l - n.+<span class="mi">1</span> = nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1e9">lhs napply nat_sub_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_pred (n + length l - n) = nat_pred (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ea"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + length l - n = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> nat_add_sub_cancel_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element of a [remove] is an element of the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1eb"><span class="kn">Definition</span> <span class="nf">remove_inlist</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A)
  : InList x (remove n l) -&gt; InList x l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (remove n l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ec"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (remove n l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ed"><span class="nb">unfold</span> remove.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (take n l ++ drop n.+<span class="mi">1</span> l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ee"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>InList x (take n l ++ drop n.+<span class="mi">1</span> l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ef"><span class="nb">apply</span> equiv_inlist_app <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(InList x (take n l) + InList x (drop n.+<span class="mi">1</span> l))%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f0"><span class="nb">revert</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (take n l) + InList x (drop n.+<span class="mi">1</span> l) -&gt;
InList x l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f1">snapply sum_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (take n l) -&gt; InList x l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1f2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1f2"><hr></label><div class="goal-conclusion">InList x (drop n.+<span class="mi">1</span> l) -&gt; InList x l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (take n l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> take_inlist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (drop n.+<span class="mi">1</span> l) -&gt; InList x l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> drop_inlist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Filter *)</span>

<span class="sd">(** Produce the list of elements of a list that satisfy a decidable predicate. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">list_filter</span>@{u v|} {A : <span class="kt">Type</span>@{u}} (l : list A) (P : A -&gt; <span class="kt">Type</span>@{v})
  (dec : <span class="kr">forall</span> <span class="nv">x</span>, Decidable (P x))
  : list A
  := <span class="kr">match</span> l <span class="kr">with</span>
    | nil =&gt; nil
    | x :: l =&gt;
      <span class="kr">if</span> dec x <span class="kr">then</span> x :: list_filter l P dec
        <span class="kr">else</span> list_filter l P dec
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f5"><span class="kn">Definition</span> <span class="nf">inlist_filter</span>@{u v k | u &lt;= k, v &lt;= k} {A : <span class="kt">Type</span>@{u}} (l : list A)
  (P : A -&gt; <span class="kt">Type</span>@{v}) (dec : <span class="kr">forall</span> <span class="nv">x</span>, Decidable (P x)) (x : A)
  : iff@{u k k} (InList x (list_filter l P dec)) (InList x l /\ P x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f7">simple_list_induction l a l IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_filter nil P dec) &lt;-&gt;
InList x nil * P x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk1f8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk1f8"><hr></label><div class="goal-conclusion">InList x (list_filter (a :: l) P dec) &lt;-&gt;
InList x (a :: l) * P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1f9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_filter nil P dec) &lt;-&gt;
InList x nil * P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1fa"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty &lt;-&gt; Empty * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1fb"><span class="nb">apply</span> iff_inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty * P x &lt;-&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1fc"><span class="nb">apply</span> iff_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty * P x &lt;~&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">snapply prod_empty_l@{v}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1fd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_filter (a :: l) P dec) &lt;-&gt;
InList x (a :: l) * P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1fe"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x
  (<span class="kr">if</span> dec a
   <span class="kr">then</span> a :: list_filter l P dec
   <span class="kr">else</span> list_filter l P dec) &lt;-&gt;
((a = x) + InList x l) * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk1ff">napply iff_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x
  (<span class="kr">if</span> dec a
   <span class="kr">then</span> a :: list_filter l P dec
   <span class="kr">else</span> list_filter l P dec) &lt;-&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk200" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk200"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt; ((a = x) + InList x l) * P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk201"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt; ((a = x) + InList x l) * P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk202"><span class="nb">apply</span> iff_inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a = x) + InList x l) * P x &lt;-&gt; <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk203"><span class="nb">apply</span> iff_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a = x) + InList x l) * P x &lt;~&gt; <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (sum_distrib_r@{k k k _ _ _ k k} _ _ _).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk204">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x
  (<span class="kr">if</span> dec a
   <span class="kr">then</span> a :: list_filter l P dec
   <span class="kr">else</span> list_filter l P dec) &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk205"><span class="nb">destruct</span> (dec a) <span class="kr">as</span> [p|p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: list_filter l P dec) &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk206" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><label class="goal-separator" for="theory-v-chk206"><hr></label><div class="goal-conclusion">InList x (list_filter l P dec) &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk207">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (a :: list_filter l P dec) &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk208"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) + InList x (list_filter l P dec) &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk209">snapply iff_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk20a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><label class="goal-separator" for="theory-v-chk20a"><hr></label><div class="goal-conclusion">(a = x) + InList x (list_filter l P dec) &lt;-&gt; <span class="nl">?B</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="theory-v-chk20b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><label class="goal-separator" for="theory-v-chk20b"><hr></label><div class="goal-conclusion"><span class="nl">?B</span> &lt;-&gt; (a = x) * P x + InList x l * P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk20c"><span class="mi">1</span>: <span class="bp">exact</span> (sum (a = x) (prod (InList@{u} x l) (P x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) + InList x (list_filter l P dec) &lt;-&gt;
(a = x) + InList x l * P x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk20d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><label class="goal-separator" for="theory-v-chk20d"><hr></label><div class="goal-conclusion">(a = x) + InList x l * P x &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk20e"><span class="mi">1</span>: <span class="nb">split</span>; <span class="nb">apply</span> functor_sum; <span class="kp">only</span> <span class="mi">1</span>,<span class="mi">3</span>: <span class="bp">exact</span> idmap; <span class="nb">apply</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) + InList x l * P x &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk20f"><span class="nb">split</span>; <span class="nb">apply</span> functor_sum@{k k k k}; <span class="kp">only</span> <span class="mi">2</span>,<span class="mi">4</span>: <span class="bp">exact</span> idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = x -&gt; (a = x) * P x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk210" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><label class="goal-separator" for="theory-v-chk210"><hr></label><div class="goal-conclusion">(a = x) * P x -&gt; a = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk211">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = x -&gt; (a = x) * P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk212"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((a = a) * P a)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (idpath, p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk213">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) * P x -&gt; a = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> fst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk214">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_filter l P dec) &lt;-&gt;
(a = x) * P x + InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk215">napply iff_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (list_filter l P dec) &lt;-&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk216" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><label class="goal-separator" for="theory-v-chk216"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt; (a = x) * P x + InList x l * P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk217"><span class="mi">1</span>: <span class="bp">exact</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x l * P x &lt;-&gt; (a = x) * P x + InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk218"><span class="nb">apply</span> iff_inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) * P x + InList x l * P x &lt;-&gt; InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk219"><span class="nb">apply</span> iff_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) * P x + InList x l * P x &lt;~&gt; InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk21a">nrefine (equiv_compose&#39;@{k k k} (sum_empty_l@{k} _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) * P x + InList x l * P x &lt;~&gt;
Empty + InList x l * P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk21b">snapply equiv_functor_sum&#39;@{k k k k k k}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) * P x &lt;~&gt; Empty</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk21c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><label class="goal-separator" for="theory-v-chk21c"><hr></label><div class="goal-conclusion">InList x l * P x &lt;~&gt; InList x l * P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk21d"><span class="mi">2</span>: <span class="bp">exact</span> equiv_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) * P x &lt;~&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk21e"><span class="nb">apply</span> equiv_to_empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>InList x (list_filter l P dec) &lt;-&gt; InList x l * P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>~ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a = x) * P x -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [[] r].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk21f"><span class="kn">Definition</span> <span class="nf">list_filter_app</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  (<span class="nv">dec</span> : <span class="kr">forall</span> <span class="nv">x</span>, Decidable (P x))
  : list_filter (l ++ l&#39;) P dec = list_filter l P dec ++ list_filter l&#39; P dec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_filter (l ++ l&#39;) P dec =
list_filter l P dec ++ list_filter l&#39; P dec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk220"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_filter (l ++ l&#39;) P dec =
list_filter l P dec ++ list_filter l&#39; P dec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk221">simple_list_induction l a l IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_filter (nil ++ l&#39;) P dec =
list_filter nil P dec ++ list_filter l&#39; P dec</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk222" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_filter (l ++ l&#39;) P dec = list_filter l P dec ++ list_filter l&#39; P dec</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk222"><hr></label><div class="goal-conclusion">list_filter ((a :: l) ++ l&#39;) P dec =
list_filter (a :: l) P dec ++ list_filter l&#39; P dec</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk223">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_filter (nil ++ l&#39;) P dec =
list_filter nil P dec ++ list_filter l&#39; P dec</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk224">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_filter (l ++ l&#39;) P dec = list_filter l P dec ++ list_filter l&#39; P dec</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_filter ((a :: l) ++ l&#39;) P dec =
list_filter (a :: l) P dec ++ list_filter l&#39; P dec</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk225"><span class="nb">simpl</span>; <span class="nb">destruct</span> (dec a); <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>dec</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_filter (l ++ l&#39;) P dec = list_filter l P dec ++ list_filter l&#39; P dec</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: list_filter (l ++ l&#39;) P dec =
(a :: list_filter l P dec) ++ list_filter l&#39; P dec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Sequences *)</span>

<span class="sd">(** The length of a reverse sequence of [n] numbers is [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk226"><span class="kn">Definition</span> <span class="nf">length_seq_rev</span>@{} (n : nat)
  : length (seq_rev n) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk227"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk228"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev <span class="mi">0</span>) = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk229" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (seq_rev n) = n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk229"><hr></label><div class="goal-conclusion">length (seq_rev n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk22a"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (seq_rev n) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of a sequence of [n] numbers is [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk22b"><span class="kn">Definition</span> <span class="nf">length_seq</span>@{} (n : nat)
  : length (seq n) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk22c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk22d">lhs napply length_reverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> length_seq_rev.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The reversed sequence of [n.+1] numbers is the [n] followed by the rest of the reversed sequence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">seq_rev_cons</span>@{} (n : nat)
  : seq_rev n.+<span class="mi">1</span> = n :: seq_rev n
  := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The sequence of [n.+1] numbers is the sequence of [n] numbers concatenated with [[n]]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk22e"><span class="kn">Definition</span> <span class="nf">seq_succ</span>@{} (n : nat)
  : seq n.+<span class="mi">1</span> = seq n ++ [n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq n.+<span class="mi">1</span> = seq n ++ [n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk22f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq n.+<span class="mi">1</span> = seq n ++ [n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> reverse_cons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Alternate definition of [seq_rev] that keeps the proofs of the entries being [&lt; n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk230"><span class="kn">Definition</span> <span class="nf">seq_rev&#39;</span>@{} (n : nat) : list {k : nat &amp; k &lt; n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {k : nat &amp; k &lt; n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk231"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {k : nat &amp; k &lt; n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk232">transparent <span class="nb">assert</span> (f : (<span class="kr">forall</span> <span class="nv">n</span>, {k : nat &amp; k &lt; n}
    -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk233" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</span></span></span></span><br></div><label class="goal-separator" for="theory-v-chk233"><hr></label><div class="goal-conclusion">list {k : nat &amp; k &lt; n}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk234">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk235"><span class="nb">intros</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; k &lt; m} -&gt; {k : nat &amp; k &lt; m.+<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk236">snapply (functor_sigma idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat,
(<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k &lt; m) a -&gt;
(<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k &lt; m.+<span class="mi">1</span>) (idmap a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk237"><span class="nb">intros</span> k H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k &lt; m) k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k &lt; m.+<span class="mi">1</span>) (idmap k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (leq_succ_r H).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk238">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : nat =&gt;
functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; k0 &lt; m) k)
   =&gt; leq_succ_r H)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {k : nat &amp; k &lt; n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk239"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : nat =&gt;
functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; k0 &lt; m) k)
   =&gt; leq_succ_r H)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {k : nat &amp; k &lt; <span class="mi">0</span>}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk23a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : nat =&gt;
functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; k0 &lt; m) k)
   =&gt; leq_succ_r H)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>list {k : nat &amp; k &lt; n}</span></span></span><br></div><label class="goal-separator" for="theory-v-chk23a"><hr></label><div class="goal-conclusion">list {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk23b"><span class="mi">1</span>: <span class="bp">exact</span> nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : nat =&gt;
functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; k0 &lt; m) k)
   =&gt; leq_succ_r H)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>list {k : nat &amp; k &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk23c">nrefine ((n; _) :: list_map (f n) IHn).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : nat =&gt;
functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt; k0 &lt; m) k)
   =&gt; leq_succ_r H)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
{k : nat &amp; k &lt; n} -&gt; {k : nat &amp; k &lt; n.+<span class="mi">1</span>}</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>list {k : nat &amp; k &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Alternate definition of [seq] that keeps the proofs of the entries being [&lt; n]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">seq&#39;</span>@{} (n : nat) : list {k : nat &amp; k &lt; n}
  := reverse (seq_rev&#39; n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of [seq_rev&#39; n] is [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk23d"><span class="kn">Definition</span> <span class="nf">length_seq_rev&#39;</span>@{} (n : nat)
  : length (seq_rev&#39; n) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev&#39; n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk23e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev&#39; n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk23f"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev&#39; <span class="mi">0</span>) = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk240" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (seq_rev&#39; n) = n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk240"><hr></label><div class="goal-conclusion">length (seq_rev&#39; n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk241"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (seq_rev&#39; n) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev&#39; n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk242"><span class="nb">cbn</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (seq_rev&#39; n) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (list_map
     (functor_sigma idmap
        (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; n) =&gt; leq_succ_r H))
     (nat_rec (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; list {k : nat &amp; k &lt; n})
        nil
        (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">IHn</span> : list {k : nat &amp; k &lt; n})
         =&gt;
         (n; leq_refl n.+<span class="mi">1</span>)
         :: list_map
              (functor_sigma idmap
                 (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; n) =&gt;
                  leq_succ_r H)) IHn) n)) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk243">lhs napply length_list_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (seq_rev&#39; n) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (nat_rec (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; list {k : nat &amp; k &lt; n}) nil
     (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">IHn</span> : list {k : nat &amp; k &lt; n}) =&gt;
      (n; leq_refl n.+<span class="mi">1</span>)
      :: list_map
           (functor_sigma idmap
              (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; n) =&gt;
               leq_succ_r H)) IHn) n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of [seq&#39; n] is [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk244"><span class="kn">Definition</span> <span class="nf">length_seq&#39;</span>@{} (n : nat)
  : length (seq&#39; n) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq&#39; n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk245"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq&#39; n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk246">lhs napply length_reverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq_rev&#39; n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> length_seq_rev&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [list_map] of first projections on [seq_rev&#39; n] is [seq_rev n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk247"><span class="kn">Definition</span> <span class="nf">seq_rev_seq_rev&#39;</span>@{} (n : nat)
  : list_map pr1 (seq_rev&#39; n) = seq_rev n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1 (seq_rev&#39; n) = seq_rev n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk248"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1 (seq_rev&#39; n) = seq_rev n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk249"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1 (seq_rev&#39; <span class="mi">0</span>) = seq_rev <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk24a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>list_map pr1 (seq_rev&#39; n) = seq_rev n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk24a"><hr></label><div class="goal-conclusion">list_map pr1 (seq_rev&#39; n.+<span class="mi">1</span>) = seq_rev n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk24b"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>list_map pr1 (seq_rev&#39; n) = seq_rev n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1 (seq_rev&#39; n.+<span class="mi">1</span>) = seq_rev n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk24c"><span class="nb">simpl</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>list_map pr1 (seq_rev&#39; n) = seq_rev n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1
  (list_map
     (functor_sigma idmap
        (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; n) =&gt; leq_succ_r H))
     (seq_rev&#39; n)) = seq_rev n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk24d">lhs_V napply list_map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>list_map pr1 (seq_rev&#39; n) = seq_rev n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map
  (<span class="kr">fun</span> <span class="nv">x</span> : {k : nat &amp; k &lt; n} =&gt;
   (functor_sigma idmap
      (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">H</span> : k &lt; n) =&gt; leq_succ_r H) x).<span class="mi">1</span>)
  (seq_rev&#39; n) = seq_rev n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [list_map] of first projections on [seq&#39; n] is [seq n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk24e"><span class="kn">Definition</span> <span class="nf">seq_seq&#39;</span>@{} (n : nat)
  : list_map pr1 (seq&#39; n) = seq n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1 (seq&#39; n) = seq n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk24f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1 (seq&#39; n) = seq n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk250">lhs napply list_map_reverse_acc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse_acc (list_map pr1 nil)
  (list_map pr1 (seq_rev&#39; n)) = seq n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk251"><span class="nb">apply</span> (ap reverse).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map pr1 (seq_rev&#39; n) = seq_rev n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> seq_rev_seq_rev&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth] element of a [seq_rev] is [n - i.+1]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk252"><span class="kn">Definition</span> <span class="nf">nth_seq_rev</span>@{} {n i} (H : i &lt; n)
  : nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk253"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk254"><span class="nb">induction</span> i <span class="kr">as</span> [|i IHi] <span class="kr">in</span> n, H |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev n) <span class="mi">0</span> = Some (n - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk255" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, i &lt; n -&gt; nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk255"><hr></label><div class="goal-conclusion">nth (seq_rev n) i.+<span class="mi">1</span> = Some (n - i.+<span class="mi">2</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk256">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev n) <span class="mi">0</span> = Some (n - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk257"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev <span class="mi">0</span>) <span class="mi">0</span> = Some (<span class="mi">0</span> - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk258" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; n -&gt; nth (seq_rev n) <span class="mi">0</span> = Some (n - <span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk258"><hr></label><div class="goal-conclusion">nth (seq_rev n.+<span class="mi">1</span>) <span class="mi">0</span> = Some (n.+<span class="mi">1</span> - <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk259"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; n -&gt; nth (seq_rev n) <span class="mi">0</span> = Some (n - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev n.+<span class="mi">1</span>) <span class="mi">0</span> = Some (n.+<span class="mi">1</span> - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">by</span> <span class="nb">rewrite</span> nat_sub_zero_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk25a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, i &lt; n -&gt; nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev n) i.+<span class="mi">1</span> = Some (n - i.+<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk25b"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; <span class="mi">0</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, i &lt; n -&gt; nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev <span class="mi">0</span>) i.+<span class="mi">1</span> = Some (<span class="mi">0</span> - i.+<span class="mi">2</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk25c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, i &lt; n -&gt; nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; n -&gt; nth (seq_rev n) i.+<span class="mi">1</span> = Some (n - i.+<span class="mi">2</span>)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk25c"><hr></label><div class="goal-conclusion">nth (seq_rev n.+<span class="mi">1</span>) i.+<span class="mi">1</span> = Some (n.+<span class="mi">1</span> - i.+<span class="mi">2</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk25d"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, i &lt; n -&gt; nth (seq_rev n) i = Some (n - i.+<span class="mi">1</span>)</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i.+<span class="mi">1</span> &lt; n -&gt; nth (seq_rev n) i.+<span class="mi">1</span> = Some (n - i.+<span class="mi">2</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq_rev n.+<span class="mi">1</span>) i.+<span class="mi">1</span> = Some (n.+<span class="mi">1</span> - i.+<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHi, leq_pred&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth] element of a [seq] is [i]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk25e"><span class="kn">Definition</span> <span class="nf">nth_seq</span>@{} {n i} (H : i &lt; n)
  : nth (seq n) i = Some i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk25f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk260"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq <span class="mi">0</span>) i = Some i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk261" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br></div><label class="goal-separator" for="theory-v-chk261"><hr></label><div class="goal-conclusion">nth (seq n.+<span class="mi">1</span>) i = Some i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk262"><span class="mi">1</span>: <span class="nb">destruct</span> (not_lt_zero_r _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n.+<span class="mi">1</span>) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk263"><span class="nb">rewrite</span> seq_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n ++ [n]) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk264"><span class="nb">destruct</span> (dec (i &lt; n)) <span class="kr">as</span> [H&#39;|H&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n ++ [n]) i = Some i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk265" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>~ (i &lt; n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk265"><hr></label><div class="goal-conclusion">nth (seq n ++ [n]) i = Some i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk266">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n ++ [n]) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk267">lhs napply nth_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; length (seq n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk268" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk268"><hr></label><div class="goal-conclusion">nth (seq n) i = Some i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk269"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">rewrite</span> length_seq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk26a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>~ (i &lt; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n ++ [n]) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk26b"><span class="nb">apply</span> geq_iff_not_lt <span class="kr">in</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; n.+<span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n ++ [n]) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk26c"><span class="nb">apply</span> leq_pred&#39; <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= n</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; n -&gt; nth (seq n) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n ++ [n]) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk26d"><span class="nb">destruct</span> (leq_antisym H H&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= i</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; i -&gt; nth (seq i) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq i ++ [i]) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk26e">lhs napply nth_last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= i</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; i -&gt; nth (seq i) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_pred (length (seq i ++ [i])) = i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk26f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= i</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; i -&gt; nth (seq i) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= i</span></span></span><br></div><label class="goal-separator" for="theory-v-chk26f"><hr></label><div class="goal-conclusion"><span class="nb">last</span> (seq i ++ [i]) = Some i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk270">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= i</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; i -&gt; nth (seq i) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_pred (length (seq i ++ [i])) = i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk271"><span class="nb">rewrite</span> length_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= i</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; i -&gt; nth (seq i) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_pred (length (seq i) + length [i]) = i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk272"><span class="nb">rewrite</span> nat_add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= i</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; i -&gt; nth (seq i) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_pred (length [i] + length (seq i)) = i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> length_seq.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk273">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt;= i</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>i &lt; i -&gt; nth (seq i) i = Some i</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>i &gt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (seq i ++ [i]) = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply last_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [nth&#39;] element of a [seq&#39;] is [i]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk274"><span class="kn">Definition</span> <span class="nf">nth&#39;_seq&#39;</span>@{} (n i : nat) (H : i &lt; length (seq&#39; n))
  : (nth&#39; (seq&#39; n) i H).<span class="mi">1</span> = i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nth&#39; (seq&#39; n) i H).<span class="mi">1</span> = i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk275"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nth&#39; (seq&#39; n) i H).<span class="mi">1</span> = i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk276"><span class="nb">unshelve</span> lhs_V napply nth&#39;_list_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; length (list_map pr1 (seq&#39; n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk277" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk277"><hr></label><div class="goal-conclusion">nth&#39; (list_map pr1 (seq&#39; n)) i <span class="nl">?Goal</span> = i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk278"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">rewrite</span> length_list_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_map pr1 (seq&#39; n)) i
  (internal_paths_rew_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; i &lt; n) H
     (length_list_map pr1 (seq&#39; n))) = i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk279"><span class="nb">unshelve</span> lhs napply (ap011D (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; nth&#39; x _ y) _ idpath).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list nat</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk27a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk27a"><hr></label><div class="goal-conclusion">list_map pr1 (seq&#39; n) = <span class="nl">?Goal</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="theory-v-chk27b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk27b"><hr></label><div class="goal-conclusion">nth&#39; <span class="nl">?Goal</span> i
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : list nat =&gt; i &lt; length x) <span class="nl">?Goal0</span>
     (internal_paths_rew_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; i &lt; n) H
        (length_list_map pr1 (seq&#39; n)))) = i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk27c"><span class="mi">2</span>: <span class="nb">apply</span> seq_seq&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (seq n) i
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : list nat =&gt; i &lt; length x)
     (seq_seq&#39; n)
     (internal_paths_rew_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; i &lt; n) H
        (length_list_map pr1 (seq&#39; n)))) = i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk27d"><span class="nb">apply</span> isinj_some.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some
  (nth&#39; (seq n) i
     (transport (<span class="kr">fun</span> <span class="nv">x</span> : list nat =&gt; i &lt; length x)
        (seq_seq&#39; n)
        (internal_paths_rew_r (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; i &lt; n) H
           (length_list_map pr1 (seq&#39; n))))) = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk27e">lhs_V napply nth_nth&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (seq n) i = Some i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk27f"><span class="nb">apply</span> nth_seq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; length (seq&#39; n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> length_seq&#39; <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk280"><span class="kn">Definition</span> <span class="nf">inlist_seq</span>@{} (n : nat) x
  : InList x (seq n) &lt;~&gt; (x &lt; n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (seq n) &lt;~&gt; x &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk281"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (seq n) &lt;~&gt; x &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk282">simple_induction n n IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (seq <span class="mi">0</span>) &lt;~&gt; x &lt; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk283" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk283"><hr></label><div class="goal-conclusion">InList x (seq n.+<span class="mi">1</span>) &lt;~&gt; x &lt; n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk284">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (seq <span class="mi">0</span>) &lt;~&gt; x &lt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk285"><span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_to_empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt; <span class="mi">0</span> -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> not_lt_zero_r.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk286">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (seq n.+<span class="mi">1</span>) &lt;~&gt; x &lt; n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk287"><span class="nb">refine</span> (_ oE equiv_transport _ (seq_succ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (seq n ++ [n]) &lt;~&gt; x &lt; n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk288">nrefine (_ oE (equiv_inlist_app _ _ _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x (seq n) + InList x [n] &lt;~&gt; x &lt; n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk289">nrefine (_ oE equiv_functor_sum&#39; (B&#39;:=x = n) IHn _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x &lt; n) + (x = n) &lt;~&gt; x &lt; n.+<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk28a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk28a"><hr></label><div class="goal-conclusion">InList x [n] &lt;~&gt; x = n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk28b"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList x [n] &lt;~&gt; x = n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk28c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n = x) + Empty &lt;~&gt; x = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_path_inverse _ _ oE sum_empty_r@{<span class="kt">Set</span>} _).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk28d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x &lt; n) + (x = n) &lt;~&gt; x &lt; n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk28e">nrefine (_ oE equiv_leq_lt_or_eq^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList x (seq n) &lt;~&gt; x &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt;= n &lt;~&gt; x &lt; n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_iff_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Turning a finite sequence into a list. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_list</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">i</span> : nat), (i &lt; n) -&gt; A)
  : list A
  := list_map (<span class="kr">fun</span> &#39;(i; Hi) =&gt; f i Hi) (seq&#39; n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk28f"><span class="kn">Definition</span> <span class="nf">length_Build_list</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">i</span> : nat), (i &lt; n) -&gt; A)
  : length (Build_list n f) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (Build_list n f) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk290"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (Build_list n f) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk291">lhs napply length_list_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq&#39; n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> length_seq&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk292"><span class="kn">Definition</span> <span class="nf">nth&#39;_Build_list</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">n</span> : nat}
  (<span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">i</span> : nat), (i &lt; n) -&gt; A) {<span class="nv">i</span> : nat} (<span class="nv">Hi</span> : i &lt; n)
  (<span class="nv">Hi&#39;</span> : i &lt; length (Build_list n f))
  : nth&#39; (Build_list n f) i Hi&#39; = f i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (Build_list n f) i Hi&#39; = f i Hi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk293"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (Build_list n f) i Hi&#39; = f i Hi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk294"><span class="nb">unshelve</span> lhs snrefine (nth&#39;_list_map _ _ _ (_^ # Hi) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (seq&#39; n) = n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk295" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk295"><hr></label><div class="goal-conclusion">(<span class="kr">let</span> <span class="nv">x</span> := nth&#39; (seq&#39; n) i (transport (lt i) <span class="nl">?Goal</span>^ Hi)
   <span class="kr">in</span>
 <span class="kr">let</span> <span class="nv">i</span> := x.<span class="mi">1</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">Hi</span> := x.<span class="mi">2</span> <span class="kr">in</span> f i Hi) = f i Hi</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk296"><span class="mi">1</span>: napply length_seq&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> <span class="nv">x</span> :=
   nth&#39; (seq&#39; n) i
     (transport (lt i) (length_seq&#39; n)^ Hi) <span class="kr">in</span>
 <span class="kr">let</span> <span class="nv">i</span> := x.<span class="mi">1</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">Hi</span> := x.<span class="mi">2</span> <span class="kr">in</span> f i Hi) = f i Hi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk297">snapply ap011D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(nth&#39; (seq&#39; n) i
   (transport (lt i) (length_seq&#39; n)^ Hi)).<span class="mi">1</span> = i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk298" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk298"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt; i &lt; n) <span class="nl">?p</span>
  (nth&#39; (seq&#39; n) i
     (transport (lt i) (length_seq&#39; n)^ Hi)).<span class="mi">2</span> = Hi</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk299"><span class="mi">1</span>: napply nth&#39;_seq&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; n -&gt; A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; n</span></span></span><br><span><var>Hi'</var><span class="hyp-type"><b>: </b><span>i &lt; length (Build_list n f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt; i &lt; n)
  (nth&#39;_seq&#39; n i
     (transport (lt i) (length_seq&#39; n)^ Hi))
  (nth&#39; (seq&#39; n) i
     (transport (lt i) (length_seq&#39; n)^ Hi)).<span class="mi">2</span> = Hi</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Restriction of an infinite sequence to a list of specified length. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">list_restrict</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">s</span> : nat -&gt; A) (<span class="nv">n</span> : nat) : list A
  := Build_list n (<span class="kr">fun</span> <span class="nv">m</span> <span class="nv">_</span> =&gt; s m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">length_list_restrict</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">s</span> : nat -&gt; A) (<span class="nv">n</span> : nat)
  : length (list_restrict s n) = n
  := length_Build_list _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [nth&#39;] of the restriction of a sequence is the corresponding term of the sequence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk29a"><span class="kn">Definition</span> <span class="nf">nth&#39;_list_restrict</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">s</span> : nat -&gt; A) {<span class="nv">n</span> : nat}
  {<span class="nv">i</span> : nat} (<span class="nv">Hi</span> : i &lt; length (list_restrict s n))
  : nth&#39; (list_restrict s n) i Hi = s i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; length (list_restrict s n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_restrict s n) i Hi = s i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk29b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; length (list_restrict s n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth&#39; (list_restrict s n) i Hi = s i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk29c"><span class="nb">unshelve</span> lhs snapply nth&#39;_list_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; length (list_restrict s n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; length (seq&#39; n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk29d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; length (list_restrict s n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk29d"><hr></label><div class="goal-conclusion">(<span class="kr">let</span> <span class="nv">x</span> := nth&#39; (seq&#39; n) i <span class="nl">?Goal</span> <span class="kr">in</span>
 <span class="kr">let</span> <span class="nv">i</span> := x.<span class="mi">1</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">Hi</span> := x.<span class="mi">2</span> <span class="kr">in</span> s i) = s i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk29e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; length (list_restrict s n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; length (seq&#39; n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((length_list_restrict _ _ @ (length_seq&#39; n)^) # Hi).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk29f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i &lt; length (list_restrict s n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> <span class="nv">x</span> :=
   nth&#39; (seq&#39; n) i
     (transport (lt i)
        (length_list_restrict s n @ (length_seq&#39; n)^)
        Hi) <span class="kr">in</span>
 <span class="kr">let</span> <span class="nv">i</span> := x.<span class="mi">1</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">Hi</span> := x.<span class="mi">2</span> <span class="kr">in</span> s i) = s i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap s (nth&#39;_seq&#39; _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Repeat *)</span>

<span class="sd">(** The length of a repeated list is the number of repetitions. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a0"><span class="kn">Definition</span> <span class="nf">length_repeat</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (x : A)
  : length (<span class="kp">repeat</span> x n) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (<span class="kp">repeat</span> x n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (<span class="kp">repeat</span> x n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a2"><span class="nb">induction</span> n <span class="nb">using</span> nat_ind@{i}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (<span class="kp">repeat</span> x <span class="mi">0</span>) = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2a3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (<span class="kp">repeat</span> x n) = n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2a3"><hr></label><div class="goal-conclusion">length (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (<span class="kp">repeat</span> x <span class="mi">0</span>) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>length (<span class="kp">repeat</span> x n) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap S IHn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element of a repeated list is equal to the repeated element. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a6"><span class="kn">Definition</span> <span class="nf">inlist_repeat</span>@{i|} {A : <span class="kt">Type</span>@{i}} (n : nat) (x y : A)
  : InList y (<span class="kp">repeat</span> x n) -&gt; y = x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y (<span class="kp">repeat</span> x n) -&gt; y = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y (<span class="kp">repeat</span> x n) -&gt; y = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2a8"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y (<span class="kp">repeat</span> x <span class="mi">0</span>) -&gt; y = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2a9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n) -&gt; y = x</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2a9"><hr></label><div class="goal-conclusion">InList y (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) -&gt; y = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2aa"><span class="mi">1</span>:<span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n) -&gt; y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y (<span class="kp">repeat</span> x n.+<span class="mi">1</span>) -&gt; y = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ab"><span class="nb">intros</span> [p | i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n) -&gt; y = x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2ac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n) -&gt; y = x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2ac"><hr></label><div class="goal-conclusion">y = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n) -&gt; y = x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">symmetry</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n) -&gt; y = x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y (<span class="kp">repeat</span> x n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Restricting a sequence to [n.+1] terms has a computation rule. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2af"><span class="kn">Definition</span> <span class="nf">list_restrict_succ</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">s</span> : nat -&gt; A) (<span class="nv">n</span> : nat)
  : list_restrict s n.+<span class="mi">1</span> = list_restrict s n ++ [s n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_restrict s n.+<span class="mi">1</span> = list_restrict s n ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_restrict s n.+<span class="mi">1</span> = list_restrict s n ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b1"><span class="nb">unfold</span> list_restrict, Build_list.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n.+<span class="mi">1</span>} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n.+<span class="mi">1</span>) =
list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n) ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b2">lhs napply list_map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map s
  (list_map (<span class="kr">fun</span> <span class="nv">x</span> : {i : nat &amp; i &lt; n.+<span class="mi">1</span>} =&gt; x.<span class="mi">1</span>)
     (seq&#39; n.+<span class="mi">1</span>)) =
list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n) ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b3"><span class="nb">rewrite</span> seq_seq&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map s (seq n.+<span class="mi">1</span>) =
list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n) ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b4"><span class="nb">rewrite</span> seq_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map s (seq n ++ [n]) =
list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n) ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b5">lhs napply list_map_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map s (seq n) ++ list_map s [n] =
list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n) ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map s (seq n) ++ [s n] =
list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n) ++ [s n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b7"><span class="nb">apply</span> (ap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; z ++ [s n])).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map s (seq n) =
list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b8"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map (<span class="kr">fun</span> <span class="nv">pat</span> : {i : nat &amp; i &lt; n} =&gt; s pat.<span class="mi">1</span>)
  (seq&#39; n) = list_map s (seq n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2b9">lhs napply list_map_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>nat -&gt; A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_map s
  (list_map (<span class="kr">fun</span> <span class="nv">x</span> : {i : nat &amp; i &lt; n} =&gt; x.<span class="mi">1</span>)
     (seq&#39; n)) = list_map s (seq n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, seq_seq&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Forall *)</span>

<span class="sd">(** If a predicate holds for all elements of a list, then the [for_all] predicate holds for the list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ba"><span class="kn">Definition</span> <span class="nf">for_all_inlist</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) <span class="nv">l</span>
  : (<span class="kr">forall</span> <span class="nv">x</span>, InList x l -&gt; P x) -&gt; for_all P l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x) -&gt; for_all P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2bb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x) -&gt; for_all P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2bc">simple_list_induction l h t IHl; <span class="nb">intros</span> H; <span class="nb">cbn</span>; <span class="nb">trivial</span>; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2bd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2bd"><hr></label><div class="goal-conclusion">for_all P t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2be">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2bf"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList h (h :: t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c1"><span class="nb">apply</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c2"><span class="nb">intros</span> y i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c3"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, InList x t -&gt; P x) -&gt; for_all P t</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x (h :: t) -&gt; P x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y (h :: t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conversely, if [for_all P l] then each element of the list satisfies [P]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c4"><span class="kn">Definition</span> <span class="nf">inlist_for_all</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  (<span class="nv">l</span> : list A)
  : for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span>, InList x l -&gt; P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c6">simple_list_induction l x l IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x nil -&gt; P x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2c7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2c7"><hr></label><div class="goal-conclusion">for_all P (x :: l) -&gt;
<span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; P x0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x nil -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradiction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2c9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2c9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (x :: l) -&gt;
<span class="kr">forall</span> <span class="nv">x0</span> : A, InList x0 (x :: l) -&gt; P x0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ca" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ca"><span class="nb">intros</span> [Hx Hl] y [-&gt; | i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2cb"><hr></label><div class="goal-conclusion">P y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2cc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2cc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2cd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2cd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ce" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ce"><span class="nb">apply</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2cf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2cf"><hr></label><div class="goal-conclusion">InList y l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d0"><span class="mi">1</span>: <span class="bp">exact</span> Hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> i.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a predicate [P] implies a predicate [Q] composed with a function [f], then [for_all P l] implies [for_all Q (list_map f l)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d1"><span class="kn">Definition</span> <span class="nf">for_all_list_map</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">Q</span> : B -&gt; <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; B) (<span class="nv">Hf</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; Q (f x))
  : <span class="kr">forall</span> <span class="nv">l</span>, for_all P l -&gt; for_all Q (list_map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
for_all P l -&gt; for_all Q (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
for_all P l -&gt; for_all Q (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d3">simple_list_induction l x l IHl; <span class="nb">simpl</span>; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; for_all Q (list_map f l)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x * for_all P l -&gt;
Q (f x) * for_all Q (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d4"><span class="nb">intros</span> [Hx Hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x -&gt; Q (f x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; for_all Q (list_map f l)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Q (f x) * for_all Q (list_map f l))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A variant of [for_all_map P Q f] where [Q] is [P o f]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d5"><span class="kn">Definition</span> <span class="nf">for_all_list_map&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : B -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B)
  : <span class="kr">forall</span> <span class="nv">l</span>, for_all (P o f) l -&gt; for_all P (list_map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
for_all (P o f) l -&gt; for_all P (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list A,
for_all (P o f) l -&gt; for_all P (list_map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> for_all_list_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a predicate [P] and a predicate [Q] together imply a predicate [R], then [for_all P l] and [for_all Q l] together imply [for_all R l]. There are also some side conditions for the default elements. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d7"><span class="kn">Lemma</span> <span class="nf">for_all_list_map2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>}
  (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">Q</span> : B -&gt; <span class="kt">Type</span>) (<span class="nv">R</span> : C -&gt; <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">Hf</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x -&gt; Q y -&gt; R (f x y))
  <span class="nv">def_l</span> (<span class="nv">Hdefl</span> : <span class="kr">forall</span> <span class="nv">l1</span>, for_all P l1 -&gt; for_all R (def_l l1))
  <span class="nv">def_r</span> (<span class="nv">Hdefr</span> : <span class="kr">forall</span> <span class="nv">l2</span>, for_all Q l2 -&gt; for_all R (def_r l2))
  (<span class="nv">l1</span> : list A) (<span class="nv">l2</span> : list B)
  : for_all P l1 -&gt; for_all Q l2
    -&gt; for_all R (list_map2 f def_l def_r l1 l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2d9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2d9"><span class="nb">revert</span> l2;
    simple_list_induction l1 x l1 IHl1;
    <span class="nb">intro</span> l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r nil l2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2da" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2da"><hr></label><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r (x :: l1) l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2db" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2db">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r nil l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> l2 <span class="kr">as</span> [|y l2]; <span class="nb">cbn</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2dc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2dc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r (x :: l1) l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2dd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2dd"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x * for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R
  <span class="kr">match</span> l2 <span class="kr">with</span>
  | nil =&gt; def_l (x :: l1)
  | y :: l2 =&gt; f x y :: list_map2 f def_l def_r l1 l2
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2de" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2de"><span class="nb">destruct</span> l2 <span class="kr">as</span> [|y l2]; <span class="nb">intros</span> [Hx Hl1];
      [<span class="nb">intros</span> _ | <span class="nb">intros</span> [Hy Hl2] ]; <span class="nb">simpl</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all R (def_l (x :: l1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2df" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2df"><span class="nb">apply</span> Hdefl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>Hdefl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l1</span> : list A,
for_all P l1 -&gt; for_all R (def_l l1)</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>Hdefr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all Q l2 -&gt; for_all R (def_r l2)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (x :: l1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A simpler variant of [for_all_map2] where both lists have the same length and the side conditions on the default elements can be avoided. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e0" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e0"><span class="kn">Definition</span> <span class="nf">for_all_list_map2&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>}
  (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">Q</span> : B -&gt; <span class="kt">Type</span>) (<span class="nv">R</span> : C -&gt; <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">Hf</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x -&gt; Q y -&gt; R (f x y))
  {<span class="nv">def_l</span> <span class="nv">def_r</span>} {<span class="nv">l1</span> : list A} {<span class="nv">l2</span> : list B}
  (<span class="nv">p</span> : length l1 = length l2)
  : for_all P l1 -&gt; for_all Q l2
    -&gt; for_all R (list_map2 f def_l def_r l1 l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l1 = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length l1 = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e2"><span class="nb">revert</span> l2 p;
    simple_list_induction l1 x l1 IHl1;
    <span class="nb">intros</span> l2 p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r nil l2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2e3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length l2</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2e3"><hr></label><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r (x :: l1) l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r nil l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e5"><span class="nb">destruct</span> l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt;
for_all Q nil -&gt;
for_all R (list_map2 f def_l def_r nil nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2e6"><hr></label><div class="goal-conclusion">for_all P nil -&gt;
for_all Q (b :: l2) -&gt;
for_all R (list_map2 f def_l def_r nil (b :: l2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt;
for_all Q nil -&gt;
for_all R (list_map2 f def_l def_r nil nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e8" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length nil = length (b :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P nil -&gt;
for_all Q (b :: l2) -&gt;
for_all R (list_map2 f def_l def_r nil (b :: l2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2e9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2e9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r (x :: l1) l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ea" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ea"><span class="nb">destruct</span> l2 <span class="kr">as</span> [|y l2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q nil -&gt;
for_all R (list_map2 f def_l def_r (x :: l1) nil)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2eb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2eb"><hr></label><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q (y :: l2) -&gt;
for_all R
  (list_map2 f def_l def_r (x :: l1) (y :: l2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ec" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ec">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q nil -&gt;
for_all R (list_map2 f def_l def_r (x :: l1) nil)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ed" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ed">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (x :: l1) -&gt;
for_all Q (y :: l2) -&gt;
for_all R
  (list_map2 f def_l def_r (x :: l1) (y :: l2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ee" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ee"><span class="nb">intros</span> [Hx Hl1] [Hy Hl2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>Q y</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>for_all Q l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all R
  (list_map2 f def_l def_r (x :: l1) (y :: l2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ef" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ef"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>Q y</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>for_all Q l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (f x y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2f0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>Q y</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>for_all Q l2</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2f0"><hr></label><div class="goal-conclusion">for_all R (list_map2 f def_l def_r l1 l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f1" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f1">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>Q y</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>for_all Q l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (f x y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f2" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f2">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>Q y</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>for_all Q l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all R (list_map2 f def_l def_r l1 l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f3" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f3"><span class="nb">apply</span> IHl1; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>Q y</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>for_all Q l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 = length l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f4" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f4"><span class="nb">apply</span> path_nat_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; R (f x y)</span></span></span><br><span><var>def_l</var><span class="hyp-type"><b>: </b><span>list A -&gt; list C</span></span></span><br><span><var>def_r</var><span class="hyp-type"><b>: </b><span>list B -&gt; list C</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list B,
length l1 = length l2 -&gt;
for_all P l1 -&gt;
for_all Q l2 -&gt;
for_all R (list_map2 f def_l def_r l1 l2)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>length (x :: l1) = length (y :: l2)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>for_all P l1</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>Q y</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>for_all Q l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(length l1).+<span class="mi">1</span> = (length l2).+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The left fold of [f] on a list [l] for which [for_all Q l] satisfies [P] if [P] and [Q] imply [P] composed with [f]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f5" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f5"><span class="kn">Lemma</span> <span class="nf">fold_left_preserves</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">Q</span> : B -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B -&gt; A)
  (<span class="nv">Hf</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x -&gt; Q y -&gt; P (f x y))
  (<span class="nv">acc</span> : A) (<span class="nv">Ha</span> : P acc) (<span class="nv">l</span> : list B) (<span class="nv">Hl</span> : for_all Q l)
  : P (fold_left f l acc).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (fold_left f l acc)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f6" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (fold_left f l acc)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f7" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f7"><span class="nb">revert</span> acc Ha Hl;
    simple_list_induction l x l IHl;
    <span class="nb">intros</span> acc Ha Hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (fold_left f nil acc)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk2f8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">acc</span> : A, P acc -&gt; for_all Q l -&gt; P (fold_left f l acc)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q (x :: l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk2f8"><hr></label><div class="goal-conclusion">P (fold_left f (x :: l) acc)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2f9" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2f9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (fold_left f nil acc)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Ha.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2fa" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2fa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">acc</span> : A, P acc -&gt; for_all Q l -&gt; P (fold_left f l acc)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (fold_left f (x :: l) acc)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2fb" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2fb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">acc</span> : A, P acc -&gt; for_all Q l -&gt; P (fold_left f l acc)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (fold_left f l (f acc x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2fc" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2fc"><span class="nb">destruct</span> Hl <span class="kr">as</span> [Qx Hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B), P x -&gt; Q y -&gt; P (f x y)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">acc</span> : A, P acc -&gt; for_all Q l -&gt; P (fold_left f l acc)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>P acc</span></span></span><br><span><var>Qx</var><span class="hyp-type"><b>: </b><span>Q x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (fold_left f l (f acc x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [for_all] preserves the truncation predicate. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2fd" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2fd"><span class="kn">Definition</span> <span class="nf">istrunc_for_all</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
  {<span class="nv">n</span> : trunc_index} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list A)
  : for_all (<span class="kr">fun</span> <span class="nv">x</span> =&gt; IsTrunc n (P x)) l -&gt; IsTrunc n (for_all P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt;
IsTrunc n (for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2fe" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2fe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt;
IsTrunc n (for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk2ff" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk2ff"><span class="nb">induction</span> l <span class="kr">as</span> [|x l IHl]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit -&gt; IsTrunc n Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk300" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt; IsTrunc n (for_all P l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk300"><hr></label><div class="goal-conclusion">IsTrunc n (P x) *
for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt;
IsTrunc n (P x * for_all P l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk301" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk301">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit -&gt; IsTrunc n Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> n; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk302" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk302">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt; IsTrunc n (for_all P l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (P x) *
for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt;
IsTrunc n (P x * for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk303" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk303"><span class="nb">intros</span> [Hx Hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt; IsTrunc n (for_all P l)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>IsTrunc n (P x)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (P x * for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk304" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk304"><span class="nb">apply</span> IHl <span class="kr">in</span> Hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; IsTrunc n (P x)) l -&gt; IsTrunc n (for_all P l)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>IsTrunc n (P x)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>IsTrunc n (for_all P l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (P x * for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk305" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk305"><span class="kn">Instance</span> <span class="nf">istrunc_for_all&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">n</span> : trunc_index}
  (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list A)
  `{<span class="kr">forall</span> <span class="nv">x</span>, IsTrunc n (P x)}
  : IsTrunc n (for_all P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsTrunc n (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk306" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk306"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsTrunc n (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> istrunc_for_all, for_all_inlist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a predicate holds for an element, then it holds [for_all] the elements of the repeated list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk307" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk307"><span class="kn">Definition</span> <span class="nf">for_all_repeat</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">n</span> : nat}
  (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">x</span> : A)
  : P x -&gt; for_all P (<span class="kp">repeat</span> x n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt; for_all P (<span class="kp">repeat</span> x n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk308" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk308"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x -&gt; for_all P (<span class="kp">repeat</span> x n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk309" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk309"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (<span class="kp">repeat</span> x n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk30a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk30a"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (<span class="kp">repeat</span> x <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk30b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>for_all P (<span class="kp">repeat</span> x n)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk30b"><hr></label><div class="goal-conclusion">for_all P (<span class="kp">repeat</span> x n.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk30c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk30c"><span class="mi">1</span>: <span class="bp">exact</span> tt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>for_all P (<span class="kp">repeat</span> x n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">for_all P (<span class="kp">repeat</span> x n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H, IHn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can form a list of pairs of a sigma type given a list and a for_all predicate over it. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk30d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk30d"><span class="kn">Definition</span> <span class="nf">list_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">p</span> : for_all P l)
  : list {x : A &amp; P x}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk30e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk30e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk30f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk30f"><span class="nb">induction</span> l <span class="kr">as</span> [|x l IHl] <span class="kr">in</span> p |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {x : A &amp; P x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk310" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P (x :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; list {x : A &amp; P x}</span></span></span><br></div><label class="goal-separator" for="theory-v-chk310"><hr></label><div class="goal-conclusion">list {x : A &amp; P x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk311" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk311"><span class="mi">1</span>: <span class="bp">exact</span> nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P (x :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; list {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk312" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk312"><span class="nb">destruct</span> p <span class="kr">as</span> [Hx Hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>for_all P l -&gt; list {x : A &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list {x : A &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((x; Hx) :: IHl Hl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The length of a list of sigma types is the same as the original list. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk313" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk313"><span class="kn">Definition</span> <span class="nf">length_list_sigma</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">l</span> : list A} {<span class="nv">p</span> : for_all P l}
  : length (list_sigma P l p) = length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_sigma P l p) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk314" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk314"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_sigma P l p) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk315" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk315"><span class="nb">revert</span> p; simple_list_induction l x l IHl; <span class="nb">intro</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P nil</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_sigma P nil p) = length nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk316" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : for_all P l, length (list_sigma P l p) = length l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P (x :: l)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk316"><hr></label><div class="goal-conclusion">length (list_sigma P (x :: l) p) = length (x :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk317" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk317"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : for_all P l, length (list_sigma P l p) = length l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>for_all P (x :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_sigma P (x :: l) p) = length (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk318" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk318"><span class="nb">destruct</span> p <span class="kr">as</span> [Hx Hl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : for_all P l, length (list_sigma P l p) = length l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_sigma P (x :: l) (Hx, Hl)) =
length (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk319" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk319"><span class="nb">cbn</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">p</span> : for_all P l, length (list_sigma P l p) = length l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>for_all P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (list_rect A
     (<span class="kr">fun</span> <span class="nv">l</span> : list A =&gt;
      for_all P l -&gt; list {x : A &amp; P x})
     (unit_name nil)
     (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">l</span> : list A)
        (<span class="nv">IHl</span> : for_all P l -&gt; list {x0 : A &amp; P x0})
        (<span class="nv">p</span> : P x * for_all P l) =&gt;
      (x; fst p) :: IHl (snd p)) l Hl) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a predicate [P] is decidable then so is [for_all P]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk31a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk31a"><span class="kn">Instance</span> <span class="nf">decidable_for_all</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  `{<span class="kr">forall</span> <span class="nv">x</span>, Decidable (P x)} (l : list A)
  : Decidable (for_all P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk31b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk31b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (for_all P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_list_induction l x l IHl; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a predicate [P] is decidable then so is [list_exists P]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk31c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk31c"><span class="kn">Instance</span> <span class="nf">decidable_list_exists</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
  `{<span class="kr">forall</span> <span class="nv">x</span>, Decidable (P x)} (l : list A)
  : Decidable (list_exists P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (list_exists P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk31d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk31d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Decidable (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (list_exists P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">simple_list_induction l x l IHl; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk31e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk31e"><span class="kn">Definition</span> <span class="nf">inlist_list_exists</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list A)
  : list_exists P l -&gt; <span class="kr">exists</span> (<span class="nv">x</span> : A), InList x l /\ P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk31f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk31f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk320" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk320">simple_list_induction l x l IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_exists P nil -&gt;
{x : A &amp; (InList x nil * P x)%type}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk321" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk321"><hr></label><div class="goal-conclusion">list_exists P (x :: l) -&gt;
{x0 : A &amp; (InList x0 (x :: l) * P x0)%type}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk322" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk322"><span class="mi">1</span>: <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_exists P (x :: l) -&gt;
{x0 : A &amp; (InList x0 (x :: l) * P x0)%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk323" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk323"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x + list_exists P l -&gt;
{x0 : A &amp; (((x = x0) + InList x0 l) * P x0)%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk324" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk324"><span class="nb">intros</span> [Px | ex].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : A &amp; (((x = x0) + InList x0 l) * P x0)%type}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk325" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ex</var><span class="hyp-type"><b>: </b><span>list_exists P l</span></span></span><br></div><label class="goal-separator" for="theory-v-chk325"><hr></label><div class="goal-conclusion">{x0 : A &amp; (((x = x0) + InList x0 l) * P x0)%type}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk326" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk326">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : A &amp; (((x = x0) + InList x0 l) * P x0)%type}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk327" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk327"><span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((x = x) + InList x l) * P x)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">left</span>|].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk328" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk328">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ex</var><span class="hyp-type"><b>: </b><span>list_exists P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : A &amp; (((x = x0) + InList x0 l) * P x0)%type}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk329" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk329"><span class="nb">destruct</span> (IHl ex) <span class="kr">as</span> [x&#39; [H Px&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ex</var><span class="hyp-type"><b>: </b><span>list_exists P l</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x&#39; l</span></span></span><br><span><var>Px'</var><span class="hyp-type"><b>: </b><span>P x&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : A &amp; (((x = x0) + InList x0 l) * P x0)%type}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk32a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk32a"><span class="kr">exists</span> <span class="nv">x&#39;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_exists P l -&gt; {x : A &amp; (InList x l * P x)%type}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ex</var><span class="hyp-type"><b>: </b><span>list_exists P l</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList x&#39; l</span></span></span><br><span><var>Px'</var><span class="hyp-type"><b>: </b><span>P x&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((x = x&#39;) + InList x&#39; l) * P x&#39;)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">right</span>|].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk32b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk32b"><span class="kn">Definition</span> <span class="nf">list_exists_inlist</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">l</span> : list A)
  : <span class="kr">forall</span> (<span class="nv">x</span> : A), InList x l -&gt; P x -&gt; list_exists P l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk32c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk32c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk32d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk32d">simple_list_induction l x l IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, InList x nil -&gt; P x -&gt; list_exists P nil</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk32e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="theory-v-chk32e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : A,
InList x0 (x :: l) -&gt; P x0 -&gt; list_exists P (x :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk32f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk32f"><span class="mi">1</span>: <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : A,
InList x0 (x :: l) -&gt; P x0 -&gt; list_exists P (x :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk330" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk330"><span class="nb">simpl</span>; <span class="nb">intros</span> y H p; <span class="nb">revert</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x = y) + InList y l -&gt; P x + list_exists P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk331" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk331"><span class="nb">apply</span> functor_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y -&gt; P x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk332" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><label class="goal-separator" for="theory-v-chk332"><hr></label><div class="goal-conclusion">InList y l -&gt; list_exists P l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk333" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk333">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y -&gt; P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">r</span> =&gt; r^ # p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk334" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk334">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList y l -&gt; list_exists P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk335" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk335"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, InList x l -&gt; P x -&gt; list_exists P l</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>InList y l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_exists P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> (IHl y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk336" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk336"><span class="kn">Definition</span> <span class="nf">list_exists_seq</span> {<span class="nv">n</span> : nat} (<span class="nv">P</span> : nat -&gt; <span class="kt">Type</span>)
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">k</span>, P k -&gt; k &lt; n)
  : (<span class="kr">exists</span> <span class="nv">k</span>, P k) &lt;-&gt; list_exists P (seq n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; P k} &lt;-&gt; list_exists P (seq n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk337" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk337"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; P k} &lt;-&gt; list_exists P (seq n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk338" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk338"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; P k} -&gt; list_exists P (seq n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk339" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br></div><label class="goal-separator" for="theory-v-chk339"><hr></label><div class="goal-conclusion">list_exists P (seq n) -&gt; {k : nat &amp; P k}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk33a" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk33a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; P k} -&gt; list_exists P (seq n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk33b" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk33b"><span class="nb">intros</span> [k p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_exists P (seq n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk33c" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk33c">snapply (list_exists_inlist P _ k _ p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">InList k (seq n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk33d" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk33d"><span class="nb">apply</span> inlist_seq, H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk33e" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk33e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_exists P (seq n) -&gt; {k : nat &amp; P k}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk33f" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk33f"><span class="nb">intros</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>list_exists P (seq n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; P k}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk340" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk340"><span class="nb">apply</span> inlist_list_exists <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>{x : nat &amp; (InList x (seq n) * P x)%type}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; P k}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk341" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk341"><span class="nb">destruct</span> H1 <span class="kr">as</span> [k [Hk p]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>InList k (seq n)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k : nat &amp; P k}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk342" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk342"><span class="kr">exists</span> <span class="nv">k</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>InList k (seq n)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An upper bound on witnesses of a decidable predicate makes the sigma type decidable. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk343" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk343"><span class="kn">Definition</span> <span class="nf">decidable_exists_nat</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Type</span>)
  (<span class="nv">H1</span> : <span class="kr">forall</span> <span class="nv">k</span>, P k -&gt; k &lt; n)
  (<span class="nv">H2</span> : <span class="kr">forall</span> <span class="nv">k</span>, Decidable (P k))
  : Decidable (<span class="kr">exists</span> <span class="nv">k</span>, P k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, Decidable (P k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable {k : nat &amp; P k}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk344" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk344"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, Decidable (P k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable {k : nat &amp; P k}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk345" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk345">napply decidable_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, Decidable (P k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt; {k : nat &amp; P k}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk346" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, Decidable (P k)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk346"><hr></label><div class="goal-conclusion">Decidable <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk347" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk347"><span class="mi">1</span>: <span class="nb">apply</span> iff_inverse; napply list_exists_seq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, Decidable (P k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="theory-v-chk348" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, Decidable (P k)</span></span></span><br></div><label class="goal-separator" for="theory-v-chk348"><hr></label><div class="goal-conclusion">Decidable (list_exists P (seq <span class="nl">?Goal0</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="theory-v-chk349" style="display: none" type="checkbox"><label class="alectryon-input" for="theory-v-chk349"><span class="mi">1</span>: <span class="bp">exact</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, P k -&gt; k &lt; n</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, Decidable (P k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (list_exists P (seq n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A common special case.  See also [decidable_search] in Misc/BoundedSearch.v for a similar result with different dependencies. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">decidable_exists_bounded_nat</span> (<span class="nv">n</span> : nat) (<span class="nv">P</span> : nat -&gt; <span class="kt">Type</span>)
  (<span class="nv">H2</span> : <span class="kr">forall</span> <span class="nv">k</span>, Decidable (P k))
  : Decidable { k : nat &amp; prod (k &lt; n) (P k) }
  := decidable_exists_nat n _ (<span class="kr">fun</span> <span class="nv">k</span> =&gt; fst) _.</span></span></pre>
</div>
</div></body>
</html>
