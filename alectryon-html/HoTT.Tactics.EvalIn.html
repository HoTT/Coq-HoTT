<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>EvalIn.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Evaluating tactics on terms *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.PathGroupoids.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It sometimes happens, in the course of writing a tactic, that we have some term in an Ltac variable (more precisely, we have what Ltac calls a &quot;constr&quot;) and we would like to act on it with some tactic such as [cbv] or [rewrite].  Ordinarily, such tactics only act on the current *goal*, and generally they have a version such as [rewrite ... in ...] which acts on something in the current *context*, but neither of these is the same as acting on a term held in an Ltac variable.</span>

<span class="sd">For some tactics, such as [cbv] and [pattern], we can write [eval TAC in H], where [H] is the term in question; this form *returns* the modified term so we can place it in another Ltac variable.  However, other tactics such as [rewrite] do not support this syntax.  (There is a feature request for it at https://coq.inria.fr/bugs/show_bug.cgi?id=3677.)</span>

<span class="sd">The following tactic [eval_in TAC H] fills this gap, allowing us to act by [rewrite] on terms in Ltac variables.  The argument [TAC] must be a tactic that takes one argument, which is an Ltac function that gets passed the name of a hypothesis to act on, such as [ltac:(fun H&#39; =&gt; rewrite H in H&#39;)].  (Unfortunately, however, [eval_in] cannot be used to exactly generalize [eval pattern in H]; see below.)</span>

<span class="sd">There is also a variant called [eval_in_using], which also accepts a second user-specified tactic and uses it to solve side-conditions generated by the first one.  We actually define [eval_in] in terms of [eval_in_using] by passing [idtac] as the second tactic. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">eval_in_using</span> tac_in using_tac H :=
  <span class="sd">(** The syntax [$(...)$] allows execution of an arbitrary tactic to supply a needed term.  By prefixing it with [constr:] which tells Ltac to expect a term, we obtain a pattern [constr:($(...)$)] which allows us to execute an arbitrary tactic in the situation of a fresh goal.   This way we avoid modifying the existing context, and we can also get our hands on a proof term corresponding to the stateful modification.  We pose [H] in the fresh context so we can play with it nicely, regardless of if it&#39;s a hypothesis or a term.  Then we run [tac_in] on the hypothesis to modify it, use [exact] to &quot;return&quot; the modified hypothesis, and give a nice error message if [using_tac] fails to solve some side-condition. *)</span>
  <span class="kr">let</span> <span class="nv">ret</span> := <span class="kp">constr</span>:(<span class="kp">ltac</span>:(
                       <span class="kr">let</span> <span class="nv">H&#39;</span> := <span class="kp">fresh</span> <span class="kr">in</span>
                       <span class="nb">pose</span> H <span class="kr">as</span> H&#39;;
                       tac_in H&#39;;
                       [ <span class="bp">exact</span> H&#39;
                       | <span class="kp">solve</span> [ using_tac
                               | <span class="kr">let</span> <span class="nv">G</span> := <span class="kr">match goal with</span> |- <span class="nl">?G</span> =&gt; <span class="kp">constr</span>:(G) <span class="kr">end</span> <span class="kr">in</span>
                                 <span class="kp">repeat</span> <span class="kr">match goal with</span> H : _ |- _ =&gt; <span class="nb">revert</span> H <span class="kr">end</span>;
                                   <span class="kr">let</span> <span class="nv">G&#39;</span> := <span class="kr">match goal with</span> |- <span class="nl">?G</span> =&gt; <span class="kp">constr</span>:(G) <span class="kr">end</span> <span class="kr">in</span>
                                   <span class="kp">fail</span> <span class="mi">1</span>
                                        <span class="s2">&quot;Cannot use&quot;</span> using_tac <span class="s2">&quot;to solve side-condition goal&quot;</span> G <span class="s2">&quot;.&quot;</span>
                                        <span class="s2">&quot;Extended goal with context:&quot;</span> G&#39; ].. ])) <span class="kr">in</span>
  <span class="sd">(** Finally, we play some games to format the return value nicely.  We want to zeta-reduce the let-in generated by [pose], but not any other [let-in]s; we do this by matching for it and doing the substitution manually.  Additionally, [pose]/[exact] also results in an extra [idmap]; we remove this with [cbv beta], which unfortunately also beta-reduces everything else.  (This is why [eval_in pattern H] doesn&#39;t strictly generalize [eval pattern in H], since the latter doesn&#39;t beta-reduce.)  Perhaps we want to zeta-reduce everything, and not beta-reduce anything instead? *)</span>
  <span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> ret <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">ret&#39;</span> := (<span class="kr">lazymatch</span> ret <span class="kr">with</span>
              | <span class="kr">let</span> <span class="nv">x</span> := <span class="nl">?x&#39;</span> <span class="kr">in</span> @<span class="nl">?P</span> x =&gt; <span class="kp">constr</span>:(P x&#39;)
               <span class="kr">end</span>) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">ret&#39;&#39;</span> := (<span class="kp">eval</span> <span class="nb">cbv</span> beta <span class="kr">in</span> ret&#39;) <span class="kr">in</span>
  <span class="kp">constr</span>:(ret&#39;&#39; : T).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">eval_in</span> tac_in H := eval_in_using tac_in <span class="kp">idtac</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk1"><span class="kn">Example</span> <span class="nf">eval_in_example</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Set</span>, A = B -&gt; A -&gt; B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : Type0, A = B -&gt; A -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : Type0, A = B -&gt; A -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk3"><span class="nb">intros</span> A B H a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Type0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk4"><span class="kr">let</span> <span class="nv">x</span> := (eval_in <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H&#39;</span> =&gt; <span class="nb">rewrite</span> H <span class="kr">in</span> H&#39;) a) <span class="kr">in</span>
  <span class="nb">pose</span> x <span class="kr">as</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Type0</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">let</span> <span class="nv">H0</span> := internal_paths_rew idmap a H <span class="kr">in</span> H0) : B</span></span><span class="hyp-type"><b>: </b><span>B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** we get a [b : B] *)</span>
  <span class="sd">(** We [Abort], so that we don&#39;t get an extra constant floating around. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Rewriting with reflexivity *)</span>

<span class="sd">(** As an example application, we define a tactic that takes a lemma whose definition is [idpath] and behaves like [rewrite], except that it doesn&#39;t insert any transport lemmas like [Overture.internal_paths_rew_r].  In other words, it does a [change], but leverages the pattern-matching and substitution engine of [rewrite] to decide what to [change] into. *)</span>

<span class="sd">(** We use a dummy inductive type since [rewrite] acts on the *type* of a hypothesis rather than its body (if any). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">dummy</span> (<span class="nv">A</span>:<span class="kt">Type</span>) := adummy : dummy A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">rewrite_refl</span> H :=
  <span class="kr">match goal with</span>
    | [ |- <span class="nl">?X</span> ] =&gt;
      <span class="kr">let</span> <span class="nv">dX&#39;</span> := eval_in <span class="kp">ltac</span>:(<span class="kr">fun</span> <span class="nv">H&#39;</span> =&gt; <span class="nb">rewrite</span> H <span class="kr">in</span> H&#39;) (adummy X) <span class="kr">in</span>
      <span class="kr">match</span> <span class="kp">type of</span> dX&#39; <span class="kr">with</span>
        | dummy <span class="nl">?X&#39;</span> =&gt; <span class="nb">change</span> X&#39;
      <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here&#39;s what it would look like with ordinary [rewrite]: *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk5"><span class="kn">Example</span> <span class="nf">rewrite_refl_example</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : A) (<span class="nv">f</span> : A -&gt; B) :
  ap f idpath = idpath :&gt; (f x = f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk7"><span class="nb">rewrite</span> ap_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Show Proof. *)</span>
  <span class="sd">(** ==&gt; (fun (A B : Type) (x : A) (f : A -&gt; B) =&gt;</span>
<span class="sd"> Overture.internal_paths_rew_r (f x = f x) (ap f 1) 1</span>
<span class="sd">   (fun p : f x = f x =&gt; p = 1) 1 (ap_1 x f)) *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And here&#39;s what we get with [rewrite_refl]: *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk8"><span class="kn">Example</span> <span class="nf">rewrite_refl_example</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : A) (<span class="nv">f</span> : A -&gt; B) :
  ap f idpath = idpath :&gt; (f x = f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="evalin-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="evalin-v-chka">rewrite_refl @ap_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Show Proof. *)</span>
  <span class="sd">(** ==&gt; (fun (A B : Type) (x : A) (f : A -&gt; B) =&gt; 1) *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre>
</div>
</div></body>
</html>
