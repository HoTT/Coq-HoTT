<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Finite.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk19"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HSet.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core Spaces.Nat.Factorial.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HFiber.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Factorization.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Quotient.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Projective.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Fin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Definition of general finite sets *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">Finite</span> (<span class="nv">X</span> : <span class="kt">Type</span>) :=
  { fcard : nat ;
    merely_equiv_fin : merely (X &lt;~&gt; Fin fcard) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> fcard X {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> merely_equiv_fin X {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a"><span class="kn">Definition</span> <span class="nf">issig_finite</span> <span class="nv">X</span>
: { n : nat &amp; merely (X &lt;~&gt; Fin n) } &lt;~&gt; Finite X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; merely (X &lt;~&gt; Fin n)} &lt;~&gt; Finite X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; merely (X &lt;~&gt; Fin n)} &lt;~&gt; Finite X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">issig.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Note that the sigma over cardinalities is not truncated.  Nevertheless, because canonical finite sets of different cardinalities are not isomorphic, being finite is still an hprop.  (Thus, we could have truncated the sigma and gotten an equivalent definition, but it would be less convenient to reason about.) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c"><span class="kn">Instance</span> <span class="nf">ishprop_finite</span> <span class="nv">X</span>
: IsHProp (Finite X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (Finite X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (Finite X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e"><span class="nb">refine</span> (istrunc_equiv_istrunc _ (issig_finite X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp {n : nat &amp; merely (X &lt;~&gt; Fin n)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f"><span class="nb">apply</span> ishprop_sigma_disjoint; <span class="nb">intros</span> n m Hn Hm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n)</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk20">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin m</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (nat_eq_fin_equiv n m (Hm oE Hn^-<span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Preservation of finiteness by equivalences *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk21"><span class="kn">Definition</span> <span class="nf">finite_equiv</span> <span class="nv">X</span> {<span class="nv">Y</span>} (<span class="nv">e</span> : X -&gt; Y) `{IsEquiv X Y e}
: Finite X -&gt; Finite Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite X -&gt; Finite Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite X -&gt; Finite Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk23"><span class="nb">intros</span> ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk24"><span class="nb">refine</span> (Build_Finite Y (fcard X) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (Y &lt;~&gt; Fin (fcard X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk25"><span class="nb">assert</span> (f := merely_equiv_fin X); strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (Y &lt;~&gt; Fin (fcard X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk26"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y &lt;~&gt; Fin (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_compose f e^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finite_equiv&#39;</span> <span class="nv">X</span> {<span class="nv">Y</span>} (<span class="nv">e</span> : X &lt;~&gt; Y)
: Finite X -&gt; Finite Y
  := finite_equiv X e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk27"><span class="kn">Corollary</span> <span class="nf">finite_equiv_equiv</span> <span class="nv">X</span> <span class="nv">Y</span>
: (X &lt;~&gt; Y) -&gt; (Finite X &lt;~&gt; Finite Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X &lt;~&gt; Y -&gt; Finite X &lt;~&gt; Finite Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X &lt;~&gt; Y -&gt; Finite X &lt;~&gt; Finite Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?; <span class="nb">apply</span> equiv_iff_hprop; <span class="nb">apply</span> finite_equiv&#39;;
    [ <span class="bp">assumption</span> | <span class="nb">symmetry</span>; <span class="bp">assumption</span> ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk29"><span class="kn">Definition</span> <span class="nf">fcard_equiv</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : X -&gt; Y) `{IsEquiv X Y e}
           `{Finite X} `{Finite Y}
: fcard X = fcard Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X = fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X = fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk2b"><span class="nb">transitivity</span> (@fcard Y (finite_equiv X e _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X = fcard Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><label class="goal-separator" for="finite-v-chk2c"><hr></label><div class="goal-conclusion">fcard Y = fcard Y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk2d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X = fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv e</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard Y = fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (@fcard Y) (path_ishprop _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fcard_equiv&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">e</span> : X &lt;~&gt; Y)
           `{Finite X} `{Finite Y}
: fcard X = fcard Y
  := fcard_equiv e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Simple examples of finite sets *)</span>

<span class="sd">(** Canonical finite sets are finite *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">finite_fin</span> <span class="nv">n</span> : Finite (Fin n)
  := Build_Finite _ n (tr (equiv_idmap _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This includes the empty set. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">finite_empty</span> : Finite Empty
  := finite_fin <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The unit type is finite, since it&#39;s equivalent to [Fin 1]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk2f"><span class="kn">Instance</span> <span class="nf">finite_unit</span> : Finite Unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk31"><span class="nb">refine</span> (finite_equiv&#39; (Fin <span class="mi">1</span>) _ _); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty + Unit &lt;~&gt; Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sum_empty_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Thus, any contractible type is finite. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">finite_contr</span> <span class="nv">X</span> `{Contr X} : Finite X
  := finite_equiv Unit equiv_contr_unit^-<span class="mi">1</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any decidable hprop is finite, since it must be equivalent to [Empty] or [Unit]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk32"><span class="kn">Definition</span> <span class="nf">finite_decidable_hprop</span> <span class="nv">X</span> `{IsHProp X} `{Decidable X}
: Finite X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk34"><span class="nb">destruct</span> (dec X) <span class="kr">as</span> [x|nx].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable X</span></span></span><br><span><var>nx</var><span class="hyp-type"><b>: </b><span>~ X</span></span></span><br></div><label class="goal-separator" for="finite-v-chk35"><hr></label><div class="goal-conclusion">Finite X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk37"><span class="nb">apply</span> finite_contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> contr_inhabited_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk38">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Decidable X</span></span></span><br><span><var>nx</var><span class="hyp-type"><b>: </b><span>~ X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (finite_equiv Empty nx^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Immediate</span> finite_decidable_hprop : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that the propositional truncation of any finite set is finite. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk39"><span class="kn">Instance</span> <span class="nf">finite_merely</span> <span class="nv">X</span> {<span class="nv">fX</span> : Finite X}
: Finite (merely X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (merely X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (merely X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** As in decidable_finite_hprop, we case on cardinality first to avoid needing funext. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk3b"><span class="nb">destruct</span> fX <span class="kr">as</span> [[|n] e]; <span class="nb">refine</span> (finite_decidable_hprop _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (merely X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk3c"><hr></label><div class="goal-conclusion">Decidable (merely X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (merely X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk3e"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ merely X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; strip_truncations; <span class="bp">exact</span> (e x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (merely X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk40"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">strip_truncations; <span class="bp">exact</span> (tr (e^-<span class="mi">1</span> (inr tt))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finite sets are closed under path-spaces. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk41"><span class="kn">Instance</span> <span class="nf">finite_paths</span> {<span class="nv">X</span>} `{Finite X} (x y : X)
: Finite (x = y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** If we assume [Funext], then typeclass inference produces this automatically, since [X] has decidable equality and (hence) is a set, so [x=y] is a decidable hprop.  But we can also deduce it without funext, since [Finite] is an hprop even without funext. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk43"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk44">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk45"><span class="nb">refine</span> (finite_equiv _ (ap e)^-<span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (e x = e y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> finite_decidable_hprop; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finite sets are also closed under successors. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk46"><span class="kn">Instance</span> <span class="nf">finite_succ</span> <span class="nv">X</span> `{Finite X} : Finite (X + Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk48"><span class="nb">refine</span> (Build_Finite _ (fcard X).+<span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (X + Unit &lt;~&gt; Fin (fcard X).+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk49"><span class="nb">pose proof</span> (merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (X + Unit &lt;~&gt; Fin (fcard X).+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk4a">strip_truncations; <span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X + Unit &lt;~&gt; Fin (fcard X).+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (_ +E <span class="mi">1</span>); <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fcard_succ</span> <span class="nv">X</span> `{Finite X}
: fcard (X + Unit) = (fcard X).+<span class="mi">1</span>
  := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decidability *)</span>		

<span class="sd">(** Like canonical finite sets, finite sets have decidable equality. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk4b"><span class="kn">Instance</span> <span class="nf">decidablepaths_finite</span> `{Funext} X `{Finite X}
: DecidablePaths X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidablePaths X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidablePaths X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk4d"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidablePaths X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk4e">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DecidablePaths X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (decidablepaths_equiv _ e^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** However, contrary to what you might expect, we cannot assert that &quot;every finite set is decidable&quot;!  That would be claiming a *uniform* way to select an element from every nonempty finite set, which contradicts univalence. *)</span>

<span class="sd">(** One thing we can prove is that any finite hprop is decidable. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk4f"><span class="kn">Instance</span> <span class="nf">decidable_finite_hprop</span> <span class="nv">X</span> `{IsHProp X} {fX : Finite X}
: Decidable X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** To avoid having to use [Funext], we case on the cardinality of [X] before stripping the truncation from its equivalence to [Fin n]; if we did things in the other order then we&#39;d have to know that [Decidable X] is an hprop, which requires funext. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk51"><span class="nb">destruct</span> fX <span class="kr">as</span> [[|n] e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk52"><hr></label><div class="goal-conclusion">Decidable X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk54"><span class="nb">right</span>; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">strip_truncations; <span class="bp">exact</span> (e x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk55">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk56"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">strip_truncations; <span class="bp">exact</span> (e^-<span class="mi">1</span> (inr tt)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that if [X] is finite, then its propositional truncation is decidable. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">decidable_merely_finite</span> <span class="nv">X</span> {<span class="nv">fX</span> : Finite X}
  : Decidable (merely X)
  := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** From this, it follows that any finite set is *merely* decidable. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk57"><span class="kn">Definition</span> <span class="nf">merely_decidable_finite</span> <span class="nv">X</span> `{Finite X}
: merely (Decidable X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (Decidable X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (Decidable X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_decidable; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Induction over finite sets *)</span>

<span class="sd">(** Most concrete applications of this don&#39;t actually require univalence, but the general version does.  For this reason the general statement is less useful (and less used in the sequel) than it might be. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk59"><span class="kn">Definition</span> <span class="nf">finite_ind_hprop</span> `{Univalence}
           (P : <span class="kr">forall</span> <span class="nv">X</span>, Finite X -&gt; <span class="kt">Type</span>)
           `{<span class="kr">forall</span> <span class="nv">X</span> (<span class="nv">fX</span>:Finite X), IsHProp (P X _)}
           (f0 : P Empty _)
           (fs : <span class="kr">forall</span> <span class="nv">X</span> (<span class="nv">fX</span>:Finite X), P X _ -&gt; P (X + Unit)%type _)
           (X : <span class="kt">Type</span>) `{Finite X}
: P X _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P X H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P X H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk5b"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P X H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk5c">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P X H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk5d"><span class="nb">assert</span> (p := transportD Finite P (path_universe e^-<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (Fin (fcard X)) (finite_fin (fcard X)) -&gt;
P X
  (transport Finite (path_universe e^-<span class="mi">1</span>)
     (finite_fin (fcard X)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P X H1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk5e"><span class="nb">refine</span> (transport (P X) (path_ishprop _ _) (p _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (Fin (fcard X)) (finite_fin (fcard X)) -&gt;
P X
  (transport Finite (path_universe e^-<span class="mi">1</span>)
     (finite_fin (fcard X)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (Fin (fcard X)) (finite_fin (fcard X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk5f"><span class="nb">generalize</span> (fcard X); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (Fin (fcard X)) (finite_fin (fcard X)) -&gt;
P X
  (transport Finite (path_universe e^-<span class="mi">1</span>)
     (finite_fin (fcard X)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (Fin n) (finite_fin n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk60"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (Fin (fcard X)) (finite_fin (fcard X)) -&gt;
P X
  (transport Finite (path_universe e^-<span class="mi">1</span>)
     (finite_fin (fcard X)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (Fin <span class="mi">0</span>) (finite_fin <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (Fin (fcard X)) (finite_fin (fcard X)) -&gt;
P X
  (transport Finite (path_universe e^-<span class="mi">1</span>)
     (finite_fin (fcard X)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>P (Fin n) (finite_fin n)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk61"><hr></label><div class="goal-conclusion">P (Fin n.+<span class="mi">1</span>) (finite_fin n.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk62">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (Fin (fcard X)) (finite_fin (fcard X)) -&gt;
P X
  (transport Finite (path_universe e^-<span class="mi">1</span>)
     (finite_fin (fcard X)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (Fin <span class="mi">0</span>) (finite_fin <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> f0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, Finite X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
IsHProp (P X fX)</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>P Empty finite_empty</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">fX</span> : Finite X),
P X fX -&gt; P (X + Unit)%type (finite_succ X)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (Fin (fcard X)) (finite_fin (fcard X)) -&gt;
P X
  (transport Finite (path_universe e^-<span class="mi">1</span>)
     (finite_fin (fcard X)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>P (Fin n) (finite_fin n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (Fin n.+<span class="mi">1</span>) (finite_fin n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport (P (Fin n.+<span class="mi">1</span>)) (path_ishprop _ _) (fs _ _ IH)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The finite axiom of choice, and projectivity *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk64"><span class="kn">Definition</span> <span class="nf">finite_choice</span> {<span class="nv">X</span>} `{Finite X} : HasChoice X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasChoice X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasChoice X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk66"><span class="nb">intros</span> P oP f; <span class="nb">clear</span> oP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (<span class="kr">forall</span> <span class="nv">x</span> : X, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk67"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (<span class="kr">forall</span> <span class="nv">x</span> : X, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk68">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (<span class="kr">forall</span> <span class="nv">x</span> : X, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk69"><span class="nb">set</span> (P&#39; := P o e^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>P'</var><span><span class="hyp-body"><b>:= </b><span>P o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (<span class="kr">forall</span> <span class="nv">x</span> : X, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk6a"><span class="nb">assert</span> (f&#39; := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f (e^-<span class="mi">1</span> x)) : <span class="kr">forall</span> <span class="nv">x</span>, merely (P&#39; x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>P'</var><span><span class="hyp-body"><b>:= </b><span>P o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), merely (P&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (<span class="kr">forall</span> <span class="nv">x</span> : X, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk6b"><span class="nb">refine</span> (Trunc_functor (X := <span class="kr">forall</span> <span class="nv">x</span>:Fin (fcard X), P&#39; x) (-<span class="mi">1</span>) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>P'</var><span><span class="hyp-body"><b>:= </b><span>P o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), merely (P&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), P&#39; x) -&gt; <span class="kr">forall</span> <span class="nv">x</span> : X, P x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>P'</var><span><span class="hyp-body"><b>:= </b><span>P o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), merely (P&#39; x)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk6c"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), P&#39; x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk6d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>P'</var><span><span class="hyp-body"><b>:= </b><span>P o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), merely (P&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), P&#39; x) -&gt; <span class="kr">forall</span> <span class="nv">x</span> : X, P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> g x; <span class="bp">exact</span> (eissect e x # g (e x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk6e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>P'</var><span><span class="hyp-body"><b>:= </b><span>P o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), merely (P&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), P&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk6f"><span class="nb">clearbody</span> P&#39;; <span class="nb">clear</span> f P e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P'</var><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), merely (P&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), P&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk70"><span class="nb">generalize dependent</span> (fcard X); <span class="nb">intros</span> n P f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n, merely (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk71"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, merely (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, P x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, merely (P x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, merely (P x)) -&gt;
Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, P x)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk72"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, P x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk73">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, merely (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, P x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tr (Empty_ind P)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk74">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, merely (P x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, merely (P x)) -&gt;
Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, P x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk75"><span class="nb">specialize</span> (IH (P o inl) (f o inl)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, merely (P x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (P o inl) x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk76"><span class="nb">assert</span> (e := f (inr tt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, merely (P x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (P o inl) x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (P (inr tt))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk77">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, merely (P x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>P (inr tt)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n, P (inl x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tr (sum_ind P IH (Unit_ind e))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk78"><span class="kn">Corollary</span> <span class="nf">isprojective_fin_n</span> (<span class="nv">n</span> : nat) : IsProjective (Fin n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsProjective (Fin n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsProjective (Fin n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk7a"><span class="nb">apply</span> (iff_isoprojective_hasochoice _ (Fin n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasChoice (Fin n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> finite_choice.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Constructions on finite sets *)</span>

<span class="sd">(** Finite sets are closed under sums, products, function spaces, and equivalence spaces.  There are multiple choices we could make regarding how to prove these facts.  Since we know what the cardinalities ought to be in all cases (since we know how to add, multiply, exponentiate, and take factorials of natural numbers), we could specify those off the bat, and then reduce to the case of canonical finite sets.  However, it&#39;s more amusing to instead prove finiteness of these constructions by &quot;finite-set induction&quot;, and then *deduce* that their cardinalities are given by the corresponding operations on natural numbers (because they satisfy the same recurrences). *)</span>

<span class="sd">(** *** Binary sums *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk7b"><span class="kn">Instance</span> <span class="nf">finite_sum</span> <span class="nv">X</span> <span class="nv">Y</span> `{Finite X} `{Finite Y}
: Finite (X + Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk7d"><span class="nb">assert</span> (e := merely_equiv_fin Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (Y &lt;~&gt; Fin (fcard Y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk7e">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk7f"><span class="nb">refine</span> (finite_equiv _ (functor_sum idmap e^-<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Fin (fcard Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk80"><span class="nb">generalize</span> (fcard Y); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Fin n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk81"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Fin <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Finite (X + Fin n)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk82"><hr></label><div class="goal-conclusion">Finite (X + Fin n.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Fin <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (finite_equiv _ (sum_empty_r X)^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk84">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Finite (X + Fin n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X + Fin n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (finite_equiv _ (equiv_sum_assoc X _ Unit) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Note that the cardinality function [fcard] actually computes.  The same will be true of all the other proofs in this section, though we don&#39;t always verify it. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk85"><span class="kn">Goal</span> fcard (Fin <span class="mi">3</span> + Fin <span class="mi">4</span>) = <span class="mi">7</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin <span class="mi">3</span> + Fin <span class="mi">4</span>) = <span class="mi">7</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk86"><span class="kn">Definition</span> <span class="nf">fcard_sum</span> <span class="nv">X</span> <span class="nv">Y</span> `{Finite X} `{Finite Y}
: fcard (X + Y) = (fcard X + fcard Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Y) = fcard X + fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Y) = fcard X + fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk88"><span class="nb">refine</span> (_ @ nat_add_comm _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Y) = fcard Y + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk89"><span class="nb">assert</span> (e := merely_equiv_fin Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (Y &lt;~&gt; Fin (fcard Y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Y) = fcard Y + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk8a">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Y) = fcard Y + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk8b"><span class="nb">refine</span> (fcard_equiv&#39; (<span class="mi">1</span> +E e) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Fin (fcard Y)) = fcard Y + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk8c"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (y + fcard X)) (fcard_equiv e^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Fin (fcard Y)) =
fcard (Fin (fcard Y)) + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk8d"><span class="nb">generalize</span> (fcard Y); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Fin n) = fcard (Fin n) + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk8e"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Fin <span class="mi">0</span>) = fcard (Fin <span class="mi">0</span>) + fcard X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (X + Fin n) = fcard (Fin n) + fcard X</span></span></span><br></div><label class="goal-separator" for="finite-v-chk8f"><hr></label><div class="goal-conclusion">fcard (X + Fin n.+<span class="mi">1</span>) = fcard (Fin n.+<span class="mi">1</span>) + fcard X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk90">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Fin <span class="mi">0</span>) = fcard (Fin <span class="mi">0</span>) + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fcard_equiv (sum_empty_r X)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (X + Fin n) = fcard (Fin n) + fcard X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X + Fin n.+<span class="mi">1</span>) = fcard (Fin n.+<span class="mi">1</span>) + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk92"><span class="nb">refine</span> (fcard_equiv (equiv_sum_assoc _ _ _)^-<span class="mi">1</span> @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (X + Fin n) = fcard (Fin n) + fcard X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard
  (X +
   (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n + Unit) = fcard (Fin n.+<span class="mi">1</span>) + fcard X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap S IH).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Binary products *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk93"><span class="kn">Instance</span> <span class="nf">finite_prod</span> <span class="nv">X</span> <span class="nv">Y</span> `{Finite X} `{Finite Y}
: Finite (X * Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk95"><span class="nb">assert</span> (e := merely_equiv_fin Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (Y &lt;~&gt; Fin (fcard Y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk96">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk97"><span class="nb">refine</span> (finite_equiv _ (functor_prod idmap e^-<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Fin (fcard Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk98"><span class="nb">generalize</span> (fcard Y); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Fin n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk99"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Fin <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Finite (X * Fin n)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk9a"><hr></label><div class="goal-conclusion">Finite (X * Fin n.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk9b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Fin <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (finite_equiv _ (prod_empty_r X)^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk9c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Finite (X * Fin n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Fin n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk9d"><span class="nb">refine</span> (finite_equiv _ (sum_distrib_l X _ Unit)^-<span class="mi">1</span> (finite_sum _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin (fcard Y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Finite (X * Fin n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X * Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (finite_equiv _ (prod_unit_r X)^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk9e"><span class="kn">Definition</span> <span class="nf">fcard_prod</span> <span class="nv">X</span> <span class="nv">Y</span> `{Finite X} `{Finite Y}
: fcard (X * Y) = fcard X * fcard Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X * Y) = fcard X * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X * Y) = fcard X * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka0"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X * Y) = fcard X * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka1">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X * Y) = fcard X * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka2"><span class="nb">refine</span> (fcard_equiv&#39; (e *E <span class="mi">1</span>) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin (fcard X) * Y) = fcard X * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka3"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * fcard Y) (fcard_equiv e^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin (fcard X) * Y) =
fcard (Fin (fcard X)) * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka4"><span class="nb">generalize</span> (fcard X); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n * Y) = fcard (Fin n) * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka5"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin <span class="mi">0</span> * Y) = fcard (Fin <span class="mi">0</span>) * fcard Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><label class="goal-separator" for="finite-v-chka6"><hr></label><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span> * Y) = fcard (Fin n.+<span class="mi">1</span>) * fcard Y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin <span class="mi">0</span> * Y) = fcard (Fin <span class="mi">0</span>) * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (fcard_equiv (prod_empty_l Y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span> * Y) = fcard (Fin n.+<span class="mi">1</span>) * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chka9"><span class="nb">refine</span> (fcard_equiv (sum_distrib_r Y (Fin n) Unit) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n * Y + Unit * Y) =
fcard (Fin n.+<span class="mi">1</span>) * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkaa"><span class="nb">refine</span> (fcard_sum _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n * Y) + fcard (Unit * Y) =
fcard (Fin n.+<span class="mi">1</span>) * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkab"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n * Y) + fcard (Unit * Y) =
fcard Y + n * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkac"><span class="nb">refine</span> (_ @ nat_add_comm _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n * Y) + fcard (Unit * Y) =
n * fcard Y + fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkad"><span class="nb">refine</span> (ap011 nat_add _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n * Y) = n * fcard Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><label class="goal-separator" for="finite-v-chkae"><hr></label><div class="goal-conclusion">fcard (Unit * Y) = fcard Y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkaf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n * Y) = n * fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n * Y) = fcard (Fin n) * fcard Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Unit * Y) = fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fcard_equiv&#39;, prod_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Function types *)</span>

<span class="sd">(** Finite sets are closed under function types, and even dependent function types. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb1"><span class="kn">Instance</span> <span class="nf">finite_forall</span> `{Funext} {X} (Y : X -&gt; <span class="kt">Type</span>)
       `{Finite X} `{<span class="kr">forall</span> <span class="nv">x</span>, Finite (Y x)}
: Finite (<span class="kr">forall</span> <span class="nv">x</span>:X, Y x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb3"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb4">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb5"><span class="nb">simple refine</span> (finite_equiv&#39; _
            (equiv_functor_forall&#39; (P := <span class="kr">fun</span> <span class="nv">x</span> =&gt; Y (e^-<span class="mi">1</span> x)) e _) _); <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : X,
(<span class="kr">fun</span> <span class="nv">x</span> : Fin (fcard X) =&gt; Y (e^-<span class="mi">1</span> x)) (e b) &lt;~&gt; Y b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><label class="goal-separator" for="finite-v-chkb6"><hr></label><div class="goal-conclusion">Finite
  (<span class="kr">forall</span> <span class="nv">a</span> : Fin (fcard X),
   (<span class="kr">fun</span> <span class="nv">x</span> : Fin (fcard X) =&gt; Y (e^-<span class="mi">1</span> x)) a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : X,
(<span class="kr">fun</span> <span class="nv">x</span> : Fin (fcard X) =&gt; Y (e^-<span class="mi">1</span> x)) (e b) &lt;~&gt; Y b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">refine</span> (equiv_transport _ (eissect e x)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite
  (<span class="kr">forall</span> <span class="nv">a</span> : Fin (fcard X),
   (<span class="kr">fun</span> <span class="nv">x</span> : Fin (fcard X) =&gt; Y (e^-<span class="mi">1</span> x)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkb9"><span class="nb">set</span> (Y&#39; := Y o e^-<span class="mi">1</span>); <span class="nb">change</span> (Finite (<span class="kr">forall</span> <span class="nv">x</span>, Y&#39; x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>Y'</var><span><span class="hyp-body"><b>:= </b><span>Y o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), Y&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkba"><span class="nb">assert</span> (<span class="kr">forall</span> <span class="nv">x</span>, Finite (Y&#39; x)) <span class="bp">by</span> <span class="bp">exact</span> _; <span class="nb">clearbody</span> Y&#39;; <span class="nb">clear</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), Y&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkbb"><span class="nb">generalize dependent</span> (fcard X); <span class="nb">intros</span> n Y&#39; ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkbc"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, Y&#39; x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><label class="goal-separator" for="finite-v-chkbd"><hr></label><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Y&#39; x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkbe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, Y&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkbf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Y&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc0"><span class="nb">refine</span> (finite_equiv _ (equiv_sum_ind Y&#39;) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite
  ((<span class="kr">forall</span>
    <span class="nv">a</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
           <span class="kr">match</span> n <span class="kr">with</span>
           | <span class="mi">0</span> =&gt; Empty
           | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
           <span class="kr">end</span>) n, Y&#39; (inl a)) *
   (<span class="kr">forall</span> <span class="nv">b</span> : Unit, Y&#39; (inr b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc1"><span class="nb">apply</span> finite_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite
  (<span class="kr">forall</span>
   <span class="nv">a</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n, Y&#39; (inl a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkc2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><label class="goal-separator" for="finite-v-chkc2"><hr></label><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">b</span> : Unit, Y&#39; (inr b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite
  (<span class="kr">forall</span>
   <span class="nv">a</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n, Y&#39; (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (<span class="kr">forall</span> <span class="nv">b</span> : Unit, Y&#39; (inr b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc5"><span class="nb">refine</span> (finite_equiv _ (@Unit_ind (<span class="kr">fun</span> <span class="nv">u</span> =&gt; Y&#39; (inr u))) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Unit_ind (A:=<span class="kr">fun</span> <span class="nv">u</span> : Unit =&gt; Y&#39; (inr u)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (isequiv_unit_ind (Y&#39; o inr)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Hint Extern</span> <span class="mi">4</span> =&gt; <span class="kp">progress</span> (<span class="nb">cbv</span> beta iota) : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc6"><span class="kn">Definition</span> <span class="nf">fcard_arrow</span> `{Funext} X Y `{Finite X} `{Finite Y}
: fcard (X -&gt; Y) = nat_pow (fcard Y) (fcard X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; Y) x) =
nat_pow (fcard Y) (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; Y) x) =
nat_pow (fcard Y) (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc8"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; Y) x) =
nat_pow (fcard Y) (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkc9">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; Y) x) =
nat_pow (fcard Y) (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkca"><span class="nb">refine</span> (fcard_equiv (functor_arrow e idmap)^-<span class="mi">1</span> @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard
  (<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X),
   (<span class="kr">fun</span> <span class="nv">_</span> : Fin (fcard X) =&gt; Y) x) =
nat_pow (fcard Y) (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkcb"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; nat_pow (fcard Y) x) (fcard_equiv e)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard
  (<span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X),
   (<span class="kr">fun</span> <span class="nv">_</span> : Fin (fcard X) =&gt; Y) x) =
nat_pow (fcard Y) (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkcc"><span class="nb">generalize</span> (fcard X); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkcd"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, (<span class="kr">fun</span> <span class="nv">_</span> : Fin <span class="mi">0</span> =&gt; Y) x) =
nat_pow (fcard Y) <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><label class="goal-separator" for="finite-v-chkce"><hr></label><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n.+<span class="mi">1</span> =&gt; Y) x) =
nat_pow (fcard Y) n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkcf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, (<span class="kr">fun</span> <span class="nv">_</span> : Fin <span class="mi">0</span> =&gt; Y) x) =
nat_pow (fcard Y) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n.+<span class="mi">1</span> =&gt; Y) x) =
nat_pow (fcard Y) n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd1"><span class="nb">refine</span> (fcard_equiv (equiv_sum_ind (<span class="kr">fun</span> (<span class="nv">_</span>:Fin n.+<span class="mi">1</span>) =&gt; Y))^-<span class="mi">1</span> @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard
  (((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
       <span class="kr">match</span> n <span class="kr">with</span>
       | <span class="mi">0</span> =&gt; Empty
       | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
       <span class="kr">end</span>) n -&gt; Y) * (Unit -&gt; Y)) =
nat_pow (fcard Y) n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd2"><span class="nb">refine</span> (fcard_prod _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard
  (<span class="kr">forall</span>
   <span class="nv">x</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n,
   (<span class="kr">fun</span>
      <span class="nv">_</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
             <span class="kr">match</span> n <span class="kr">with</span>
             | <span class="mi">0</span> =&gt; Empty
             | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
             <span class="kr">end</span>) n =&gt; Y) x) *
fcard (<span class="kr">forall</span> <span class="nv">x</span> : Unit, unit_name Y x) =
nat_pow (fcard Y) n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd3">lhs napply nat_mul_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Unit, unit_name Y x) *
fcard
  (<span class="kr">forall</span>
   <span class="nv">x</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n,
   (<span class="kr">fun</span>
      <span class="nv">_</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
             <span class="kr">match</span> n <span class="kr">with</span>
             | <span class="mi">0</span> =&gt; Empty
             | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
             <span class="kr">end</span>) n =&gt; Y) x) = nat_pow (fcard Y) n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd4"><span class="nb">apply</span> (ap011 nat_mul).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Unit, unit_name Y x) = fcard Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkd5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><label class="goal-separator" for="finite-v-chkd5"><hr></label><div class="goal-conclusion">fcard
  (<span class="kr">forall</span>
   <span class="nv">x</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n,
   (<span class="kr">fun</span>
      <span class="nv">_</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
             <span class="kr">match</span> n <span class="kr">with</span>
             | <span class="mi">0</span> =&gt; Empty
             | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
             <span class="kr">end</span>) n =&gt; Y) x) =
nat_iter n (nat_mul (fcard Y)) <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd6">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : Unit, unit_name Y x) = fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (fcard_equiv (@Unit_ind (<span class="kr">fun</span> (<span class="nv">_</span>:Unit) =&gt; Y))^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin n, (<span class="kr">fun</span> <span class="nv">_</span> : Fin n =&gt; Y) x) =
nat_pow (fcard Y) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard
  (<span class="kr">forall</span>
   <span class="nv">x</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n,
   (<span class="kr">fun</span>
      <span class="nv">_</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
             <span class="kr">match</span> n <span class="kr">with</span>
             | <span class="mi">0</span> =&gt; Empty
             | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
             <span class="kr">end</span>) n =&gt; Y) x) =
nat_iter n (nat_mul (fcard Y)) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [fcard] still computes, despite the funext: *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd8"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">fs</span>:Funext, fcard (Fin <span class="mi">3</span> -&gt; Fin <span class="mi">4</span>) = <span class="mi">64</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">fs</span> : Funext,
fcard (<span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">3</span>, (<span class="kr">fun</span> <span class="nv">_</span> : Fin <span class="mi">3</span> =&gt; Fin <span class="mi">4</span>) x) =
<span class="mi">64</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Automorphism types (i.e. symmetric groups) *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkd9"><span class="kn">Instance</span> <span class="nf">finite_aut</span> `{Funext} X `{Finite X}
: Finite (X &lt;~&gt; X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X &lt;~&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkda"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X &lt;~&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkdb"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X &lt;~&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkdc">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (X &lt;~&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkdd"><span class="nb">refine</span> (finite_equiv _
            (equiv_functor_equiv e^-<span class="mi">1</span> e^-<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Fin (fcard X) &lt;~&gt; Fin (fcard X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkde"><span class="nb">generalize</span> (fcard X); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Fin n &lt;~&gt; Fin n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkdf"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Fin <span class="mi">0</span> &lt;~&gt; Fin <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chke0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Finite (Fin n &lt;~&gt; Fin n)</span></span></span><br></div><label class="goal-separator" for="finite-v-chke0"><hr></label><div class="goal-conclusion">Finite (Fin n.+<span class="mi">1</span> &lt;~&gt; Fin n.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Fin <span class="mi">0</span> &lt;~&gt; Fin <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Finite (Fin n &lt;~&gt; Fin n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Fin n.+<span class="mi">1</span> &lt;~&gt; Fin n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (finite_equiv _ (equiv_fin_equiv n n) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke3"><span class="kn">Definition</span> <span class="nf">fcard_aut</span> `{Funext} X `{Finite X}
: fcard (X &lt;~&gt; X) = factorial (fcard X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X &lt;~&gt; X) = factorial (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X &lt;~&gt; X) = factorial (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke5"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X &lt;~&gt; X) = factorial (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke6">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X &lt;~&gt; X) = factorial (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke7"><span class="nb">refine</span> (fcard_equiv
            (equiv_functor_equiv e^-<span class="mi">1</span> e^-<span class="mi">1</span>)^-<span class="mi">1</span> @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin (fcard X) &lt;~&gt; Fin (fcard X)) =
factorial (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke8"><span class="nb">generalize</span> (fcard X); <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n &lt;~&gt; Fin n) = factorial n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chke9"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin <span class="mi">0</span> &lt;~&gt; Fin <span class="mi">0</span>) = factorial <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><label class="goal-separator" for="finite-v-chkea"><hr></label><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span> &lt;~&gt; Fin n.+<span class="mi">1</span>) = factorial n.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkeb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin <span class="mi">0</span> &lt;~&gt; Fin <span class="mi">0</span>) = factorial <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkec">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span> &lt;~&gt; Fin n.+<span class="mi">1</span>) = factorial n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chked"><span class="nb">refine</span> (fcard_equiv (equiv_fin_equiv n n)^-<span class="mi">1</span> @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span> * (Fin n &lt;~&gt; Fin n)) = factorial n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkee"><span class="nb">refine</span> (fcard_prod _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span>) * fcard (Fin n &lt;~&gt; Fin n) =
factorial n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkef"><span class="nb">apply</span> ap011.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><label class="goal-separator" for="finite-v-chkf0"><hr></label><div class="goal-conclusion">fcard (Fin n &lt;~&gt; Fin n) =
(<span class="kr">fix</span> factorial (n : nat) : nat :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; <span class="mi">1</span>
   | n0.+<span class="mi">1</span> =&gt; n0.+<span class="mi">1</span> * factorial n0
   <span class="kr">end</span>) n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n.+<span class="mi">1</span>) = n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>fcard (Fin n &lt;~&gt; Fin n) = factorial n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n &lt;~&gt; Fin n) =
(<span class="kr">fix</span> factorial (n : nat) : nat :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; <span class="mi">1</span>
   | n0.+<span class="mi">1</span> =&gt; n0.+<span class="mi">1</span> * factorial n0
   <span class="kr">end</span>) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [fcard] still computes: *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf3"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">fs</span>:Funext, fcard (Fin <span class="mi">4</span> &lt;~&gt; Fin <span class="mi">4</span>) = <span class="mi">24</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">fs</span> : Funext, fcard (Fin <span class="mi">4</span> &lt;~&gt; Fin <span class="mi">4</span>) = <span class="mi">24</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Finite sums of natural numbers *)</span>

<span class="sd">(** Perhaps slightly less obviously, finite sets are also closed under sigmas. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf4"><span class="kn">Instance</span> <span class="nf">finite_sigma</span> {<span class="nv">X</span>} (<span class="nv">Y</span> : X -&gt; <span class="kt">Type</span>)
       `{Finite X} `{<span class="kr">forall</span> <span class="nv">x</span>, Finite (Y x)}
: Finite { x:X &amp; Y x }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : X &amp; Y x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : X &amp; Y x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf6"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : X &amp; Y x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf7">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : X &amp; Y x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf8"><span class="nb">refine</span> (finite_equiv&#39; _
            (equiv_functor_sigma (equiv_inverse e)
                                 (<span class="kr">fun</span> <span class="nv">x</span> (<span class="nv">y</span>:Y (e^-<span class="mi">1</span> x)) =&gt; y)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : Fin (fcard X) &amp; Y (e^-<span class="mi">1</span> x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Unfortunately, because [compose] is currently beta-expanded, [set (Y&#39; := Y o e^-1)] doesn&#39;t change the goal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkf9"><span class="nb">set</span> (Y&#39; := <span class="kr">fun</span> <span class="nv">x</span> =&gt; Y (e^-<span class="mi">1</span> x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>Y'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : Fin (fcard X) =&gt; Y (e^-<span class="mi">1</span> x)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : _ &amp; Y&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkfa"><span class="nb">assert</span> (<span class="kr">forall</span> <span class="nv">x</span>, Finite (Y&#39; x)) <span class="bp">by</span> <span class="bp">exact</span> _; <span class="nb">clearbody</span> Y&#39;; <span class="nb">clear</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin (fcard X), Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : _ &amp; Y&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkfb"><span class="nb">generalize dependent</span> (fcard X); <span class="nb">intros</span> n Y&#39; ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : _ &amp; Y&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkfc"><span class="nb">induction</span> n <span class="kr">as</span> [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : _ &amp; Y&#39; x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chkfd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite {x : _ &amp; Y&#39; x}</span></span></span><br></div><label class="goal-separator" for="finite-v-chkfd"><hr></label><div class="goal-conclusion">Finite {x : _ &amp; Y&#39; x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkfe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin <span class="mi">0</span>, Finite (Y&#39; x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : _ &amp; Y&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (finite_equiv Empty pr1^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chkff">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite {x : _ &amp; Y&#39; x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : _ &amp; Y&#39; x}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk100"><span class="nb">refine</span> (finite_equiv _ (equiv_sigma_sum (Fin n) Unit Y&#39;)^-<span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite {x : _ &amp; Y&#39; x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite
  ({a : Fin n &amp; Y&#39; (inl a)} + {b : Unit &amp; Y&#39; (inr b)})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk101"><span class="nb">apply</span> finite_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite {x : _ &amp; Y&#39; x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {a : Fin n &amp; Y&#39; (inl a)}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk102" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite {x : _ &amp; Y&#39; x}</span></span></span><br></div><label class="goal-separator" for="finite-v-chk102"><hr></label><div class="goal-conclusion">Finite {b : Unit &amp; Y&#39; (inr b)}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk103">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite {x : _ &amp; Y&#39; x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {a : Fin n &amp; Y&#39; (inl a)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk104">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Y'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Fin n.+<span class="mi">1</span>, Finite (Y&#39; x)</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">Y&#39;</span> : Fin n -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : Fin n, Finite (Y&#39; x)) -&gt;
Finite {x : _ &amp; Y&#39; x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {b : Unit &amp; Y&#39; (inr b)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (finite_equiv _ (equiv_contr_sigma _)^-<span class="mi">1</span> _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Amusingly, this automatically gives us a way to add up a family of natural numbers indexed by any finite set.  (We could of course also define such an operation directly, probably using [merely_ind_hset].) *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finadd</span> {<span class="nv">X</span>} `{Finite X} (f : X -&gt; nat) : nat
  := fcard { x:X &amp; Fin (f x) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk105"><span class="kn">Definition</span> <span class="nf">fcard_sigma</span> {<span class="nv">X</span>} (<span class="nv">Y</span> : X -&gt; <span class="kt">Type</span>)
       `{Finite X} `{<span class="kr">forall</span> <span class="nv">x</span>, Finite (Y x)}
: fcard { x:X &amp; Y x } = finadd (<span class="kr">fun</span> <span class="nv">x</span> =&gt; fcard (Y x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard {x : X &amp; Y x} =
finadd (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk106"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard {x : X &amp; Y x} =
finadd (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk107"><span class="nb">set</span> (f := <span class="kr">fun</span> <span class="nv">x</span> =&gt; fcard (Y x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard {x : X &amp; Y x} = finadd f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk108"><span class="nb">set</span> (g := <span class="kr">fun</span> <span class="nv">x</span> =&gt; merely_equiv_fin (Y x) : merely (Y x &lt;~&gt; Fin (f x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
merely_equiv_fin (Y x) : merely (Y x &lt;~&gt; Fin (f x))</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (Y x &lt;~&gt; Fin (f x))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard {x : X &amp; Y x} = finadd f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk109"><span class="nb">apply</span> finite_choice <span class="kr">in</span> g; [| <span class="bp">exact</span> _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>merely (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x &lt;~&gt; Fin (f x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard {x : X &amp; Y x} = finadd f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk10a">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x &lt;~&gt; Fin (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard {x : X &amp; Y x} = finadd f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk10b"><span class="nb">unfold</span> finadd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x &lt;~&gt; Fin (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard {x : X &amp; Y x} =
fcard {x : X &amp; (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; Fin (f x0)) x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fcard_equiv&#39; (equiv_functor_sigma_id g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The sum of a finite constant family is the product by its cardinality. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk10c"><span class="kn">Definition</span> <span class="nf">finadd_const</span> <span class="nv">X</span> `{Finite X} n
: finadd (<span class="kr">fun</span> <span class="nv">x</span>:X =&gt; n) = fcard X * n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finadd (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; n) = fcard X * n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk10d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finadd (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; n) = fcard X * n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk10e"><span class="nb">transitivity</span> (fcard (X * Fin n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finadd (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; n) = fcard (X * Fin n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk10f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="finite-v-chk10f"><hr></label><div class="goal-conclusion">fcard (X * Fin n) = fcard X * n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk110">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finadd (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; n) = fcard (X * Fin n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fcard_equiv&#39; (equiv_sigma_prod0 X (Fin n))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk111">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (X * Fin n) = fcard X * n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fcard_prod X (Fin n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Closure under sigmas and paths also implies closure under hfibers. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk112"><span class="kn">Definition</span> <span class="nf">finite_hfiber</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">y</span> : Y)
       `{Finite X} `{Finite Y}
: Finite (hfiber f y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk113"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Therefore, the cardinality of the domain of a map between finite sets is the sum of the cardinalities of its hfibers. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk114"><span class="kn">Definition</span> <span class="nf">fcard_domain</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) `{Finite X} `{Finite Y}
: fcard X = finadd (<span class="kr">fun</span> <span class="nv">y</span> =&gt; fcard (hfiber f y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X =
finadd
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   fcard {x : X &amp; (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; f x0 = y) x})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk115"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X =
finadd
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   fcard {x : X &amp; (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; f x0 = y) x})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk116"><span class="nb">refine</span> (_ @ fcard_sigma (hfiber f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X = fcard {x : Y &amp; hfiber f x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fcard_equiv&#39; (equiv_fibration_replacement f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In particular, the image of a map between finite sets is finite. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk117"><span class="kn">Definition</span> <span class="nf">finite_image</span>
       {<span class="nv">X</span> <span class="nv">Y</span>} `{Finite X} `{Finite Y} (f : X -&gt; Y)
: Finite (himage f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (himage f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk118"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (himage f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Finite products of natural numbers *)</span>

<span class="sd">(** Similarly, closure of finite sets under [forall] automatically gives us a way to multiply a family of natural numbers indexed by any finite set.  Of course, if we defined this explicitly, it wouldn&#39;t need funext. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finmult</span> `{Funext} {X} `{Finite X} (f : X -&gt; nat) : nat
  := fcard (<span class="kr">forall</span> <span class="nv">x</span>:X, Fin (f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk119"><span class="kn">Definition</span> <span class="nf">fcard_forall</span> `{Funext} {X} (Y : X -&gt; <span class="kt">Type</span>)
       `{Finite X} `{<span class="kr">forall</span> <span class="nv">x</span>, Finite (Y x)}
: fcard (<span class="kr">forall</span> <span class="nv">x</span>:X, Y x) = finmult (<span class="kr">fun</span> <span class="nv">x</span> =&gt; fcard (Y x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x) =
finmult (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk11a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x) =
finmult (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk11b"><span class="nb">set</span> (f := <span class="kr">fun</span> <span class="nv">x</span> =&gt; fcard (Y x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x) = finmult f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk11c"><span class="nb">set</span> (g := <span class="kr">fun</span> <span class="nv">x</span> =&gt; merely_equiv_fin (Y x) : merely (Y x &lt;~&gt; Fin (f x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
merely_equiv_fin (Y x) : merely (Y x &lt;~&gt; Fin (f x))</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, merely (Y x &lt;~&gt; Fin (f x))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x) = finmult f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk11d"><span class="nb">apply</span> finite_choice <span class="kr">in</span> g; [| <span class="bp">exact</span> _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>merely (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x &lt;~&gt; Fin (f x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x) = finmult f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk11e">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x &lt;~&gt; Fin (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x) = finmult f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk11f"><span class="nb">unfold</span> finmult.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Finite (Y x)</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : X =&gt; fcard (Y x)</span></span><span class="hyp-type"><b>: </b><span>X -&gt; nat</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Y x &lt;~&gt; Fin (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, Y x) =
fcard (<span class="kr">forall</span> <span class="nv">x</span> : X, (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; Fin (f x0)) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fcard_equiv&#39; (equiv_functor_forall&#39; (equiv_idmap X) g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The product of a finite constant family is the exponential by its cardinality. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk120"><span class="kn">Definition</span> <span class="nf">finmult_const</span> `{Funext} X `{Finite X} n
: finmult (<span class="kr">fun</span> <span class="nv">x</span>:X =&gt; n) = nat_pow n (fcard X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finmult (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; n) = nat_pow n (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk121"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finmult (<span class="kr">fun</span> <span class="nv">_</span> : X =&gt; n) = nat_pow n (fcard X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fcard_arrow X (Fin n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Finite subsets *)</span>

<span class="sd">(** Closure under sigmas implies that a detachable subset of a finite set is finite. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk122"><span class="kn">Instance</span> <span class="nf">finite_detachable_subset</span> {<span class="nv">X</span>} `{Finite X} (P : X -&gt; <span class="kt">Type</span>)
       `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} `{<span class="kr">forall</span> <span class="nv">x</span>, Decidable (P x)}
: Finite { x:X &amp; P x }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Decidable (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : X &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk123"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Decidable (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : X &amp; P x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conversely, if a subset of a finite set is finite, then it is detachable.  We show first that an embedding between finite subsets has detachable image. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk124"><span class="kn">Definition</span> <span class="nf">detachable_image_finite</span>
           {<span class="nv">X</span> <span class="nv">Y</span>} `{Finite X} `{Finite Y} (f : X -&gt; Y) `{IsEmbedding f}
: <span class="kr">forall</span> <span class="nv">y</span>, Decidable (hfiber f y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Y, Decidable (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk125"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Y, Decidable (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk126"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk127"><span class="nb">assert</span> (ff : Finite (hfiber f y)) <span class="bp">by</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>ff</var><span class="hyp-type"><b>: </b><span>Finite (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk128"><span class="nb">destruct</span> ff <span class="kr">as</span> [[|n] e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (hfiber f y &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (hfiber f y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk129" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (hfiber f y &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk129"><hr></label><div class="goal-conclusion">Decidable (hfiber f y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk12a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (hfiber f y &lt;~&gt; Fin <span class="mi">0</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="nb">intros</span> u; strip_truncations; <span class="bp">exact</span> (e u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk12b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (hfiber f y &lt;~&gt; Fin n.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>; strip_truncations; <span class="bp">exact</span> (e^-<span class="mi">1</span> (inr tt)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk12c"><span class="kn">Definition</span> <span class="nf">detachable_finite_subset</span> {<span class="nv">X</span>} `{Finite X}
           (P : X -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)}
           {Pf : Finite ({ x:X &amp; P x })}
: <span class="kr">forall</span> <span class="nv">x</span>, Decidable (P x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, Decidable (P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk12d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, Decidable (P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk12e"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk12f">nrefine (decidable_equiv&#39; _ (hfiber_fibration x P)^-<span class="mi">1</span>%equiv _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (hfiber pr1 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk130">nrefine (detachable_image_finite pr1 x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite {x : _ &amp; P x}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk131" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="finite-v-chk131"><hr></label><div class="goal-conclusion">Finite X</div></blockquote><input class="alectryon-extra-goal-toggle" id="finite-v-chk132" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="finite-v-chk132"><hr></label><div class="goal-conclusion">IsEmbedding pr1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk133"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, IsHProp (P x)</span></span></span><br><span><var>Pf</var><span class="hyp-type"><b>: </b><span>Finite {x : X &amp; P x}</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding pr1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (mapinO_pr1 (Tr (-<span class="mi">1</span>))).  <span class="sd">(** Why doesn&#39;t Coq find this? *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Quotients *)</span>

<span class="sd">(** The quotient of a finite set by a detachable equivalence relation is finite. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">DecidableQuotients</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence} {X} `{Finite X}
          (R : Relation X) `{is_mere_relation X R}
          `{Reflexive _ R} `{Transitive _ R} `{Symmetric _ R}
          {Rd : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, Decidable (R x y)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk134">#[export] <span class="kn">Instance</span> <span class="nf">finite_quotient</span> : Finite (Quotient R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk135"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk136"><span class="nb">assert</span> (e := merely_equiv_fin X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin (fcard X))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk137">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk138"><span class="nb">pose</span> (R&#39; x y := R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk139"><span class="nb">assert</span> (is_mere_relation _ R&#39;) <span class="bp">by</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk13a"><span class="nb">assert</span> (Reflexive R&#39;) <span class="bp">by</span> (<span class="nb">intros</span> ?; <span class="nb">unfold</span> R&#39;; <span class="nb">apply</span> <span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk13b"><span class="nb">assert</span> (Symmetric R&#39;) <span class="bp">by</span> (<span class="nb">intros</span> ? ?; <span class="nb">unfold</span> R&#39;; <span class="nb">apply</span> <span class="nb">symmetry</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk13c"><span class="nb">assert</span> (Transitive R&#39;) <span class="bp">by</span> (<span class="nb">intros</span> ? ? ?; <span class="nb">unfold</span> R&#39;; <span class="bp">exact</span> <span class="nb">transitivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk13d"><span class="nb">assert</span> (R&#39;d : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, Decidable (R&#39; x y))
      <span class="bp">by</span> (<span class="nb">intros</span> ? ?; <span class="nb">unfold</span> R&#39;; <span class="nb">apply</span> Rd).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X), Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk13e">srefine (finite_equiv&#39; _ (equiv_quotient_functor R&#39; R e^-<span class="mi">1</span> _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X), Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Fin (fcard X),
R&#39; a b &lt;-&gt; R (e^-<span class="mi">1</span> a) (e^-<span class="mi">1</span> b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk13f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X), Decidable (R&#39; x y)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk13f"><hr></label><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk140"><span class="mi">1</span>: <span class="bp">by</span> <span class="kp">try</span> (<span class="nb">intros</span>; <span class="nb">split</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin (fcard X)</span></span></span><br><span><var>R'</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X) =&gt; R (e^-<span class="mi">1</span> x) (e^-<span class="mi">1</span> y)</span></span><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X), Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk141"><span class="nb">clearbody</span> R&#39;; <span class="nb">clear</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin (fcard X) -&gt; Fin (fcard X) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin (fcard X)) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin (fcard X), Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk142"><span class="nb">generalize dependent</span> (fcard X);
      <span class="nb">intros</span> n; <span class="nb">induction</span> n <span class="kr">as</span> [|n IH]; <span class="nb">intros</span> R&#39; ? ? ? ? ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin <span class="mi">0</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin <span class="mi">0</span>, Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk143"><hr></label><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk144">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin <span class="mi">0</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin <span class="mi">0</span>, Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk145"><span class="nb">refine</span> (finite_equiv Empty _^-<span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin <span class="mi">0</span> -&gt; Fin <span class="mi">0</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin <span class="mi">0</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin <span class="mi">0</span>, Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient R&#39; -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Quotient_rec R&#39; _ Empty_rec (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; <span class="kr">match</span> x <span class="kr">with</span> <span class="kr">end</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk146">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk147"><span class="nb">pose</span> (R&#39;&#39; x y := R&#39; (inl x) (inl y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk148"><span class="nb">assert</span> (is_mere_relation _ R&#39;&#39;) <span class="bp">by</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk149"><span class="nb">assert</span> (Reflexive R&#39;&#39;) <span class="bp">by</span> (<span class="nb">intros</span> ?; <span class="nb">unfold</span> R&#39;&#39;; <span class="nb">apply</span> <span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk14a"><span class="nb">assert</span> (Symmetric R&#39;&#39;) <span class="bp">by</span> (<span class="nb">intros</span> ? ?; <span class="nb">unfold</span> R&#39;&#39;; <span class="nb">apply</span> <span class="nb">symmetry</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk14b"><span class="nb">assert</span> (Transitive R&#39;&#39;) <span class="bp">by</span> (<span class="nb">intros</span> ? ? ?; <span class="nb">unfold</span> R&#39;&#39;; <span class="bp">exact</span> <span class="nb">transitivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk14c"><span class="nb">assert</span> (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, Decidable (R&#39;&#39; x y)) <span class="bp">by</span> (<span class="nb">intros</span> ? ?; <span class="nb">unfold</span> R&#39;&#39;; <span class="nb">apply</span> R&#39;d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk14d"><span class="nb">assert</span> (inlresp := (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; idmap)
                         : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk14e"><span class="nb">destruct</span> (dec (merely {x:Fin n &amp; R&#39; (inl x) (inr tt)})) <span class="kr">as</span> [p|np].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk14f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><label class="goal-separator" for="finite-v-chk14f"><hr></label><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk150">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk151">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>{x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk152"><span class="nb">destruct</span> p <span class="kr">as</span> [x r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk153"><span class="nb">refine</span> (finite_equiv&#39; (Quotient R&#39;&#39;) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient R&#39;&#39; &lt;~&gt; Quotient R&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk154"><span class="nb">refine</span> (Build_Equiv _ _ (Quotient_functor R&#39;&#39; R&#39; inl inlresp) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Quotient_functor R&#39;&#39; R&#39; inl inlresp)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk155"><span class="nb">apply</span> isequiv_surj_emb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk156" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk156"><hr></label><div class="goal-conclusion">IsEmbedding (Quotient_functor R&#39;&#39; R&#39; inl inlresp)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk157">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk158"><span class="nb">apply</span> BuildIsSurjection.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Quotient R&#39;,
merely
  (hfiber (Quotient_functor R&#39;&#39; R&#39; inl inlresp) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk159"><span class="nb">refine</span> (Quotient_ind_hprop R&#39; _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Fin n.+<span class="mi">1</span>,
merely
  (hfiber (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (class_of R&#39; a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk15a"><span class="nb">intros</span> [y|[]]; <span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (class_of R&#39; (inl y))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk15b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk15b"><hr></label><div class="goal-conclusion">hfiber (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (class_of R&#39; (inr tt))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk15c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (class_of R&#39; (inl y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> (<span class="nv">class_of</span> <span class="nv">R&#39;&#39;</span> <span class="nv">y</span>); <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk15d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (class_of R&#39; (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk15e"><span class="kr">exists</span> (<span class="nv">class_of</span> <span class="nv">R&#39;&#39;</span> <span class="nv">x</span>); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R&#39; (inl x) = class_of R&#39; (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> qglue, r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk15f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (Quotient_functor R&#39;&#39; R&#39; inl inlresp)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk160"><span class="nb">apply</span> isembedding_isinj_hset; <span class="nb">intros</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Quotient R&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Quotient R&#39;&#39;,
Quotient_functor R&#39;&#39; R&#39; inl inlresp u =
Quotient_functor R&#39;&#39; R&#39; inl inlresp y -&gt; u = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk161"><span class="nb">refine</span> (Quotient_ind_hprop R&#39;&#39; _ _); <span class="nb">intros</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Quotient R&#39;&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R&#39;&#39; R&#39; inl inlresp u =
Quotient_functor R&#39;&#39; R&#39; inl inlresp (class_of R&#39;&#39; v) -&gt;
u = class_of R&#39;&#39; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk162"><span class="nb">revert</span> u; <span class="nb">refine</span> (Quotient_ind_hprop R&#39;&#39; _ _); <span class="nb">intros</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br><span><var>v, u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R&#39;&#39; R&#39; inl inlresp (class_of R&#39;&#39; u) =
Quotient_functor R&#39;&#39; R&#39; inl inlresp (class_of R&#39;&#39; v) -&gt;
class_of R&#39;&#39; u = class_of R&#39;&#39; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk163"><span class="nb">simpl</span>; <span class="nb">intros</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br><span><var>v, u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>class_of R&#39; (inl u) = class_of R&#39; (inl v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R&#39;&#39; u = class_of R&#39;&#39; v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk164"><span class="nb">apply</span> qglue; <span class="nb">unfold</span> R&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R&#39; (inl x) (inr tt)</span></span></span><br><span><var>v, u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>class_of R&#39; (inl u) = class_of R&#39; (inl v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R&#39; (inl u) (inl v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (related_quotient_paths R&#39; (inl u) (inl v) q).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk165">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk166">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Finite (Quotient R&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk167"><span class="nb">refine</span> (finite_equiv&#39; (Quotient R&#39;&#39; + Unit) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient R&#39;&#39; + Unit &lt;~&gt; Quotient R&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk168"><span class="nb">refine</span> (Build_Equiv _ _ (sum_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Quotient R&#39;)
                                        (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
                                        (<span class="kr">fun</span> <span class="nv">_</span> =&gt; class_of R&#39; (inr tt))) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk169"><span class="nb">apply</span> isequiv_surj_emb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk16a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><label class="goal-separator" for="finite-v-chk16a"><hr></label><div class="goal-conclusion">IsEmbedding
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk16b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk16c"><span class="nb">apply</span> BuildIsSurjection.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Quotient R&#39;,
merely
  (hfiber
     (sum_ind
        (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
        (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
        (unit_name (class_of R&#39; (inr tt)))) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk16d"><span class="nb">refine</span> (Quotient_ind_hprop R&#39; _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Fin n.+<span class="mi">1</span>,
merely
  (hfiber
     (sum_ind
        (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
        (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
        (unit_name (class_of R&#39; (inr tt))))
     (class_of R&#39; a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk16e"><span class="nb">intros</span> [y|[]]; <span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))
  (class_of R&#39; (inl y))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk16f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><label class="goal-separator" for="finite-v-chk16f"><hr></label><div class="goal-conclusion">hfiber
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))
  (class_of R&#39; (inr tt))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk170">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))
  (class_of R&#39; (inl y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> (<span class="nv">inl</span> (class_of R&#39;&#39; y)); <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk171">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))
  (class_of R&#39; (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> (<span class="nv">inr</span> <span class="nv">tt</span>); <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk172">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (sum_ind
     (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
     (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
     (unit_name (class_of R&#39; (inr tt))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk173"><span class="nb">apply</span> isembedding_isinj_hset; <span class="nb">intros</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(Quotient R&#39;&#39; + Unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Quotient R&#39;&#39; + Unit,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) u =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) y -&gt; u = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk174"><span class="nb">refine</span> (sum_ind _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(Quotient R&#39;&#39; + Unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Quotient R&#39;&#39;,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) u =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) (inl a) -&gt;
u = inl a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk175" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(Quotient R&#39;&#39; + Unit)%type</span></span></span><br></div><label class="goal-separator" for="finite-v-chk175"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) u =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) 
  (inr b) -&gt; u = inr b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk176">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(Quotient R&#39;&#39; + Unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Quotient R&#39;&#39;,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) u =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) (inl a) -&gt;
u = inl a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk177"><span class="nb">refine</span> (Quotient_ind_hprop R&#39;&#39; _ _); <span class="nb">intros</span> v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(Quotient R&#39;&#39; + Unit)%type</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) u =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt)))
  (inl (class_of R&#39;&#39; v)) -&gt; u = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk178"><span class="nb">revert</span> u; <span class="nb">refine</span> (sum_ind _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Quotient R&#39;&#39;,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) (inl a) =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt)))
  (inl (class_of R&#39;&#39; v)) -&gt;
inl a = inl (class_of R&#39;&#39; v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk179" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><label class="goal-separator" for="finite-v-chk179"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) 
  (inr b) =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt)))
  (inl (class_of R&#39;&#39; v)) -&gt;
inr b = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk17a">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Quotient R&#39;&#39;,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) (inl a) =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt)))
  (inl (class_of R&#39;&#39; v)) -&gt;
inl a = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk17b"><span class="nb">refine</span> (Quotient_ind_hprop R&#39;&#39; _ _); <span class="nb">intros</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v, u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt)))
  (inl (class_of R&#39;&#39; u)) =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt)))
  (inl (class_of R&#39;&#39; v)) -&gt;
inl (class_of R&#39;&#39; u) = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk17c"><span class="nb">simpl</span>; <span class="nb">intros</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v, u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>class_of R&#39; (inl u) = class_of R&#39; (inl v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl (class_of R&#39;&#39; u) = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk17d"><span class="nb">apply</span> ap, qglue; <span class="nb">unfold</span> R&#39;&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v, u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>class_of R&#39; (inl u) = class_of R&#39; (inl v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R&#39; (inl u) (inl v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (related_quotient_paths R&#39; (inl u) (inl v) q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk17e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) (inr b) =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt)))
  (inl (class_of R&#39;&#39; v)) -&gt;
inr b = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk17f"><span class="nb">intros</span> []; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R&#39; (inr tt) = class_of R&#39; (inl v) -&gt;
inr tt = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk180"><span class="nb">intros</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>class_of R&#39; (inr tt) = class_of R&#39; (inl v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inr tt = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk181"><span class="nb">apply</span> related_quotient_paths <span class="kr">in</span> q; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>R&#39; (inr tt) (inl v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inr tt = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk182"><span class="nb">apply</span> <span class="nb">symmetry in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>R&#39; (inl v) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inr tt = inl (class_of R&#39;&#39; v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elim</span> (np (tr (v ; q))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk183">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(Quotient R&#39;&#39; + Unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit,
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) u =
sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) (inr b) -&gt;
u = inr b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk184"><span class="nb">intros</span> []; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(Quotient R&#39;&#39; + Unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind (<span class="kr">fun</span> <span class="nv">_</span> : Quotient R&#39;&#39; + Unit =&gt; Quotient R&#39;)
  (Quotient_functor R&#39;&#39; R&#39; inl inlresp)
  (unit_name (class_of R&#39; (inr tt))) u =
class_of R&#39; (inr tt) -&gt; u = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk185"><span class="nb">destruct</span> u <span class="kr">as</span> [u|[]]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Quotient R&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R&#39;&#39; R&#39; inl inlresp u =
class_of R&#39; (inr tt) -&gt; inl u = inr tt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk186" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><label class="goal-separator" for="finite-v-chk186"><hr></label><div class="goal-conclusion">class_of R&#39; (inr tt) = class_of R&#39; (inr tt) -&gt;
inr tt = inr tt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk187">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Quotient R&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R&#39;&#39; R&#39; inl inlresp u =
class_of R&#39; (inr tt) -&gt; inl u = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk188"><span class="nb">revert</span> u; <span class="nb">refine</span> (Quotient_ind_hprop R&#39;&#39; _ _); <span class="nb">intros</span> u; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R&#39; (inl u) = class_of R&#39; (inr tt) -&gt;
inl (class_of R&#39;&#39; u) = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk189"><span class="nb">intros</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>class_of R&#39; (inl u) = class_of R&#39; (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl (class_of R&#39;&#39; u) = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk18a"><span class="nb">apply</span> related_quotient_paths <span class="kr">in</span> q; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>R&#39; (inl u) (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl (class_of R&#39;&#39; u) = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elim</span> (np (tr (u;q))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk18b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">R&#39;</span> : Fin n -&gt; Fin n -&gt; <span class="kt">Type</span>,
is_mere_relation (Fin n) R&#39; -&gt;
Reflexive R&#39; -&gt;
Symmetric R&#39; -&gt;
Transitive R&#39; -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n, Decidable (R&#39; x y)) -&gt;
Finite (Quotient R&#39;)</span></span></span><br><span><var>R'</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin n.+<span class="mi">1</span> -&gt; <span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>is_mere_relation (Fin n.+<span class="mi">1</span>) R&#39;</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;</span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;</span></span></span><br><span><var>X3</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;</span></span></span><br><span><var>R'd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Fin n.+<span class="mi">1</span>, Decidable (R&#39; x y)</span></span></span><br><span><var>R''</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span>
  <span class="nv">x</span>
   <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | <span class="mi">0</span> =&gt; Empty
          | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
          <span class="kr">end</span>) n =&gt; 
R&#39; (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt;
(<span class="kr">fix</span> Fin (n : nat) : Type0 :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; Empty
   | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
   <span class="kr">end</span>) n -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>X4</var><span class="hyp-type"><b>: </b><span>is_mere_relation
  ((<span class="kr">fix</span> Fin (n : nat) : Type0 :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Empty
      | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
      <span class="kr">end</span>) n) R&#39;&#39;</span></span></span><br><span><var>X5</var><span class="hyp-type"><b>: </b><span>Reflexive R&#39;&#39;</span></span></span><br><span><var>X6</var><span class="hyp-type"><b>: </b><span>Symmetric R&#39;&#39;</span></span></span><br><span><var>X7</var><span class="hyp-type"><b>: </b><span>Transitive R&#39;&#39;</span></span></span><br><span><var>X8</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n, Decidable (R&#39;&#39; x y)</span></span></span><br><span><var>inlresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : (<span class="kr">fix</span> Fin (n : nat) : Type0 :=
        <span class="kr">match</span> n <span class="kr">with</span>
        | <span class="mi">0</span> =&gt; Empty
        | n0.+<span class="mi">1</span> =&gt; (Fin n0 + Unit)%type
        <span class="kr">end</span>) n,
R&#39;&#39; x y -&gt; R&#39; (inl x) (inl y)</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ merely {x : Fin n &amp; R&#39; (inl x) (inr tt)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R&#39; (inr tt) = class_of R&#39; (inr tt) -&gt;
inr tt = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Therefore, the cardinality of [X] is the sum of the cardinalities of its equivalence classes. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk18c"><span class="kn">Definition</span> <span class="nf">fcard_quotient</span>
  : fcard X = finadd (<span class="kr">fun</span> <span class="nv">z</span>:Quotient R =&gt; fcard {x:X &amp; in_class R z x}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X =
finadd
  (<span class="kr">fun</span> <span class="nv">z</span> : Quotient R =&gt;
   fcard
     {x : X &amp;
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; trunctype_type (in_class R z x0))
       x})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk18d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X =
finadd
  (<span class="kr">fun</span> <span class="nv">z</span> : Quotient R =&gt;
   fcard
     {x : X &amp;
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; trunctype_type (in_class R z x0))
       x})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk18e"><span class="nb">refine</span> (fcard_domain (class_of R) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finadd
  (<span class="kr">fun</span> <span class="nv">y</span> : Quotient R =&gt;
   fcard {x : X &amp; (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; class_of R x0 = y) x}) =
finadd
  (<span class="kr">fun</span> <span class="nv">z</span> : Quotient R =&gt;
   fcard
     {x : X &amp;
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; trunctype_type (in_class R z x0))
       x})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk18f"><span class="nb">apply</span> ap, path_arrow; <span class="nb">intros</span> z; <span class="nb">revert</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Quotient R,
fcard {x : X &amp; (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; class_of R x0 = z) x} =
fcard
  {x : X &amp;
  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; trunctype_type (in_class R z x0)) x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk190"><span class="nb">refine</span> (Quotient_ind_hprop _ _ _); <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard
  {x0 : X &amp;
  (<span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; class_of R x1 = class_of R x) x0} =
fcard {x0 : X &amp; (<span class="kr">fun</span> <span class="nv">x1</span> : X =&gt; R x x1) x0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk191"><span class="nb">apply</span> fcard_equiv&#39;; <span class="nb">unfold</span> hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : X &amp; class_of R x0 = class_of R x} &lt;~&gt;
{x0 : X &amp; R x x0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk192"><span class="nb">refine</span> (equiv_functor_sigma_id _); <span class="nb">intros</span> y; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R y = class_of R x &lt;~&gt; R x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk193"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R x y &lt;~&gt; class_of R y = class_of R x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk194"><span class="nb">refine</span> (path_quotient R y x oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation X</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation X R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Rd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, Decidable (R x y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R x y &lt;~&gt; R y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_iff_hprop; <span class="nb">apply</span> <span class="nb">symmetry</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">DecidableQuotients</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Injections *)</span>

<span class="sd">(** An injection between finite sets induces an inequality between their cardinalities. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk195"><span class="kn">Definition</span> <span class="nf">leq_inj_finite</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">fX</span> : Finite X} {<span class="nv">fY</span> : Finite Y}
           (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">i</span> : IsEmbedding f)
: fcard X &lt;= fcard Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>fY</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X &lt;= fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk196"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>fY</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X &lt;= fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk197"><span class="nb">assert</span> (MapIn (Tr (-<span class="mi">1</span>)) f) <span class="bp">by</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>fY</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X &lt;= fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk198"><span class="nb">clear</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>fY</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X &lt;= fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk199"><span class="nb">destruct</span> fX <span class="kr">as</span> [n e]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n)</span></span></span><br><span><var>fY</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk19a"><span class="nb">destruct</span> fY <span class="kr">as</span> [m e&#39;]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>merely (Y &lt;~&gt; Fin m)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk19b">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk19c"><span class="nb">pose</span> (g := e&#39; o f o e^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>e&#39; o f o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk19d"><span class="nb">assert</span> (MapIn (Tr (-<span class="mi">1</span>)) g) <span class="bp">by</span> (<span class="nb">unfold</span> g; <span class="bp">exact</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>e&#39; o f o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk19e"><span class="nb">clearbody</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk19f"><span class="nb">clear</span> e e&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a0"><span class="nb">generalize dependent</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m),
MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a1"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin <span class="mi">0</span> -&gt; Fin m),
MapIn (Tr (-<span class="mi">1</span>)) g -&gt; <span class="mi">0</span> &lt;= m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1a2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n.+<span class="mi">1</span> -&gt; Fin m),
MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n.+<span class="mi">1</span> &lt;= m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a3"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n.+<span class="mi">1</span> -&gt; Fin m),
MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n.+<span class="mi">1</span> &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a4"><span class="nb">intros</span> m g ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a5"><span class="nb">assert</span> (i : IsInjective g) <span class="bp">by</span> (<span class="nb">apply</span> isinj_embedding; <span class="bp">exact</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a6"><span class="nb">destruct</span> m <span class="kr">as</span> [|m].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin <span class="mi">0</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1a7"><hr></label><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin <span class="mi">0</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elim</span> (g (inr tt)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1a9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1aa"><span class="nb">pose</span> (h := (fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ab"><span class="nb">assert</span> (MapIn (Tr (-<span class="mi">1</span>)) h) <span class="bp">by</span> (<span class="nb">unfold</span> h; <span class="bp">exact</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ac"><span class="nb">assert</span> (Ha : <span class="kr">forall</span> <span class="nv">a</span>:Fin n, is_inl (h (inl a))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1ad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1ad"><hr></label><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ae">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1af"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b0"><span class="nb">remember</span> (g (inl a)) <span class="kr">as</span> b <span class="nb">eqn</span>:p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m.+<span class="mi">1</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b1"><span class="nb">destruct</span> b <span class="kr">as</span> [b|[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1b2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1b2"><hr></label><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b4"><span class="nb">assert</span> (q : g (inl a) &lt;&gt; (g (inr tt))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (inl a) &lt;&gt; g (inr tt)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inl a) &lt;&gt; g (inr tt)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1b5"><hr></label><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (inl a) &lt;&gt; g (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b7"><span class="nb">intros</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>g (inl a) = g (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inl_ne_inr _ _ (i _ _ r)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inl a) &lt;&gt; g (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1b9"><span class="nb">rewrite</span> p <span class="kr">in</span> q; <span class="nb">apply</span> symmetric_neq <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inr tt) &lt;&gt; inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ba"><span class="nb">assert</span> (r : h (inl a) = inl b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inr tt) &lt;&gt; inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (inl a) = inl b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1bb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inr tt) &lt;&gt; inl b</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>h (inl a) = inl b</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1bb"><hr></label><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1bc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inr tt) &lt;&gt; inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (inl a) = inl b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1bd"><span class="nb">unfold</span> h; <span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inr tt) &lt;&gt; inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_transpose_last_with m (g (inr tt)) (inl b) =
g (inl a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fin_transpose_last_with_rest m (g (inr tt)) b q @ p^).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1be">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Fin m</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inl b</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g (inr tt) &lt;&gt; inl b</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>h (inl a) = inl b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> r; <span class="bp">exact</span> tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1bf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c0"><span class="nb">assert</span> (q : h (inl a) = g (inr tt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (inl a) = g (inr tt)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inl a) = g (inr tt)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1c1"><hr></label><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (inl a) = g (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c3"><span class="nb">unfold</span> h; <span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_transpose_last_with m (g (inr tt)) (g (inr tt)) =
g (inl a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (_ @ p^); <span class="nb">apply</span> fin_transpose_last_with_with.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inl a) = g (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (h (inl a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c5"><span class="nb">rewrite</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inl a) = g (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (g (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c6"><span class="nb">destruct</span> (is_inl_or_is_inr (g (inr tt))) <span class="kr">as</span> [l|r]; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inl a) = g (inr tt)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>is_inr (g (inr tt))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (g (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c7"><span class="nb">assert</span> (s := inr_un_inr _ r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inl a) = g (inr tt)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>is_inr (g (inr tt))</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inr (un_inr (g (inr tt)) r) = g (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (g (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c8"><span class="nb">revert</span> s; <span class="nb">generalize</span> (un_inr (g (inr tt)) r); <span class="nb">intros</span> [] s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (inl a) = inr tt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inl a) = g (inr tt)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>is_inr (g (inr tt))</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inr tt = g (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (g (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elim</span> (inl_ne_inr _ _ (i _ _ (p @ s))).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1c9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ca"><span class="nb">assert</span> (Hb : <span class="kr">forall</span> <span class="nv">b</span>:Unit, is_inr (h (inr b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit, is_inr (h (inr b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Unit, is_inr (h (inr b))</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1cb"><hr></label><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1cc">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit, is_inr (h (inr b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1cd"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inr (h (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ce"><span class="nb">assert</span> (q : h (inr tt) = inr tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (inr tt) = inr tt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1cf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inr tt) = inr tt</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1cf"><hr></label><div class="goal-conclusion">is_inr (h (inr tt))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (inr tt) = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d1"><span class="nb">unfold</span> h; <span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_transpose_last_with m (g (inr tt)) (inr tt) =
g (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fin_transpose_last_with_last.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d2">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h (inr tt) = inr tt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inr (h (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> q; <span class="bp">exact</span> tt.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Unit, is_inr (h (inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.+<span class="mi">1</span> &lt;= m.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d4"><span class="nb">apply</span> leq_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">g</span> : Fin n -&gt; Fin m), MapIn (Tr (-<span class="mi">1</span>)) g -&gt; n &lt;= m</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsInjective g</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>(fin_transpose_last_with m (g (inr tt)))^-<span class="mi">1</span> o g</span></span><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span> -&gt; Fin m.+<span class="mi">1</span></span></span></span></span><br><span><var>X2</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) h</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Fin n, is_inl (h (inl a))</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Unit, is_inr (h (inr b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IHn m (unfunctor_sum_l h Ha)
             (mapinO_unfunctor_sum_l (Tr (-<span class="mi">1</span>)) h Ha Hb)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Surjections  *)</span>
<span class="sd">(** A surjection between finite sets induces an inequality between their cardinalities. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d5"><span class="kn">Definition</span> <span class="nf">geq_surj_finite</span>  {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">fX</span> : Finite X} {<span class="nv">fY</span> : Finite Y}
           (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">i</span> : IsSurjection f)
  : fcard X &gt;= fcard Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>fY</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X &gt;= fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>fX</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>fY</var><span class="hyp-type"><b>: </b><span>Finite Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard X &gt;= fcard Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d7"><span class="nb">destruct</span> fX <span class="kr">as</span> [n e], fY <span class="kr">as</span> [m e&#39;]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>merely (Y &lt;~&gt; Fin m)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d8"><span class="nb">assert</span> (k := isprojective_fin_n m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>merely (X &lt;~&gt; Fin n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>merely (Y &lt;~&gt; Fin m)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1d9">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1da"><span class="nb">pose</span> (g := e&#39; o f o e^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>e&#39; o f o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1db"><span class="nb">assert</span> (k&#39; : IsSurjection g) <span class="bp">by</span> <span class="bp">exact</span> _ .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>e&#39; o f o e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1dc"><span class="nb">clearbody</span> g; <span class="nb">clear</span> i f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1dd"><span class="nb">assert</span> (j := k (Fin n) _ (Fin m) _ idmap g k&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>merely {s : Fin m -&gt; Fin n &amp; g o s == idmap}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1de">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>{s : Fin m -&gt; Fin n &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : Fin m =&gt; g (s x)) == idmap}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1df"><span class="nb">simpl</span>; <span class="nb">destruct</span> j <span class="kr">as</span> [s is_section].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Fin m -&gt; Fin n</span></span></span><br><span><var>is_section</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Fin m =&gt; g (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e0"><span class="nb">change</span> n <span class="kr">with</span> (fcard (Fin n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Fin m -&gt; Fin n</span></span></span><br><span><var>is_section</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Fin m =&gt; g (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n) &gt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e1"><span class="nb">change</span> m <span class="kr">with</span> (fcard (Fin m)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Fin m -&gt; Fin n</span></span></span><br><span><var>is_section</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Fin m =&gt; g (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fcard (Fin n) &gt;= fcard (Fin m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e2"><span class="nb">apply</span> (leq_inj_finite s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsProjective (Fin m)</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>Y &lt;~&gt; Fin m</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; Fin n</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Fin n -&gt; Fin m</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) g</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Fin m -&gt; Fin n</span></span></span><br><span><var>is_section</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : Fin m =&gt; g (s x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isembedding_isinj_hset, (isinj_section is_section).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Enumerations *)</span>

<span class="sd">(** A function from [nat] to a finite set must repeat itself eventually. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Enumeration</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext} {X} `{Finite@{_ <span class="kt">Set</span> _} X} (e : nat -&gt; X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">er</span> (<span class="nv">n</span> : nat) : Fin n -&gt; X
    := <span class="kr">fun</span> <span class="nv">k</span> =&gt; e (nat_fin n k).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e3"><span class="kn">Lemma</span> <span class="nf">finite_enumeration_stage</span> (<span class="nv">n</span> : nat)
  : IsEmbedding (er n)
    + { n : nat &amp; { k : nat &amp; e n = e (n + k).+<span class="mi">1</span> }}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er n) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er n) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e5"><span class="nb">induction</span> n <span class="kr">as</span> [|n [IH|IH]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er <span class="mi">0</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1e6"><hr></label><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote><input class="alectryon-extra-goal-toggle" id="finite-v-chk1e7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1e7"><hr></label><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er <span class="mi">0</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1e9"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (er <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ea"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (hfiber (er <span class="mi">0</span>) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> hprop_inhabited_contr; <span class="nb">intros</span> [[] _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1eb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ec"><span class="nb">destruct</span> (detachable_image_finite (er n) (er n.+<span class="mi">1</span> (inr tt)))
        <span class="kr">as</span> [[k p]|ne].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n k = er n.+<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1ed" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1ed"><hr></label><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ee">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n k = er n.+<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ef"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n k = er n.+<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f0"><span class="kr">exists</span> (<span class="nv">nat_fin</span> <span class="nv">n</span> <span class="nv">k</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n k = er n.+<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{k0 : nat &amp; e (nat_fin n k) = e (nat_fin n k + k0).+<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f1"><span class="kr">exists</span> (<span class="nv">nat_fin_compl</span> <span class="nv">n</span> <span class="nv">k</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n k = er n.+<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e (nat_fin n k) =
e (nat_fin n k + nat_fin_compl n k).+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f2"><span class="nb">rewrite</span> nat_fin_compl_compl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n k = er n.+<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e (nat_fin n k) = e n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f4"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (er n.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f5"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (hfiber (er n.+<span class="mi">1</span>) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f6"><span class="nb">apply</span> hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : hfiber (er n.+<span class="mi">1</span>) x, x0 = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f7"><span class="nb">intros</span> k l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k, l</var><span class="hyp-type"><b>: </b><span>hfiber (er n.+<span class="mi">1</span>) x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f8"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k, l</var><span class="hyp-type"><b>: </b><span>hfiber (er n.+<span class="mi">1</span>) x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k.<span class="mi">1</span> = l.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1f9"><span class="nb">destruct</span> k <span class="kr">as</span> [[k|[]] p], l <span class="kr">as</span> [[l|[]] q]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl k = inl l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk1fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1fa"><hr></label><div class="goal-conclusion">inl k = inr tt</div></blockquote><input class="alectryon-extra-goal-toggle" id="finite-v-chk1fb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1fb"><hr></label><div class="goal-conclusion">inr tt = inl l</div></blockquote><input class="alectryon-extra-goal-toggle" id="finite-v-chk1fc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br></div><label class="goal-separator" for="finite-v-chk1fc"><hr></label><div class="goal-conclusion">inr tt = inr tt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1fd">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl k = inl l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1fe"><span class="nb">apply</span> isinj_embedding <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsInjective (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl k = inl l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk1ff"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsInjective (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk200"><span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsInjective (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">er n k = er n l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk201"><span class="nb">unfold</span> er <span class="kr">in</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsInjective (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>e (nat_fin n.+<span class="mi">1</span> (inl k)) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e (nat_fin n.+<span class="mi">1</span> (inl l)) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">er n k = er n l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk202"><span class="nb">simpl</span> <span class="kr">in</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsInjective (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>e (nat_fin n k) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>e (nat_fin n l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">er n k = er n l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p @ q^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk203">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl k = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk204"><span class="nb">refine</span> (Empty_rec (ne _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk205"><span class="kr">exists</span> <span class="nv">k</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl k) = x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">er n k = er n.+<span class="mi">1</span> (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p @ q^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk206">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inr tt = inl l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk207"><span class="nb">refine</span> (Empty_rec (ne _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk208"><span class="kr">exists</span> <span class="nv">l</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inl l) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">er n l = er n.+<span class="mi">1</span> (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (q @ p^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk209">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er n)</span></span></span><br><span><var>ne</var><span class="hyp-type"><b>: </b><span>~ hfiber (er n) (er n.+<span class="mi">1</span> (inr tt))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>er n.+<span class="mi">1</span> (inr tt) = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inr tt = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk20a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(IsEmbedding (er n.+<span class="mi">1</span>) +
 {n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}})%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="bp">exact</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk20b"><span class="kn">Definition</span> <span class="nf">finite_enumeration_repeats</span>
  : { n : nat &amp; { k : nat &amp; e n = e (n + k).+<span class="mi">1</span> }}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk20c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk20d"><span class="nb">destruct</span> (finite_enumeration_stage (fcard X).+<span class="mi">1</span>) <span class="kr">as</span> [p|?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er (fcard X).+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finite-v-chk20e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</span></span></span><br></div><label class="goal-separator" for="finite-v-chk20e"><hr></label><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk20f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er (fcard X).+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk210"><span class="nb">assert</span> (q := leq_inj_finite (er (fcard X).+<span class="mi">1</span>) p); <span class="nb">simpl</span> <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>IsEmbedding (er (fcard X).+<span class="mi">1</span>)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(fcard X).+<span class="mi">1</span> &lt;= fcard X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elim</span> (lt_irrefl _ q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finite-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="finite-v-chk211">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Finite X</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>nat -&gt; X</span></span></span><br><span><var>er</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">k</span> : Fin n) =&gt; e (nat_fin n k)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, Fin n -&gt; X</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{n : nat &amp; {k : nat &amp; e n = e (n + k).+<span class="mi">1</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Enumeration</span>.</span></span></pre>
</div>
</div></body>
</html>
