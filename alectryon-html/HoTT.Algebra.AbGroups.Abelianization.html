<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Abelianization.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types Truncations.Core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT.WildCat <span class="kn">Require Import</span> Core Equiv EquivGpd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Cubical.DPath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Coeq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.AbGroups.AbelianGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.ReflectiveSubuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Abelianization *)</span>

<span class="sd">(** In this file we define what it means for a group homomorphism [G -&gt; H] into an abelian group [H] to be an abelianization. We then construct an example of an abelianization. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> wc_iso_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Definition of abelianization.</span>

<span class="sd">  A &quot;unit&quot; homomorphism [eta : G -&gt; G_ab], with [G_ab] abelian, is considered an abelianization if and only if for all homomorphisms [G -&gt; A], where [A] is abelian, there exists a unique [g : G_ab -&gt; A] such that [h == g o eta X].   We express this in funext-free form by saying that precomposition with [eta] in the wild 1-category [Group] induces an equivalence of hom 0-groupoids, in the sense of WildCat/EquivGpd.</span>

<span class="sd">  Unfortunately, if [eta : GroupHomomorphism G G_ab] and we write [cat_precomp A eta] then Coq is unable to guess that the relevant 1-category is [Group].  Even writing [cat_precomp (A := Group) A eta] isn&#39;t good enough, I guess because the typeclass inference that finds the instance [is01cat_group] doesn&#39;t happen until after the type of [eta] would have to be resolved to a [Hom] in some wild category.  However, with the following auxiliary definition we can force the typeclass inference to happen first.  (It would be worth thinking about whether the design of the wild categories library could be improved to avoid this.)  *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">group_precomp</span> {<span class="nv">a</span> <span class="nv">b</span>} := @cat_precomp Group _ _ a b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsAbelianization</span> {<span class="nv">G</span> : Group} (<span class="nv">G_ab</span> : AbGroup)
      (<span class="nv">eta</span> : GroupHomomorphism G G_ab)
  := issurjinj_isabel :: <span class="kr">forall</span> (<span class="nv">A</span> : AbGroup),
      IsSurjInj (group_precomp A eta).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1"><span class="kn">Definition</span> <span class="nf">isequiv_group_precomp_isabelianization</span> `{Funext}
  {G : Group} {G_ab : AbGroup} (eta : GroupHomomorphism G G_ab)
  `{!IsAbelianization G_ab eta} (A : AbGroup)
  : IsEquiv (group_precomp A eta).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (group_precomp A eta)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (group_precomp A eta)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3">snapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G $-&gt; A) -&gt; G_ab $-&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk4"><hr></label><div class="goal-conclusion">group_precomp A eta o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk5"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o group_precomp A eta == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G $-&gt; A) -&gt; G_ab $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G_ab $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (surjinj_inv (group_precomp A eta) g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_precomp A eta
o (<span class="kr">fun</span> <span class="nv">g</span> : G $-&gt; A =&gt;
   surjinj_inv (group_precomp A eta) g) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_precomp A eta
  (surjinj_inv (group_precomp A eta) f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka">snapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_precomp A eta
  (surjinj_inv (group_precomp A eta) f) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (eisretr0gpd_inv (group_precomp A eta) f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">g</span> : G $-&gt; A =&gt;
 surjinj_inv (group_precomp A eta) g)
o group_precomp A eta == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkc"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G_ab $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">surjinj_inv (group_precomp A eta)
  (group_precomp A eta f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkd">snapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>G_ab</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G G_ab</span></span></span><br><span><var>IsAbelianization0</var><span class="hyp-type"><b>: </b><span>IsAbelianization G_ab eta</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G_ab $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">surjinj_inv (group_precomp A eta)
  (group_precomp A eta f) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (eissect0gpd_inv (group_precomp A eta) f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_group_precomp_isabelianization</span> `{Funext}
  {G : Group} {G_ab : AbGroup} (eta : GroupHomomorphism G G_ab)
  `{!IsAbelianization G_ab eta} (A : AbGroup)
  : (G_ab $-&gt; A) &lt;~&gt; (G $-&gt; A)
  := Build_Equiv _ _ _ (isequiv_group_precomp_isabelianization eta A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here we define abelianization as a HIT. Specifically as a set-coequalizer of the following two maps [fun &#39;(a, b, c) =&gt; a * (b * c)] and [fun &#39;(a, b, c) =&gt; a * (c * b)].</span>

<span class="sd">From this we can show that Abel G is an abelian group.</span>

<span class="sd">In fact this models the following HIT:</span>

<span class="sd">&lt;&lt;</span>
<span class="sd">HIT Abel (G : Group) := </span>
<span class="sd"> | abel_in : G -&gt; Abel G</span>
<span class="sd"> | abel_in_comm : forall x y z, abel_in (x * (y * z)) = abel_in (x * (z * y)).</span>
<span class="sd">&gt;&gt;</span>

<span class="sd">We also derive [abel_in] and [abel_in_comm] from our coequalizer definition, and even prove the induction and computation rules for this HIT.</span>

<span class="sd">This HIT was suggested by Dan Christensen. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Abel</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Let G be a group. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">G</span> : Group).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We locally define a map uncurry2 that lets us uncurry [A * B * C -&gt; D] twice. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">uncurry2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>}
    : (A -&gt; B -&gt; C -&gt; D) -&gt; A * B * C -&gt; D
    := <span class="kr">fun</span> <span class="nv">f</span> &#39;(a, b, c) =&gt; f a b c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The type [Abel] is defined to be the set coequalizer of the following maps [G^3 -&gt; G]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Abel</span>
    := Tr <span class="mi">0</span> (Coeq
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We have a natural map from [G] to [Abel G]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abel_in</span> : G -&gt; Abel := tr o coeq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This map satisfies the condition [ab_comm]. It&#39;s a form of commutativity in a right factor. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abel_in_comm</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>
    : abel_in (a * (b * c)) = abel_in (a * (c * b))
    := ap tr (cglue (a, b, c)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** It is clear that Abel is a set. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">istrunc_abel</span> : IsHSet Abel := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We can derive the induction principle from the ones for truncation and the coequalizer. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chke"><span class="kn">Definition</span> <span class="nf">Abel_ind</span> (<span class="nv">P</span> : Abel -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)} 
    (a : <span class="kr">forall</span> <span class="nv">x</span>, P (abel_in x))
    (c : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, abel_in_comm x y z # a (x * (y * z)) = a (x * (z * y)))
    : <span class="kr">forall</span> (<span class="nv">x</span> : Abel), P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk10">rapply Trunc_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : Coeq (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b))),
P (tr a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk11">snapply Coeq_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : G,
(<span class="kr">fun</span>
   <span class="nv">w</span> : Coeq
         (uncurry2 (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a0 * (b * c)))
         (uncurry2 (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a0 * (c * b)))
 =&gt; P (tr w)) (coeq a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk12"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : G * G * G,
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)))
   =&gt; P (tr w)) (cglue b)
  (<span class="nl">?coeq&#39;</span>
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)) b)) =
<span class="nl">?coeq&#39;</span> (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)) b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk13"><span class="mi">1</span>: <span class="bp">exact</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : G * G * G,
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)))
   =&gt; P (tr w)) (cglue b)
  (a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)) b)) =
a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk14"><span class="nb">intros</span> [[x y] z].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)))
   =&gt; P (tr w)) (cglue (x, y, z))
  (a
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c))
        (x, y, z))) =
a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)) (x, y, z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk15">nrefine (transport_compose _ _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (ap tr (cglue (x, y, z)))
  (a
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c))
        (x, y, z))) =
a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)) (x, y, z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The computation rule on point constructors holds definitionally. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Abel_ind_beta_abel_in</span> (<span class="nv">P</span> : Abel -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)}
    (a : <span class="kr">forall</span> <span class="nv">x</span>, P (abel_in x))
    (c : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, DPath P (abel_in_comm x y z) (a (x * (y * z))) (a (x * (z * y))))
    (x : G)
    : Abel_ind P a c (abel_in x) = a x
    := idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The computation rule on paths. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk16"><span class="kn">Definition</span> <span class="nf">Abel_ind_beta_abel_in_comm</span> (<span class="nv">P</span> : Abel -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)}
    (a : <span class="kr">forall</span> <span class="nv">x</span>, P (abel_in x))
    (c : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, abel_in_comm x y z # a (x * (y * z)) = a (x * (z * y)))
    (x y z : G)
    : apD (Abel_ind P a c) (abel_in_comm x y z) = c x y z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Abel_ind P a c) (abel_in_comm x y z) = c x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Abel_ind P a c) (abel_in_comm x y z) = c x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk18">nrefine (apD_compose&#39; tr _ _ @ ap _ _ @ concat_V_pp _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport P (abel_in_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD
  (<span class="kr">fun</span>
     <span class="nv">x</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)))
   =&gt; Abel_ind P a c (tr x)) (cglue (x, y, z)) =
transport_compose P tr (cglue (x, y, z))
  (Abel_ind P a c (tr (coeq (x * (y * z))))) @ c x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply Coeq_ind_beta_cglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We also have a recursion principle. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk19"><span class="kn">Definition</span> <span class="nf">Abel_rec</span> (<span class="nv">P</span> : <span class="kt">Type</span>) `{IsHSet P} (a : G -&gt; P)
    (c : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, a (x * (y * z)) = a (x * (z * y)))
    : Abel -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G -&gt; P</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
a (x * (y * z)) = a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Abel -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G -&gt; P</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
a (x * (y * z)) = a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Abel -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1b"><span class="nb">apply</span> (Abel_ind _ a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>G -&gt; P</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
a (x * (y * z)) = a (x * (z * y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
transport (<span class="kr">fun</span> <span class="nv">_</span> : Abel =&gt; P) (abel_in_comm x y z)
  (a (x * (y * z))) = a (x * (z * y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> dp_const, c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is a simpler version of [Abel_ind] when our target is an [HProp]. This lets us discard all the higher paths. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1c"><span class="kn">Definition</span> <span class="nf">Abel_ind_hprop</span> (<span class="nv">P</span> : Abel -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} 
    (a : <span class="kr">forall</span> <span class="nv">x</span>, P (abel_in x))
    : <span class="kr">forall</span> (<span class="nv">x</span> : Abel), P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1e">srapply Trunc_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : Coeq (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b))),
P (tr a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1f">srapply Coeq_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Abel -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, P (abel_in x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : G,
(<span class="kr">fun</span>
   <span class="nv">x</span> : Coeq
         (uncurry2 (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a0 * (b * c)))
         (uncurry2 (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a0 * (c * b)))
 =&gt; P (tr x)) (coeq a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Abel</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [IsHProp] argument of [Abel_ind_hprop] can usually be found by typeclass resolution, but [srapply] is slow, so we use this tactic instead. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Ltac</span> <span class="nf">Abel_ind_hprop</span> x := snapply Abel_ind_hprop; [<span class="bp">exact</span> _ | <span class="nb">intro</span> x].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We make sure that [G] is implicit in the arguments of [abel_in]</span>
<span class="sd"> and [abel_in_comm]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> abel_in {_} g%_mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> abel_in_comm {_} (a b c)%_mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we can show that [Abel G] is in fact an abelian group. We will denote the operation in [Abel G] by the multiplicative [*] notation even though it is later shown to be commutative. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AbelGroup</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">G</span> : Group).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Firstly we define the operation on [Abel G]. This is defined as follows:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">        abel_in x * abel_in y := abel_in (x * y)</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">      But we need to also check that it preserves [ab_comm] in the appropriate way. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk20">#[export] <span class="kn">Instance</span> <span class="nf">sgop_abel</span> : SgOp (Abel G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (Abel G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (Abel G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk22"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Abel G -&gt; Abel G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk23">srapply Abel_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; Abel G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk24"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, <span class="nl">?a</span> (x * (y * z)) = <span class="nl">?a</span> (x * (z * y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk25">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; Abel G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk26"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Abel G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk27"><span class="nb">revert</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Abel G -&gt; Abel G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk28">srapply Abel_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; Abel G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk29"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, <span class="nl">?a</span> (x * (y * z)) = <span class="nl">?a</span> (x * (z * y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; Abel G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2b"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Abel G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abel_in (a * b)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
(<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; abel_in (a * b)) (x * (y * z)) =
(<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; abel_in (a * b)) (x * (z * y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2d"><span class="nb">intros</span> a c d; <span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * (c * d) * b) = abel_in (a * (d * c) * b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* The pattern seems to be to alternate [associativity] and [ab_comm]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2e"><span class="nb">refine</span> (ap _ (associativity _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * (c * d * b)) = abel_in (a * (d * c) * b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2f"><span class="nb">refine</span> (abel_in_comm _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * (b * (c * d))) =
abel_in (a * (d * c) * b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk30"><span class="nb">refine</span> (ap _ (associativity _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * b * (c * d)) = abel_in (a * (d * c) * b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk31"><span class="nb">refine</span> (abel_in_comm _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * b * (d * c)) = abel_in (a * (d * c) * b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk32"><span class="nb">refine</span> (ap _ (associativity _ _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * (b * (d * c))) =
abel_in (a * (d * c) * b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk33"><span class="nb">refine</span> (abel_in_comm _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, a, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * (d * c * b)) = abel_in (a * (d * c) * b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (associativity _ _ _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk34">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; abel_in (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap abel_in (associativity a (c * d) b)^ @
    (abel_in_comm a (c * d) b @
     (ap abel_in (associativity a b (c * d)) @
      (abel_in_comm (a * b) c d @
       (ap abel_in (associativity a b (d * c))^ @
        (abel_in_comm a b (d * c) @
         ap abel_in (associativity a (d * c) b))))))
    :
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (c * d)) =
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (d * c))) a)
  (x * (y * z)) =
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; abel_in (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap abel_in (associativity a (c * d) b)^ @
    (abel_in_comm a (c * d) b @
     (ap abel_in (associativity a b (c * d)) @
      (abel_in_comm (a * b) c d @
       (ap abel_in (associativity a b (d * c))^ @
        (abel_in_comm a b (d * c) @
         ap abel_in (associativity a (d * c) b))))))
    :
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (c * d)) =
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (d * c))) a)
  (x * (z * y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk35"><span class="nb">intros</span> b c d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br><span><var>b, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; abel_in (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap abel_in (associativity a (c * d) b)^ @
    (abel_in_comm a (c * d) b @
     (ap abel_in (associativity a b (c * d)) @
      (abel_in_comm (a * b) c d @
       (ap abel_in (associativity a b (d * c))^ @
        (abel_in_comm a b (d * c) @
         ap abel_in (associativity a (d * c) b))))))
    :
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (c * d)) =
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (d * c))) a)
  (b * (c * d)) =
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; abel_in (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap abel_in (associativity a (c * d) b)^ @
    (abel_in_comm a (c * d) b @
     (ap abel_in (associativity a b (c * d)) @
      (abel_in_comm (a * b) c d @
       (ap abel_in (associativity a b (d * c))^ @
        (abel_in_comm a b (d * c) @
         ap abel_in (associativity a (d * c) b))))))
    :
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (c * d)) =
    (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b)) (a * (d * c))) a)
  (b * (d * c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk36"><span class="nb">revert</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, c, d</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b))
   (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap abel_in (associativity a0 (c * d) b)^ @
    (abel_in_comm a0 (c * d) b @
     (ap abel_in (associativity a0 b (c * d)) @
      (abel_in_comm (a0 * b) c d @
       (ap abel_in (associativity a0 b (d * c))^ @
        (abel_in_comm a0 b (d * c) @
         ap abel_in (associativity a0 (d * c) b))))))
    :
    (<span class="kr">fun</span> <span class="nv">a1</span> : G =&gt; abel_in (a1 * b)) (a0 * (c * d)) =
    (<span class="kr">fun</span> <span class="nv">a1</span> : G =&gt; abel_in (a1 * b)) (a0 * (d * c))) a)
  (b * (c * d)) =
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; abel_in (a0 * b))
   (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap abel_in (associativity a0 (c * d) b)^ @
    (abel_in_comm a0 (c * d) b @
     (ap abel_in (associativity a0 b (c * d)) @
      (abel_in_comm (a0 * b) c d @
       (ap abel_in (associativity a0 b (d * c))^ @
        (abel_in_comm a0 b (d * c) @
         ap abel_in (associativity a0 (d * c) b))))))
    :
    (<span class="kr">fun</span> <span class="nv">a1</span> : G =&gt; abel_in (a1 * b)) (a0 * (c * d)) =
    (<span class="kr">fun</span> <span class="nv">a1</span> : G =&gt; abel_in (a1 * b)) (a0 * (d * c))) a)
  (b * (d * c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk37">Abel_ind_hprop a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, c, d, a</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * (b * (c * d))) =
abel_in (a * (b * (d * c)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk38"><span class="nb">refine</span> (ap _ (associativity _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, c, d, a</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * b * (c * d)) =
abel_in (a * (b * (d * c)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk39"><span class="nb">refine</span> (abel_in_comm _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b, c, d, a</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (a * b * (d * c)) =
abel_in (a * (b * (d * c)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (associativity _ _ _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We can now easily show that this operation is associative by [associativity] in [G] and the fact that being associative is a proposition. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3a">#[export] <span class="kn">Instance</span> <span class="nf">associative_abel_sgop</span> : Associative (.*.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3c"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Abel G, x * (y * z) = x * y * z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3d">Abel_ind_hprop z; <span class="nb">revert</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt; x * (y * x0) = x * y * x0)
  (abel_in z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3e">Abel_ind_hprop y; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>z, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt;
 (<span class="kr">fun</span> <span class="nv">x1</span> : Abel G =&gt; x * (x0 * x1) = x * x0 * x1)
   (abel_in z)) (abel_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3f">Abel_ind_hprop x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>z, y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in x * (abel_in y * abel_in z) =
abel_in x * abel_in y * abel_in z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply (ap abel_in); <span class="nb">apply</span> associativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** From this we know that [Abel G] is a semigroup. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">issemigroup_abel</span> : IsSemiGroup (Abel G) := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We define the group unit as [abel_in] of the unit of [G] *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">monunit_abel_zero</span> : MonUnit (Abel G) := abel_in mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** By using Abel_ind_hprop we can prove the left and right identity laws. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk40">#[export] <span class="kn">Instance</span> <span class="nf">leftidentity_abel</span> : LeftIdentity (.*.) <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk42">Abel_ind_hprop x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * abel_in x = abel_in x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply (ap abel_in); <span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk43">#[export] <span class="kn">Instance</span> <span class="nf">rightidentity_abel</span> : RightIdentity (.*.) <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity sg_op <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk45">Abel_ind_hprop x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in x * <span class="mi">1</span> = abel_in x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply (ap abel_in); <span class="nb">apply</span> right_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Hence [Abel G] is a monoid *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ismonoid_abel</span> : IsMonoid (Abel G) := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We can also prove that the operation is commutative! This will come in handy later. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk46">#[export] <span class="kn">Instance</span> <span class="nf">commutative_abel</span> : Commutative (.*.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk48"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Abel G, x * y = y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk49">Abel_ind_hprop y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Abel G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt; x * x0 = x0 * x) (abel_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4a"><span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt; x * x0 = x0 * x) (abel_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4b">Abel_ind_hprop x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in x * abel_in y = abel_in y * abel_in x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4c"><span class="nb">refine</span> ((ap abel_in (left_identity _))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (<span class="mi">1</span> * (x * y)) = abel_in y * abel_in x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4d"><span class="nb">refine</span> (_ @ (ap abel_in (left_identity _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (<span class="mi">1</span> * (x * y)) = abel_in (<span class="mi">1</span> * (y * x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abel_in_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we can define the inverse operation. This is just</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">        (abel_in g)^ := abel_in g^</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">      However when checking that it respects [ab_comm] we have to show the following:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">        abel_in (z^ * y^ * x^) = abel_in (y^ * z^ * x^)</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">      there is no obvious way to do this, but we note that [abel_in (x * y)] is exactly the definition of [abel_in x * abel_in y]! Hence by [commutativity] we can show this. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4e">#[export] <span class="kn">Instance</span> <span class="nf">inverse_abel</span> : Inverse (Abel G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Inverse (Abel G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Inverse (Abel G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk50">srapply (Abel_rec _ _ (abel_in o inv)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
(abel_in o inv) (x * (y * z)) =
(abel_in o inv) (x * (z * y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk51"><span class="nb">intros</span> x y z; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (x * (y * z))^ = abel_in (x * (z * y))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk52">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * (y * z))^ = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk53"><hr></label><div class="goal-conclusion">abel_in <span class="nl">?Goal</span> = abel_in (x * (z * y))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk54"><span class="mi">2</span>: rhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * (y * z))^ = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk55"><hr></label><div class="goal-conclusion">abel_in <span class="nl">?Goal</span> = abel_in <span class="nl">?Goal1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk56"><hr></label><div class="goal-conclusion">(x * (z * y))^ = <span class="nl">?Goal1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk57"><span class="mi">1</span>,<span class="mi">3</span>: lhs rapply inverse_sg_op; napply (ap (.* _)); rapply inverse_sg_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in (z^ * y^ * x^) = abel_in (y^ * z^ * x^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk58"><span class="nb">change</span> (abel_in z^ * abel_in y^ * abel_in x^
      = abel_in y^ * abel_in z^ * abel_in x^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in z^ * abel_in y^ * abel_in x^ =
abel_in y^ * abel_in z^ * abel_in x^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk59"><span class="nb">apply</span> (ap (.* _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in z^ * abel_in y^ = abel_in y^ * abel_in z^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (commutativity (abel_in z^) (abel_in y^)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Again by [Abel_ind_hprop] and the corresponding laws for [G] we can prove the left and right inverse laws. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5a">#[export] <span class="kn">Instance</span> <span class="nf">leftinverse_abel</span> : LeftInverse (.*.) (^) <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5c">Abel_ind_hprop x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abel_in x)^ * abel_in x = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply (ap abel_in); <span class="nb">apply</span> left_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5d"><span class="kn">Instance</span> <span class="nf">rightinverse_abel</span> : RightInverse (.*.) (^) <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightInverse sg_op inv <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5f">Abel_ind_hprop x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in x * (abel_in x)^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply (ap abel_in); <span class="nb">apply</span> right_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Thus [Abel G] is a group *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isgroup_abel</span> : IsGroup (Abel G) := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And furthermore, since the operation is commutative, it is an abelian group. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isabgroup_abel</span> : IsAbGroup (Abel G) := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** By definition, the map [abel_in] is also a group homomorphism. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk60">#[export] <span class="kn">Instance</span> <span class="nf">issemigrouppreserving_abel_in</span> : IsSemiGroupPreserving abel_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving abel_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk61"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving abel_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> IsSemiGroupPreserving.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AbelGroup</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can easily prove that [abel_in] is a surjection. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk62"><span class="kn">Instance</span> <span class="nf">issurj_abel_in</span> {<span class="nv">G</span> : Group} : IsSurjection (@abel_in G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) abel_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk63"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) abel_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk64"><span class="nb">apply</span> BuildIsSurjection.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Abel G, merely (hfiber abel_in b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk65">Abel_ind_hprop x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (hfiber abel_in (abel_in x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk66"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber abel_in (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk67"><span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_in x = abel_in x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we finally check that our definition of abelianization satisfies the universal property of being an abelianization. *)</span>

<span class="sd">(** We define [abel] to be the abelianization of a group. This is a map from [Group] to [AbGroup]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk68"><span class="kn">Definition</span> <span class="nf">abel</span> : Group -&gt; AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6a"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6b">snapply Build_AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk6c"><hr></label><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Build_Group (Abel G)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We don&#39;t wish for [abel G] to be unfolded when using [simpl] or [cbn]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> abel G : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The unit of this map is the map [abel_in] which typeclasses can pick up to be a homomorphism. We write it out explicitly here. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abel_unit</span> {<span class="nv">G</span> : Group} : G $-&gt; abel G
  := @Build_GroupHomomorphism G (abel G) abel_in _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6f"><span class="kn">Definition</span> <span class="nf">grp_homo_abel_rec</span> {<span class="nv">G</span> : Group} {<span class="nv">A</span> : AbGroup} (<span class="nv">f</span> : G $-&gt; A)
  : abel G $-&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel G $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel G $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk71">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel G -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk72"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk73">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel G -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk74">srapply (Abel_rec _ _ f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, f (x * (y * z)) = f (x * (z * y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk75"><span class="nb">intros</span> x y z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * (y * z)) = f (x * (z * y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk76">napply grp_homo_op_agree; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (y * z) = f (z * y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk77"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _ @ (grp_homo_op _ _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>x, y, z</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y * f z = f z * f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk78">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving
  (Abel_rec G A f
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
      grp_homo_op_agree f f <span class="mi">1</span>
        ((grp_homo_op f y z @
          commutativity (f y) (f z)) @
         (grp_homo_op f z y)^)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk79"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>abel G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y0</span> : abel G,
Abel_rec G A f
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
   grp_homo_op_agree f f <span class="mi">1</span>
     ((grp_homo_op f y z @ commutativity (f y) (f z)) @
      (grp_homo_op f z y)^)) (y * y0) =
Abel_rec G A f
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
   grp_homo_op_agree f f <span class="mi">1</span>
     ((grp_homo_op f y z @ commutativity (f y) (f z)) @
      (grp_homo_op f z y)^)) y *
Abel_rec G A f
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
   grp_homo_op_agree f f <span class="mi">1</span>
     ((grp_homo_op f y z @ commutativity (f y) (f z)) @
      (grp_homo_op f z y)^)) y0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7a">Abel_ind_hprop x; <span class="nb">revert</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : abel G,
(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
 Abel_rec G A f
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">z</span> : G =&gt;
    grp_homo_op_agree f f <span class="mi">1</span>
      ((grp_homo_op f y0 z @
        commutativity (f y0) (f z)) @
       (grp_homo_op f z y0)^)) (y * x) =
 Abel_rec G A f
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">z</span> : G =&gt;
    grp_homo_op_agree f f <span class="mi">1</span>
      ((grp_homo_op f y0 z @
        commutativity (f y0) (f z)) @
       (grp_homo_op f z y0)^)) y *
 Abel_rec G A f
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">z</span> : G =&gt;
    grp_homo_op_agree f f <span class="mi">1</span>
      ((grp_homo_op f y0 z @
        commutativity (f y0) (f z)) @
       (grp_homo_op f z y0)^)) x) (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7b">Abel_ind_hprop y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
  Abel_rec G A f
    (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
     grp_homo_op_agree f f <span class="mi">1</span>
       ((grp_homo_op f y z @ commutativity (f y) (f z)) @
        (grp_homo_op f z y)^)) (x0 * x) =
  Abel_rec G A f
    (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
     grp_homo_op_agree f f <span class="mi">1</span>
       ((grp_homo_op f y z @ commutativity (f y) (f z)) @
        (grp_homo_op f z y)^)) x0 *
  Abel_rec G A f
    (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
     grp_homo_op_agree f f <span class="mi">1</span>
       ((grp_homo_op f y z @ commutativity (f y) (f z)) @
        (grp_homo_op f z y)^)) x) (abel_in x))
  (abel_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7c"><span class="kn">Definition</span> <span class="nf">abel_ind_homotopy</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} {<span class="nv">f</span> <span class="nv">g</span> : Hom (A:=Group) (abel G) H}
  (<span class="nv">p</span> : f $o abel_unit $== g $o abel_unit)
  : f $== g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>abel G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $o abel_unit $== g $o abel_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>abel G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $o abel_unit $== g $o abel_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7e">rapply Abel_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>abel G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $o abel_unit $== g $o abel_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, f (abel_in x) = g (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finally we can prove that our construction abel is an abelianization. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7f"><span class="kn">Instance</span> <span class="nf">isabelianization_abel</span> {<span class="nv">G</span> : Group}
  : IsAbelianization (abel G) abel_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization (abel G) abel_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization (abel G) abel_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk81"><span class="nb">intros</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj (group_precomp A abel_unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk82"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (group_precomp A abel_unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk83"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : abel G $-&gt; A,
group_precomp A abel_unit x $==
group_precomp A abel_unit y -&gt; x $== y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk84">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (group_precomp A abel_unit)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk85"><span class="nb">intros</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : abel G $-&gt; A &amp; group_precomp A abel_unit a $== h}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk86">snrefine (grp_homo_abel_rec h; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : abel G $-&gt; A =&gt;
 group_precomp A abel_unit a $== h)
  (grp_homo_abel_rec h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk87"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
 Coeq_ind
   (<span class="kr">fun</span>
      <span class="nv">_</span> : Coeq
            (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
            (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)))
    =&gt; A) h
   (<span class="kr">fun</span> <span class="nv">b</span> : G * G * G =&gt;
    transport_compose
      (<span class="kr">fun</span>
         <span class="nv">_</span> : Trunc <span class="mi">0</span>
               (Coeq
                  (uncurry2
                     (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)))
                  (uncurry2
                     (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0))))
       =&gt; A) tr
      (cglue (fst (fst b), snd (fst b), snd b))
      (h
         (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c))
            (fst (fst b), snd (fst b), snd b))) @
    dp_const
      (grp_homo_op_agree h h <span class="mi">1</span>
         ((grp_homo_op h (snd (fst b)) (snd b) @
           commutativity (h (snd (fst b))) (h (snd b))) @
          (grp_homo_op h (snd b) (snd (fst b)))^)))
   (coeq x)) == h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk88">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : abel G $-&gt; A,
group_precomp A abel_unit x $==
group_precomp A abel_unit y -&gt; x $== y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk89"><span class="nb">intros</span> g h p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>abel G $-&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>group_precomp A abel_unit g $==
group_precomp A abel_unit h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $== h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8a">Abel_ind_hprop x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>abel G $-&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>group_precomp A abel_unit g $==
group_precomp A abel_unit h</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
 (grp_homo_map
  :
  GroupHomomorphism (abel G) A -&gt; abel G $-&gt; A) g x =
 (grp_homo_map
  :
  GroupHomomorphism (abel G) A -&gt; abel G $-&gt; A) h x)
  (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8b"><span class="kn">Theorem</span> <span class="nf">groupiso_isabelianization</span> {<span class="nv">G</span> : Group}
  (<span class="nv">A</span> <span class="nv">B</span> : AbGroup)
  (<span class="nv">eta1</span> : GroupHomomorphism G A)
  (<span class="nv">eta2</span> : GroupHomomorphism G B)
  {<span class="nv">isab1</span> : IsAbelianization A eta1}
  {<span class="nv">isab2</span> : IsAbelianization B eta2}
  : A ‚âÖ B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8d"><span class="nb">destruct</span> (esssurj (group_precomp B eta1) eta2) <span class="kr">as</span> [a ac].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8e"><span class="nb">destruct</span> (esssurj (group_precomp A eta2) eta1) <span class="kr">as</span> [b bc].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8f">srapply (Build_GroupIsomorphism _ _ a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk90">srapply (isequiv_adjointify _ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a o b == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chk91"><hr></label><div class="goal-conclusion">b o a == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk92">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a o b == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk93"><span class="nb">refine</span> (essinj (group_precomp B eta2)
                   (x := a $o b) (y := Id (A := Group) B) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_precomp B eta2 (a $o b) $==
group_precomp B eta2 (Id B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk94"><span class="nb">intros</span> x; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a (b (eta2 x)) = eta2 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk95"><span class="nb">refine</span> (_ @ ac x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a (b (eta2 x)) = a (eta1 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, bc.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk96">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b o a == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk97">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b o a == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk98"><span class="nb">refine</span> (essinj (group_precomp A eta1)
                   (x := b $o a) (y := Id (A := Group) A) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>group_precomp B eta1 a $== eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B $-&gt; A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>group_precomp A eta2 b $== eta1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_precomp A eta1 (b $o a) $==
group_precomp A eta1 (Id A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk99"><span class="nb">intros</span> x; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b (a (eta1 x)) = eta1 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9a"><span class="nb">refine</span> (_ @ bc x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism B A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b (a (eta1 x)) = b (eta2 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, ac.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9b"><span class="kn">Theorem</span> <span class="nf">homotopic_isabelianization</span> {<span class="nv">G</span> : Group} (<span class="nv">A</span> <span class="nv">B</span> : AbGroup)
  (<span class="nv">eta1</span> : GroupHomomorphism G A) (<span class="nv">eta2</span> : GroupHomomorphism G B)
  {<span class="nv">isab1</span> : IsAbelianization A eta1} {<span class="nv">isab2</span> : IsAbelianization B eta2}
  : eta2 == grp_homo_compose (groupiso_isabelianization A B eta1 eta2) eta1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta2 ==
grp_homo_compose
  (groupiso_isabelianization A B eta1 eta2) eta1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta2 ==
grp_homo_compose
  (groupiso_isabelianization A B eta1 eta2) eta1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9d"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta2 x =
grp_homo_compose
  (groupiso_isabelianization A B eta1 eta2) eta1 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta1</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>eta2</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G B</span></span></span><br><span><var>isab1</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta1</span></span></span><br><span><var>isab2</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (groupiso_isabelianization A B eta1 eta2) eta1 x =
eta2 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((esssurj (group_precomp B eta1) eta2).<span class="mi">2</span> x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Hence any abelianization is surjective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9f"><span class="kn">Instance</span> <span class="nf">issurj_isabelianization</span> {<span class="nv">G</span> : Group}
  (<span class="nv">A</span> : AbGroup) (<span class="nv">eta</span> : GroupHomomorphism G A)
  : IsAbelianization A eta -&gt; IsSurjection eta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization A eta -&gt; IsConnMap (Tr (-<span class="mi">1</span>)) eta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization A eta -&gt; IsConnMap (Tr (-<span class="mi">1</span>)) eta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka1"><span class="nb">intros</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) eta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka2"><span class="nb">pose</span> (homotopic_isabelianization A (abel G) eta abel_unit) <span class="kr">as</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>IsAbelianization A eta</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>homotopic_isabelianization A (abel G) eta abel_unit</span></span><span class="hyp-type"><b>: </b><span>abel_unit ==
grp_homo_compose
  (groupiso_isabelianization A (abel G) eta
     abel_unit) eta</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) eta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@cancelL_isequiv_conn_map _ _ _ _ _ _ _
    (conn_map_homotopic _ _ _ p _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka3"><span class="kn">Instance</span> <span class="nf">isabelianization_identity</span> (<span class="nv">A</span> : AbGroup) : IsAbelianization A grp_homo_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization A grp_homo_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbelianization A grp_homo_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka5"><span class="nb">intros</span> B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj (group_precomp B grp_homo_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka6"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (group_precomp B grp_homo_id)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chka7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A $-&gt; B,
group_precomp B grp_homo_id x $==
group_precomp B grp_homo_id y -&gt; x $== y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (group_precomp B grp_homo_id)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> h; <span class="bp">exact</span> (h ; <span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A $-&gt; B,
group_precomp B grp_homo_id x $==
group_precomp B grp_homo_id y -&gt; x $== y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> g h p; <span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkaa"><span class="kn">Instance</span> <span class="nf">isequiv_abgroup_abelianization</span>
  (<span class="nv">A</span> <span class="nv">B</span> : AbGroup) (<span class="nv">eta</span> : GroupHomomorphism A B) {<span class="nv">isab</span> : IsAbelianization B eta}
  : IsEquiv eta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv eta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv eta</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkac">srapply isequiv_homotopic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chkad"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?f</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="abelianization-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><label class="goal-separator" for="abelianization-v-chkae"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> == eta</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkaf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (groupiso_isabelianization A B grp_homo_id eta).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (groupiso_isabelianization A B grp_homo_id eta)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>isab</var><span class="hyp-type"><b>: </b><span>IsAbelianization B eta</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">groupiso_isabelianization A B grp_homo_id eta == eta</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> homotopic_isabelianization.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb2"><span class="kn">Instance</span> <span class="nf">is0functor_abel</span> : Is0Functor abel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor abel</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor abel</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb4">snapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; abel a $-&gt; abel b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb5"><span class="nb">intros</span> A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel A $-&gt; abel B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb6">snapply grp_homo_abel_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; abel B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abel_unit $o f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb7"><span class="kn">Instance</span> <span class="nf">is1functor_abel</span> : Is1Functor abel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor abel</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor abel</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb9">snapply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap abel f $== fmap abel g</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Group, fmap abel (Id a) $== Id (abel a)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap abel (g $o f) $== fmap abel g $o fmap abel f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap abel f $== fmap abel g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkbb"><span class="nb">intros</span> A B f g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap abel f $== fmap abel g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkbc"><span class="nb">unfold</span> abel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap abel f $== fmap abel g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkbd">rapply Abel_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
fmap abel f (abel_in x) = fmap abel g (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkbe"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap abel f (abel_in x) = fmap abel g (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap abel_in (p x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkbf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Group, fmap abel (Id a) $== Id (abel a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkc0"><span class="nb">intros</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap abel (Id A) $== Id (abel A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply Abel_ind_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkc1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap abel (g $o f) $== fmap abel g $o fmap abel f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkc2"><span class="nb">intros</span> A B C f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap abel (g $o f) $== fmap abel g $o fmap abel f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply Abel_ind_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
