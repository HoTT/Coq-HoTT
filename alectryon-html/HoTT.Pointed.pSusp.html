<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>pSusp.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Loops.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.pTrunc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.pEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.Suspension.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.BlakersMassey.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">X</span> A B f g n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Pointedness of [Susp] and path spaces thereof *)</span>
<span class="sd">(** We arbitrarily choose [North] to be the point. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_susp</span> {<span class="nv">X</span> : <span class="kt">Type</span>} : IsPointed (Susp X) | <span class="mi">0</span>
  := North.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_path_susp</span> `{IsPointed X}
  : IsPointed (North = South :&gt; Susp X) | <span class="mi">0</span> := merid (point X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_path_susp&#39;</span> `{IsPointed X}
  : IsPointed (South = North :&gt; Susp X) | <span class="mi">0</span> := (merid (point X))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">psusp</span> (<span class="nv">X</span> : <span class="kt">Type</span>) : pType
  := [Susp X, _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Suspension Functor *)</span>

<span class="sd">(** [psusp] has a functorial action. *)</span>
<span class="sd">(** TODO: make this a displayed functor *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0functor_psusp</span> : Is0Functor psusp
  := Build_Is0Functor _ _ _ _ psusp (<span class="kr">fun</span> <span class="nv">X</span> <span class="nv">Y</span> <span class="nv">f</span>
      =&gt; Build_pMap (functor_susp f) <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [psusp] is a 1-functor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1"><span class="kn">Instance</span> <span class="nf">is1functor_psusp</span> : Is1Functor psusp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor psusp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor psusp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3">snapply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap psusp f $== fmap psusp g</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, fmap psusp (Id a) $== Id (psusp a)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap psusp (g $o f) $== fmap psusp g $o fmap psusp f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Action on 2-cells *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap psusp f $== fmap psusp g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5"><span class="nb">intros</span> X Y f g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X $-&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap psusp f $== fmap psusp g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap (functor_susp f) <span class="mi">1</span> ==*
Build_pMap (functor_susp g) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap (functor_susp f) <span class="mi">1</span> ==
Build_pMap (functor_susp g) <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk8"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (Build_pMap (functor_susp f) <span class="mi">1</span>) @
(dpoint_eq (Build_pMap (functor_susp g) <span class="mi">1</span>))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap (functor_susp f) <span class="mi">1</span> ==
Build_pMap (functor_susp g) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp f == functor_susp g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chkb">srapply Susp_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; functor_susp f y = functor_susp g y)
  North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="psusp-v-chkc"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; functor_susp f y = functor_susp g y)
  South</div></blockquote><input class="alectryon-extra-goal-toggle" id="psusp-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="psusp-v-chkd"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   functor_susp f y = functor_susp g y) (merid x) 
  <span class="nl">?H_N</span> = <span class="nl">?H_S</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chke"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   functor_susp f y = functor_susp g y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chkf"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   functor_susp f y = functor_susp g y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk10"><span class="nb">rewrite</span> transport_paths_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (functor_susp f) (merid x))^ @ <span class="mi">1</span>) @
ap (functor_susp g) (merid x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk11"><span class="nb">rewrite</span> concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (functor_susp f) (merid x))^ @
ap (functor_susp g) (merid x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk12"><span class="nb">rewrite</span> <span class="mi">2</span> Susp_rec_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(merid (f x))^ @ merid (g x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk13"><span class="nb">destruct</span> (p x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(merid (f x))^ @ merid (f x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_Vp.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk14">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Susp_ind
   (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
    functor_susp f y = functor_susp g y) <span class="mi">1</span> <span class="mi">1</span>
   (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
    internal_paths_rew_r
      (<span class="kr">fun</span>
         <span class="nv">p</span> : functor_susp f South =
             functor_susp g South =&gt; p = <span class="mi">1</span>)
      (internal_paths_rew_r
         (<span class="kr">fun</span>
            <span class="nv">p</span> : functor_susp f South =
                functor_susp f North =&gt;
          p @ ap (functor_susp g) (merid x) = <span class="mi">1</span>)
         (internal_paths_rew_r
            (<span class="kr">fun</span>
               <span class="nv">p</span> : Susp_rec North South
                     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0))
                     North =
                   Susp_rec North South
                     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (f x0))
                     South =&gt;
             p^ @ ap (functor_susp g) (merid x) = <span class="mi">1</span>)
            (internal_paths_rew_r
               (<span class="kr">fun</span>
                  <span class="nv">p</span> : Susp_rec North South
                        (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (g x0))
                        North =
                      Susp_rec North South
                        (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (g x0))
                        South =&gt;
                (merid (f x))^ @ p = <span class="mi">1</span>)
               (<span class="kr">let</span> <span class="nv">p0</span> := p x <span class="kr">in</span>
                <span class="kr">let</span> <span class="nv">y</span> := g x <span class="kr">in</span>
                <span class="kr">match</span>
                  p0 <span class="kr">in</span> (_ = y0)
                  <span class="kr">return</span> ((merid ...)^ @ merid y0 = <span class="mi">1</span>)
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt; concat_Vp (merid (f x))
                <span class="kr">end</span>) (Susp_rec_beta_merid x))
            (Susp_rec_beta_merid x))
         (concat_p1 (ap (functor_susp f) (merid x))^))
      (transport_paths_FlFr (merid x) <span class="mi">1</span>)
    :
    transport
      (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
       functor_susp f y = functor_susp g y) (merid x)
      <span class="mi">1</span> = <span class="mi">1</span>)
 :
 Build_pMap (functor_susp f) <span class="mi">1</span> ==
 Build_pMap (functor_susp g) <span class="mi">1</span>) pt =
dpoint_eq (Build_pMap (functor_susp f) <span class="mi">1</span>) @
(dpoint_eq (Build_pMap (functor_susp g) <span class="mi">1</span>))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Preservation of identity. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, fmap psusp (Id a) $== Id (psusp a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk16"><span class="nb">intros</span> X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap psusp (Id X) $== Id (psusp X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk17">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap psusp (Id X) == Id (psusp X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="psusp-v-chk18"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap psusp (Id X)) @
(dpoint_eq (Id (psusp X)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk19">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap psusp (Id X) == Id (psusp X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1a">srapply Susp_ind; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   fmap psusp (Id X) y = Id (psusp X) y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1b"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   fmap psusp (Id X) y = Id (psusp X) y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1c"><span class="nb">refine</span> (transport_paths_FFlr _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (fmap psusp (Id X)) (ap idmap (merid x)))^ @ <span class="mi">1</span>) @
merid x = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ap_idmap, Susp_rec_beta_merid,
        concat_p1, concat_Vp.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   fmap psusp (Id X) y = Id (psusp X) y) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   transport_paths_FFlr (merid x) <span class="mi">1</span> @
   internal_paths_rew_r
     (<span class="kr">fun</span> <span class="nv">p</span> : North = Id (psusp X) South =&gt;
      ((ap (fmap psusp (Id X)) p)^ @ <span class="mi">1</span>) @ merid x = <span class="mi">1</span>)
     (internal_paths_rew_r
        (<span class="kr">fun</span>
           <span class="nv">p</span> : Susp_rec North South
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (Id X x0)) North =
               Susp_rec North South
                 (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid (Id X x0)) South
         =&gt; (p^ @ <span class="mi">1</span>) @ merid x = <span class="mi">1</span>)
        (internal_paths_rew_r
           (<span class="kr">fun</span>
              <span class="nv">p</span> : fmap psusp (Id X)
                    (Id (psusp X) South) =
                  fmap psusp (Id X) North =&gt;
            p @ merid x = <span class="mi">1</span>)
           (internal_paths_rew_r
              (<span class="kr">fun</span>
                 <span class="nv">p</span> : fmap psusp (Id X)
                       (Id (psusp X) South) =
                     fmap psusp (Id X)
                       (Id (psusp X) South) =&gt; p = <span class="mi">1</span>)
              <span class="mi">1</span> (concat_Vp (merid x)))
           (concat_p1 (merid (Id X x))^))
        (Susp_rec_beta_merid x)) (ap_idmap (merid x)))
  pt =
dpoint_eq (fmap psusp (Id X)) @
(dpoint_eq (Id (psusp X)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Preservation of composition. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap psusp (g $o f) $== fmap psusp g $o fmap psusp f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk1f">pointed_reduce_rewrite; srefine (Build_pHomotopy _ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk20"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> ispointed_susp = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk21">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk22">srapply Susp_ind; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : a,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp a =&gt;
   functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)) y =
   functor_susp g (functor_susp f y)) (merid x) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk23"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp a =&gt;
   functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) y =
   functor_susp g (functor_susp f y)) (merid x) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk24"><span class="nb">refine</span> (transport_paths_FlFr _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x))) (merid x))^ @
 <span class="mi">1</span>) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))
  (merid x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk25"><span class="nb">rewrite</span> concat_p1; <span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt; functor_susp g (functor_susp f x))
  (merid x) =
ap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x))) (merid x) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> concat_p1, ap_compose, !Susp_rec_beta_merid.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk26">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a -&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b -&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp a =&gt;
   functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; g (f x)) y =
   (<span class="kr">fun</span> <span class="nv">x</span> : Susp a =&gt;
    functor_susp g (functor_susp f x)) y) <span class="mi">1</span> <span class="mi">1</span>
  ((<span class="kr">fun</span> <span class="nv">x</span> : a =&gt;
    transport_paths_FlFr (merid x) <span class="mi">1</span> @
    internal_paths_rew_r
      (<span class="kr">fun</span>
         <span class="nv">p</span> : functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0))
               South =
             functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0))
               North =&gt;
       p @
       ap
         (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
          functor_susp g (functor_susp f x0))
         (merid x) = <span class="mi">1</span>)
      (moveR_Vp
         (ap
            (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
             functor_susp g (functor_susp f x0))
            (merid x)) <span class="mi">1</span>
         (ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
            (merid x))
         (internal_paths_rew_r
            (<span class="kr">fun</span>
               <span class="nv">p</span> : functor_susp g
                     (functor_susp f North) =
                   functor_susp
                     (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)) South =&gt;
             ap
               (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
                functor_susp g (functor_susp f x0))
               (merid x) = p)
            (internal_paths_rew_r
               (<span class="kr">fun</span>
                  <span class="nv">p</span> : functor_susp g
                        (functor_susp f North) =
                      functor_susp g
                        (functor_susp f South) =&gt;
                p =
                ap
                  (functor_susp
                     (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
                  (merid x))
               (internal_paths_rew_r
                  (<span class="kr">fun</span>
                     <span class="nv">p</span> : Susp_rec North South
                           (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; merid (f x0))
                           North =
                         Susp_rec North South
                           (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; merid (f x0))
                           South =&gt;
                   ap (functor_susp g) p =
                   ap
                     (functor_susp
                        (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
                     (merid x))
                  (internal_paths_rew_r
                     (<span class="kr">fun</span>
                        <span class="nv">p</span> : Susp_rec North South
                              (<span class="kr">fun</span> ... =&gt; merid ...)
                              North =
                            Susp_rec North South
                              (<span class="kr">fun</span> ... =&gt; merid ...)
                              South =&gt;
                      p =
                      ap
                        (functor_susp
                           (<span class="kr">fun</span> ... =&gt; g ...))
                        (merid x))
                     (internal_paths_rew_r
                        (<span class="kr">fun</span>
                           <span class="nv">p</span> : Susp_rec North South
                                 (...) North =
                               Susp_rec North South
                                 (...) South =&gt;
                         merid (g (...)) = p) <span class="mi">1</span>
                        (Susp_rec_beta_merid x))
                     (Susp_rec_beta_merid (f x)))
                  (Susp_rec_beta_merid x))
               (ap_compose (functor_susp f)
                  (functor_susp g) (merid x)))
            (concat_p1
               (ap
                  (functor_susp
                     (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
                  (merid x)))))
      (concat_p1
         (ap (functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)))
            (merid x))^))
   :
   <span class="kr">forall</span> <span class="nv">x</span> : a,
   transport
     (<span class="kr">fun</span> <span class="nv">y</span> : Susp a =&gt;
      functor_susp (<span class="kr">fun</span> <span class="nv">x0</span> : a =&gt; g (f x0)) y =
      (<span class="kr">fun</span> <span class="nv">x0</span> : Susp a =&gt;
       functor_susp g (functor_susp f x0)) y)
     (merid x) <span class="mi">1</span> = <span class="mi">1</span>) ispointed_susp = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Loop-Suspension Adjunction *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Book_Loop_Susp_Adjunction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is the proof of the adjunction isomorphism given in the book (6.5.4); we put it in a non-exported module for reasons discussed below. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk27"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint</span> `{Funext} (A B : pType)
  : (psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(psusp A -&gt;* B) &lt;~&gt; (A -&gt;* loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk29"><span class="nb">refine</span> (_ oE (issig_pmap (psusp A) B)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : psusp A -&gt; B &amp; f pt = pt} &lt;~&gt; (A -&gt;* loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2a"><span class="nb">refine</span> (_ oE (equiv_functor_sigma_pb
                 (Q := <span class="kr">fun</span> <span class="nv">NSm</span> =&gt; fst NSm.<span class="mi">1</span> = point B)
                 (equiv_Susp_rec A B))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{NSm : {NS : B * B &amp; A -&gt; fst NS = snd NS} &amp;
fst NSm.<span class="mi">1</span> = pt} &lt;~&gt; (A -&gt;* loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2b"><span class="nb">transitivity</span> {bp : {b:B &amp; b = point B} &amp; {b:B &amp; A -&gt; bp.<span class="mi">1</span> = b} }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{NSm : {NS : B * B &amp; A -&gt; fst NS = snd NS} &amp;
fst NSm.<span class="mi">1</span> = pt} &lt;~&gt;
{bp : {b : B &amp; b = pt} &amp; {b : B &amp; A -&gt; bp.<span class="mi">1</span> = b}}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk2c"><hr></label><div class="goal-conclusion">{bp : {b : B &amp; b = pt} &amp; {b : B &amp; A -&gt; bp.<span class="mi">1</span> = b}} &lt;~&gt;
(A -&gt;* loops B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2d"><span class="mi">1</span>:make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{bp : {b : B &amp; b = pt} &amp; {b : B &amp; A -&gt; bp.<span class="mi">1</span> = b}} &lt;~&gt;
(A -&gt;* loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2e"><span class="nb">refine</span> (_ oE equiv_contr_sigma _); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{b : B &amp; A -&gt; pt = b} &lt;~&gt; (A -&gt;* loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk2f"><span class="nb">refine</span> (_ oE (equiv_sigma_contr
                   (A := {p : B &amp; A -&gt; point B = p})
                   (<span class="kr">fun</span> <span class="nv">pm</span> =&gt; { q : point B = pm.<span class="mi">1</span> &amp; pm.<span class="mi">2</span> (point A) = q }))^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{pm : {p : B &amp; A -&gt; pt = p} &amp;
{q : pt = pm.<span class="mi">1</span> &amp; pm.<span class="mi">2</span> pt = q}} &lt;~&gt; (A -&gt;* loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Unfortunately, with this definition it seems to be quite hard to prove that the isomorphism is natural on pointed maps.  The following proof gets partway there, but ends with a pretty intractable goal.  It&#39;s also quite slow, so we don&#39;t want to compile it all the time. *)</span>
  <span class="sd">(**</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">  Definition loop_susp_adjoint_nat_r `{Funext} (A B B&#39; : pType)</span>
<span class="sd">             (f : psusp A -&gt;* B) (g : B -&gt;* B&#39;)</span>
<span class="sd">  : loop_susp_adjoint A B&#39; (g o* f)</span>
<span class="sd">    ==* fmap loops g o* loop_susp_adjoint A B f.</span>
<span class="sd">  Proof.</span>
<span class="sd">    pointed_reduce. (* Very slow for some reason. *)</span>
<span class="sd">    exact (Build_pHomotopy _ _).</span>
<span class="sd">    - intros a. simpl.</span>
<span class="sd">      exact (_ @ (concat_1p _)^).</span>
<span class="sd">      exact (_ @ (concat_p1 _)^).</span>
<span class="sd">      rewrite !transport_sigma. simpl.</span>
<span class="sd">      rewrite !(transport_arrow_fromconst (B := A)).</span>
<span class="sd">      rewrite !transport_paths_Fr.</span>
<span class="sd">      rewrite !ap_V, !ap_pr1_path_basedpaths.</span>
<span class="sd">      Fail rewrite ap_pp, !(ap_compose f g), ap_V. (* This line fails with current versions of the library. *)</span>
<span class="sd">      Fail reflexivity.</span>
<span class="sd">      admit.</span>
<span class="sd">    - cbn.</span>
<span class="sd">      Fail reflexivity.</span>
<span class="sd">  Abort.</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">   *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Book_Loop_Susp_Adjunction</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Thus, instead we will construct the adjunction in terms of a unit and counit natural transformation. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">loop_susp_unit</span> (<span class="nv">X</span> : pType) : X -&gt;* loops (psusp X)
  := Build_pMap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; merid x @ (merid (point X))^) (concat_pV _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** By Freudenthal, we have that this map is (2n+2)-connected when [X] is (n+1)-connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk30"><span class="kn">Instance</span> <span class="nf">conn_map_loop_susp_unit</span> `{Univalence} (n : trunc_index)
  (X : pType) `{IsConnected n.+<span class="mi">1</span> X}
  : IsConnMap (n +<span class="mi">2</span>+ n) (loop_susp_unit X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ n)) (loop_susp_unit X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (n +<span class="mi">2</span>+ n)) (loop_susp_unit X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (conn_map_compose _ merid (equiv_concat_r (merid pt)^ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We also have this corollary: *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk32"><span class="kn">Definition</span> <span class="nf">pequiv_ptr_loop_psusp</span> `{Univalence} (X : pType) n `{IsConnected n.+<span class="mi">1</span> X}
  : pTr (n +<span class="mi">2</span>+ n) X &lt;~&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pTr (n +<span class="mi">2</span>+ n) X &lt;~&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pTr (n +<span class="mi">2</span>+ n) X &lt;~&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk34">snapply Build_pEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pTr (n +<span class="mi">2</span>+ n) X -&gt;* pTr (n +<span class="mi">2</span>+ n) (loops (psusp X))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk35"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?pointed_equiv_fun</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk36"><span class="mi">1</span>:<span class="bp">exact</span> (fmap (pTr _) (loop_susp_unit _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (fmap (pTr (n +<span class="mi">2</span>+ n)) (loop_susp_unit X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply O_inverts_conn_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk37"><span class="kn">Definition</span> <span class="nf">loop_susp_unit_natural</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} (<span class="nv">f</span> : X -&gt;* Y)
  : loop_susp_unit Y o* f
  ==* fmap loops (fmap psusp f) o* loop_susp_unit X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_unit Y o* f ==*
fmap loops (fmap psusp f) o* loop_susp_unit X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_unit Y o* f ==*
fmap loops (fmap psusp f) o* loop_susp_unit X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk39">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_unit [Y, f point0]
o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} ==*
Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>)) <span class="mi">1</span>
o* loop_susp_unit [X, point0]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3a">snapply Build_pHomotopy; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x) @ (merid (f point0))^) ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 <span class="mi">1</span> @
 (ap (functor_susp f) (merid x @ (merid point0)^) @ <span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk3b"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> point0 =
(<span class="mi">1</span> @ concat_pV (merid (f point0))) @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x) @ (merid (f point0))^) ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 <span class="mi">1</span> @
 (ap (functor_susp f) (merid x @ (merid point0)^) @ <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3d"><span class="nb">intros</span> x; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @
(ap (functor_susp f) (merid x @ (merid point0)^) @ <span class="mi">1</span>) =
merid (f x) @ (merid (f point0))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3e">lhs napply concat_1p; lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp f) (merid x @ (merid point0)^) =
merid (f x) @ (merid (f point0))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk3f">lhs napply (ap_pV _ (merid x) (merid point0)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp f) (merid x) @
(ap (functor_susp f) (merid point0))^ =
merid (f x) @ (merid (f point0))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_rec_beta_merid _ @@ inverse2 (Susp_rec_beta_merid _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk40">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
  (concat_1p
     (ap (functor_susp f) (merid x @ (merid point0)^) @
      <span class="mi">1</span>) @
   (concat_p1
      (ap (functor_susp f) (merid x @ (merid point0)^)) @
    (ap_pV (functor_susp f) (merid x) (merid point0) @
     (Susp_rec_beta_merid x @@
      inverse2 (Susp_rec_beta_merid point0)))))^)
 :
 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid (f x) @ (merid (f point0))^) ==
 (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
  <span class="mi">1</span> @
  (ap (functor_susp f) (merid x @ (merid point0)^) @ <span class="mi">1</span>)))
  point0 =
(<span class="mi">1</span> @ concat_pV (merid (f point0))) @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk41"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0)))))^ =
(<span class="mi">1</span> @ concat_pV (merid (f point0))) @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk42"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0)))))^ @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>) =
<span class="mi">1</span> @ concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk43">rhs napply concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0)))))^ @
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
    <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
   (concat_pV (merid point0)) @ <span class="mi">1</span>) =
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk44"><span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
  (concat_pV (merid point0)) @ <span class="mi">1</span> =
(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0))))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk45">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   <span class="mi">1</span> @ (ap (functor_susp f) p @ <span class="mi">1</span>))
  (concat_pV (merid point0)) =
(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0))))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Handle the [ap ... (1 @ q)] part. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk46">lhs napply (ap_compose (<span class="kr">fun</span> <span class="nv">p</span> =&gt; ap _ p @ <span class="mi">1</span>) _ (concat_pV _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (concat <span class="mi">1</span>)
  (ap
     (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
      ap (functor_susp f) p @ <span class="mi">1</span>)
     (concat_pV (merid point0))) =
(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0))))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk47">lhs_V napply concat_1p_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p
  (ap (functor_susp f)
     (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   ap (functor_susp f) p @ <span class="mi">1</span>)
  (concat_pV (merid point0)) =
(concat_1p
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
 (concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0))))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk48">rhs napply concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p
  (ap (functor_susp f)
     (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   ap (functor_susp f) p @ <span class="mi">1</span>)
  (concat_pV (merid point0)) =
concat_1p
  (ap (functor_susp f)
     (merid point0 @ (merid point0)^) @ <span class="mi">1</span>) @
((concat_p1
    (ap (functor_susp f)
       (merid point0 @ (merid point0)^)) @
  (ap_pV (functor_susp f) 
     (merid point0) (merid point0) @
   (Susp_rec_beta_merid point0 @@
    inverse2 (Susp_rec_beta_merid point0)))) @
 concat_pV (merid (f point0)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk49"><span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   ap (functor_susp f) p @ <span class="mi">1</span>)
  (concat_pV (merid point0)) =
(concat_p1
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^)) @
 (ap_pV (functor_susp f) (merid point0) (merid point0) @
  (Susp_rec_beta_merid point0 @@
   inverse2 (Susp_rec_beta_merid point0)))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Handle the [ap ... (q @ 1)] part. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4a">lhs napply (ap_compose _ (<span class="kr">fun</span> <span class="nv">q</span> =&gt; q @ <span class="mi">1</span>) (concat_pV _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">q</span> : ispointed_susp = ispointed_susp =&gt; q @ <span class="mi">1</span>)
  (ap (ap (functor_susp f)) (concat_pV (merid point0))) =
(concat_p1
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^)) @
 (ap_pV (functor_susp f) (merid point0) (merid point0) @
  (Susp_rec_beta_merid point0 @@
   inverse2 (Susp_rec_beta_merid point0)))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4b">lhs_V napply concat_p1_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1
  (ap (functor_susp f)
     (merid point0 @ (merid point0)^)) @
ap (ap (functor_susp f)) (concat_pV (merid point0)) =
(concat_p1
   (ap (functor_susp f)
      (merid point0 @ (merid point0)^)) @
 (ap_pV (functor_susp f) (merid point0) (merid point0) @
  (Susp_rec_beta_merid point0 @@
   inverse2 (Susp_rec_beta_merid point0)))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4c">rhs napply concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1
  (ap (functor_susp f)
     (merid point0 @ (merid point0)^)) @
ap (ap (functor_susp f)) (concat_pV (merid point0)) =
concat_p1
  (ap (functor_susp f)
     (merid point0 @ (merid point0)^)) @
((ap_pV (functor_susp f) (merid point0) (merid point0) @
  (Susp_rec_beta_merid point0 @@
   inverse2 (Susp_rec_beta_merid point0))) @
 concat_pV (merid (f point0)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4d"><span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (ap (functor_susp f)) (concat_pV (merid point0)) =
(ap_pV (functor_susp f) (merid point0) (merid point0) @
 (Susp_rec_beta_merid point0 @@
  inverse2 (Susp_rec_beta_merid point0))) @
concat_pV (merid (f point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Finish it off. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap_pV (functor_susp f) (merid point0) (merid point0) @
 (Susp_rec_beta_merid point0 @@
  inverse2 (Susp_rec_beta_merid point0))) @
concat_pV (merid (f point0)) =
ap (ap (functor_susp f)) (concat_pV (merid point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk4f">lhs napply concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pV (functor_susp f) (merid point0) (merid point0) @
((Susp_rec_beta_merid point0 @@
  inverse2 (Susp_rec_beta_merid point0)) @
 concat_pV (merid (f point0))) =
ap (ap (functor_susp f)) (concat_pV (merid point0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap_ap_concat_pV _ _ _ (Susp_rec_beta_merid point0)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">loop_susp_counit</span> (<span class="nv">X</span> : pType) : psusp (loops X) -&gt;* X
  := Build_pMap (Susp_rec (point X) (point X) idmap) <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk50"><span class="kn">Definition</span> <span class="nf">loop_susp_counit_natural</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} (<span class="nv">f</span> : X -&gt;* Y)
  : f o* loop_susp_counit X
  ==* loop_susp_counit Y o* fmap psusp (fmap loops f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* loop_susp_counit X ==*
loop_susp_counit Y o* fmap psusp (fmap loops f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* loop_susp_counit X ==*
loop_susp_counit Y o* fmap psusp (fmap loops f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk52">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
o* loop_susp_counit [X, point0] ==*
loop_susp_counit [Y, f point0]
o* Build_pMap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)))
     <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk53"><span class="nb">simple refine</span> (Build_pHomotopy _ _); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
 f (Susp_rec pt pt idmap x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
 Susp_rec pt pt idmap
   (functor_susp
      (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk54"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> pt = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk55">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
 f (Susp_rec pt pt idmap x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
 Susp_rec pt pt idmap
   (functor_susp
      (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk56"><span class="nb">simple refine</span> (Susp_ind _ _ _ _); <span class="nb">cbn</span>; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point0 = point0) =&gt;
   f (Susp_rec pt pt idmap y) =
   Susp_rec pt pt idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
        y)) (merid p) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk57"><span class="nb">rewrite</span> transport_paths_FlFr, ap_compose, concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (ap (Susp_rec pt pt idmap) (merid p)))^ @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
   Susp_rec pt pt idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
        x)) (merid p) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk58"><span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
   Susp_rec pt pt idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
        x)) (merid p) =
ap f (ap (Susp_rec pt pt idmap) (merid p)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk59"><span class="nb">refine</span> (ap_compose
              (Susp_rec North South (<span class="kr">fun</span> <span class="nv">x0</span> =&gt; merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>))))
              (Susp_rec (point Y) (point Y) idmap) (merid p) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec pt pt idmap)
  (ap
     (Susp_rec North South
        (<span class="kr">fun</span> <span class="nv">x0</span> : point0 = point0 =&gt;
         merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>)))) 
     (merid p)) =
ap f (ap (Susp_rec pt pt idmap) (merid p)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5a"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> Susp_rec_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>) =
ap f (ap (Susp_rec pt pt idmap) (merid p)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5b"><span class="nb">refine</span> (concat_1p _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f p @ <span class="mi">1</span> =
ap f (ap (Susp_rec pt pt idmap) (merid p)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5c">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f p = ap f (ap (Susp_rec pt pt idmap) (merid p))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5d">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = ap (Susp_rec pt pt idmap) (merid p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point0 = point0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec pt pt idmap) (merid p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_rec_beta_merid _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point0</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point0 = point0) =&gt;
   (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
    f (Susp_rec pt pt idmap x)) y =
   (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
    Susp_rec pt pt idmap
      (functor_susp
         (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
         x)) y)
  (<span class="mi">1</span>
   :
   (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point0 = point0) =&gt;
    (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
     f (Susp_rec pt pt idmap x)) y =
    (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
     Susp_rec pt pt idmap
       (functor_susp
          (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
          x)) y) North)
  (<span class="mi">1</span>
   :
   (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point0 = point0) =&gt;
    (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
     f (Susp_rec pt pt idmap x)) y =
    (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
     Susp_rec pt pt idmap
       (functor_susp
          (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt; <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))
          x)) y) South)
  ((<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt;
    internal_paths_rew_r
      (<span class="kr">fun</span>
         <span class="nv">p0</span> : f (Susp_rec pt pt idmap South) =
              Susp_rec pt pt idmap
                (functor_susp
                   (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt;
                    <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>)) South) =&gt;
       p0 = <span class="mi">1</span>)
      (internal_paths_rew_r
         (<span class="kr">fun</span>
            <span class="nv">p0</span> : f (Susp_rec pt pt idmap North) =
                 f (Susp_rec pt pt idmap South) =&gt;
          (p0^ @ <span class="mi">1</span>) @
          ap
            (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
             Susp_rec pt pt idmap
               (functor_susp
                  (<span class="kr">fun</span> <span class="nv">p1</span> : point0 = point0 =&gt;
                   <span class="mi">1</span> @ (ap f p1 @ <span class="mi">1</span>)) x)) 
            (merid p) = <span class="mi">1</span>)
         (internal_paths_rew_r
            (<span class="kr">fun</span>
               <span class="nv">p0</span> : f (Susp_rec pt pt idmap South) =
                    f (Susp_rec pt pt idmap North) =&gt;
             p0 @
             ap
               (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
                Susp_rec pt pt idmap
                  (functor_susp
                     (<span class="kr">fun</span> <span class="nv">p1</span> : point0 = point0 =&gt;
                      <span class="mi">1</span> @ (ap f p1 @ <span class="mi">1</span>)) x)) 
               (merid p) = <span class="mi">1</span>)
            (moveR_Vp
               (ap
                  (<span class="kr">fun</span> <span class="nv">x</span> : Susp (point0 = point0) =&gt;
                   Susp_rec pt pt idmap
                     (functor_susp
                       (<span class="kr">fun</span> <span class="nv">p0</span> : point0 = point0 =&gt;
                       <span class="mi">1</span> @ (ap f p0 @ <span class="mi">1</span>)) x))
                  (merid p)) <span class="mi">1</span>
               (ap f
                  (ap (Susp_rec pt pt idmap) (merid p)))
               (ap_compose
                  (Susp_rec North South
                     (<span class="kr">fun</span> <span class="nv">x0</span> : point0 = point0 =&gt;
                      merid (<span class="mi">1</span> @ (ap f x0 @ <span class="mi">1</span>))))
                  (Susp_rec pt pt idmap) 
                  (merid p) @
                internal_paths_rew_r
                  (<span class="kr">fun</span>
                     <span class="nv">p0</span> : 
                      Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : point0 = point0 =&gt;
                       merid (<span class="mi">1</span> @ ...)) North =
                      Susp_rec North South
                       (<span class="kr">fun</span> <span class="nv">x0</span> : point0 = point0 =&gt;
                       merid (<span class="mi">1</span> @ ...)) South =&gt;
                   ap (Susp_rec pt pt idmap) p0 =
                   ap f
                     (ap 
                       (Susp_rec pt pt idmap)
                       (merid p)) @ <span class="mi">1</span>)
                  (internal_paths_rew_r
                     (<span class="kr">fun</span>
                       <span class="nv">p0</span> : 
                       Susp_rec pt pt idmap North =
                       Susp_rec pt pt idmap South =&gt;
                      p0 =
                      ap f
                       (ap 
                       (Susp_rec pt pt idmap)
                       (merid p)) @ <span class="mi">1</span>)
                     (concat_1p (ap f p @ <span class="mi">1</span>) @
                      ap11
                       (ap11 <span class="mi">1</span>
                       (ap11 <span class="mi">1</span>
                       (Susp_rec_beta_merid p)^)) <span class="mi">1</span>)
                     (Susp_rec_beta_merid
                       (<span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>))))
                  (Susp_rec_beta_merid p)))
            (concat_p1
               (ap f
                  (ap (Susp_rec pt pt idmap) (merid p)))^))
         (ap_compose (Susp_rec pt pt idmap) f
            (merid p)))
      (transport_paths_FlFr (merid p) <span class="mi">1</span>))
   :
   <span class="kr">forall</span> <span class="nv">x</span> : point0 = point0,
   transport
     (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point0 = point0) =&gt;
      (<span class="kr">fun</span> <span class="nv">x0</span> : Susp (point0 = point0) =&gt;
       f (Susp_rec pt pt idmap x0)) y =
      (<span class="kr">fun</span> <span class="nv">x0</span> : Susp (point0 = point0) =&gt;
       Susp_rec pt pt idmap
         (functor_susp
            (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt;
             <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) x0)) y) 
     (merid x)
     (<span class="mi">1</span>
      :
      (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point0 = point0) =&gt;
       (<span class="kr">fun</span> <span class="nv">x0</span> : Susp (point0 = point0) =&gt;
        f (Susp_rec pt pt idmap x0)) y =
       (<span class="kr">fun</span> <span class="nv">x0</span> : Susp (point0 = point0) =&gt;
        Susp_rec pt pt idmap
          (functor_susp
             (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt;
              <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) x0)) y) North) =
   (<span class="mi">1</span>
    :
    (<span class="kr">fun</span> <span class="nv">y</span> : Susp (point0 = point0) =&gt;
     (<span class="kr">fun</span> <span class="nv">x0</span> : Susp (point0 = point0) =&gt;
      f (Susp_rec pt pt idmap x0)) y =
     (<span class="kr">fun</span> <span class="nv">x0</span> : Susp (point0 = point0) =&gt;
      Susp_rec pt pt idmap
        (functor_susp
           (<span class="kr">fun</span> <span class="nv">p</span> : point0 = point0 =&gt;
            <span class="mi">1</span> @ (ap f p @ <span class="mi">1</span>)) x0)) y) South)) pt = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now the triangle identities *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk60"><span class="kn">Definition</span> <span class="nf">loop_susp_triangle1</span> (<span class="nv">X</span> : pType)
  : fmap loops (loop_susp_counit X) o* loop_susp_unit (loops X)
  ==* pmap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk61"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* This proof has a lot of overlap with [loop_susp_unit_natural]. Can a common lemma be factored out? *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk62">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) == pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk63"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (fmap loops (loop_susp_counit X)
   o* loop_susp_unit (loops X)) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit X)
o* loop_susp_unit (loops X) == pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk65"><span class="nb">intros</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>loops X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @
(ap (Susp_rec pt pt idmap) (merid p @ (merid <span class="mi">1</span>)^) @ <span class="mi">1</span>) =
p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk66">lhs napply concat_1p; lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>loops X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec pt pt idmap) (merid p @ (merid <span class="mi">1</span>)^) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk67">lhs napply (ap_pV _ (merid p) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>loops X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec pt pt idmap) (merid p) @
(ap (Susp_rec pt pt idmap) (merid <span class="mi">1</span>))^ = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk68">lhs napply (Susp_rec_beta_merid _ @@ inverse2 (Susp_rec_beta_merid _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>loops X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ <span class="mi">1</span>^ = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">p</span> : loops X =&gt;
  concat_1p
    (ap (Susp_rec pt pt idmap) (merid p @ (merid <span class="mi">1</span>)^) @
     <span class="mi">1</span>) @
  (concat_p1
     (ap (Susp_rec pt pt idmap) (merid p @ (merid <span class="mi">1</span>)^)) @
   (ap_pV (Susp_rec pt pt idmap) (merid p) (merid <span class="mi">1</span>) @
    ((Susp_rec_beta_merid p @@
      inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ concat_p1 p)))
  :
  (fmap loops (loop_susp_counit X)
   o* loop_susp_unit (loops X)) p = pmap_idmap p)
 :
 fmap loops (loop_susp_counit X)
 o* loop_susp_unit (loops X) == pmap_idmap) pt =
dpoint_eq
  (fmap loops (loop_susp_counit X)
   o* loop_susp_unit (loops X)) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^) @
   <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^)) @
 (ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
  ((Susp_rec_beta_merid pt @@
    inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>))) =
(ap
   (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
    <span class="mi">1</span> @ (ap (Susp_rec pt pt idmap) p @ <span class="mi">1</span>))
   (concat_pV (merid pt)) @ <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6b"><span class="kp">do</span> <span class="mi">2</span> rhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^) @
   <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^)) @
 (ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
  ((Susp_rec_beta_merid pt @@
    inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>))) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
   <span class="mi">1</span> @ (ap (Susp_rec pt pt idmap) p @ <span class="mi">1</span>))
  (concat_pV (merid pt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6c">rhs napply (ap_compose (<span class="kr">fun</span> <span class="nv">p</span> =&gt; ap _ p @ <span class="mi">1</span>) _ (concat_pV _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^) @
   <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^)) @
 (ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
  ((Susp_rec_beta_merid pt @@
    inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>))) =
ap (concat <span class="mi">1</span>)
  (ap
     (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
      ap (Susp_rec pt pt idmap) p @ <span class="mi">1</span>)
     (concat_pV (merid pt)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6d">rhs_V napply (concat_1p_1 _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_1p
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^) @
   <span class="mi">1</span>) @
(concat_p1
   (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^)) @
 (ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
  ((Susp_rec_beta_merid pt @@
    inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>))) =
concat_1p
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid pt)^) @
   <span class="mi">1</span>) @
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt; ap (Susp_rec pt pt idmap) p @ <span class="mi">1</span>)
  (concat_pV (merid pt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6e"><span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^)) @
(ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
 ((Susp_rec_beta_merid pt @@
   inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>)) =
ap
  (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt; ap (Susp_rec pt pt idmap) p @ <span class="mi">1</span>)
  (concat_pV (merid pt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk6f">rhs napply (ap_compose _ (<span class="kr">fun</span> <span class="nv">q</span> =&gt; q @ <span class="mi">1</span>) (concat_pV _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^)) @
(ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
 ((Susp_rec_beta_merid pt @@
   inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>)) =
ap (<span class="kr">fun</span> <span class="nv">q</span> : pt = pt =&gt; q @ <span class="mi">1</span>)
  (ap (ap (Susp_rec pt pt idmap))
     (concat_pV (merid pt)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk70">rhs_V napply concat_p1_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_p1
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid <span class="mi">1</span>)^)) @
(ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
 ((Susp_rec_beta_merid pt @@
   inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>)) =
concat_p1
  (ap (Susp_rec pt pt idmap) (merid pt @ (merid pt)^)) @
ap (ap (Susp_rec pt pt idmap)) (concat_pV (merid pt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk71"><span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap_pV (Susp_rec pt pt idmap) (merid pt) (merid <span class="mi">1</span>) @
((Susp_rec_beta_merid pt @@
  inverse2 (Susp_rec_beta_merid <span class="mi">1</span>)) @ <span class="mi">1</span>) =
ap (ap (Susp_rec pt pt idmap)) (concat_pV (merid pt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap_ap_concat_pV _ _ _ (Susp_rec_beta_merid pt)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>. <span class="c">(* A bit slow, ~0.09s. *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk72"><span class="kn">Definition</span> <span class="nf">loop_susp_triangle2</span> (<span class="nv">X</span> : pType)
  : loop_susp_counit (psusp X) o* fmap psusp (loop_susp_unit X)
  ==* pmap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit (psusp X)
o* fmap psusp (loop_susp_unit X) ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit (psusp X)
o* fmap psusp (loop_susp_unit X) ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk74"><span class="nb">simple refine</span> (Build_pHomotopy _ _);
  [ <span class="nb">simple refine</span> (Susp_ind _ _ _ _) | ]; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec ispointed_susp ispointed_susp idmap
  (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid pt)^)
     South) = South</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk75"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   Susp_rec ispointed_susp ispointed_susp idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid x0 @ (merid pt)^) y) = y)
  (merid x) <span class="mi">1</span> = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk76">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec ispointed_susp ispointed_susp idmap
  (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid pt)^)
     South) = South</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (merid (point X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk77">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   Susp_rec ispointed_susp ispointed_susp idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; merid x0 @ (merid pt)^) y) = y)
  (merid x) <span class="mi">1</span> = merid pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk78"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   Susp_rec ispointed_susp ispointed_susp idmap
     (functor_susp
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid pt)^) y) = y)
  (merid x) <span class="mi">1</span> = merid pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk79"><span class="nb">rewrite</span> transport_paths_FlFr, ap_idmap, ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (Susp_rec ispointed_susp ispointed_susp idmap)
    (ap
       (functor_susp
          (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; merid x @ (merid pt)^))
       (merid x)))^ @ <span class="mi">1</span>) @ merid x = merid pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7a"><span class="nb">rewrite</span> Susp_rec_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap (Susp_rec ispointed_susp ispointed_susp idmap)
    (merid (merid x @ (merid pt)^)))^ @ <span class="mi">1</span>) @ merid x =
merid pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7b"><span class="nb">apply</span> moveR_pM; <span class="nb">rewrite</span> concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (Susp_rec ispointed_susp ispointed_susp idmap)
   (merid (merid x @ (merid pt)^)))^ =
merid pt @ (merid x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7c"><span class="nb">refine</span> (inverse2 (Susp_rec_beta_merid _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(merid x @ (merid pt)^)^ = merid pt @ (merid x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> inv_pp, inv_V; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we can finally construct the adjunction equivalence. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7d"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint</span> `{Funext} (A B : pType)
  : (psusp A -&gt;** B) &lt;~&gt;* (A -&gt;** loops B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(psusp A -&gt;** B) &lt;~&gt;* (A -&gt;** loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(psusp A -&gt;** B) &lt;~&gt;* (A -&gt;** loops B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk7f">snapply Build_pEquiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(psusp A -&gt;** B) &lt;~&gt; (A -&gt;** loops B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk80" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk80"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk81">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(psusp A -&gt;** B) &lt;~&gt; (A -&gt;** loops B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk82"><span class="nb">refine</span> (equiv_adjointify
              (<span class="kr">fun</span> <span class="nv">f</span> =&gt; fmap loops f o* loop_susp_unit A)
              (<span class="kr">fun</span> <span class="nv">g</span> =&gt; loop_susp_counit B o* fmap psusp g) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A -&gt;* loops B =&gt;
 fmap loops (loop_susp_counit B o* fmap psusp x)
 o* loop_susp_unit A) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="psusp-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="psusp-v-chk83"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : psusp A $-&gt; B =&gt;
 loop_susp_counit B
 o* fmap psusp (fmap loops x o* loop_susp_unit A)) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk84">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A -&gt;* loops B =&gt;
 fmap loops (loop_susp_counit B o* fmap psusp x)
 o* loop_susp_unit A) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk85"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit B o* fmap psusp g)
o* loop_susp_unit A = g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk86"><span class="nb">apply</span> path_pforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit B o* fmap psusp g)
o* loop_susp_unit A ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk87">lhs&#39; <span class="bp">exact</span> (pmap_prewhisker _ (fmap_comp loops _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit B) $o
fmap loops (fmap psusp g) o* loop_susp_unit A ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk88">lhs&#39; <span class="nb">apply</span> pmap_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit B)
o* (fmap loops (fmap psusp g) o* loop_susp_unit A) ==*
g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk89">lhs&#39; <span class="bp">exact</span> (pmap_postwhisker _ (loop_susp_unit_natural g)^* ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit B)
o* (loop_susp_unit (loops B) o* g) ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8a">lhs_V&#39; <span class="nb">apply</span> pmap_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (loop_susp_counit B)
o* loop_susp_unit (loops B) o* g ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8b">lhs&#39; <span class="bp">exact</span> (pmap_prewhisker g (loop_susp_triangle1 B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_idmap o* g ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pmap_postcompose_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : psusp A $-&gt; B =&gt;
 loop_susp_counit B
 o* fmap psusp (fmap loops x o* loop_susp_unit A)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8d"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit B
o* fmap psusp (fmap loops f o* loop_susp_unit A) = f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8e"><span class="nb">apply</span> path_pforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit B
o* fmap psusp (fmap loops f o* loop_susp_unit A) ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk8f">lhs&#39; <span class="bp">exact</span> (pmap_postwhisker _ (fmap_comp psusp _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit B
o* (fmap psusp (fmap loops f) $o
    fmap psusp (loop_susp_unit A)) ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk90">lhs_V&#39; <span class="nb">apply</span> pmap_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit B o* fmap psusp (fmap loops f)
o* fmap psusp (loop_susp_unit A) ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk91">lhs&#39; <span class="bp">exact</span> (pmap_prewhisker _ (loop_susp_counit_natural f)^* ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* loop_susp_counit (psusp A)
o* fmap psusp (loop_susp_unit A) ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk92">lhs&#39; <span class="nb">apply</span> pmap_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
o* (loop_susp_counit (psusp A)
    o* fmap psusp (loop_susp_unit A)) ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk93">lhs&#39; <span class="bp">exact</span> (pmap_postwhisker f (loop_susp_triangle2 A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o* pmap_idmap ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pmap_precompose_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk94">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_adjointify
  (<span class="kr">fun</span> <span class="nv">f</span> : psusp A $-&gt; B =&gt;
   fmap loops f o* loop_susp_unit A)
  (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt;* loops B =&gt;
   loop_susp_counit B o* fmap psusp g)
  ((<span class="kr">fun</span> <span class="nv">g</span> : A -&gt;* loops B =&gt;
    path_pforall
      (phomotopy_transitive&#39;
         (fmap loops
            (loop_susp_counit B o* fmap psusp g)
          o* loop_susp_unit A)
         (fmap loops (loop_susp_counit B) $o
          fmap loops (fmap psusp g)
          o* loop_susp_unit A) g
         (pmap_prewhisker (loop_susp_unit A)
            (fmap_comp loops (fmap psusp g)
               (loop_susp_counit B)))
         (phomotopy_transitive&#39;
            (fmap loops (loop_susp_counit B) $o
             fmap loops (fmap psusp g)
             o* loop_susp_unit A)
            (fmap loops (loop_susp_counit B)
             o* (fmap loops (fmap psusp g)
                 o* loop_susp_unit A)) g
            (pmap_compose_assoc
               (fmap loops (loop_susp_counit B))
               (fmap loops (fmap psusp g))
               (loop_susp_unit A))
            (phomotopy_transitive&#39;
               (fmap loops (loop_susp_counit B)
                o* (fmap loops (fmap psusp g)
                    o* loop_susp_unit A))
               (fmap loops (loop_susp_counit B)
                o* (loop_susp_unit (loops B) o* g)) g
               (pmap_postwhisker
                  (fmap loops (loop_susp_counit B))
                  (loop_susp_unit_natural g)^*)
               (phomotopy_transitive&#39;
                  (fmap loops (loop_susp_counit B)
                   o* (loop_susp_unit (loops B) o* g))
                  (fmap loops (loop_susp_counit B)
                   o* loop_susp_unit (loops B) o* g) g
                  (phomotopy_symmetric&#39;
                     (fmap loops (loop_susp_counit B)
                      o* loop_susp_unit (loops B) o* g)
                     (fmap loops (loop_susp_counit B)
                      o* (loop_susp_unit (loops B)
                          o* g))
                     (pmap_compose_assoc
                        (fmap loops
                           (loop_susp_counit B))
                        (loop_susp_unit (loops B)) g))
                  (phomotopy_transitive&#39;
                     (fmap loops (loop_susp_counit B)
                      o* loop_susp_unit (loops B) o* g)
                     (pmap_idmap o* g) g
                     (pmap_prewhisker g
                        (loop_susp_triangle1 B))
                     (pmap_postcompose_idmap g)))))))
   :
   (<span class="kr">fun</span> <span class="nv">x</span> : A -&gt;* loops B =&gt;
    fmap loops (loop_susp_counit B o* fmap psusp x)
    o* loop_susp_unit A) == idmap)
  ((<span class="kr">fun</span> <span class="nv">f</span> : psusp A $-&gt; B =&gt;
    path_pforall
      (phomotopy_transitive&#39;
         (loop_susp_counit B
          o* fmap psusp
               (fmap loops f o* loop_susp_unit A))
         (loop_susp_counit B
          o* (fmap psusp (fmap loops f) $o
              fmap psusp (loop_susp_unit A))) f
         (pmap_postwhisker (loop_susp_counit B)
            (fmap_comp psusp (loop_susp_unit A)
               (fmap loops f)))
         (phomotopy_transitive&#39;
            (loop_susp_counit B
             o* (fmap psusp (fmap loops f) $o
                 fmap psusp (loop_susp_unit A)))
            (loop_susp_counit B
             o* fmap psusp (fmap loops f)
             o* fmap psusp (loop_susp_unit A)) f
            (phomotopy_symmetric&#39;
               (loop_susp_counit B
                o* fmap psusp (fmap loops f)
                o* fmap psusp (loop_susp_unit A))
               (loop_susp_counit B
                o* (fmap psusp (fmap loops f) $o
                    fmap psusp (loop_susp_unit A)))
               (pmap_compose_assoc
                  (loop_susp_counit B)
                  (fmap psusp (fmap loops f))
                  (fmap psusp (loop_susp_unit A))))
            (phomotopy_transitive&#39;
               (loop_susp_counit B
                o* fmap psusp (fmap loops f)
                o* fmap psusp (loop_susp_unit A))
               (f o* loop_susp_counit (psusp A)
                o* fmap psusp (loop_susp_unit A)) f
               (pmap_prewhisker
                  (fmap psusp (loop_susp_unit A))
                  (loop_susp_counit_natural f)^*)
               (phomotopy_transitive&#39;
                  (f o* loop_susp_counit (psusp A)
                   o* fmap psusp (loop_susp_unit A))
                  (f
                   o* (loop_susp_counit (psusp A)
                       o* fmap psusp
                            (loop_susp_unit A))) f
                  (pmap_compose_assoc f
                     (loop_susp_counit (psusp A))
                     (fmap psusp (loop_susp_unit A)))
                  (phomotopy_transitive&#39;
                     (f
                      o* (loop_susp_counit (psusp A)
                          o* fmap psusp
                               (loop_susp_unit A)))
                     (f o* pmap_idmap) f
                     (pmap_postwhisker f
                        (loop_susp_triangle2 A))
                     (pmap_precompose_idmap f)))))))
   :
   (<span class="kr">fun</span> <span class="nv">x</span> : psusp A $-&gt; B =&gt;
    loop_susp_counit B
    o* fmap psusp (fmap loops x o* loop_susp_unit A)) ==
   idmap) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk95"><span class="nb">apply</span> path_pforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_adjointify
  (<span class="kr">fun</span> <span class="nv">f</span> : psusp A $-&gt; B =&gt;
   fmap loops f o* loop_susp_unit A)
  (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt;* loops B =&gt;
   loop_susp_counit B o* fmap psusp g)
  (<span class="kr">fun</span> <span class="nv">g</span> : A -&gt;* loops B =&gt;
   path_pforall
     (phomotopy_transitive&#39;
        (fmap loops
           (loop_susp_counit B o* fmap psusp g)
         o* loop_susp_unit A)
        (fmap loops (loop_susp_counit B) $o
         fmap loops (fmap psusp g) o* loop_susp_unit A)
        g
        (pmap_prewhisker (loop_susp_unit A)
           (fmap_comp loops (fmap psusp g)
              (loop_susp_counit B)))
        (phomotopy_transitive&#39;
           (fmap loops (loop_susp_counit B) $o
            fmap loops (fmap psusp g)
            o* loop_susp_unit A)
           (fmap loops (loop_susp_counit B)
            o* (fmap loops (fmap psusp g)
                o* loop_susp_unit A)) g
           (pmap_compose_assoc
              (fmap loops (loop_susp_counit B))
              (fmap loops (fmap psusp g))
              (loop_susp_unit A))
           (phomotopy_transitive&#39;
              (fmap loops (loop_susp_counit B)
               o* (fmap loops (fmap psusp g)
                   o* loop_susp_unit A))
              (fmap loops (loop_susp_counit B)
               o* (loop_susp_unit (loops B) o* g)) g
              (pmap_postwhisker
                 (fmap loops (loop_susp_counit B))
                 (loop_susp_unit_natural g)^*)
              (phomotopy_transitive&#39;
                 (fmap loops (loop_susp_counit B)
                  o* (loop_susp_unit (loops B) o* g))
                 (fmap loops (loop_susp_counit B)
                  o* loop_susp_unit (loops B) o* g) g
                 (phomotopy_symmetric&#39;
                    (fmap loops (loop_susp_counit B)
                     o* loop_susp_unit (loops B) o* g)
                    (fmap loops (loop_susp_counit B)
                     o* (loop_susp_unit (loops B) o* g))
                    (pmap_compose_assoc
                       (fmap loops
                          (loop_susp_counit B))
                       (loop_susp_unit (loops B)) g))
                 (phomotopy_transitive&#39;
                    (fmap loops (loop_susp_counit B)
                     o* loop_susp_unit (loops B) o* g)
                    (pmap_idmap o* g) g
                    (pmap_prewhisker g
                       (loop_susp_triangle1 B))
                    (pmap_postcompose_idmap g)))))))
  (<span class="kr">fun</span> <span class="nv">f</span> : psusp A $-&gt; B =&gt;
   path_pforall
     (phomotopy_transitive&#39;
        (loop_susp_counit B
         o* fmap psusp
              (fmap loops f o* loop_susp_unit A))
        (loop_susp_counit B
         o* (fmap psusp (fmap loops f) $o
             fmap psusp (loop_susp_unit A))) f
        (pmap_postwhisker (loop_susp_counit B)
           (fmap_comp psusp (loop_susp_unit A)
              (fmap loops f)))
        (phomotopy_transitive&#39;
           (loop_susp_counit B
            o* (fmap psusp (fmap loops f) $o
                fmap psusp (loop_susp_unit A)))
           (loop_susp_counit B
            o* fmap psusp (fmap loops f)
            o* fmap psusp (loop_susp_unit A)) f
           (phomotopy_symmetric&#39;
              (loop_susp_counit B
               o* fmap psusp (fmap loops f)
               o* fmap psusp (loop_susp_unit A))
              (loop_susp_counit B
               o* (fmap psusp (fmap loops f) $o
                   fmap psusp (loop_susp_unit A)))
              (pmap_compose_assoc (loop_susp_counit B)
                 (fmap psusp (fmap loops f))
                 (fmap psusp (loop_susp_unit A))))
           (phomotopy_transitive&#39;
              (loop_susp_counit B
               o* fmap psusp (fmap loops f)
               o* fmap psusp (loop_susp_unit A))
              (f o* loop_susp_counit (psusp A)
               o* fmap psusp (loop_susp_unit A)) f
              (pmap_prewhisker
                 (fmap psusp (loop_susp_unit A))
                 (loop_susp_counit_natural f)^*)
              (phomotopy_transitive&#39;
                 (f o* loop_susp_counit (psusp A)
                  o* fmap psusp (loop_susp_unit A))
                 (f
                  o* (loop_susp_counit (psusp A)
                      o* fmap psusp (loop_susp_unit A)))
                 f
                 (pmap_compose_assoc f
                    (loop_susp_counit (psusp A))
                    (fmap psusp (loop_susp_unit A)))
                 (phomotopy_transitive&#39;
                    (f
                     o* (loop_susp_counit (psusp A)
                         o* fmap psusp
                              (loop_susp_unit A)))
                    (f o* pmap_idmap) f
                    (pmap_postwhisker f
                       (loop_susp_triangle2 A))
                    (pmap_precompose_idmap f))))))) pt ==*
pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk96"><span class="nb">unfold</span> equiv_adjointify, equiv_fun.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops pt o* loop_susp_unit A ==* pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk97">lhs&#39; <span class="bp">exact</span> (pmap_prewhisker _ fmap_loops_pconst).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst o* loop_susp_unit A ==* pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">tapply cat_zero_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And its naturality is easy. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk98"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint_nat_r</span> `{Funext} (A B B&#39; : pType)
  (f : psusp A -&gt;* B) (g : B -&gt;* B&#39;) : loop_susp_adjoint A B&#39; (g o* f)
  ==* fmap loops g o* loop_susp_adjoint A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_adjoint A B&#39; (g o* f) ==*
fmap loops g o* loop_susp_adjoint A B f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_adjoint A B&#39; (g o* f) ==*
fmap loops g o* loop_susp_adjoint A B f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   (ap g (point_eq f) @ point_eq g)^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; g (f x)) p @
    (ap g (point_eq f) @ point_eq g)))
  (whiskerL (ap g (point_eq f) @ point_eq g)^
     (concat_1p (ap g (point_eq f) @ point_eq g)) @
   concat_Vp (ap g (point_eq f) @ point_eq g))
o* loop_susp_unit A ==*
Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
   (point_eq g)^ @ (ap g p @ point_eq g))
  (whiskerL (point_eq g)^ (concat_1p (point_eq g)) @
   concat_Vp (point_eq g))
o* (Build_pMap
      (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
       (point_eq f)^ @ (ap f p @ point_eq f))
      (whiskerL (point_eq f)^ (concat_1p (point_eq f)) @
       concat_Vp (point_eq f)) o* loop_susp_unit A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9b">rhs_V&#39; <span class="nb">apply</span> pmap_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   (ap g (point_eq f) @ point_eq g)^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; g (f x)) p @
    (ap g (point_eq f) @ point_eq g)))
  (whiskerL (ap g (point_eq f) @ point_eq g)^
     (concat_1p (ap g (point_eq f) @ point_eq g)) @
   concat_Vp (ap g (point_eq f) @ point_eq g))
o* loop_susp_unit A ==*
Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
   (point_eq g)^ @ (ap g p @ point_eq g))
  (whiskerL (point_eq g)^ (concat_1p (point_eq g)) @
   concat_Vp (point_eq g))
o* Build_pMap
     (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
      (point_eq f)^ @ (ap f p @ point_eq f))
     (whiskerL (point_eq f)^ (concat_1p (point_eq f)) @
      concat_Vp (point_eq f)) o* loop_susp_unit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9c"><span class="nb">apply</span> pmap_prewhisker.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>psusp A -&gt;* B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt;* B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
   (ap g (point_eq f) @ point_eq g)^ @
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; g (f x)) p @
    (ap g (point_eq f) @ point_eq g)))
  (whiskerL (ap g (point_eq f) @ point_eq g)^
     (concat_1p (ap g (point_eq f) @ point_eq g)) @
   concat_Vp (ap g (point_eq f) @ point_eq g)) ==*
Build_pMap
  (<span class="kr">fun</span> <span class="nv">p</span> : pt = pt =&gt;
   (point_eq g)^ @ (ap g p @ point_eq g))
  (whiskerL (point_eq g)^ (concat_1p (point_eq g)) @
   concat_Vp (point_eq g))
o* Build_pMap
     (<span class="kr">fun</span> <span class="nv">p</span> : ispointed_susp = ispointed_susp =&gt;
      (point_eq f)^ @ (ap f p @ point_eq f))
     (whiskerL (point_eq f)^ (concat_1p (point_eq f)) @
      concat_Vp (point_eq f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap_comp loops f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9d"><span class="kn">Definition</span> <span class="nf">loop_susp_adjoint_nat_l</span> `{Funext} (A A&#39; B : pType)
  (f : A -&gt;* loops B) (g : A&#39; -&gt;* A) : (loop_susp_adjoint A&#39; B)^-<span class="mi">1</span> (f o* g)
  ==* (loop_susp_adjoint A B)^-<span class="mi">1</span> f o* fmap psusp g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(loop_susp_adjoint A&#39; B)^-<span class="mi">1</span> (f o* g) ==*
(loop_susp_adjoint A B)^-<span class="mi">1</span> f o* fmap psusp g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(loop_susp_adjoint A&#39; B)^-<span class="mi">1</span> (f o* g) ==*
(loop_susp_adjoint A B)^-<span class="mi">1</span> f o* fmap psusp g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chk9f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit B
o* Build_pMap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; f (g x))) <span class="mi">1</span> ==*
loop_susp_counit B o* Build_pMap (functor_susp f) <span class="mi">1</span>
o* Build_pMap (functor_susp g) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka0">rhs&#39; <span class="nb">apply</span> pmap_compose_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loop_susp_counit B
o* Build_pMap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; f (g x))) <span class="mi">1</span> ==*
loop_susp_counit B
o* (Build_pMap (functor_susp f) <span class="mi">1</span>
    o* Build_pMap (functor_susp g) <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka1"><span class="nb">apply</span> pmap_postwhisker.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt;* loops B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A&#39; -&gt;* A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_pMap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : A&#39; =&gt; f (g x))) <span class="mi">1</span> ==*
Build_pMap (functor_susp f) <span class="mi">1</span>
o* Build_pMap (functor_susp g) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap_comp psusp g f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka2"><span class="kn">Instance</span> <span class="nf">is1natural_loop_susp_adjoint_r</span> `{Funext} (A : pType)
  : Is1Natural (opyon (psusp A)) (opyon A o loops)
      (loop_susp_adjoint A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (opyon (psusp A)) (opyon A o loops)
  (<span class="kr">fun</span> <span class="nv">B</span> : pType =&gt; loop_susp_adjoint A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (opyon (psusp A)) (opyon A o loops)
  (<span class="kr">fun</span> <span class="nv">B</span> : pType =&gt; loop_susp_adjoint A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka4">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : pType) (<span class="nv">f</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">B</span> : pType =&gt; pointed_fun (loop_susp_adjoint A B))
  a&#39; $o fmap (opyon (psusp A)) f $==
fmap (opyon A o loops) f $o
(<span class="kr">fun</span> <span class="nv">B</span> : pType =&gt; pointed_fun (loop_susp_adjoint A B))
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka5"><span class="nb">intros</span> B B&#39; g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>opyon (psusp A) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(loop_susp_adjoint A B&#39; $o fmap (opyon (psusp A)) g) f =
(fmap (opyon A o loops) g $o loop_susp_adjoint A B) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka6">rhs_V rapply cat_assoc_strong.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>opyon (psusp A) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(loop_susp_adjoint A B&#39; $o fmap (opyon (psusp A)) g) f =
fmap loops g $o fmap loops f $o loop_susp_unit A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka7"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x o* loop_susp_unit A) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>opyon (psusp A) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (fmap (opyon (psusp A)) g f) =
fmap loops g $o fmap loops f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka8"><span class="nb">apply</span> path_pforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>opyon (psusp A) B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (fmap (opyon (psusp A)) g f) ==*
fmap loops g $o fmap loops f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">tapply (fmap_comp loops).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chka9"><span class="kn">Lemma</span> <span class="nf">natequiv_loop_susp_adjoint_r</span> `{Funext} (A : pType)
  : NatEquiv (opyon (psusp A)) (opyon A o loops).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (psusp A)) (opyon A o loops)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="psusp-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="psusp-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (psusp A)) (opyon A o loops)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply Build_NatEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
