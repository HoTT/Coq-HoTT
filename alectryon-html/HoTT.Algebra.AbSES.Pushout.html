<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Pushout.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types Truncations.Core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT.WildCat <span class="kn">Require Import</span> Core <span class="kn">Universe</span> <span class="nf">Opposite</span> NatTrans.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core Homotopy.ExactSequence HIT.epi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.ReflectiveSubuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbelianGroup AbPushout AbHom AbGroups.Biproduct.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbSES.Core AbSES.DirectSum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_add_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Pushouts of short exact sequences *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk1"><span class="kn">Definition</span> <span class="nf">abses_pushout</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  : AbSES B A -&gt; AbSES B A&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B A -&gt; AbSES B A&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B A -&gt; AbSES B A&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk3"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B A&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk4">snapply (Build_AbSES (ab_pushout f (inclusion E))
                        ab_pushout_inl
                        (ab_pushout_rec grp_homo_const (projection E) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_const o f == projection E o inclusion E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk5"><hr></label><div class="goal-conclusion">IsEmbedding ab_pushout_inl</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk6"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (ab_pushout_rec grp_homo_const (projection E) <span class="nl">?p</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk7"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) ab_pushout_inl
  (ab_pushout_rec grp_homo_const (projection E) <span class="nl">?p</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_const o f == projection E o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; rapply iscomplex_abses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding ab_pushout_inl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply ab_pushout_embedding_inl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (ab_pushout_rec grp_homo_const (projection E)
     ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; B) (<span class="nv">p</span> : x == y) (<span class="nv">x0</span> : A) =&gt;
       (p x0)^) (projection E o inclusion E)
        (grp_homo_const o f) (iscomplex_abses E)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb">napply (cancelR_issurjection ab_pushout_inr _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : E =&gt;
   ab_pushout_rec grp_homo_const (projection E)
     (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^)
     (ab_pushout_inr x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc">rapply (conn_map_homotopic _ (projection E)); <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : E =&gt;
 ab_pushout_rec grp_homo_const (projection E)
   (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^)
   (ab_pushout_inr x)) == projection E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply ab_pushout_rec_beta_right.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) ab_pushout_inl
  (ab_pushout_rec grp_homo_const (projection E)
     ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; B) (<span class="nv">p</span> : x == y) (<span class="nv">x0</span> : A) =&gt;
       (p x0)^) (projection E o inclusion E)
        (grp_homo_const o f) (iscomplex_abses E)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex ab_pushout_inl
  (ab_pushout_rec grp_homo_const (projection E)
     ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; B) (<span class="nv">p</span> : x == y) (<span class="nv">x0</span> : A) =&gt;
       (p x0)^) (projection E o inclusion E)
        (grp_homo_const o f) (iscomplex_abses E)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkf"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk10">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex ab_pushout_inl
  (ab_pushout_rec grp_homo_const (projection E)
     ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; B) (<span class="nv">p</span> : x == y) (<span class="nv">x0</span> : A) =&gt;
       (p x0)^) (projection E o inclusion E)
        (grp_homo_const o f) (iscomplex_abses E)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk11">srapply phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_pushout_rec grp_homo_const (projection E)
  ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; B) (<span class="nv">p</span> : x == y) (<span class="nv">x0</span> : A) =&gt;
    (p x0)^) (projection E o inclusion E)
     (grp_homo_const o f) (iscomplex_abses E))
o* ab_pushout_inl == pconst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply ab_pushout_rec_beta_left.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk12">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (phomotopy_homotopy_hset
        (ab_pushout_rec_beta_left f (inclusion E)
           grp_homo_const (projection E)
           (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk13"><span class="nb">intros</span> [bc&#39; p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f (inclusion E)
              grp_homo_const (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk14">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f (inclusion E)
              grp_homo_const (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** Pick a preimage under the quotient map. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk15"><span class="nb">assert</span> (bc : merely (hfiber grp_quotient_map bc&#39;)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (hfiber grp_quotient_map bc&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>merely (hfiber grp_quotient_map bc&#39;)</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk16"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f (inclusion E)
              grp_homo_const (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk17"><span class="mi">1</span>: <span class="nb">apply</span> center, issurj_class_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>merely (hfiber grp_quotient_map bc&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f (inclusion E)
              grp_homo_const (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk18">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>hfiber grp_quotient_map bc&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f (inclusion E)
              grp_homo_const (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk19"><span class="nb">destruct</span> bc <span class="kr">as</span> [[b c] q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f (inclusion E)
              grp_homo_const (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** The E-component of the preimage is in the kernel of [projection E]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk1a"><span class="nb">assert</span> (c_in_kernel : (projection E) c = mon_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E c = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="pushout-v-chk1b"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f (inclusion E)
              grp_homo_const (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk1c"><span class="mi">1</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E c = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk1d"><span class="nb">refine</span> (_ @ p); <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; =
projection E c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk1e"><span class="nb">rewrite</span> &lt;- q; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + projection E c = projection E c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk1f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f 
              (inclusion E) grp_homo_const
              (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** By exactness, we get an element in [A]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk20"><span class="nb">pose proof</span> (a := isexact_preimage _ _ _ c c_in_kernel).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (hfiber (inclusion E) c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f 
              (inclusion E) grp_homo_const
              (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk21">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>hfiber (inclusion E) c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f 
              (inclusion E) grp_homo_const
              (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk22"><span class="nb">destruct</span> a <span class="kr">as</span> [a s].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (ab_pushout_rec_beta_left f 
              (inclusion E) grp_homo_const
              (projection E)
              (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
     (bc&#39;; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="sd">(** Now the goal is to show that [bc&#39;] lies in the image of [ab_pushout_inl]. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk23"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (cxfib
     (phomotopy_homotopy_hset
        (ab_pushout_rec_beta_left f 
           (inclusion E) grp_homo_const 
           (projection E)
           (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^))))
  (bc&#39;; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk24"><span class="kr">exists</span> (<span class="nv">b</span> + - f (- a)); <span class="nb">cbn</span>.  <span class="c">(* It simplifies the algebra to write [- f(- a)] instead of [f a]. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(class_of
   (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
    Trunc (-<span class="mi">1</span>)
      {x0 : A &amp;
      (- f x0, inclusion E x0) =
      (- fst x + fst y, - snd x + snd y)})
   (b - f (- a), group_unit);
ab_pushout_rec_beta_left f 
  (inclusion E)
  (grp_homo_compose (grp_trivial_rec B)
     (grp_trivial_corec A&#39;)) 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^)
  (b - f (- a))) = (bc&#39;; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk25"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
   Trunc (-<span class="mi">1</span>)
     {x0 : A &amp;
     (- f x0, inclusion E x0) =
     (- fst x + fst y, - snd x + snd y)})
  (b - f (- a), group_unit) = bc&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk26"><span class="nb">change</span> (ab_pushout_inl (b + - f (- a)) = bc&#39;).  <span class="c">(* Just to guide the reader. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_pushout_inl (b - f (- a)) = bc&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk27"><span class="nb">refine</span> (_ @ q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_pushout_inl (b - f (- a)) = grp_quotient_map (b, c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk28"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_quotient_map (b, c) = ab_pushout_inl (b - f (- a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk29"><span class="nb">apply</span> path_ab_pushout; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trunc (-<span class="mi">1</span>)
  {x : A &amp;
  (- f x, inclusion E x) =
  (- b + (b - f (- a)), - c + group_unit)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk2a"><span class="nb">refine</span> (tr (-a; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- f (- a), inclusion E (- a)) =
(- b + (b - f (- a)), - c + group_unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk2b"><span class="nb">apply</span> path_prod; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- f (- a) = - b + (b - f (- a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk2c"><hr></label><div class="goal-conclusion">inclusion E (- a) = - c + group_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk2d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- f (- a) = - b + (b - f (- a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk2e"><span class="nb">apply</span> grp_moveL_Mg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- - b - f (- a) = b - f (- a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk2f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>bc'</var><span class="hyp-type"><b>: </b><span>ab_pushout f (inclusion E)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>ab_pushout_rec grp_homo_const 
  (projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; (iscomplex_abses E x0)^) bc&#39; = pt</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_quotient_map (b, c) = bc&#39;</span></span></span><br><span><var>c_in_kernel</var><span class="hyp-type"><b>: </b><span>projection E c = <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>inclusion E a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E (- a) = - c + group_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((preserves_inverse a) @ ap _ s @ (right_identity _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The universal property of [abses_pushout_morphism] *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk30"><span class="kn">Definition</span> <span class="nf">abses_pushout_morphism</span> `{Univalence} {A A&#39; B : AbGroup}
  (E : AbSES B A) (f : A $-&gt; A&#39;)
  : AbSESMorphism E (abses_pushout f E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk32">snapply (Build_AbSESMorphism f _ grp_homo_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; abses_pushout f E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk33"><hr></label><div class="goal-conclusion">inclusion (abses_pushout f E) $o f ==
<span class="nl">?component2</span> $o inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk34"><hr></label><div class="goal-conclusion">projection (abses_pushout f E) $o <span class="nl">?component2</span> ==
grp_homo_id $o projection E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; abses_pushout f E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ab_pushout_inr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout f E) $o f ==
ab_pushout_inr $o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ab_pushout_commsq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout f E) $o ab_pushout_inr ==
grp_homo_id $o projection E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply ab_pushout_rec_beta_right.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any map [f : E -&gt; F] of short exact sequences factors (uniquely) through [abses_pushout E f1]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk38"><span class="kn">Definition</span> <span class="nf">abses_pushout_morphism_rec</span> `{Univalence} {A B X Y : AbGroup}
  {E : AbSES B A} {F : AbSES Y X} (f : AbSESMorphism E F)
  : AbSESMorphism (abses_pushout (component1 f) E) F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism (abses_pushout (component1 f) E) F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism (abses_pushout (component1 f) E) F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk3a">snapply (Build_AbSESMorphism grp_homo_id _ (component3 f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (component1 f) E $-&gt; F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk3b"><hr></label><div class="goal-conclusion">inclusion F $o grp_homo_id ==
<span class="nl">?component2</span> $o
inclusion (abses_pushout (component1 f) E)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk3c"><hr></label><div class="goal-conclusion">projection F $o <span class="nl">?component2</span> ==
component3 f $o
projection (abses_pushout (component1 f) E)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (component1 f) E $-&gt; F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk3e">rapply ab_pushout_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="nl">?Goal</span> (component1 f x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="nl">?Goal0</span> (inclusion E x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_square.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F $o grp_homo_id ==
ab_pushout_rec (inclusion F) (component2 f)
  (left_square f) $o
inclusion (abses_pushout (component1 f) E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk40"><span class="nb">intro</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F x =
inclusion F x + component2 f group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk41"><span class="nb">rewrite</span> grp_homo_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F x = inclusion F x + <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_identity _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk42">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F $o
ab_pushout_rec (inclusion F) (component2 f)
  (left_square f) ==
component3 f $o
projection (abses_pushout (component1 f) E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk43">snapply (issurj_isepi_funext grp_quotient_map).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) grp_quotient_map</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk44"><hr></label><div class="goal-conclusion">projection F $o
ab_pushout_rec (inclusion F) (component2 f)
  (left_square f) o grp_quotient_map ==
component3 f $o
projection (abses_pushout (component1 f) E)
o grp_quotient_map</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk45"><hr></label><div class="goal-conclusion">IsHSet Y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk46"><span class="mi">1</span>: <span class="nb">apply</span> issurj_class_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F $o
ab_pushout_rec (inclusion F) (component2 f)
  (left_square f) o grp_quotient_map ==
component3 f $o
projection (abses_pushout (component1 f) E)
o grp_quotient_map</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk47"><hr></label><div class="goal-conclusion">IsHSet Y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk48"><span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F $o
ab_pushout_rec (inclusion F) (component2 f)
  (left_square f) o grp_quotient_map ==
component3 f $o
projection (abses_pushout (component1 f) E)
o grp_quotient_map</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk49"><span class="nb">intro</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod X E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F
  (inclusion F (fst x) + component2 f (snd x)) =
component3 f (group_unit + projection E (snd x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk4a">napply grp_homo_op_agree.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod X E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (inclusion F (fst x)) =
component3 f group_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod X E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk4b"><hr></label><div class="goal-conclusion">projection F (component2 f (snd x)) =
component3 f (projection E (snd x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk4c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod X E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (inclusion F (fst x)) =
component3 f group_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk4d"><span class="nb">refine</span> (_ @ (grp_homo_unit _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod X E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (inclusion F (fst x)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> iscomplex_abses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk4e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod X E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (component2 f (snd x)) =
component3 f (projection E (snd x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> right_square.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The original map factors via the induced map. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk4f"><span class="kn">Definition</span> <span class="nf">abses_pushout_morphism_rec_beta</span> `{Univalence} (A B X Y : AbGroup)
  (E : AbSES B A) (F : AbSES Y X) (f : AbSESMorphism E F)
  : f = absesmorphism_compose (abses_pushout_morphism_rec f)
                              (abses_pushout_morphism E (component1 f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =
absesmorphism_compose (abses_pushout_morphism_rec f)
  (abses_pushout_morphism E (component1 f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =
absesmorphism_compose (abses_pushout_morphism_rec f)
  (abses_pushout_morphism E (component1 f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk51"><span class="nb">apply</span> (equiv_ap issig_AbSESMorphism^-<span class="mi">1</span> _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">issig_AbSESMorphism^-<span class="mi">1</span> f =
issig_AbSESMorphism^-<span class="mi">1</span>
  (absesmorphism_compose
     (abses_pushout_morphism_rec f)
     (abses_pushout_morphism E (component1 f)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk52">srapply path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
(issig_AbSESMorphism^-<span class="mi">1</span>
   (absesmorphism_compose
      (abses_pushout_morphism_rec f)
      (abses_pushout_morphism E (component1 f)))).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk53"><span class="mi">1</span>: <span class="nb">apply</span> path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
fst
  (issig_AbSESMorphism^-<span class="mi">1</span>
     (absesmorphism_compose
        (abses_pushout_morphism_rec f)
        (abses_pushout_morphism E (component1 f)))).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk54"><hr></label><div class="goal-conclusion">snd (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
snd
  (issig_AbSESMorphism^-<span class="mi">1</span>
     (absesmorphism_compose
        (abses_pushout_morphism_rec f)
        (abses_pushout_morphism E (component1 f)))).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk55"><span class="mi">1</span>: <span class="nb">apply</span> path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (fst (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span>) =
fst
  (fst
     (issig_AbSESMorphism^-<span class="mi">1</span>
        (absesmorphism_compose
           (abses_pushout_morphism_rec f)
           (abses_pushout_morphism E (component1 f)))).<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk56"><hr></label><div class="goal-conclusion">snd (fst (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span>) =
snd
  (fst
     (issig_AbSESMorphism^-<span class="mi">1</span>
        (absesmorphism_compose
           (abses_pushout_morphism_rec f)
           (abses_pushout_morphism E (component1 f)))).<span class="mi">1</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk57"><hr></label><div class="goal-conclusion">snd (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
snd
  (issig_AbSESMorphism^-<span class="mi">1</span>
     (absesmorphism_compose
        (abses_pushout_morphism_rec f)
        (abses_pushout_morphism E (component1 f)))).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk58"><span class="kp">all</span>: <span class="nb">apply</span> equiv_path_grouphomomorphism; <span class="nb">intro</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">component1 f x = component1 f x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk59"><hr></label><div class="goal-conclusion">component2 f x =
inclusion F group_unit + component2 f x</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk5a"><hr></label><div class="goal-conclusion">component3 f x = component3 f x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk5b"><span class="mi">1</span>,<span class="mi">3</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">component2 f x =
inclusion F group_unit + component2 f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk5c"><span class="nb">rewrite</span> grp_homo_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">component2 f x = <span class="mi">0</span> + component2 f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_identity _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given [E : AbSES B A&#39;] and [F : AbSES B A] and a morphism [f : E -&gt; F], the pushout of [E] along [f_1] is [F] if [f_3] is homotopic to [id_B]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk5d"><span class="kn">Lemma</span> <span class="nf">abses_pushout_component3_id&#39;</span> `{Univalence}
  {A A&#39; B : AbGroup} {E : AbSES B A&#39;} {F : AbSES B A}
  (f : AbSESMorphism E F) (h : component3 f == grp_homo_id)
  : abses_pushout (component1 f) E $== F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (component1 f) E $== F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (component1 f) E $== F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk5f"><span class="nb">pose</span> (g := abses_pushout_morphism_rec f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (component1 f) E $== F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk60">napply abses_path_data_to_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data (abses_pushout (component1 f) E) F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk61"><span class="kr">exists</span> (<span class="nv">component2</span> <span class="nv">g</span>); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">component2 g $o
inclusion (abses_pushout (component1 f) E) ==
inclusion F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br></div><label class="goal-separator" for="pushout-v-chk62"><hr></label><div class="goal-conclusion">projection (abses_pushout (component1 f) E) ==
projection F $o component2 g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk63">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">component2 g $o
inclusion (abses_pushout (component1 f) E) ==
inclusion F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk64"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(component2 g $o
 inclusion (abses_pushout (component1 f) E)) x =
inclusion F x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_square g _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk65">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout (component1 f) E) ==
projection F $o component2 g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk66"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component3 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pushout_morphism_rec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism (abses_pushout (component1 f) E) F</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pushout (component1 f) E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout (component1 f) E) x =
(projection F $o component2 g) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((right_square g _) @ h _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version with equality instead of path data. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_component3_id</span> `{Univalence}
  {A A&#39; B : AbGroup} {E : AbSES B A&#39;} {F : AbSES B A}
  (f : AbSESMorphism E F) (h : component3 f == grp_homo_id)
  : abses_pushout (component1 f) E = F
  := equiv_path_abses_iso (abses_pushout_component3_id&#39; f h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given short exact sequences [E] and [F] and homomorphisms [f : A&#39; $-&gt; A] and [g : D&#39; $-&gt; D], there is a morphism [E + F -&gt; fE + gF] induced by the universal properties of the pushouts of [E] and [F]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_directsum_pushout_morphism</span> `{Univalence}
  {A A&#39; B C D D&#39; : AbGroup} {E : AbSES B A&#39;} {F : AbSES C D&#39;}
  (f : A&#39; $-&gt; A) (g : D&#39; $-&gt; D)
  : AbSESMorphism (abses_direct_sum E F) (abses_direct_sum (abses_pushout f E) (abses_pushout g F))
  := functor_abses_directsum (abses_pushout_morphism E f) (abses_pushout_morphism F g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For [E, F : AbSES B A&#39;] and [f, g : A&#39; $-&gt; A], we have (f+g)(E+F) = fE + gF, where + denotes the direct sum. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_directsum_distributive_pushouts</span> `{Univalence}
  {A A&#39; B C C&#39; D : AbGroup} {E : AbSES B A&#39;} {F : AbSES D C&#39;} (f : A&#39; $-&gt; A) (g : C&#39; $-&gt; C)
  : abses_pushout (functor_ab_biprod f g) (abses_direct_sum E F)
    = abses_direct_sum (abses_pushout f E) (abses_pushout g F)
  := abses_pushout_component3_id (abses_directsum_pushout_morphism f g) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given an [AbSESMorphism] whose third component is the identity, we know that it induces a path from the pushout of the domain along the first map to the codomain. Conversely, given a path from a pushout, we can deduce that the following square commutes: *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk67"><span class="kn">Definition</span> <span class="nf">abses_path_pushout_inclusion_commsq</span> `{Univalence} {A A&#39; B : AbGroup}
  (alpha : A $-&gt; A&#39;) (E : AbSES B A) (F : AbSES B A&#39;)
  (p : abses_pushout alpha E = F)
  : <span class="kr">exists</span> <span class="nv">phi</span> : middle E $-&gt; F, inclusion F o alpha == phi o inclusion E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : E $-&gt; F &amp;
inclusion F o alpha == phi o inclusion E}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : E $-&gt; F &amp;
inclusion F o alpha == phi o inclusion E}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk69"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : E $-&gt; abses_pushout alpha E &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 inclusion (abses_pushout alpha E) (alpha x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; phi (inclusion E x))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk6a"><span class="kr">exists</span> <span class="nv">ab_pushout_inr</span>; <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout alpha E) (alpha x) =
ab_pushout_inr (inclusion E x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply ab_pushout_commsq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality of [abses_pushout f : AbSES B A -&gt; AbSES B A&#39;] *)</span>

<span class="sd">(** In this file we will prove various &quot;levels&quot; of functoriality of pushing out. Here we show that the induced map between [AbSES B A] respect the groupoid structure of [is1gpd_abses] from AbSES.Core. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk6b"><span class="kn">Instance</span> <span class="nf">is0functor_abses_pushout</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  : Is0Functor (abses_pushout (B:=B) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (abses_pushout f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (abses_pushout f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk6d">srapply Build_Is0Functor;
    <span class="nb">intros</span> E F p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f E $-&gt; abses_pushout f F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk6e">srapply abses_path_data_to_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data (abses_pushout f E)
  (abses_pushout f F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk6f">srefine (functor_ab_pushout f f (inclusion _) (inclusion _) grp_homo_id grp_homo_id p.<span class="mi">1</span> _ _; (_, _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_id $o f == f $o grp_homo_id</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk70"><hr></label><div class="goal-conclusion">inclusion F $o grp_homo_id == p.<span class="mi">1</span> $o inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk71"><hr></label><div class="goal-conclusion">functor_ab_pushout f f (inclusion E) (inclusion F)
  grp_homo_id grp_homo_id p.<span class="mi">1</span> <span class="nl">?h</span> <span class="nl">?k</span> $o
inclusion (abses_pushout f E) ==
inclusion (abses_pushout f F)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk72"><hr></label><div class="goal-conclusion">projection (abses_pushout f E) ==
projection (abses_pushout f F) $o
functor_ab_pushout f f (inclusion E) (inclusion F)
  grp_homo_id grp_homo_id p.<span class="mi">1</span> <span class="nl">?h</span> <span class="nl">?k</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk73">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_id $o f == f $o grp_homo_id</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk74">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F $o grp_homo_id == p.<span class="mi">1</span> $o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> (fst p.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk75">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_ab_pushout f f (inclusion E) (inclusion F)
  grp_homo_id grp_homo_id p.<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)
  ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; F) (<span class="nv">p</span> : x == y) (<span class="nv">x0</span> : A) =&gt;
    (p x0)^) (p.<span class="mi">1</span> $o inclusion E)
     (inclusion F $o grp_homo_id) (fst p.<span class="mi">2</span>)) $o
inclusion (abses_pushout f E) ==
inclusion (abses_pushout f F)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply ab_pushout_rec_beta_left.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk76">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout f E) ==
projection (abses_pushout f F) $o
functor_ab_pushout f f (inclusion E) (inclusion F)
  grp_homo_id grp_homo_id p.<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)
  ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A -&gt; F) (<span class="nv">p</span> : x == y) (<span class="nv">x0</span> : A) =&gt;
    (p x0)^) (p.<span class="mi">1</span> $o inclusion E)
     (inclusion F $o grp_homo_id) (fst p.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk77">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ab_biprod A&#39; E,
(<span class="kr">fun</span>
   <span class="nv">x</span> : ab_biprod A&#39; E /
       in_cosetL
         {|
           normalsubgroup_subgroup :=
             ab_pushout_subgroup f (inclusion E);
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup (ab_biprod A&#39; E)
               (ab_pushout_subgroup f (inclusion E))
         |} =&gt;
 projection (abses_pushout f E) x =
 (projection (abses_pushout f F) $o
  functor_ab_pushout f f (inclusion E) (inclusion F)
    grp_homo_id grp_homo_id p.<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)
    ((<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A -&gt; F) (<span class="nv">p</span> : x0 == y) (<span class="nv">x1</span> : A) =&gt;
      (p x1)^) (p.<span class="mi">1</span> $o inclusion E)
       (inclusion F $o grp_homo_id) (fst p.<span class="mi">2</span>))) x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup :=
            ab_pushout_subgroup f (inclusion E);
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup (ab_biprod A&#39; E)
              (ab_pushout_subgroup f (inclusion E))
        |}) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk78"><span class="nb">intro</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod A&#39; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + projection E (snd x) =
group_unit + projection F (group_unit + p.<span class="mi">1</span> (snd x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk79"><span class="nb">apply</span> grp_cancelL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod A&#39; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (snd x) =
projection F (group_unit + p.<span class="mi">1</span> (snd x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk7a"><span class="nb">refine</span> (snd p.<span class="mi">2</span> (snd x) @ ap (projection F) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod A&#39; E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p.<span class="mi">1</span> (snd x) = group_unit + p.<span class="mi">1</span> (snd x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_identity _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk7b"><span class="kn">Instance</span> <span class="nf">is1functor_abses_pushout</span> `{Univalence}
  {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  : Is1Functor (abses_pushout (B:=B) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (abses_pushout f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (abses_pushout f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk7d">srapply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (abses_pushout f) f0 $== fmap (abses_pushout f) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk7e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbSES B A,
fmap (abses_pushout f) (Id a) $==
Id (abses_pushout f a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk7f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f0</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c),
fmap (abses_pushout f) (g $o f0) $==
fmap (abses_pushout f) g $o fmap (abses_pushout f) f0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk80">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (abses_pushout f) f0 $== fmap (abses_pushout f) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk81"><span class="nb">intros</span> E F g0 g1 h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g0 $== g1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pushout f) g0 $==
fmap (abses_pushout f) g1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk82">rapply Quotient_ind_hprop; <span class="nb">intros</span> [a&#39; e]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g0 $== g1</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * F =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion F x0) = - x + y})
  (a&#39;, group_unit) +
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * F =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion F x0) = - x + y})
  (group_unit, g0.<span class="mi">1</span> e) =
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * F =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion F x0) = - x + y})
  (a&#39;, group_unit) +
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * F =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion F x0) = - x + y})
  (group_unit, g1.<span class="mi">1</span> e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (h e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbSES B A,
fmap (abses_pushout f) (Id a) $==
Id (abses_pushout f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk84"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pushout f) (Id E) $==
Id (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk85">rapply Quotient_ind_hprop; <span class="nb">intros</span> [a&#39; e]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion E x0) = - x + y})
  (a&#39;, group_unit) +
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion E x0) = - x + y})
  (group_unit, e) =
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion E x0) = - x + y})
  (a&#39;, e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk86"><span class="nb">refine</span> (ap (class_of _) (path_prod&#39; _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + group_unit = a&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk87"><hr></label><div class="goal-conclusion">group_unit + e = e</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk88">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + group_unit = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_unit_r _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk89">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + e = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_unit_l _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk8a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f0</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c),
fmap (abses_pushout f) (g $o f0) $==
fmap (abses_pushout f) g $o fmap (abses_pushout f) f0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk8b"><span class="nb">intros</span> E F G g0 g1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pushout f) (g1 $o g0) $==
fmap (abses_pushout f) g1 $o fmap (abses_pushout f) g0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk8c">rapply Quotient_ind_hprop; <span class="nb">intros</span> [a&#39; e]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * G =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion G x0) = - x + y})
  (a&#39;, group_unit) +
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * G =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion G x0) = - x + y})
  (group_unit, g1.<span class="mi">1</span> (g0.<span class="mi">1</span> e)) =
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * G =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion G x0) = - x + y})
  (a&#39; + group_unit, group_unit) +
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * G =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion G x0) = - x + y})
  (group_unit, g1.<span class="mi">1</span> (group_unit + g0.<span class="mi">1</span> e))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk8d"><span class="nb">refine</span> (ap (class_of _) (path_prod&#39; _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + group_unit = a&#39; + group_unit + group_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk8e"><hr></label><div class="goal-conclusion">group_unit + g1.<span class="mi">1</span> (g0.<span class="mi">1</span> e) =
group_unit + g1.<span class="mi">1</span> (group_unit + g0.<span class="mi">1</span> e)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk8f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + group_unit = a&#39; + group_unit + group_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_unit_r _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk90">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + g1.<span class="mi">1</span> (g0.<span class="mi">1</span> e) =
group_unit + g1.<span class="mi">1</span> (group_unit + g0.<span class="mi">1</span> e)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ + g1.<span class="mi">1</span> x) (grp_unit_l _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk91"><span class="kn">Definition</span> <span class="nf">abses_pushout_path_data_1</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;) {E : AbSES B A} 
  : fmap (abses_pushout f) (Id E) = Id (abses_pushout f E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pushout f) (Id E) = Id (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk92"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pushout f) (Id E) = Id (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk93">srapply path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pushout f) (Id E)).<span class="mi">1</span> =
(Id (abses_pushout f E)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk94"><span class="nb">apply</span> equiv_path_groupisomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pushout f) (Id E)).<span class="mi">1</span> ==
(Id (abses_pushout f E)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk95">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ab_biprod A&#39; E,
(<span class="kr">fun</span>
   <span class="nv">x</span> : ab_biprod A&#39; E /
       in_cosetL
         {|
           normalsubgroup_subgroup :=
             ab_pushout_subgroup f (inclusion E);
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup (ab_biprod A&#39; E)
               (ab_pushout_subgroup f (inclusion E))
         |} =&gt;
 (fmap (abses_pushout f) (Id E)).<span class="mi">1</span> x =
 (Id (abses_pushout f E)).<span class="mi">1</span> x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup :=
            ab_pushout_subgroup f (inclusion E);
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup (ab_biprod A&#39; E)
              (ab_pushout_subgroup f (inclusion E))
        |}) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk96"><span class="nb">intros</span> [a&#39; e]; <span class="nb">simpl</span>. <span class="c">(* This is true even on the representatives. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion E x0) = - x + y})
  (a&#39;, group_unit) +
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion E x0) = - x + y})
  (group_unit, e) =
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A&#39; * E =&gt;
   Tr (-<span class="mi">1</span>)
     {x0 : A &amp; (- f x0, inclusion E x0) = - x + y})
  (a&#39;, e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk97"><span class="nb">apply</span> qglue.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_cosetL (ab_pushout_subgroup f (inclusion E))
  ((a&#39;, group_unit) + (group_unit, e)) (a&#39;, e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk98"><span class="nb">refine</span> (tr (<span class="mi">0</span>; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_corec (ab_homo_negation $o f) (inclusion E)
  <span class="mi">0</span> = - ((a&#39;, group_unit) + (group_unit, e)) + (a&#39;, e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk99"><span class="nb">apply</span> path_prod&#39;; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- f <span class="mi">0</span> = - (a&#39; + group_unit) + a&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk9a"><hr></label><div class="goal-conclusion">inclusion E <span class="mi">0</span> = - (group_unit + e) + e</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk9b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- f <span class="mi">0</span> = - (a&#39; + group_unit) + a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk9c"><span class="nb">refine</span> (ap _ (grp_homo_unit _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- <span class="mi">0</span> = - (a&#39; + group_unit) + a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk9d"><span class="nb">refine</span> (grp_inv_unit @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = - (a&#39; + group_unit) + a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk9e"><span class="nb">apply</span> grp_moveL_Vg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + group_unit + <span class="mi">0</span> = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_identity _ @ right_identity _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk9f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E <span class="mi">0</span> = - (group_unit + e) + e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka0"><span class="nb">refine</span> (grp_homo_unit _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = - (group_unit + e) + e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka1"><span class="nb">apply</span> grp_moveL_Vg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + e + <span class="mi">0</span> = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_identity _ @ left_identity _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka2"><span class="kn">Definition</span> <span class="nf">ap_abses_pushout</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  {E F : AbSES B A} (p : E = F)
  : ap (abses_pushout f) p
    = equiv_path_abses_iso (fmap (abses_pushout f) (equiv_path_abses_iso^-<span class="mi">1</span> p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pushout f) p =
equiv_path_abses_iso
  (fmap (abses_pushout f) (equiv_path_abses_iso^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pushout f) p =
equiv_path_abses_iso
  (fmap (abses_pushout f) (equiv_path_abses_iso^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka4"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pushout f) <span class="mi">1</span> =
equiv_path_abses_iso
  (fmap (abses_pushout f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka5"><span class="nb">refine</span> (_ @ ap _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pushout f) <span class="mi">1</span> = equiv_path_abses_iso <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chka6"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> =
fmap (abses_pushout f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka7"><span class="mi">2</span>: <span class="bp">exact</span> ((abses_pushout_path_data_1 f)^ @ ap _ equiv_path_absesV_1^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pushout f) <span class="mi">1</span> =
equiv_path_abses_iso (Id (abses_pushout f E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_abses_1^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka8"><span class="kn">Definition</span> <span class="nf">ap_abses_pushout_data</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  {E F : AbSES B A} (p : E $== F)
  : ap (abses_pushout f) (equiv_path_abses_iso p)
    = equiv_path_abses_iso (fmap (abses_pushout f) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $== F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pushout f) (equiv_path_abses_iso p) =
equiv_path_abses_iso (fmap (abses_pushout f) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chka9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $== F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pushout f) (equiv_path_abses_iso p) =
equiv_path_abses_iso (fmap (abses_pushout f) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkaa"><span class="nb">refine</span> (ap_abses_pushout _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $== F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso
  (fmap (abses_pushout f)
     (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso p))) =
equiv_path_abses_iso (fmap (abses_pushout f) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkab"><span class="nb">apply</span> (ap (equiv_path_abses_iso o _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $== F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkac"><span class="kn">Definition</span> <span class="nf">abses_pushout_point&#39;</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  : abses_pushout f (point (AbSES B A)) $== pt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f pt $== pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f pt $== pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkae">srapply abses_path_data_to_iso;
    srefine (_; (_,_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f pt $-&gt; pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkaf"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion (abses_pushout f pt) ==
inclusion pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkb0"><hr></label><div class="goal-conclusion">projection (abses_pushout f pt) ==
projection pt $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f pt $-&gt; pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb2">snrefine (ab_pushout_rec ab_biprod_inl _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt $-&gt; ab_biprod A&#39; B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkb3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkb3"><hr></label><div class="goal-conclusion">ab_biprod_inl o f == <span class="nl">?c</span> o inclusion pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt $-&gt; ab_biprod A&#39; B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_ab_biprod f grp_homo_id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_inl o f ==
functor_ab_biprod f grp_homo_id o inclusion pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_pushout_rec ab_biprod_inl
  (functor_ab_biprod f grp_homo_id) (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) $o
inclusion (abses_pushout f pt) == inclusion pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb7"><span class="nb">intro</span> a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_pushout_rec ab_biprod_inl
   (functor_ab_biprod f grp_homo_id) (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) $o
 inclusion (abses_pushout f pt)) a&#39; = inclusion pt a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkb8"><span class="nb">apply</span> path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst
  ((ab_pushout_rec ab_biprod_inl
      (functor_ab_biprod f grp_homo_id)
      (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) $o
    inclusion (abses_pushout f pt)) a&#39;) =
fst (inclusion pt a&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkb9"><hr></label><div class="goal-conclusion">snd
  ((ab_pushout_rec ab_biprod_inl
      (functor_ab_biprod f grp_homo_id)
      (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) $o
    inclusion (abses_pushout f pt)) a&#39;) =
snd (inclusion pt a&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkba">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst
  ((ab_pushout_rec ab_biprod_inl
      (functor_ab_biprod f grp_homo_id)
      (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) $o
    inclusion (abses_pushout f pt)) a&#39;) =
fst (inclusion pt a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkbb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + f <span class="mi">0</span> = a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (grp_homo_unit f) @ right_identity _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkbc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  ((ab_pushout_rec ab_biprod_inl
      (functor_ab_biprod f grp_homo_id)
      (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>) $o
    inclusion (abses_pushout f pt)) a&#39;) =
snd (inclusion pt a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkbd"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + <span class="mi">0</span> = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_identity _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkbe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout f pt) ==
projection pt $o
ab_pushout_rec ab_biprod_inl
  (functor_ab_biprod f grp_homo_id) (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkbf">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ab_biprod A&#39; pt,
(<span class="kr">fun</span>
   <span class="nv">x</span> : ab_biprod A&#39; pt /
       in_cosetL
         {|
           normalsubgroup_subgroup :=
             ab_pushout_subgroup f (inclusion pt);
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup (ab_biprod A&#39; pt)
               (ab_pushout_subgroup f (inclusion pt))
         |} =&gt;
 projection (abses_pushout f pt) x =
 (projection pt $o
  ab_pushout_rec ab_biprod_inl
    (functor_ab_biprod f grp_homo_id)
    (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)) x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup :=
            ab_pushout_subgroup f (inclusion pt);
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup (ab_biprod A&#39; pt)
              (ab_pushout_subgroup f (inclusion pt))
        |}) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_point</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  : abses_pushout f (point (AbSES B A)) = pt
  := equiv_path_abses_iso (abses_pushout_point&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout&#39;</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  : AbSES B A --&gt;* AbSES B A&#39;
  := Build_BasepointPreservingFunctor (abses_pushout f) (abses_pushout_point&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_pmap</span> `{Univalence} {A A&#39; B : AbGroup} (f : A $-&gt; A&#39;)
  : AbSES B A -&gt;* AbSES B A&#39;
  := to_pointed (abses_pushout&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The following general lemma lets us show that [abses_pushout f E] is trivial in cases of interest. It says that if you have a map [phi : E -&gt; A&#39;], then if you push out along the restriction [phi $o inclusion E], the result is trivial. Specifically, we get a morphism witnessing this fact.  *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc0"><span class="kn">Definition</span> <span class="nf">abses_pushout_trivial_morphism</span> {<span class="nv">B</span> <span class="nv">A</span> <span class="nv">A&#39;</span> : AbGroup}
  (<span class="nv">E</span> : AbSES B A) (<span class="nv">f</span> : A $-&gt; A&#39;) (<span class="nv">phi</span> : middle E $-&gt; A&#39;)
  (<span class="nv">k</span> : f == phi $o inclusion E)
  : AbSESMorphism E (pt : AbSES B A&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E (pt : AbSES B A&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E (pt : AbSES B A&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc2">srapply (Build_AbSESMorphism f _ grp_homo_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkc3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkc3"><hr></label><div class="goal-conclusion">inclusion pt $o f == <span class="nl">?component2</span> $o inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkc4"><hr></label><div class="goal-conclusion">projection pt $o <span class="nl">?component2</span> ==
grp_homo_id $o projection E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc5"><span class="mi">1</span>: <span class="bp">exact</span> (ab_biprod_corec phi (projection E)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion pt $o f ==
ab_biprod_corec phi (projection E) $o inclusion E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkc6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkc6"><hr></label><div class="goal-conclusion">projection pt $o ab_biprod_corec phi (projection E) ==
grp_homo_id $o projection E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc7">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion pt $o f ==
ab_biprod_corec phi (projection E) $o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc8"><span class="nb">intro</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f a, group_unit) =
(phi (inclusion E a), projection E (inclusion E a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkc9"><span class="nb">refine</span> (path_prod&#39; (k a) _^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E a) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isexact_inclusion_projection.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkca">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>E $-&gt; A&#39;</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>f == phi $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection pt $o ab_biprod_corec phi (projection E) ==
grp_homo_id $o projection E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The pushout of a short exact sequence along its inclusion map is trivial. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_inclusion_morphism</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
  : AbSESMorphism E (pt : AbSES B E)
  := abses_pushout_trivial_morphism E (inclusion E) grp_homo_id (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_inclusion</span> `{Univalence} {B A : AbGroup} (E : AbSES B A)
  : abses_pushout (inclusion E) E = pt
  := abses_pushout_component3_id
       (abses_pushout_inclusion_morphism E) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pushing out along [grp_homo_const] is trivial. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_const_morphism</span> {<span class="nv">B</span> <span class="nv">A</span> <span class="nv">A&#39;</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
  : AbSESMorphism E (pt : AbSES B A&#39;)
  := abses_pushout_trivial_morphism E
       grp_homo_const grp_homo_const (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_const</span> `{Univalence} {B A A&#39; : AbGroup} (E : AbSES B A)
  : abses_pushout grp_homo_const E = pt :&gt; AbSES B A&#39;
  := abses_pushout_component3_id
       (abses_pushout_const_morphism E) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pushing out a fixed extension, with the map variable. This is the connecting map in the contravariant six-term exact sequence (see SixTerm.v). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkcb"><span class="kn">Definition</span> <span class="nf">abses_pushout_abses</span> `{Univalence} {B A G : AbGroup} (E : AbSES B A)
  : ab_hom A G -&gt;* AbSES B G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_hom A G -&gt;* AbSES B G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_hom A G -&gt;* AbSES B G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkcd">srapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_hom A G -&gt; AbSES B G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkce"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkcf"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">g</span> =&gt; abses_pushout g E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt; abses_pushout g E) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality of pushing out *)</span>

<span class="sd">(** For every [E : AbSES B A], the pushout of [E] along [id_A] is [E]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_id</span> `{Univalence} {A B : AbGroup}
  : abses_pushout (B:=B) (@grp_homo_id A) == idmap
  := <span class="kr">fun</span> <span class="nv">E</span> =&gt; abses_pushout_component3_id (abses_morphism_id E) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd0"><span class="kn">Definition</span> <span class="nf">abses_pushout_pmap_id</span> `{Univalence} {A B : AbGroup}
  : abses_pushout_pmap (B:=B) (@grp_homo_id A) ==* @pmap_idmap (AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap grp_homo_id ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap grp_homo_id ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd2">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap grp_homo_id == pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkd3"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (abses_pushout_pmap grp_homo_id) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd4"><span class="mi">1</span>: <span class="bp">exact</span> abses_pushout_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_id pt =
dpoint_eq (abses_pushout_pmap grp_homo_id) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd5"><span class="nb">refine</span> (_ @ (concat_p1 _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_id pt =
dpoint_eq (abses_pushout_pmap grp_homo_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* For some reason Coq spends time finding [x] below, so we specify it. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd6">napply (ap equiv_path_abses_iso
             (x:=abses_pushout_component3_id&#39; (abses_morphism_id pt) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_component3_id&#39; (abses_morphism_id pt)
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>) =
bp_pointed (abses_pushout&#39; grp_homo_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd7"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_pushout_component3_id&#39; (abses_morphism_id pt)
   (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)).<span class="mi">1</span> =
(bp_pointed (abses_pushout&#39; grp_homo_id)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd8"><span class="nb">apply</span> equiv_path_groupisomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_pushout_component3_id&#39; (abses_morphism_id pt)
   (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)).<span class="mi">1</span> ==
(bp_pointed (abses_pushout&#39; grp_homo_id)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply Quotient_ind_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pushing out along homotopic maps induces homotopic pushout functors. This statement has a short proof by path induction on the homotopy [h], but we prefer to construct a path using [abses_path_data_iso] with better computational properties. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkd9"><span class="kn">Lemma</span> <span class="nf">abses_pushout_homotopic&#39;</span> `{Univalence} {A A&#39; B : AbGroup}
  (f f&#39; : A $-&gt; A&#39;) (h : f == f&#39;)
  : abses_pushout (B:=B) f $=&gt; abses_pushout f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f $=&gt; abses_pushout f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkda"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f $=&gt; abses_pushout f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkdb"><span class="nb">intro</span> E; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso (abses_pushout f E)
  (abses_pushout f&#39; E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkdc"><span class="nb">apply</span> abses_path_data_to_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data (abses_pushout f E)
  (abses_pushout f&#39; E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkdd">snrefine (_; (_, _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f E $-&gt; abses_pushout f&#39; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkde" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkde"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion (abses_pushout f E) ==
inclusion (abses_pushout f&#39; E)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkdf"><hr></label><div class="goal-conclusion">projection (abses_pushout f E) ==
projection (abses_pushout f&#39; E) $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f E $-&gt; abses_pushout f&#39; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke1">srapply (ab_pushout_rec (inclusion _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; abses_pushout f&#39; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chke2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pushout-v-chke2"><hr></label><div class="goal-conclusion">inclusion (abses_pushout f&#39; E) o f == <span class="nl">?c</span> o inclusion E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke3"><span class="mi">1</span>: <span class="bp">exact</span> ab_pushout_inr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout f&#39; E) o f ==
ab_pushout_inr o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke4"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout f&#39; E) (f x) =
ab_pushout_inr (inclusion E x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke5"><span class="nb">refine</span> (ap _ (h x) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout f&#39; E) (f&#39; x) =
ab_pushout_inr (inclusion E x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ab_pushout_commsq x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_pushout_rec (inclusion (abses_pushout f&#39; E))
  ab_pushout_inr
  ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
    ap (inclusion (abses_pushout f&#39; E)) (h x) @
    ab_pushout_commsq x)
   :
   inclusion (abses_pushout f&#39; E) o f ==
   ab_pushout_inr o inclusion E) $o
inclusion (abses_pushout f E) ==
inclusion (abses_pushout f&#39; E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ab_pushout_rec_beta_left.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout f E) ==
projection (abses_pushout f&#39; E) $o
ab_pushout_rec (inclusion (abses_pushout f&#39; E))
  ab_pushout_inr
  ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
    ap (inclusion (abses_pushout f&#39; E)) (h x) @
    ab_pushout_commsq x)
   :
   inclusion (abses_pushout f&#39; E) o f ==
   ab_pushout_inr o inclusion E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke8">rapply Quotient_ind_hprop; <span class="nb">intros</span> [a&#39; e]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + projection E e =
group_unit + projection E (group_unit + e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ + projection E x) (grp_unit_l _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_homotopic</span> `{Univalence} {A A&#39; B : AbGroup}
  (f f&#39; : A $-&gt; A&#39;) (h : f == f&#39;)
  : abses_pushout (B:=B) f == abses_pushout f&#39;
  := equiv_path_data_homotopy _ _ (abses_pushout_homotopic&#39; _ _ h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chke9"><span class="kn">Definition</span> <span class="nf">abses_pushout_phomotopic&#39;</span> `{Univalence} {A A&#39; B : AbGroup}
  (f f&#39; : A $-&gt; A&#39;) (h : f == f&#39;)
  : abses_pushout&#39; (B:=B) f $=&gt;* abses_pushout&#39; f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout&#39; f $=&gt;* abses_pushout&#39; f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkea"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout&#39; f $=&gt;* abses_pushout&#39; f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkeb"><span class="kr">exists</span> (<span class="nv">abses_pushout_homotopic&#39;</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">h</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_homotopic&#39; f f&#39; h pt $==
bp_pointed (abses_pushout&#39; f) $@
(bp_pointed (abses_pushout&#39; f&#39;))^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkec"><span class="nb">apply</span> gpd_moveL_Vh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bp_pointed (abses_pushout&#39; f&#39;) $o
abses_pushout_homotopic&#39; f f&#39; h pt $==
bp_pointed (abses_pushout&#39; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chked">rapply Quotient_ind_hprop; <span class="nb">intros</span> [a&#39; [a b]]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a&#39; + group_unit, group_unit) + (f&#39; (<span class="mi">0</span> + a), <span class="mi">0</span> + b) =
(a&#39;, group_unit) + (f a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkee"><span class="nb">apply</span> path_prod&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + group_unit + f&#39; (<span class="mi">0</span> + a) = a&#39; + f a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkef"><hr></label><div class="goal-conclusion">group_unit + (<span class="mi">0</span> + b) = group_unit + b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a&#39; + group_unit + f&#39; (<span class="mi">0</span> + a) = a&#39; + f a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> grp_unit_l, grp_unit_r, (h a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + (<span class="mi">0</span> + b) = group_unit + b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_phomotopic</span> `{Univalence} {A A&#39; B : AbGroup}
  (f f&#39; : A $-&gt; A&#39;) (h : f == f&#39;)
  : abses_pushout_pmap (B:=B) f ==* abses_pushout_pmap f&#39;
  := equiv_ptransformation_phomotopy (abses_pushout_phomotopic&#39; f f&#39; h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf2"><span class="kn">Definition</span> <span class="nf">abses_pushout_compose&#39;</span> `{Univalence} {A0 A1 A2 B : AbGroup}
  (f : A0 $-&gt; A1) (g : A1 $-&gt; A2)
  : abses_pushout (g $o f) $=&gt; abses_pushout (B:=B) g o abses_pushout f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (g $o f) $=&gt;
abses_pushout g o abses_pushout f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (g $o f) $=&gt;
abses_pushout g o abses_pushout f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf4"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (g $o f) E $-&gt;
abses_pushout g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf5">srapply abses_path_data_to_iso;
    srefine (_; (_,_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (g $o f) E $-&gt;
abses_pushout g (abses_pushout f E)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkf6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkf6"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion (abses_pushout (g $o f) E) ==
inclusion (abses_pushout g (abses_pushout f E))</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chkf7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkf7"><hr></label><div class="goal-conclusion">projection (abses_pushout (g $o f) E) ==
projection (abses_pushout g (abses_pushout f E)) $o
<span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (g $o f) E $-&gt;
abses_pushout g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkf9">snapply ab_pushout_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A2 $-&gt; abses_pushout g (abses_pushout f E)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chkfa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkfa"><hr></label><div class="goal-conclusion">E $-&gt; abses_pushout g (abses_pushout f E)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chkfb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><label class="goal-separator" for="pushout-v-chkfb"><hr></label><div class="goal-conclusion"><span class="nl">?b</span> o (g $o f) == <span class="nl">?c</span> o inclusion E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkfc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A2 $-&gt; abses_pushout g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> inclusion.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkfd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; abses_pushout g (abses_pushout f E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (component2 (abses_pushout_morphism _ g)
                        $o component2 (abses_pushout_morphism _ f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkfe">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout g (abses_pushout f E))
o (g $o f) ==
component2
  (abses_pushout_morphism (abses_pushout f E) g) $o
component2 (abses_pushout_morphism E f) o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chkff"><span class="nb">intro</span> a0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout g (abses_pushout f E))
  ((g $o f) a0) =
(component2
   (abses_pushout_morphism (abses_pushout f E) g) $o
 component2 (abses_pushout_morphism E f))
  (inclusion E a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk100"><span class="nb">refine</span> (left_square (abses_pushout_morphism _ g) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(component2
   (abses_pushout_morphism (abses_pushout f E) g) $o
 inclusion (abses_pushout f E)) (f a0) =
(component2
   (abses_pushout_morphism (abses_pushout f E) g) $o
 component2 (abses_pushout_morphism E f))
  (inclusion E a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (component2 (abses_pushout_morphism (abses_pushout f E) g))
                (left_square (abses_pushout_morphism _ f) a0)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk101">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_pushout_rec
  (inclusion (abses_pushout g (abses_pushout f E)))
  (component2
     (abses_pushout_morphism (abses_pushout f E) g) $o
   component2 (abses_pushout_morphism E f))
  ((<span class="kr">fun</span> <span class="nv">a0</span> : A0 =&gt;
    left_square
      (abses_pushout_morphism (abses_pushout f E) g)
      (f a0) @
    ap
      (component2
         (abses_pushout_morphism (abses_pushout f E) g))
      (left_square (abses_pushout_morphism E f) a0))
   :
   inclusion (abses_pushout g (abses_pushout f E))
   o (g $o f) ==
   component2
     (abses_pushout_morphism (abses_pushout f E) g) $o
   component2 (abses_pushout_morphism E f)
   o inclusion E) $o
inclusion (abses_pushout (g $o f) E) ==
inclusion (abses_pushout g (abses_pushout f E))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ab_pushout_rec_beta_left.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk102">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout (g $o f) E) ==
projection (abses_pushout g (abses_pushout f E)) $o
ab_pushout_rec
  (inclusion (abses_pushout g (abses_pushout f E)))
  (component2
     (abses_pushout_morphism (abses_pushout f E) g) $o
   component2 (abses_pushout_morphism E f))
  ((<span class="kr">fun</span> <span class="nv">a0</span> : A0 =&gt;
    left_square
      (abses_pushout_morphism (abses_pushout f E) g)
      (f a0) @
    ap
      (component2
         (abses_pushout_morphism (abses_pushout f E) g))
      (left_square (abses_pushout_morphism E f) a0))
   :
   inclusion (abses_pushout g (abses_pushout f E))
   o (g $o f) ==
   component2
     (abses_pushout_morphism (abses_pushout f E) g) $o
   component2 (abses_pushout_morphism E f)
   o inclusion E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk103">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ab_biprod A2 E,
(<span class="kr">fun</span>
   <span class="nv">x</span> : ab_biprod A2 E /
       in_cosetL
         {|
           normalsubgroup_subgroup :=
             ab_pushout_subgroup (g $o f)
               (inclusion E);
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup (ab_biprod A2 E)
               (ab_pushout_subgroup (g $o f)
                  (inclusion E))
         |} =&gt;
 projection (abses_pushout (g $o f) E) x =
 (projection (abses_pushout g (abses_pushout f E)) $o
  ab_pushout_rec
    (inclusion (abses_pushout g (abses_pushout f E)))
    (component2
       (abses_pushout_morphism (abses_pushout f E) g) $o
     component2 (abses_pushout_morphism E f))
    ((<span class="kr">fun</span> <span class="nv">a0</span> : A0 =&gt;
      left_square
        (abses_pushout_morphism (abses_pushout f E) g)
        (f a0) @
      ap
        (component2
           (abses_pushout_morphism (abses_pushout f E)
              g))
        (left_square (abses_pushout_morphism E f) a0))
     :
     inclusion (abses_pushout g (abses_pushout f E))
     o (g $o f) ==
     component2
       (abses_pushout_morphism (abses_pushout f E) g) $o
     component2 (abses_pushout_morphism E f)
     o inclusion E)) x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup :=
            ab_pushout_subgroup (g $o f) (inclusion E);
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup (ab_biprod A2 E)
              (ab_pushout_subgroup (g $o f)
                 (inclusion E))
        |}) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk104"><span class="nb">intro</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod A2 E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + projection E (snd x) =
group_unit + (group_unit + projection E (<span class="mi">0</span> + snd x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk105"><span class="nb">apply</span> grp_cancelL; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>ab_biprod A2 E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit + projection E (<span class="mi">0</span> + snd x) =
projection E (snd x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_identity _ @ ap (projection E) (left_identity _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pushout_compose</span> `{Univalence} {A0 A1 A2 B : AbGroup}
  (f : A0 $-&gt; A1) (g : A1 $-&gt; A2)
  : abses_pushout (g $o f) == abses_pushout (B:=B) g o abses_pushout f
  := equiv_path_data_homotopy _ _ (abses_pushout_compose&#39; f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk106"><span class="kn">Definition</span> <span class="nf">abses_pushout_pcompose&#39;</span> `{Univalence} {A0 A1 A2 B : AbGroup}
  (f : A0 $-&gt; A1) (g : A1 $-&gt; A2)
  : abses_pushout&#39; (B:=B) (g $o f) $=&gt;* abses_pushout&#39; g $o* abses_pushout&#39; f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout&#39; (g $o f) $=&gt;*
abses_pushout&#39; g $o* abses_pushout&#39; f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk107"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout&#39; (g $o f) $=&gt;*
abses_pushout&#39; g $o* abses_pushout&#39; f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk108"><span class="kr">exists</span> (<span class="nv">abses_pushout_compose&#39;</span> <span class="nv">f</span> <span class="nv">g</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_compose&#39; f g pt $==
bp_pointed (abses_pushout&#39; (g $o f)) $@
(bp_pointed (abses_pushout&#39; g $o* abses_pushout&#39; f))^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk109"><span class="nb">apply</span> gpd_moveL_Vh. <span class="c">(* it&#39;s easiest to construct a path in [pt] *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bp_pointed (abses_pushout&#39; g $o* abses_pushout&#39; f) $o
abses_pushout_compose&#39; f g pt $==
bp_pointed (abses_pushout&#39; (g $o f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk10a">rapply Quotient_ind_hprop; <span class="nb">intros</span> [a2 [a0 b]]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A2</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A0</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a2 + group_unit + group_unit, group_unit) +
(g (<span class="mi">0</span> + (<span class="mi">0</span> + group_unit + f (<span class="mi">0</span> + a0))),
<span class="mi">0</span> + (group_unit + (<span class="mi">0</span> + b))) =
(a2, group_unit) + (g (f a0), b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">7</span> grp_unit_l, <span class="mi">2</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk10b"><span class="kn">Definition</span> <span class="nf">abses_pushout_pcompose</span> `{Univalence} {A0 A1 A2 B : AbGroup}
  (f : A0 $-&gt; A1) (g : A1 $-&gt; A2)
  : abses_pushout_pmap (B:=B) (g $o f)
      ==* abses_pushout_pmap g o* abses_pushout_pmap f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap (g $o f) ==*
abses_pushout_pmap g o* abses_pushout_pmap f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk10c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap (g $o f) ==*
abses_pushout_pmap g o* abses_pushout_pmap f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk10d"><span class="nb">refine</span> (_ @* (to_pointed_compose _ _)^*).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap (g $o f) ==*
to_pointed (abses_pushout&#39; g $o* abses_pushout&#39; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk10e"><span class="nb">apply</span> equiv_ptransformation_phomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A0, A1, A2, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A0 $-&gt; A1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A1 $-&gt; A2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout&#39; (g $o f) $=&gt;*
abses_pushout&#39; g $o* abses_pushout&#39; f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_pcompose&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [AbSES B : AbGroup -&gt; pType] and [AbSES&#39; B : AbGroup -&gt; Type] are covariant functors, for any [B]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk10f"><span class="kn">Instance</span> <span class="nf">is0functor_abses&#39;01</span> `{Univalence} {B : AbGroup^op}
  : Is0Functor (AbSES&#39; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (AbSES&#39; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk110"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (AbSES&#39; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk111"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup,
(a $-&gt; b) -&gt; AbSES&#39; B a $-&gt; AbSES&#39; B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">g</span> =&gt; abses_pushout g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk112"><span class="kn">Instance</span> <span class="nf">is1functor_abses&#39;01</span> `{Univalence} {B : AbGroup^op}
  : Is1Functor (AbSES&#39; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (AbSES&#39; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk113"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (AbSES&#39; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk114"><span class="nb">apply</span> Build_Is1Functor; <span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f == abses_pushout g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk115" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk115"><hr></label><div class="goal-conclusion">abses_pushout grp_homo_id == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk116"><hr></label><div class="goal-conclusion">abses_pushout (grp_homo_compose g f) ==
(<span class="kr">fun</span> <span class="nv">x</span> : AbSES&#39; B a =&gt;
 abses_pushout g (abses_pushout f x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk117">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout f == abses_pushout g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> abses_pushout_homotopic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk118">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout grp_homo_id == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> abses_pushout_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk119">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (grp_homo_compose g f) ==
(<span class="kr">fun</span> <span class="nv">x</span> : AbSES&#39; B a =&gt;
 abses_pushout g (abses_pushout f x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk11a"><span class="kn">Instance</span> <span class="nf">is0functor_abses01</span> `{Univalence} {B : AbGroup^op}
  : Is0Functor (AbSES B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (AbSES B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk11b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (AbSES B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk11c"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup,
(a $-&gt; b) -&gt; AbSES B a $-&gt; AbSES B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">g</span> =&gt; abses_pushout_pmap g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk11d"><span class="kn">Instance</span> <span class="nf">is1functor_abses01</span> `{Univalence} {B : AbGroup^op}
  : Is1Functor (AbSES B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (AbSES B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk11e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (AbSES B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk11f"><span class="nb">apply</span> Build_Is1Functor; <span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap f ==* abses_pushout_pmap g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pushout-v-chk120" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk120"><hr></label><div class="goal-conclusion">abses_pushout_pmap grp_homo_id ==* pmap_idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="pushout-v-chk121" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><label class="goal-separator" for="pushout-v-chk121"><hr></label><div class="goal-conclusion">abses_pushout_pmap (grp_homo_compose g f) ==*
abses_pushout_pmap g o* abses_pushout_pmap f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk122">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap f ==* abses_pushout_pmap g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> abses_pushout_phomotopic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk123">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap grp_homo_id ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_pmap_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pushout-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="pushout-v-chk124">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout_pmap (grp_homo_compose g f) ==*
abses_pushout_pmap g o* abses_pushout_pmap f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_pcompose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
