<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>FinSeq.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk0"><span class="kn">Require Import</span>
  HoTT.Basics
  HoTT.Types
  HoTT.Universes.HSet
  HoTT.Spaces.Finite.Fin
  HoTT.Spaces.Finite.FinInduction
  HoTT.Spaces.Nat.Core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finite-dimensional sequence. It is often referred to as vector,</span>
<span class="sd">    but we call it finite sequence [FinSeq] to avoid confusion with</span>
<span class="sd">    vector from linear algebra.</span>

<span class="sd">    Note that the induction principle [finseq_]*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">FinSeq</span>@{u} (n : nat) (A : <span class="kt">Type</span>@{u}) : <span class="kt">Type</span>@{u} := Fin n -&gt; A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The empty finite sequence. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fsnil</span> {<span class="nv">A</span> : <span class="kt">Type</span>} : FinSeq <span class="mi">0</span> A := Empty_rec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk1"><span class="kn">Definition</span> <span class="nf">path_fsnil</span> `{Funext} {A : <span class="kt">Type</span>} (v : FinSeq <span class="mi">0</span> A) : fsnil = v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq <span class="mi">0</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsnil = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq <span class="mi">0</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsnil = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Add an element in the end of a finite sequence, [fscons&#39;] and [fscons]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fscons&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq (nat_pred n) A)
  : FinSeq n A
  := <span class="kr">fun</span> <span class="nv">i</span> =&gt;  fin_rec (<span class="kr">fun</span> <span class="nv">n</span> =&gt; FinSeq (nat_pred n) A -&gt; A)
                       (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; a) (<span class="kr">fun</span> <span class="nv">n&#39;</span> <span class="nv">i</span> <span class="nv">_</span> <span class="nv">v</span> =&gt; v i) i v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fscons</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">n</span> : nat} : A -&gt; FinSeq n A -&gt; FinSeq n.+<span class="mi">1</span> A
  := fscons&#39; n.+<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Take the first element of a non-empty finite sequence,</span>
<span class="sd">    [fshead&#39;] and [fshead]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fshead&#39;</span> {<span class="nv">A</span>} (<span class="nv">n</span> : nat) : <span class="mi">0</span> &lt; n -&gt; FinSeq n A -&gt; A
  := <span class="kr">match</span> n <span class="kr">with</span>
     | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">N</span> <span class="nv">_</span> =&gt; Empty_rec (not_lt_zero_r _ N)
     | n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">v</span> =&gt; v fin_zero
     <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fshead</span> {<span class="nv">A</span>} {<span class="nv">n</span> : nat} : FinSeq n.+<span class="mi">1</span> A -&gt; A := fshead&#39; n.+<span class="mi">1</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk3"><span class="kn">Definition</span> <span class="nf">fshead&#39;_beta_fscons&#39;</span> {<span class="nv">A</span>} <span class="nv">n</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq (nat_pred n) A)
  : fshead&#39; n N (fscons&#39; n a v) = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead&#39; n N (fscons&#39; n a v) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead&#39; n N (fscons&#39; n a v) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk5"><span class="nb">destruct</span> n; [<span class="nb">elim</span> (lt_irrefl _ N)|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (apD10 (fin_rec_beta_zero _ _ _ _) v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk6"><span class="kn">Definition</span> <span class="nf">fshead_beta_fscons</span> {<span class="nv">A</span>} {<span class="nv">n</span>} (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A)
  : fshead (fscons a v) = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead (fscons a v) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead (fscons a v) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fshead&#39;_beta_fscons&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If the sequence is non-empty, then remove the first element. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fstail&#39;</span> {<span class="nv">A</span>} (<span class="nv">n</span> : nat) : FinSeq n A -&gt; FinSeq (nat_pred n) A
  := <span class="kr">match</span> n <span class="kr">with</span>
     | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; Empty_rec
     | n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">v</span> <span class="nv">i</span> =&gt; v (fsucc i)
     <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Remove the first element from a non-empty sequence. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fstail</span> {<span class="nv">A</span>} {<span class="nv">n</span> : nat} : FinSeq n.+<span class="mi">1</span> A -&gt; FinSeq n A := fstail&#39; n.+<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk8"><span class="kn">Definition</span> <span class="nf">fstail&#39;_beta_fscons&#39;</span> {<span class="nv">A</span>} <span class="nv">n</span> (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq (nat_pred n) A)
  : fstail&#39; n (fscons&#39; n a v) == v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39; n (fscons&#39; n a v) == v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39; n (fscons&#39; n a v) == v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chka"><span class="nb">intro</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (nat_pred n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39; n (fscons&#39; n a v) i = v i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chkb"><span class="nb">destruct</span> n; [<span class="nb">elim</span> i|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin (nat_pred n.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v) i = v i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (apD10 (fin_rec_beta_fsucc _ _ _ _) v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chkc"><span class="kn">Definition</span> <span class="nf">fstail_beta_fscons</span> `{Funext} {A} {n} (a : A) (v : FinSeq n A)
  : fstail (fscons a v) = v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail (fscons a v) = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail (fscons a v) = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chke">funext i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail (fscons a v) i = v i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fstail&#39;_beta_fscons&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A non-empty finite sequence is equal to [fscons] of head and tail,</span>
<span class="sd">    [path_expand_fscons&#39;] and [path_expand_fscons]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chkf"><span class="kn">Lemma</span> <span class="nf">path_expand_fscons&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat)
  (<span class="nv">i</span> : Fin n) (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A)
  : fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n &gt; <span class="mi">0</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n &gt; <span class="mi">0</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk11"><span class="nb">induction</span> i <span class="nb">using</span> fin_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> (fshead&#39; n.+<span class="mi">1</span> N v) (fstail&#39; n.+<span class="mi">1</span> v)
  fin_zero = v fin_zero</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finseq-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i</span></span></span><br></div><label class="goal-separator" for="finseq-v-chk12"><hr></label><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> (fshead&#39; n.+<span class="mi">1</span> N v) (fstail&#39; n.+<span class="mi">1</span> v)
  (fsucc i) = v (fsucc i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> (fshead&#39; n.+<span class="mi">1</span> N v) (fstail&#39; n.+<span class="mi">1</span> v)
  fin_zero = v fin_zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fshead_beta_fscons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> (fshead&#39; n.+<span class="mi">1</span> N v) (fstail&#39; n.+<span class="mi">1</span> v)
  (fsucc i) = v (fsucc i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead v) (fstail v)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk15"><span class="kn">Lemma</span> <span class="nf">path_expand_fscons</span> `{Funext} {A} {n} (v : FinSeq n.+<span class="mi">1</span> A)
  : fscons (fshead v) (fstail v) = v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons (fshead v) (fstail v) = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons (fshead v) (fstail v) = v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk17">funext i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons (fshead v) (fstail v) i = v i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_expand_fscons&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The following [path_fscons&#39;] and [path_fscons] gives a way to construct</span>
<span class="sd">    a path between [fscons] finite sequences. They cooperate nicely with</span>
<span class="sd">    [path_expand_fscons&#39;] and [path_expand_fscons]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk18"><span class="kn">Definition</span> <span class="nf">path_fscons&#39;</span> {<span class="nv">A</span>} <span class="nv">n</span> {<span class="nv">a1</span> <span class="nv">a2</span> : A} {<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A}
  (<span class="nv">p</span> : a1 = a2) (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i</span>, v1 i = v2 i) (<span class="nv">i</span> : Fin n)
  : fscons&#39; n a1 v1 i = fscons&#39; n a2 v2 i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n), v1 i = v2 i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n a1 v1 i = fscons&#39; n a2 v2 i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n), v1 i = v2 i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n a1 v1 i = fscons&#39; n a2 v2 i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk1a"><span class="nb">induction</span> i <span class="nb">using</span> fin_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> a1 v1 fin_zero =
fscons&#39; n.+<span class="mi">1</span> a2 v2 fin_zero</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finseq-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
(<span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n), v1 i = v2 i) -&gt;
fscons&#39; n a1 v1 i = fscons&#39; n a2 v2 i</span></span></span><br></div><label class="goal-separator" for="finseq-v-chk1b"><hr></label><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> a1 v1 (fsucc i) =
fscons&#39; n.+<span class="mi">1</span> a2 v2 (fsucc i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk1c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> a1 v1 fin_zero =
fscons&#39; n.+<span class="mi">1</span> a2 v2 fin_zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fshead_beta_fscons _ _ @ p @ (fshead_beta_fscons _ _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
(<span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n), v1 i = v2 i) -&gt;
fscons&#39; n a1 v1 i = fscons&#39; n a2 v2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> a1 v1 (fsucc i) =
fscons&#39; n.+<span class="mi">1</span> a2 v2 (fsucc i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk1e"><span class="nb">refine</span> (_ @ (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a2 v2 i)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
(<span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n), v1 i = v2 i) -&gt;
fscons&#39; n a1 v1 i = fscons&#39; n a2 v2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons&#39; n.+<span class="mi">1</span> a1 v1 (fsucc i) = v2 i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a1 v1 i @ q i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk1f"><span class="kn">Definition</span> <span class="nf">path_fscons&#39;_beta</span> {<span class="nv">A</span>} (<span class="nv">n</span> : nat)
    (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq (nat_pred n) A) (<span class="nv">i</span> : Fin n)
    : path_fscons&#39; n (idpath a) (<span class="kr">fun</span> <span class="nv">j</span> =&gt; idpath (v j)) i = idpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_fscons&#39; n <span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n) =&gt; <span class="mi">1</span>) i = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_fscons&#39; n <span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n) =&gt; <span class="mi">1</span>) i = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk21"><span class="nb">induction</span> i <span class="nb">using</span> fin_ind; <span class="nb">unfold</span> path_fscons&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
   fscons&#39; n a v1 i = fscons&#39; n a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons a v1 @ <span class="mi">1</span>) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
          fscons&#39; n a v1 i = fscons&#39; n a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v2 i)^) fin_zero v v
  (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt; <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finseq-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq (nat_pred n) A,
path_fscons&#39; n <span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n) =&gt; <span class="mi">1</span>) i = <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="finseq-v-chk22"><hr></label><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
   fscons&#39; n a v1 i = fscons&#39; n a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons a v1 @ <span class="mi">1</span>) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
          fscons&#39; n a v1 i = fscons&#39; n a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v2 i)^) (fsucc i) v v
  (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt; <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
   fscons&#39; n a v1 i = fscons&#39; n a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons a v1 @ <span class="mi">1</span>) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
          fscons&#39; n a v1 i = fscons&#39; n a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v2 i)^) fin_zero v v
  (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt; <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk24"><span class="nb">rewrite</span> fin_ind_beta_zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fshead_beta_fscons a v @ <span class="mi">1</span>) @
(fshead_beta_fscons a v)^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk25"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; p @ _) (concat_p1 _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead_beta_fscons a v @ (fshead_beta_fscons a v)^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq (nat_pred n) A,
path_fscons&#39; n <span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n) =&gt; <span class="mi">1</span>) i = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
   fscons&#39; n a v1 i = fscons&#39; n a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons a v1 @ <span class="mi">1</span>) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n), v1 i0 = v2 i0) -&gt;
          fscons&#39; n a v1 i = fscons&#39; n a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v2 i)^) (fsucc i) v v
  (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt; <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk27"><span class="nb">rewrite</span> fin_ind_beta_fsucc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq (nat_pred n) A,
path_fscons&#39; n <span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n) =&gt; <span class="mi">1</span>) i = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i @ <span class="mi">1</span>) @
(fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i)^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk28"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; p @ _) (concat_p1 _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq (nat_pred n) A,
path_fscons&#39; n <span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n) =&gt; <span class="mi">1</span>) i = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i @
(fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i)^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk29"><span class="kn">Definition</span> <span class="nf">path_fscons</span> `{Funext} {A} {n} {a1 a2 : A} (p : a1 = a2)
  {v1 v2 : FinSeq n A} (q : v1 = v2)
  : fscons a1 v1 = fscons a2 v2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons a1 v1 = fscons a2 v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons a1 v1 = fscons a2 v2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk2b">funext i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fscons a1 v1 i = fscons a2 v2 i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk2c"><span class="nb">apply</span> path_fscons&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 = a2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finseq-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="finseq-v-chk2d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 = a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n.+<span class="mi">1</span>), v1 i = v2 i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk30"><span class="nb">intro</span> j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>a1 = a2</span></span></span><br><span><var>v1, v2</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>v1 = v2</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Fin (nat_pred n.+<span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">v1 j = v2 j</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (apD10 q j).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk31"><span class="kn">Lemma</span> <span class="nf">path_fscons_beta</span> `{Funext} {A} {n} (a : A) (v : FinSeq n A)
  : path_fscons (idpath a) (idpath v) = idpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_fscons <span class="mi">1</span> <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_fscons <span class="mi">1</span> <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk33"><span class="nb">refine</span> (ap (path_forall _ _) _ @ eta_path_forall _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">i</span> : Fin n.+<span class="mi">1</span> =&gt;
 path_fscons&#39; n.+<span class="mi">1</span> <span class="mi">1</span>
   (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt; apD10 <span class="mi">1</span> j) i) =
apD10 <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk34">funext i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_fscons&#39; n.+<span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt; apD10 <span class="mi">1</span> j) i =
apD10 <span class="mi">1</span> i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_fscons&#39;_beta n.+<span class="mi">1</span> a v i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The lemmas [path_expand_fscons_fscons&#39;] and [path_expand_fscons_fscons]</span>
<span class="sd">    identify [path_expand_fscons&#39;] with [path_fscons&#39;] and</span>
<span class="sd">    [path_expand_fscons] with [path_fscons]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk35"><span class="kn">Lemma</span> <span class="nf">path_expand_fscons_fscons&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat)
  (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq (nat_pred n) A) (<span class="nv">i</span> : Fin n)
  : path_expand_fscons&#39; n i N (fscons&#39; n a v) =
    path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v) (fstail&#39;_beta_fscons&#39; n a v) i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_expand_fscons&#39; n i N (fscons&#39; n a v) =
path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v)
  (fstail&#39;_beta_fscons&#39; n a v) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_expand_fscons&#39; n i N (fscons&#39; n a v) =
path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v)
  (fstail&#39;_beta_fscons&#39; n a v) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk37"><span class="nb">induction</span> i <span class="nb">using</span> fin_ind; <span class="nb">unfold</span> path_fscons&#39;, path_expand_fscons&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
   fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fshead_beta_fscons (v fin_zero) (fstail&#39; n.+<span class="mi">1</span> v))
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
          fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i =
          v i) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead v) (fstail v) i)
  fin_zero N (fscons&#39; n.+<span class="mi">1</span> a v) =
fin_ind
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0), v1 i0 = v2 i0) -&gt;
   fscons&#39; n0 (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
   fscons&#39; n0 a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n0.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 @
    fshead&#39;_beta_fscons&#39; n.+<span class="mi">1</span> N a v) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0),
           v1 i0 = v2 i0) -&gt;
          fscons&#39; n0
            (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
          fscons&#39; n0 a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span>
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span> a v2 i)^) fin_zero
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) v
  (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finseq-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq (nat_pred n) A),
path_expand_fscons&#39; n i N (fscons&#39; n a v) =
path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v) (fstail&#39;_beta_fscons&#39; n a v) i</span></span></span><br></div><label class="goal-separator" for="finseq-v-chk38"><hr></label><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
   fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fshead_beta_fscons (v fin_zero) (fstail&#39; n.+<span class="mi">1</span> v))
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
          fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i =
          v i) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead v) (fstail v) i)
  (fsucc i) N (fscons&#39; n.+<span class="mi">1</span> a v) =
fin_ind
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0), v1 i0 = v2 i0) -&gt;
   fscons&#39; n0 (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
   fscons&#39; n0 a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n0.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 @
    fshead&#39;_beta_fscons&#39; n.+<span class="mi">1</span> N a v) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0),
           v1 i0 = v2 i0) -&gt;
          fscons&#39; n0
            (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
          fscons&#39; n0 a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span>
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span> a v2 i)^) (fsucc i)
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) v
  (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
   fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fshead_beta_fscons (v fin_zero) (fstail&#39; n.+<span class="mi">1</span> v))
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
          fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i =
          v i) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead v) (fstail v) i)
  fin_zero N (fscons&#39; n.+<span class="mi">1</span> a v) =
fin_ind
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0), v1 i0 = v2 i0) -&gt;
   fscons&#39; n0 (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
   fscons&#39; n0 a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n0.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 @
    fshead&#39;_beta_fscons&#39; n.+<span class="mi">1</span> N a v) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0),
           v1 i0 = v2 i0) -&gt;
          fscons&#39; n0
            (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
          fscons&#39; n0 a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span>
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span> a v2 i)^) fin_zero
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) v
  (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk3a"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> fin_ind_beta_zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead_beta_fscons (fscons&#39; n.+<span class="mi">1</span> a v fin_zero)
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) =
(fshead_beta_fscons
   (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v))
   (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) @
 fshead&#39;_beta_fscons&#39; n.+<span class="mi">1</span> N a v) @
(fshead_beta_fscons a v)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk3b"><span class="nb">refine</span> (_ @ concat_p_pp _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead_beta_fscons (fscons&#39; n.+<span class="mi">1</span> a v fin_zero)
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) =
fshead_beta_fscons (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v))
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) @
(fshead&#39;_beta_fscons&#39; n.+<span class="mi">1</span> N a v @
 (fshead_beta_fscons a v)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk3c"><span class="nb">refine</span> (_ @ (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; _ @ p) (concat_pV _))^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fshead_beta_fscons (fscons&#39; n.+<span class="mi">1</span> a v fin_zero)
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) =
fshead_beta_fscons (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v))
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p1 _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq (nat_pred n) A),
path_expand_fscons&#39; n i N (fscons&#39; n a v) =
path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v) (fstail&#39;_beta_fscons&#39; n a v) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_ind
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n) =&gt;
   <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
   fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i = v i)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fshead_beta_fscons (v fin_zero) (fstail&#39; n.+<span class="mi">1</span> v))
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Fin n)
     (<span class="nv">_</span> : <span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n A),
          fscons&#39; n (fshead&#39; n N v) (fstail&#39; n v) i =
          v i) (<span class="nv">_</span> : n.+<span class="mi">1</span> &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq n.+<span class="mi">1</span> A) =&gt;
   fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead v) (fstail v) i)
  (fsucc i) N (fscons&#39; n.+<span class="mi">1</span> a v) =
fin_ind
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0) =&gt;
   <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
   (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0), v1 i0 = v2 i0) -&gt;
   fscons&#39; n0 (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
   fscons&#39; n0 a v2 i)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">i</span> : Fin (nat_pred n0.+<span class="mi">1</span>), v1 i = v2 i)
   =&gt;
   (fshead_beta_fscons
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 @
    fshead&#39;_beta_fscons&#39; n.+<span class="mi">1</span> N a v) @
   (fshead_beta_fscons a v2)^)
  (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">i</span> : Fin n0)
     (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0) A,
          (<span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0),
           v1 i0 = v2 i0) -&gt;
          fscons&#39; n0
            (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i =
          fscons&#39; n0 a v2 i)
     (<span class="nv">v1</span> <span class="nv">v2</span> : FinSeq (nat_pred n0.+<span class="mi">1</span>) A)
     (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i0</span> : Fin (nat_pred n0.+<span class="mi">1</span>),
          v1 i0 = v2 i0) =&gt;
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span>
      (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v)) v1 i @ q i) @
   (fstail&#39;_beta_fscons&#39; n0.+<span class="mi">1</span> a v2 i)^) (fsucc i)
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) v
  (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk3e"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> fin_ind_beta_fsucc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq (nat_pred n) A),
path_expand_fscons&#39; n i N (fscons&#39; n a v) =
path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v) (fstail&#39;_beta_fscons&#39; n a v) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead (fscons&#39; n.+<span class="mi">1</span> a v))
  (fstail (fscons&#39; n.+<span class="mi">1</span> a v)) i =
(fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span>
   (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v))
   (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) i @
 fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i) @
(fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk3f"><span class="nb">refine</span> (_ @ concat_p_pp _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq (nat_pred n) A),
path_expand_fscons&#39; n i N (fscons&#39; n a v) =
path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v) (fstail&#39;_beta_fscons&#39; n a v) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead (fscons&#39; n.+<span class="mi">1</span> a v))
  (fstail (fscons&#39; n.+<span class="mi">1</span> a v)) i =
fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span>
  (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v))
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) i @
(fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i @
 (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v i)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk40"><span class="nb">refine</span> (_ @ (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; _ @ p) (concat_pV _))^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>n.+<span class="mi">1</span> &gt; <span class="mi">0</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq (nat_pred n.+<span class="mi">1</span>) A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">N</span> : n &gt; <span class="mi">0</span>) (<span class="nv">v</span> : FinSeq (nat_pred n) A),
path_expand_fscons&#39; n i N (fscons&#39; n a v) =
path_fscons&#39; n (fshead&#39;_beta_fscons&#39; n N a v) (fstail&#39;_beta_fscons&#39; n a v) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> (fshead (fscons&#39; n.+<span class="mi">1</span> a v))
  (fstail (fscons&#39; n.+<span class="mi">1</span> a v)) i =
fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span>
  (fshead&#39; n.+<span class="mi">1</span> N (fscons&#39; n.+<span class="mi">1</span> a v))
  (fstail&#39; n.+<span class="mi">1</span> (fscons&#39; n.+<span class="mi">1</span> a v)) i @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_p1 _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk41"><span class="kn">Lemma</span> <span class="nf">path_expand_fscons_fscons</span> `{Funext}
  {A : <span class="kt">Type</span>} {n : nat} (a : A) (v : FinSeq n A)
  : path_expand_fscons (fscons a v) =
    path_fscons (fshead_beta_fscons a v) (fstail_beta_fscons a v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_expand_fscons (fscons a v) =
path_fscons (fshead_beta_fscons a v)
  (fstail_beta_fscons a v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_expand_fscons (fscons a v) =
path_fscons (fshead_beta_fscons a v)
  (fstail_beta_fscons a v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk43"><span class="nb">refine</span> (ap (path_forall _ _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">i</span> : Fin n.+<span class="mi">1</span> =&gt;
 path_expand_fscons&#39; n.+<span class="mi">1</span> i (leq_add_r <span class="mi">1</span> n)
   (fscons a v)) =
(<span class="kr">fun</span> <span class="nv">i</span> : Fin n.+<span class="mi">1</span> =&gt;
 path_fscons&#39; n.+<span class="mi">1</span> (fshead_beta_fscons a v)
   (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt;
    apD10 (fstail_beta_fscons a v) j) i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk44">funext i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_expand_fscons&#39; n.+<span class="mi">1</span> i (leq_add_r <span class="mi">1</span> n)
  (fscons a v) =
path_fscons&#39; n.+<span class="mi">1</span> (fshead_beta_fscons a v)
  (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt;
   apD10 (fstail_beta_fscons a v) j) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk45"><span class="nb">pose</span> (p := eisretr apD10 (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>eisretr apD10 (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</span></span><span class="hyp-type"><b>: </b><span>(apD10 o apD10^-<span class="mi">1</span>) (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v) =
idmap (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_expand_fscons&#39; n.+<span class="mi">1</span> i (leq_add_r <span class="mi">1</span> n)
  (fscons a v) =
path_fscons&#39; n.+<span class="mi">1</span> (fshead_beta_fscons a v)
  (<span class="kr">fun</span> <span class="nv">j</span> : Fin (nat_pred n.+<span class="mi">1</span>) =&gt;
   apD10 (fstail_beta_fscons a v) j) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk46"><span class="nb">refine</span> (_ @ (ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; _ f i) p)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Fin n.+<span class="mi">1</span></span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>eisretr apD10 (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</span></span><span class="hyp-type"><b>: </b><span>(apD10 o apD10^-<span class="mi">1</span>) (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v) =
idmap (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_expand_fscons&#39; n.+<span class="mi">1</span> i (leq_add_r <span class="mi">1</span> n)
  (fscons a v) =
path_fscons&#39; n.+<span class="mi">1</span> (fshead_beta_fscons a v)
  (fstail&#39;_beta_fscons&#39; n.+<span class="mi">1</span> a v) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_expand_fscons_fscons&#39; n.+<span class="mi">1</span> _ a v i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The induction principle for finite sequence, [finseq_ind].</span>
<span class="sd">    Note that it uses funext and does not compute. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk47"><span class="kn">Lemma</span> <span class="nf">finseq_ind</span> `{Funext} {A : <span class="kt">Type</span>} (P : <span class="kr">forall</span> <span class="nv">n</span>, FinSeq n A -&gt; <span class="kt">Type</span>)
  (z : P <span class="mi">0</span> fsnil) (s : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> (<span class="nv">v</span> : FinSeq n A), P n v -&gt; P n.+<span class="mi">1</span> (fscons a v))
  {n : nat} (v : FinSeq n A)
  : P n v.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n v</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk49"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq <span class="mi">0</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="mi">0</span> v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="finseq-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq n A, P n v</span></span></span><br></div><label class="goal-separator" for="finseq-v-chk4a"><hr></label><div class="goal-conclusion">P n.+<span class="mi">1</span> v</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq <span class="mi">0</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="mi">0</span> v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport (P <span class="mi">0</span>) (path_fsnil v) z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq n A, P n v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n.+<span class="mi">1</span> v</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk4d"><span class="nb">refine</span> (transport (P n.+<span class="mi">1</span>) (path_expand_fscons v) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq n A, P n v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n.+<span class="mi">1</span> (fscons (fshead v) (fstail v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk4e"><span class="nb">apply</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n.+<span class="mi">1</span> A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">v</span> : FinSeq n A, P n v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n (fstail v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk4f"><span class="kn">Lemma</span> <span class="nf">finseq_ind_beta_fsnil</span> `{Funext} {A : <span class="kt">Type</span>}
  (P : <span class="kr">forall</span> <span class="nv">n</span>, FinSeq n A -&gt; <span class="kt">Type</span>) (z : P <span class="mi">0</span> fsnil)
  (s : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A), P n v -&gt; P n.+<span class="mi">1</span> (fscons a v))
  : finseq_ind P z s fsnil = z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finseq_ind P z s fsnil = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finseq_ind P z s fsnil = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ x z) (hset_path2 <span class="mi">1</span> (path_fsnil fsnil)))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk51"><span class="kn">Lemma</span> <span class="nf">finseq_ind_beta_fscons</span> `{Funext} {A : <span class="kt">Type</span>}
  (P : <span class="kr">forall</span> <span class="nv">n</span>, FinSeq n A -&gt; <span class="kt">Type</span>) (z : P <span class="mi">0</span> fsnil)
  (s : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A), P n v -&gt; P n.+<span class="mi">1</span> (fscons a v))
  {n : nat} (a : A) (v : FinSeq n A)
  : finseq_ind P z s (fscons a v) = s n a v (finseq_ind P z s v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finseq_ind P z s (fscons a v) =
s n a v (finseq_ind P z s v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finseq_ind P z s (fscons a v) =
s n a v (finseq_ind P z s v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk53"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (P n.+<span class="mi">1</span>) (path_expand_fscons (fscons a v))
  (s n (fshead (fscons a v)) (fstail (fscons a v))
     (finseq_ind P z s (fstail (fscons a v)))) =
s n a v (finseq_ind P z s v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk54"><span class="nb">induction</span> (path_expand_fscons_fscons a v)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (P n.+<span class="mi">1</span>)
  (path_fscons (fshead_beta_fscons a v)
     (fstail_beta_fscons a v))
  (s n (fshead (fscons a v)) (fstail (fscons a v))
     (finseq_ind P z s (fstail (fscons a v)))) =
s n a v (finseq_ind P z s v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk55"><span class="nb">set</span> (p1 := fshead_beta_fscons a v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>fshead_beta_fscons a v</span></span><span class="hyp-type"><b>: </b><span>fshead (fscons a v) = a</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (P n.+<span class="mi">1</span>)
  (path_fscons p1 (fstail_beta_fscons a v))
  (s n (fshead (fscons a v)) (fstail (fscons a v))
     (finseq_ind P z s (fstail (fscons a v)))) =
s n a v (finseq_ind P z s v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk56"><span class="nb">set</span> (p2 := fstail_beta_fscons a v).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br><span><var>p1</var><span><span class="hyp-body"><b>:= </b><span>fshead_beta_fscons a v</span></span><span class="hyp-type"><b>: </b><span>fshead (fscons a v) = a</span></span></span></span><br><span><var>p2</var><span><span class="hyp-body"><b>:= </b><span>fstail_beta_fscons a v</span></span><span class="hyp-type"><b>: </b><span>fstail (fscons a v) = v</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (P n.+<span class="mi">1</span>) (path_fscons p1 p2)
  (s n (fshead (fscons a v)) (fstail (fscons a v))
     (finseq_ind P z s (fstail (fscons a v)))) =
s n a v (finseq_ind P z s v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="finseq-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="finseq-v-chk57"><span class="nb">induction</span> p1, p2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, FinSeq n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>P <span class="mi">0</span> fsnil</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A) (<span class="nv">v</span> : FinSeq n A),
P n v -&gt; P n.+<span class="mi">1</span> (fscons a v)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>FinSeq n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (P n.+<span class="mi">1</span>) (path_fscons <span class="mi">1</span> <span class="mi">1</span>)
  (s n (fshead (fscons a (fstail (fscons a v))))
     (fstail (fscons a v))
     (finseq_ind P z s (fstail (fscons a v)))) =
s n (fshead (fscons a (fstail (fscons a v))))
  (fstail (fscons a v))
  (finseq_ind P z s (fstail (fscons a v)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; transport _ p _) (path_fscons_beta _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
