<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Yoneda.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * The Yoneda Lemma *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb0"><span class="kn">Require Import</span> Category.Core Functor.Core NaturalTransformation.Core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Category.Dual Functor.Dual.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Functor.Composition.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Category.Morphisms FunctorCategory.Morphisms.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> SetCategory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Functor.Attributes.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Functor.Composition.Functorial.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Functor.Identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HomFunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> FunctorCategory.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> NaturalTransformation.Paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HoTT.Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Universe Polymorphism</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Asymmetric Patterns</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> morphism_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> category_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> functor_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Quoting Wikipedia on the Yoneda lemma (changing [A] to [a] and</span>
<span class="sd">    [C] to [A] so that we can use unicode superscripts and</span>
<span class="sd">    subscripts):</span>

<span class="sd">    In mathematics, specifically in category theory, the Yoneda lemma</span>
<span class="sd">    is an abstract result on functors of the type morphisms into a</span>
<span class="sd">    fixed object. It is a vast generalisation of Cayley&#39;s theorem from</span>
<span class="sd">    group theory (viewing a group as a particular kind of category</span>
<span class="sd">    with just one object). It allows the embedding of any category</span>
<span class="sd">    into a category of functors (contravariant set-valued functors)</span>
<span class="sd">    defined on that category. It also clarifies how the embedded</span>
<span class="sd">    category, of representable functors and their natural</span>
<span class="sd">    transformations, relates to the other objects in the larger</span>
<span class="sd">    functor category. It is an important tool that underlies several</span>
<span class="sd">    modern developments in algebraic geometry and representation</span>
<span class="sd">    theory. It is named after Nobuo Yoneda.</span>

<span class="sd">    ** Generalities</span>

<span class="sd">    The Yoneda lemma suggests that instead of studying the (locally</span>
<span class="sd">    small) category [A], one should study the category of all functors</span>
<span class="sd">    of [A] into [Set] (the category of sets with functions as</span>
<span class="sd">    morphisms). [Set] is a category we understand well, and a functor</span>
<span class="sd">    of [A] into [Set] can be seen as a &quot;representation&quot; of [A] in</span>
<span class="sd">    terms of known structures. The original category [A] is contained</span>
<span class="sd">    in this functor category, but new objects appear in the functor</span>
<span class="sd">    category which were absent and &quot;hidden&quot; in [A]. Treating these new</span>
<span class="sd">    objects just like the old ones often unifies and simplifies the</span>
<span class="sd">    theory.  This approach is akin to (and in fact generalizes) the</span>
<span class="sd">    common method of studying a ring by investigating the modules over</span>
<span class="sd">    that ring. The ring takes the place of the category [A], and the</span>
<span class="sd">    category of modules over the ring is a category of functors</span>
<span class="sd">    defined on [A].</span>

<span class="sd">    ** Formal statement</span>

<span class="sd">    *** General version</span>

<span class="sd">    Yoneda&#39;s lemma concerns functors from a fixed category [A] to the</span>
<span class="sd">    category of sets, [Set]. If [A] is a locally small category</span>
<span class="sd">    (i.e. the hom-sets are actual sets and not proper classes), then</span>
<span class="sd">    each object [a] of [A] gives rise to a natural functor to [Set]</span>
<span class="sd">    called a hom-functor. This functor is denoted:</span>

<span class="sd">    [h·µÉ = Hom(a, ‚îÄ)].</span>

<span class="sd">    The (covariant) hom-functor [h·µÉ] sends [x] to the set of morphisms</span>
<span class="sd">    [Hom(a, x)] and sends a morphism [f] from [x] to [y] to the</span>
<span class="sd">    morphism [f ‚àò ‚îÄ] (composition with [f] on the left) that sends a</span>
<span class="sd">    morphism [g] in [Hom(a, x)] to the morphism [f ‚àò g] in [Hom(a,</span>
<span class="sd">    y)]. That is,</span>

<span class="sd">    [f ‚Ü¶ Hom(a, f) = ‚ü¶ Hom(a, x) ‚àã g ‚Ü¶ f ‚àò g ‚àà Hom(a,y) ‚üß].</span>
<span class="sd"> *)</span>

<span class="sd">(** ** The (co-)Yoneda functors [A ‚Üí (A·µí·µñ ‚Üí set)] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">yoneda</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* TODO(JasonGross): Find a way to unify the [yoneda] and [coyoneda] lemmas into a single lemma which is more functorial. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">coyoneda</span> <span class="nv">A</span> : Functor A^op (A -&gt; set_cat)
    := ExponentialLaws.Law4.Functors.inverse _ _ _ (hom_functor A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">yoneda</span> <span class="nv">A</span> : Functor A (A^op -&gt; set_cat)
    := coyoneda A^op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">yoneda</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The (co-)Yoneda lemma *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">coyoneda_lemma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">functor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : PreCategory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Let [F] be an arbitrary functor from [A] to [Set]. Then Yoneda&#39;s</span>
<span class="sd">      lemma says that: *)</span>
    <span class="c">(*Variable F : Functor A (@set_cat fs).*)</span>
    <span class="sd">(** For each object [a] of [A], *)</span>
    <span class="c">(*Variable a : A.*)</span>
    <span class="sd">(** the natural transformations from [h·µÉ] to [F] are in one-to-one</span>
<span class="sd">      correspondence with the elements of [F(a)]. That is,</span>

<span class="sd">      [Nat(h·µÉ, F) ‚âÖ F(a)].</span>

<span class="sd">      Moreover this isomorphism is natural in [a] and [F] when both</span>
<span class="sd">      sides are regarded as functors from [Set·¥¨ √ó A] to</span>
<span class="sd">      [Set].</span>

<span class="sd">      Given a natural transformation [Œ¶] from [h·µÉ] to [F], the</span>
<span class="sd">      corresponding element of [F(a)] is [u = Œ¶‚Çê(id‚Çê)]. *)</span>

    <span class="c">(*   Definition coyoneda_lemma_morphism (a : A)</span>
<span class="c">  : morphism set_cat</span>
<span class="c">             (BuildhSet</span>
<span class="c">                (morphism (A -&gt; set_cat) (coyoneda A a) F)</span>
<span class="c">                _)</span>
<span class="c">             (F a)</span>
<span class="c">    := fun phi =&gt; phi a 1%morphism. *)</span>


</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">coyoneda_functor</span>
    : Functor (A -&gt; set_cat)
              (A -&gt; set_cat)
      := (compose_functor _ _ set_cat (coyoneda A)^op)
           o (yoneda (A -&gt; set_cat)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">functor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">nt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : PreCategory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb1"><span class="kn">Definition</span> <span class="nf">coyoneda_natural_transformation_helper</span> <span class="nv">F</span>
    : morphism (_ -&gt; _) (coyoneda_functor A F) F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism (A -&gt; set_cat)
  ((coyoneda_functor A) _0 F)%object F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism (A -&gt; set_cat)
  ((coyoneda_functor A) _0 F)%object F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb3"><span class="nb">refine</span> (Build_NaturalTransformation
                (coyoneda_functor A F) F
                (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">phi</span> =&gt; phi a <span class="mi">1</span>%morphism)
                _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">d</span> : A) (<span class="nv">m</span> : morphism A s d),
((<span class="kr">fun</span>
    <span class="nv">phi</span> : Trunc.trunctype_type
            (((coyoneda_functor A) _0 F) _0 d)%object
  =&gt; phi d <span class="mi">1</span>)
 o ((coyoneda_functor A) _0 F)%object _1 m)%morphism =
(F _1 m
 o (<span class="kr">fun</span>
      <span class="nv">phi</span> : Trunc.trunctype_type
              (((coyoneda_functor A) _0 F) _0 s)%object
    =&gt; phi s <span class="mi">1</span>))%morphism</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">d</span> : A) (<span class="nv">m</span> : morphism A s d),
(<span class="kr">fun</span>
   <span class="nv">x</span> : NaturalTransformation
         (Functors.inverse_object_of_object_of
            (hom_functor A) s) F =&gt;
 x d (<span class="mi">1</span> o <span class="mi">1</span> o m)%morphism) =
(<span class="kr">fun</span>
   <span class="nv">x</span> : NaturalTransformation
         (Functors.inverse_object_of_object_of
            (hom_functor A) s) F =&gt;
 (F _1 m) (x s <span class="mi">1</span>%morphism))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (
          <span class="kp">repeat</span> (<span class="nb">intro</span> || <span class="nb">apply</span> path_forall);
          <span class="nb">simpl</span> <span class="kr">in</span> *;
            <span class="kr">match goal with</span>
              | [ T : NaturalTransformation _ _ |- _ ]
                =&gt; <span class="nb">simpl</span> <span class="nb">rewrite</span> &lt;- (<span class="kr">fun</span> <span class="nv">s</span> <span class="nv">d</span> <span class="nv">m</span> =&gt; apD10 (commutes T s d m))
            <span class="kr">end</span>;
          <span class="nb">rewrite</span> <span class="nl">?left_identity</span>, <span class="nl">?right_identity</span>;
          <span class="bp">reflexivity</span>
        ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb5"><span class="kn">Definition</span> <span class="nf">coyoneda_natural_transformation</span>
    : morphism (_ -&gt; _)
               (coyoneda_functor A)
               <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism ((A -&gt; set_cat) -&gt; A -&gt; set_cat)
  (coyoneda_functor A) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism ((A -&gt; set_cat) -&gt; A -&gt; set_cat)
  (coyoneda_functor A) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb7"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation (coyoneda_functor A) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation (coyoneda_functor A) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkb9"><span class="kr">let</span> <span class="nv">F</span> := <span class="kr">match goal with</span> |- NaturalTransformation <span class="nl">?F</span> <span class="nl">?G</span> =&gt; <span class="kp">constr</span>:(F) <span class="kr">end</span> <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">G</span> := <span class="kr">match goal with</span> |- NaturalTransformation <span class="nl">?F</span> <span class="nl">?G</span> =&gt; <span class="kp">constr</span>:(G) <span class="kr">end</span> <span class="kr">in</span>
      <span class="nb">refine</span> (Build_NaturalTransformation
                F G
                coyoneda_natural_transformation_helper
                _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">d</span> : (A -&gt; set_cat)%category)
(<span class="nv">m</span> : morphism (A -&gt; set_cat) s d),
(coyoneda_natural_transformation_helper d
 o (coyoneda_functor A) _1 m)%morphism =
(<span class="mi">1</span> _1 m o coyoneda_natural_transformation_helper s)%morphism</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkba"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">d</span> : Functor A set_cat)
(<span class="nv">m</span> : NaturalTransformation s d),
Core.compose
  (coyoneda_natural_transformation_helper d)
  (Core.whisker_r
     (Functors.inverse_object_of_morphism_of
        (hom_functor (A -&gt; set_cat)^op) s d m)
     (coyoneda A)^op) =
Core.compose m
  (coyoneda_natural_transformation_helper s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="kp">repeat</span> <span class="kp">first</span> [ <span class="nb">intro</span>
                             | <span class="kp">progress</span> path_natural_transformation
                             | <span class="bp">reflexivity</span> ]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">nt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkbb"><span class="kn">Definition</span> <span class="nf">coyoneda_lemma_morphism_inverse</span>
             `{Funext}
             A
             (F : object (A -&gt; set_cat))
             a
  : morphism set_cat
             (F a)
             (coyoneda_functor A F a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism set_cat (F _0 a)%object
  (((coyoneda_functor A) _0 F) _0 a)%object</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkbc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism set_cat (F _0 a)%object
  (((coyoneda_functor A) _0 F) _0 a)%object</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkbd"><span class="nb">intro</span> Fa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Fa</var><span class="hyp-type"><b>: </b><span>Trunc.trunctype_type (F _0 a)%object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trunc.trunctype_type
  (((coyoneda_functor A) _0 F) _0 a)%object</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkbe"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>A -&gt; set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Fa</var><span class="hyp-type"><b>: </b><span>Trunc.trunctype_type (F _0 a)%object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation
  (snd (F, ((coyoneda A)^op _0 a)%object))
  (fst (F, ((coyoneda A)^op _0 a)%object))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkbf"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor A set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Fa</var><span class="hyp-type"><b>: </b><span>Trunc.trunctype_type (F _0 a)%object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation
  (Functors.inverse_object_of_object_of
     (hom_functor A) a) F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc0"><span class="kr">let</span> <span class="nv">F0</span> := <span class="kr">match goal with</span> |- NaturalTransformation <span class="nl">?F</span> <span class="nl">?G</span> =&gt; <span class="kp">constr</span>:(F) <span class="kr">end</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">G0</span> := <span class="kr">match goal with</span> |- NaturalTransformation <span class="nl">?F</span> <span class="nl">?G</span> =&gt; <span class="kp">constr</span>:(G) <span class="kr">end</span> <span class="kr">in</span>
    <span class="nb">refine</span> (Build_NaturalTransformation
              F0 G0
              (<span class="kr">fun</span> <span class="nv">a&#39;</span> : A =&gt; (<span class="kr">fun</span> <span class="nv">f</span> : morphism A a a&#39; =&gt; F _1 f Fa))
              _
           ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor A set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Fa</var><span class="hyp-type"><b>: </b><span>Trunc.trunctype_type (F _0 a)%object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">d</span> : A) (<span class="nv">m</span> : morphism A s d),
((<span class="kr">fun</span> <span class="nv">f</span> : morphism A a d =&gt; (F _1 f) Fa)
 o (Functors.inverse_object_of_object_of
      (hom_functor A) a) _1 m)%morphism =
(F _1 m o (<span class="kr">fun</span> <span class="nv">f</span> : morphism A a s =&gt; (F _1 f) Fa))%morphism</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc1"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor A set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Fa</var><span class="hyp-type"><b>: </b><span>Trunc.trunctype_type (F _0 a)%object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">d</span> : A) (<span class="nv">m</span> : morphism A s d),
(<span class="kr">fun</span> <span class="nv">x</span> : morphism A a s =&gt; (F _1 (m o x o <span class="mi">1</span>)) Fa) =
(<span class="kr">fun</span> <span class="nv">x</span> : morphism A a s =&gt; (F _1 m) ((F _1 x) Fa))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (
        <span class="kp">repeat</span> <span class="kp">first</span> [ <span class="bp">reflexivity</span>
                     | <span class="nb">intro</span>
                     | <span class="nb">apply</span> path_forall
                     | <span class="kp">progress</span> <span class="nb">rewrite</span> <span class="nl">?composition_of</span>, <span class="nl">?identity_of</span> ]
      ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc2">#[export] <span class="kn">Instance</span> <span class="nf">coyoneda_lemma</span> `{Funext} A
  : IsIsomorphism (coyoneda_natural_transformation A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism (coyoneda_natural_transformation A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism (coyoneda_natural_transformation A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc4"><span class="nb">eapply</span> isisomorphism_natural_transformation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : (A -&gt; set_cat)%category,
IsIsomorphism (coyoneda_natural_transformation A x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Functor A set_cat,
IsIsomorphism
  (coyoneda_natural_transformation_helper x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc6"><span class="nb">intro</span> F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor A set_cat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (coyoneda_natural_transformation_helper F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc7"><span class="nb">eapply</span> isisomorphism_natural_transformation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor A set_cat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
IsIsomorphism
  (coyoneda_natural_transformation_helper F x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc8"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor A set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (coyoneda_natural_transformation_helper F a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkc9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>Functor A set_cat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (<span class="kr">fun</span>
     <span class="nv">phi</span> : NaturalTransformation
             (Functors.inverse_object_of_object_of
                (hom_functor A) a) F =&gt;
   phi a <span class="mi">1</span>%morphism)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> (<span class="nv">coyoneda_lemma_morphism_inverse</span> <span class="nv">F</span> <span class="nv">a</span>);
      <span class="nb">simpl</span> <span class="kr">in</span> *;
    <span class="kp">abstract</span> (
        <span class="kp">repeat</span> (<span class="nb">intro</span> || <span class="nb">apply</span> path_forall || path_natural_transformation);
        <span class="nb">simpl</span> <span class="kr">in</span> *;
          <span class="kp">solve</span> [ <span class="nb">simpl</span> <span class="nb">rewrite</span> &lt;- (<span class="kr">fun</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">m</span> =&gt; ap10 (commutes x c d m));
                  <span class="nb">rewrite</span> <span class="nl">?right_identity</span>, <span class="nl">?left_identity</span>;
                  <span class="bp">reflexivity</span>
                | <span class="nb">rewrite</span> identity_of;
                  <span class="bp">reflexivity</span> ]
      ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">coyoneda_lemma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">yoneda_lemma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** There is a contravariant version of Yoneda&#39;s lemma which</span>
<span class="sd">      concerns contravariant functors from [A] to [Set]. This version</span>
<span class="sd">      involves the contravariant hom-functor</span>

<span class="sd">      [h‚Çê = Hom(‚îÄ, A)],</span>

<span class="sd">      which sends [x] to the hom-set [Hom(x, a)]. Given an arbitrary</span>
<span class="sd">      contravariant functor [G] from [A] to [Set], Yoneda&#39;s lemma</span>
<span class="sd">      asserts that</span>

<span class="sd">      [Nat(h‚Çê, G) ‚âÖ G(a)]. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">functor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : PreCategory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Let [F] be an arbitrary functor from [A] to [Set]. Then Yoneda&#39;s</span>
<span class="sd">      lemma says that: *)</span>
    <span class="c">(*Variable F : Functor A (@set_cat fs).*)</span>
    <span class="sd">(** For each object [a] of [A], *)</span>
    <span class="c">(*Variable a : A.*)</span>
    <span class="sd">(** the natural transformations from [h·µÉ] to [F] are in one-to-one</span>
<span class="sd">      correspondence with the elements of [F(a)]. That is,</span>

<span class="sd">      [Nat(h·µÉ, F) ‚âÖ F(a)].</span>

<span class="sd">      Moreover this isomorphism is natural in [a] and [F] when both</span>
<span class="sd">      sides are regarded as functors from [Set·¥¨ √ó A] to</span>
<span class="sd">      [Set].</span>

<span class="sd">      Given a natural transformation [Œ¶] from [h·µÉ] to [F], the</span>
<span class="sd">      corresponding element of [F(a)] is [u = Œ¶‚Çê(id‚Çê)]. *)</span>

    <span class="c">(* Definition yoneda_lemma_morphism A (G : object (A^op -&gt; set_cat)) (a : A)</span>
<span class="c">  : morphism set_cat</span>
<span class="c">             (BuildhSet</span>
<span class="c">                (morphism (A^op -&gt; set_cat) (yoneda A a) G)</span>
<span class="c">                _)</span>
<span class="c">             (G a)</span>
<span class="c">    := fun phi =&gt; phi a 1%morphism.*)</span>

</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">yoneda_functor</span>
    : Functor (A^op -&gt; set_cat)
              (A^op -&gt; set_cat)
      := coyoneda_functor A^op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">functor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : PreCategory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">yoneda_natural_transformation</span>
  : morphism (_ -&gt; _)
             <span class="mi">1</span>
             (yoneda_functor A)
    := @morphism_inverse _ _ _ _ (coyoneda_lemma A^op).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">yoneda_lemma</span>
  : IsIsomorphism yoneda_natural_transformation
    := @isisomorphism_inverse _ _ _ _ (coyoneda_lemma A^op).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">yoneda_lemma</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The Yoneda embedding</span>

<span class="sd">    An important special case of Yoneda&#39;s lemma is when the functor</span>
<span class="sd">    [F] from [A] to [Set] is another hom-functor [h·µá]. In this case,</span>
<span class="sd">    the covariant version of Yoneda&#39;s lemma states that</span>

<span class="sd">    [Nat(h·µÉ, h·µá) ‚âÖ Hom(b, a)].</span>

<span class="sd">    That is, natural transformations between hom-functors are in</span>
<span class="sd">    one-to-one correspondence with morphisms (in the reverse</span>
<span class="sd">    direction) between the associated objects. Given a morphism [f : b</span>
<span class="sd">    ‚Üí a] the associated natural transformation is denoted [Hom(f, ‚îÄ)].</span>

<span class="sd">    Mapping each object [a] in [A] to its associated hom-functor [h·µÉ=</span>
<span class="sd">    Hom(a, ‚îÄ)] and each morphism [f : B ‚Üí A] to the corresponding</span>
<span class="sd">    natural transformation [Hom(f, ‚îÄ)] determines a contravariant</span>
<span class="sd">    functor [h‚Åª] from [A] to [Set·¥¨], the functor category of all</span>
<span class="sd">    (covariant) functors from [A] to [Set]. One can interpret [h‚Åª] as</span>
<span class="sd">    a covariant functor:</span>

<span class="sd">    [h‚Åª : A·µí·µñ ‚Üí Set·¥¨].</span>

<span class="sd">    The meaning of Yoneda&#39;s lemma in this setting is that the functor</span>
<span class="sd">    [h‚Åª] is fully faithful, and therefore gives an embedding of [A·µí·µñ]</span>
<span class="sd">    in the category of functors to [Set]. The collection of all</span>
<span class="sd">    functors {[h·µÉ], [a] in [A]} is a subcategory of [SetÃÇ·¥¨]. Therefore,</span>
<span class="sd">    Yoneda embedding implies that the category [A·µí·µñ] is isomorphic to</span>
<span class="sd">    the category {[h·µÉ], [a] in [A]}.</span>

<span class="sd">    The contravariant version of Yoneda&#39;s lemma states that</span>

<span class="sd">    [Nat(h‚Çê, h_b) ‚âÖ Hom(a, b)].</span>

<span class="sd">    Therefore, [h‚Çã] gives rise to a covariant functor from [A] to the</span>
<span class="sd">    category of contravariant functors to [Set]:</span>

<span class="sd">    [h‚Çã : A ‚Üí Set‚ÅΩ‚ÅΩ·¥¨‚Åæ·µí·µñ‚Åæ].</span>

<span class="sd">    Yoneda&#39;s lemma then states that any locally small category [A] can</span>
<span class="sd">    be embedded in the category of contravariant functors from [A] to</span>
<span class="sd">    [Set] via [h‚Çã]. This is called the Yoneda embedding. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FullyFaithful</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkca"><span class="kn">Definition</span> <span class="nf">coyoneda_embedding</span> (<span class="nv">A</span> : PreCategory) : IsFullyFaithful (coyoneda A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsFullyFaithful (coyoneda A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkcb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsFullyFaithful (coyoneda A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkcc"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A^op%category</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (induced_hom_natural_transformation (coyoneda A)
     (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkcd"><span class="nb">pose proof</span> (@isisomorphism_inverse
                  _ _ _ _
                  (@isisomorphism_components_of
                     _ _ _ _ _ _
                     (@isisomorphism_components_of
                        _ _ _ _ _ _
                        (@coyoneda_lemma _ A)
                        (@coyoneda _ A b))
                     a)) <span class="kr">as</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A^op%category</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (coyoneda_natural_transformation A
     ((coyoneda A) _0 b)%object a)^-<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (induced_hom_natural_transformation (coyoneda A)
     (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkce"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (coyoneda_lemma_morphism_inverse
     (Functors.inverse_object_of_object_of
        (hom_functor A) b) a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">m</span> : morphism A b a =&gt;
   Functors.inverse_object_of_morphism_of
     (hom_functor A) a b m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkcf"><span class="nb">unfold</span> coyoneda_lemma_morphism_inverse <span class="kr">in</span> *; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">m</span> : morphism A b a =&gt;
   Functors.inverse_object_of_morphism_of
     (hom_functor A) a b m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd0"><span class="nb">unfold</span> Functors.inverse_object_of_morphism_of <span class="kr">in</span> *; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">m</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">c</span> : A) (<span class="nv">g</span> : morphism A a c) =&gt;
      (<span class="mi">1</span> o g o m)%morphism)
     (Functors.inverse_object_of_morphism_of_subproof
        (hom_functor A) a b m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd1"><span class="kr">let</span> <span class="nv">m</span> := <span class="kr">match</span> <span class="kp">type of</span> H&#39; <span class="kr">with</span> IsIsomorphism <span class="nl">?m</span> =&gt; <span class="kp">constr</span>:(m) <span class="kr">end</span> <span class="kr">in</span>
    <span class="nb">apply</span> isisomorphism_set_cat_natural_transformation_paths <span class="kr">with</span> (T1 := m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
(<span class="nv">x</span> : Trunc.trunctype_type
       {|
         Trunc.trunctype_type := morphism A b a;
         Trunc.trunctype_istrunc :=
           trunc_morphism A b a
       |}) (<span class="nv">y</span> : A),
Build_NaturalTransformation
  (Functors.inverse_object_of_object_of
     (hom_functor A) a)
  (Functors.inverse_object_of_object_of
     (hom_functor A) b)
  (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
   (f o x o <span class="mi">1</span>)%morphism)
  (coyoneda_lemma_morphism_inverse_subproof
     (Functors.inverse_object_of_object_of
        (hom_functor A) b) a x) y =
Build_NaturalTransformation
  (Functors.inverse_object_of_object_of
     (hom_functor A) a)
  (Functors.inverse_object_of_object_of
     (hom_functor A) b)
  (<span class="kr">fun</span> (<span class="nv">c</span> : A) (<span class="nv">g</span> : morphism A a c) =&gt;
   (<span class="mi">1</span> o g o x)%morphism)
  (Functors.inverse_object_of_morphism_of_subproof
     (hom_functor A) a b x) y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="yoneda-v-chkd2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</span></span></span><br></div><label class="goal-separator" for="yoneda-v-chkd2"><hr></label><div class="goal-conclusion">IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
(<span class="nv">x</span> : Trunc.trunctype_type
       {|
         Trunc.trunctype_type := morphism A b a;
         Trunc.trunctype_istrunc :=
           trunc_morphism A b a
       |}) (<span class="nv">y</span> : A),
Build_NaturalTransformation
  (Functors.inverse_object_of_object_of
     (hom_functor A) a)
  (Functors.inverse_object_of_object_of
     (hom_functor A) b)
  (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
   (f o x o <span class="mi">1</span>)%morphism)
  (coyoneda_lemma_morphism_inverse_subproof
     (Functors.inverse_object_of_object_of
        (hom_functor A) b) a x) y =
Build_NaturalTransformation
  (Functors.inverse_object_of_object_of
     (hom_functor A) a)
  (Functors.inverse_object_of_object_of
     (hom_functor A) b)
  (<span class="kr">fun</span> (<span class="nv">c</span> : A) (<span class="nv">g</span> : morphism A a c) =&gt;
   (<span class="mi">1</span> o g o x)%morphism)
  (Functors.inverse_object_of_morphism_of_subproof
     (hom_functor A) a b x) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : morphism A b a) (<span class="nv">y</span> : A),
(<span class="kr">fun</span> <span class="nv">f</span> : morphism A a y =&gt; (f o x o <span class="mi">1</span>)%morphism) =
(<span class="kr">fun</span> <span class="nv">g</span> : morphism A a y =&gt; (<span class="mi">1</span> o g o x)%morphism)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd5"><span class="nb">clear</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : morphism A b a) (<span class="nv">y</span> : A),
(<span class="kr">fun</span> <span class="nv">f</span> : morphism A a y =&gt; (f o x o <span class="mi">1</span>)%morphism) =
(<span class="kr">fun</span> <span class="nv">g</span> : morphism A a y =&gt; (<span class="mi">1</span> o g o x)%morphism)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_forall;
      <span class="nb">intro</span>;
      <span class="nb">rewrite</span> left_identity, right_identity;
      <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd7"><span class="nb">destruct</span> H&#39; <span class="kr">as</span> [m&#39; H0&#39; H1&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>morphism set_cat
  {|
    Trunc.trunctype_type :=
      NaturalTransformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b);
    Trunc.trunctype_istrunc :=
      trunc_natural_transformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b)
  |}
  {|
    Trunc.trunctype_type := morphism A b a;
    Trunc.trunctype_istrunc :=
      trunc_morphism A b a
  |}</span></span></span><br><span><var>H0'</var><span class="hyp-type"><b>: </b><span>(m&#39;
o (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)))%morphism =
<span class="mi">1</span>%morphism</span></span></span><br><span><var>H1'</var><span class="hyp-type"><b>: </b><span>((<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)) o m&#39;)%morphism =
<span class="mi">1</span>%morphism</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
   Build_NaturalTransformation
     (Functors.inverse_object_of_object_of
        (hom_functor A) a)
     (Functors.inverse_object_of_object_of
        (hom_functor A) b)
     (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
      (f o Fa o <span class="mi">1</span>)%morphism)
     (coyoneda_lemma_morphism_inverse_subproof
        (Functors.inverse_object_of_object_of
           (hom_functor A) b) a Fa))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkd8">(<span class="kr">exists</span> <span class="nv">m&#39;</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>morphism set_cat
  {|
    Trunc.trunctype_type :=
      NaturalTransformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b);
    Trunc.trunctype_istrunc :=
      trunc_natural_transformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b)
  |}
  {|
    Trunc.trunctype_type := morphism A b a;
    Trunc.trunctype_istrunc :=
      trunc_morphism A b a
  |}</span></span></span><br><span><var>H0'</var><span class="hyp-type"><b>: </b><span>(m&#39;
o (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)))%morphism =
<span class="mi">1</span>%morphism</span></span></span><br><span><var>H1'</var><span class="hyp-type"><b>: </b><span>((<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)) o m&#39;)%morphism =
<span class="mi">1</span>%morphism</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m&#39;
 o (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
    Build_NaturalTransformation
      (Functors.inverse_object_of_object_of
         (hom_functor A) a)
      (Functors.inverse_object_of_object_of
         (hom_functor A) b)
      (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
       f o Fa o <span class="mi">1</span>)
      (coyoneda_lemma_morphism_inverse_subproof
         (Functors.inverse_object_of_object_of
            (hom_functor A) b) a Fa)))%morphism =
<span class="mi">1</span>%morphism</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="yoneda-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>morphism set_cat
  {|
    Trunc.trunctype_type :=
      NaturalTransformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b);
    Trunc.trunctype_istrunc :=
      trunc_natural_transformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b)
  |}
  {|
    Trunc.trunctype_type := morphism A b a;
    Trunc.trunctype_istrunc :=
      trunc_morphism A b a
  |}</span></span></span><br><span><var>H0'</var><span class="hyp-type"><b>: </b><span>(m&#39;
o (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)))%morphism =
<span class="mi">1</span>%morphism</span></span></span><br><span><var>H1'</var><span class="hyp-type"><b>: </b><span>((<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)) o m&#39;)%morphism =
<span class="mi">1</span>%morphism</span></span></span><br></div><label class="goal-separator" for="yoneda-v-chkd9"><hr></label><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
  Build_NaturalTransformation
    (Functors.inverse_object_of_object_of
       (hom_functor A) a)
    (Functors.inverse_object_of_object_of
       (hom_functor A) b)
    (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
    (coyoneda_lemma_morphism_inverse_subproof
       (Functors.inverse_object_of_object_of
          (hom_functor A) b) a Fa)) o m&#39;)%morphism =
<span class="mi">1</span>%morphism</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkda">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>morphism set_cat
  {|
    Trunc.trunctype_type :=
      NaturalTransformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b);
    Trunc.trunctype_istrunc :=
      trunc_natural_transformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b)
  |}
  {|
    Trunc.trunctype_type := morphism A b a;
    Trunc.trunctype_istrunc :=
      trunc_morphism A b a
  |}</span></span></span><br><span><var>H0'</var><span class="hyp-type"><b>: </b><span>(m&#39;
o (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)))%morphism =
<span class="mi">1</span>%morphism</span></span></span><br><span><var>H1'</var><span class="hyp-type"><b>: </b><span>((<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)) o m&#39;)%morphism =
<span class="mi">1</span>%morphism</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m&#39;
 o (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
    Build_NaturalTransformation
      (Functors.inverse_object_of_object_of
         (hom_functor A) a)
      (Functors.inverse_object_of_object_of
         (hom_functor A) b)
      (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt;
       f o Fa o <span class="mi">1</span>)
      (coyoneda_lemma_morphism_inverse_subproof
         (Functors.inverse_object_of_object_of
            (hom_functor A) b) a Fa)))%morphism =
<span class="mi">1</span>%morphism</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H0&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkdb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>morphism set_cat
  {|
    Trunc.trunctype_type :=
      NaturalTransformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b);
    Trunc.trunctype_istrunc :=
      trunc_natural_transformation
        (Functors.inverse_object_of_object_of
           (hom_functor A) a)
        (Functors.inverse_object_of_object_of
           (hom_functor A) b)
  |}
  {|
    Trunc.trunctype_type := morphism A b a;
    Trunc.trunctype_istrunc :=
      trunc_morphism A b a
  |}</span></span></span><br><span><var>H0'</var><span class="hyp-type"><b>: </b><span>(m&#39;
o (<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)))%morphism =
<span class="mi">1</span>%morphism</span></span></span><br><span><var>H1'</var><span class="hyp-type"><b>: </b><span>((<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
Build_NaturalTransformation
(Functors.inverse_object_of_object_of (hom_functor A) a)
(Functors.inverse_object_of_object_of (hom_functor A) b)
(<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
(coyoneda_lemma_morphism_inverse_subproof
(Functors.inverse_object_of_object_of (hom_functor A) b) a Fa)) o m&#39;)%morphism =
<span class="mi">1</span>%morphism</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span> <span class="nv">Fa</span> : morphism A b a =&gt;
  Build_NaturalTransformation
    (Functors.inverse_object_of_object_of
       (hom_functor A) a)
    (Functors.inverse_object_of_object_of
       (hom_functor A) b)
    (<span class="kr">fun</span> (<span class="nv">a&#39;</span> : A) (<span class="nv">f</span> : morphism A a a&#39;) =&gt; f o Fa o <span class="mi">1</span>)
    (coyoneda_lemma_morphism_inverse_subproof
       (Functors.inverse_object_of_object_of
          (hom_functor A) b) a Fa)) o m&#39;)%morphism =
<span class="mi">1</span>%morphism</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H1&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkdc"><span class="kn">Definition</span> <span class="nf">yoneda_embedding</span> (<span class="nv">A</span> : PreCategory) : IsFullyFaithful (yoneda A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsFullyFaithful (yoneda A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsFullyFaithful (yoneda A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkde"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (induced_hom_natural_transformation (yoneda A)
     (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chkdf"><span class="nb">pose proof</span> (@coyoneda_embedding A^op a b) <span class="kr">as</span> CYE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>CYE</var><span class="hyp-type"><b>: </b><span>IsIsomorphism (induced_hom_natural_transformation (coyoneda A^op) (a, b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (induced_hom_natural_transformation (yoneda A)
     (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chke0"><span class="nb">unfold</span> yoneda.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>CYE</var><span class="hyp-type"><b>: </b><span>IsIsomorphism (induced_hom_natural_transformation (coyoneda A^op) (a, b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (induced_hom_natural_transformation (coyoneda A^op)
     (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="yoneda-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="yoneda-v-chke1"><span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> CYE <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">T&#39;</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> T) <span class="kr">in</span>
    <span class="nb">pose proof</span> ((<span class="kr">fun</span> <span class="nv">x</span> : T =&gt; (x : T&#39;)) CYE) <span class="kr">as</span> CYE&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>CYE</var><span class="hyp-type"><b>: </b><span>IsIsomorphism (induced_hom_natural_transformation (coyoneda A^op) (a, b))</span></span></span><br><span><var>CYE'</var><span class="hyp-type"><b>: </b><span>IsIsomorphism
  (<span class="kr">fun</span> <span class="nv">m</span> : morphism A a b =&gt;
   Functors.inverse_object_of_morphism_of
     (hom_functor A^op) a b m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsIsomorphism
  (induced_hom_natural_transformation (coyoneda A^op)
     (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">let</span> <span class="nv">G</span> := <span class="kr">match goal with</span> |- <span class="nl">?G</span> =&gt; <span class="kp">constr</span>:(G) <span class="kr">end</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">G&#39;</span> := (<span class="kp">eval</span> <span class="nb">simpl</span> <span class="kr">in</span> G) <span class="kr">in</span>
    <span class="bp">exact</span> ((<span class="kr">fun</span> <span class="nv">x</span> : G&#39; =&gt; (x : G)) CYE&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FullyFaithful</span>.</span></span></pre>
</div>
</div></body>
</html>
