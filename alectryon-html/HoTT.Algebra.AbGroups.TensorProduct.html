<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>TensorProduct.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Tactics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Forall Types.Sigma Types.Prod.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.Core WildCat.Equiv WildCat.Monoidal WildCat.Bifunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.NatTrans WildCat.MonoidalTwistConstruction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.Groups.Group Algebra.Groups.QuotientGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.AbGroups.AbelianGroup Algebra.AbGroups.Biproduct.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.AbGroups.AbHom Algebra.AbGroups.FreeAbelianGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.AbGroups.Abelianization Algebra Algebra.Groups.FreeGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Quotient.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.List.Core Spaces.Int.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbGroups.Z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_add_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The Tensor Product of Abelian Groups *)</span>

<span class="sd">(** Various maps [A * B ‚Üí C] from the cartesian product of two abelian groups to another abelian group are &quot;biadditive&quot; (also called &quot;bilinear&quot;), meaning that they are group homomorphisms when we fix the left or right argument.</span>

<span class="sd">The tensor product of abelian groups is a construction that produces an abelian group [A ‚äó B] along with a biadditive map [A * B -&gt; A ‚äó B] which is initial among biadditive maps from [A * B].  This means that any biadditive map [A * B ‚Üí C] factors uniquely through the tensor product via a group homomorphism [A ‚äó B -&gt; C].</span>

<span class="sd">Biadditive functions appear in all sorts of contexts ranging from linear algebra to analysis. Therefore having a way to systematically study them is very useful. *)</span>

<span class="sd">(** ** Construction *)</span>

<span class="sd">(** We define the tensor product of abelian groups as a quotient of the free abelian group on pairs of elements of the two groups by the subgroup generated by the biadditive pairs. *)</span>

<span class="sd">(** Here we define the subgroup of biadditive pairs in two steps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1"><span class="kn">Definition</span> <span class="nf">family_biadditive_pairs</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup}
  : FreeAbGroup (A * B) -&gt; <span class="kt">Type</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (A * B) -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (A * B) -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk3"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk4"><span class="nb">refine</span> ((<span class="kr">exists</span> (<span class="nv">a1</span> <span class="nv">a2</span> : A) (<span class="nv">b</span> : B), _) + <span class="kr">exists</span> (<span class="nv">a</span> : A) (<span class="nv">b1</span> <span class="nv">b2</span> : B), _)%type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk5"><hr></label><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk7"><span class="nb">refine</span> (- _ + (_ + _) = x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (A * B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk8"><hr></label><div class="goal-conclusion">FreeAbGroup (A * B)</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk9"><hr></label><div class="goal-conclusion">FreeAbGroup (A * B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka"><span class="mi">1</span>-<span class="mi">3</span>: <span class="nb">apply</span> freeabgroup_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkb"><hr></label><div class="goal-conclusion">A * B</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkc"><hr></label><div class="goal-conclusion">A * B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a1 + a2, b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a1, b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a2, b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk11"><span class="nb">refine</span> (- _ + (_ + _) = x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (A * B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk12"><hr></label><div class="goal-conclusion">FreeAbGroup (A * B)</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk13"><hr></label><div class="goal-conclusion">FreeAbGroup (A * B)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk14"><span class="mi">1</span>-<span class="mi">3</span>: <span class="nb">apply</span> freeabgroup_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk15"><hr></label><div class="goal-conclusion">A * B</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk16"><hr></label><div class="goal-conclusion">A * B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk17">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a, b1 + b2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk18">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a, b1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk19">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a, b2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subgroup_biadditive_pairs</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup}
  : Subgroup (FreeAbGroup (A * B))
  := subgroup_generated family_biadditive_pairs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tensor product [ab_tensor_prod A B] of two abelian groups [A] and [B] is defined to be a quotient of the free abelian group on pairs of elements [A * B] by the subgroup of biadditive pairs. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod</span> (<span class="nv">A</span> <span class="nv">B</span> : AbGroup) : AbGroup
  := QuotientAbGroup (FreeAbGroup (A * B)) subgroup_biadditive_pairs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> ab_tensor_prod A B : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tensor product of [A] and [B] contains formal sums and differences of pairs of elements from [A] and [B]. We denote these pairs as &quot;simple tensors&quot; and name them [tensor]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tensor</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} : A -&gt; B -&gt; ab_tensor_prod A B
  := <span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; grp_quotient_map (freeabgroup_in (a, b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Properties of tensors *)</span>

<span class="sd">(** The characterizing property of simple tensors are that they are biadditive in their arguments. *)</span>

<span class="sd">(** A [tensor] of a sum distributes over the sum on the left. *)</span> 
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1a"><span class="kn">Definition</span> <span class="nf">tensor_dist_l</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B)
  : tensor a (b + b&#39;) = tensor a b + tensor a b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a (b + b&#39;) = tensor a b + tensor a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a (b + b&#39;) = tensor a b + tensor a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c"><span class="nb">apply</span> qglue, tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_generated_type family_biadditive_pairs
  (- freeabgroup_in (a, b + b&#39;) +
   (freeabgroup_in (a, b) + freeabgroup_in (a, b&#39;)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d"><span class="nb">apply</span> sgt_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">family_biadditive_pairs
  (- freeabgroup_in (a, b + b&#39;) +
   (freeabgroup_in (a, b) + freeabgroup_in (a, b&#39;)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1e"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a0 : A &amp;
{b1 : B &amp;
{b2 : B &amp;
- freeabgroup_in (a0, b1 + b2) +
(freeabgroup_in (a0, b1) + freeabgroup_in (a0, b2)) =
- freeabgroup_in (a, b + b&#39;) +
(freeabgroup_in (a, b) + freeabgroup_in (a, b&#39;))}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span>, b, b&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [tensor] of a sum distributes over the sum on the right. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f"><span class="kn">Definition</span> <span class="nf">tensor_dist_r</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B)
  : tensor (a + a&#39;) b = tensor a b + tensor a&#39; b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (a + a&#39;) b = tensor a b + tensor a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (a + a&#39;) b = tensor a b + tensor a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk21"><span class="nb">apply</span> qglue, tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">subgroup_generated_type family_biadditive_pairs
  (- freeabgroup_in (a + a&#39;, b) +
   (freeabgroup_in (a, b) + freeabgroup_in (a&#39;, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk22"><span class="nb">apply</span> sgt_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">family_biadditive_pairs
  (- freeabgroup_in (a + a&#39;, b) +
   (freeabgroup_in (a, b) + freeabgroup_in (a&#39;, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk23"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a1 : A &amp;
{a2 : A &amp;
{b0 : B &amp;
- freeabgroup_in (a1 + a2, b0) +
(freeabgroup_in (a1, b0) + freeabgroup_in (a2, b0)) =
- freeabgroup_in (a + a&#39;, b) +
(freeabgroup_in (a, b) + freeabgroup_in (a&#39;, b))}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span>, a&#39;, b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tensoring on the left is a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk24"><span class="kn">Definition</span> <span class="nf">grp_homo_tensor_l</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">a</span> : A)
  : B $-&gt; ab_tensor_prod A B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; ab_tensor_prod A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; ab_tensor_prod A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk26">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; ab_tensor_prod A B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk27"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; ab_tensor_prod A B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">b</span> =&gt; tensor a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk2a"><span class="nb">intros</span> b b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a (b + b&#39;) = tensor a b + tensor a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tensoring on the right is a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk2b"><span class="kn">Definition</span> <span class="nf">grp_homo_tensor_r</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">b</span> : B)
  : A $-&gt; ab_tensor_prod A B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; ab_tensor_prod A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; ab_tensor_prod A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk2d">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; ab_tensor_prod A B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk2e"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; ab_tensor_prod A B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; tensor a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk31"><span class="nb">intros</span> a a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (a + a&#39;) b = tensor a b + tensor a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tensors preserve negation in the left argument. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tensor_neg_l</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">a</span> : A) (<span class="nv">b</span> : B)
  : tensor (-a) b = - tensor a b
  := grp_homo_inv (grp_homo_tensor_r b) a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tensors preserve negation in the right argument. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tensor_neg_r</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">a</span> : A) (<span class="nv">b</span> : B)
  : tensor a (-b) = - tensor a b
  := grp_homo_inv (grp_homo_tensor_l a) b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tensoring by zero on the left is zero. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tensor_zero_l</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">b</span> : B)
  : tensor (A:=A) <span class="mi">0</span> b = <span class="mi">0</span>
  := grp_homo_unit (grp_homo_tensor_r b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tensoring by zero on the right is zero. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tensor_zero_r</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">a</span> : A)
  : tensor (B:=B) a <span class="mi">0</span> = <span class="mi">0</span>
  := grp_homo_unit (grp_homo_tensor_l a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [tensor] map is biadditive and therefore can be written in a curried form using the internal abelian group hom. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk32"><span class="kn">Definition</span> <span class="nf">grp_homo_tensor</span> `{Funext} {A B : AbGroup}
  : A $-&gt; ab_hom B (ab_tensor_prod A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; ab_hom B (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; ab_hom B (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk34">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; ab_hom B (ab_tensor_prod A B)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk35"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; ab_hom B (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk37"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_hom B (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk38">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; ab_tensor_prod A B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk39"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk3a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; ab_tensor_prod A B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tensor a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk3b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (tensor a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   {|
     grp_homo_map := tensor a;
     issemigrouppreserving_grp_homo := tensor_dist_l a
   |})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk3d"><span class="nb">intros</span> a a&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := tensor (a + a&#39;);
  issemigrouppreserving_grp_homo :=
    tensor_dist_l (a + a&#39;)
|} =
{|
  grp_homo_map := tensor a;
  issemigrouppreserving_grp_homo := tensor_dist_l a
|} +
{|
  grp_homo_map := tensor a&#39;;
  issemigrouppreserving_grp_homo := tensor_dist_l a&#39;
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk3e"><span class="nb">apply</span> equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := tensor (a + a&#39;);
  issemigrouppreserving_grp_homo :=
    tensor_dist_l (a + a&#39;)
|} ==
{|
  grp_homo_map := tensor a;
  issemigrouppreserving_grp_homo := tensor_dist_l a
|} +
{|
  grp_homo_map := tensor a&#39;;
  issemigrouppreserving_grp_homo := tensor_dist_l a&#39;
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk3f"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := tensor (a + a&#39;);
  issemigrouppreserving_grp_homo :=
    tensor_dist_l (a + a&#39;)
|} b =
({|
   grp_homo_map := tensor a;
   issemigrouppreserving_grp_homo := tensor_dist_l a
 |} +
 {|
   grp_homo_map := tensor a&#39;;
   issemigrouppreserving_grp_homo := tensor_dist_l a&#39;
 |}) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Induction principles *)</span>

<span class="sd">(** Here we write down some induction principles to help us prove lemmas about the tensor product. Some of these are quite specialised but are patterns that appear often in practice. *)</span> 

<span class="sd">(** Our main recursion principle states that in order to build a homomorphism out of the tensor product, it is sufficient to provide a map out of the direct product which is biadditive, that is, a map that preserves addition in each argument of the product. *)</span>

<span class="sd">(** We separate out the proof of this part, so we can make it opaque. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk40"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_rec_helper</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  (<span class="nv">f</span> : A -&gt; B -&gt; C)
  (<span class="nv">l</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span>, f a (b + b&#39;) = f a b + f a b&#39;)
  (<span class="nv">r</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span>, f (a + a&#39;) b = f a b + f a&#39; b)
  (<span class="nv">x</span> : FreeAbGroup (A * B)) (<span class="nv">insg</span> : subgroup_biadditive_pairs x)
  : grp_homo_abel_rec (FreeGroup_rec (uncurry f)) x = mon_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>insg</var><span class="hyp-type"><b>: </b><span>subgroup_biadditive_pairs x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_abel_rec (FreeGroup_rec (uncurry f)) x = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>insg</var><span class="hyp-type"><b>: </b><span>subgroup_biadditive_pairs x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_abel_rec (FreeGroup_rec (uncurry f)) x = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk42"><span class="nb">set</span> (abel_rec := grp_homo_abel_rec (FreeGroup_rec (uncurry f))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>insg</var><span class="hyp-type"><b>: </b><span>subgroup_biadditive_pairs x</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec x = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk43">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>insg</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type family_biadditive_pairs
  x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec x = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk44"><span class="nb">induction</span> insg <span class="kr">as</span> [ x biad | | g h insg_g IHg insg_h IHh ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>biad</var><span class="hyp-type"><b>: </b><span>family_biadditive_pairs x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec x = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk45"><hr></label><div class="goal-conclusion">abel_rec <span class="mi">0</span> = <span class="mi">0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>insg_g</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs g</span></span></span><br><span><var>insg_h</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs h</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>abel_rec g = <span class="mi">0</span></span></span></span><br><span><var>IHh</var><span class="hyp-type"><b>: </b><span>abel_rec h = <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk46"><hr></label><div class="goal-conclusion">abel_rec (g - h) = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>biad</var><span class="hyp-type"><b>: </b><span>family_biadditive_pairs x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec x = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk48"><span class="nb">destruct</span> biad <span class="kr">as</span> [ [ a [ a&#39; [ b p ] ] ] | [ a [ b [ b&#39; p ] ] ] ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>- freeabgroup_in (a + a&#39;, b) +
(freeabgroup_in (a, b) + freeabgroup_in (a&#39;, b)) =
x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec x = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>- freeabgroup_in (a, b + b&#39;) +
(freeabgroup_in (a, b) + freeabgroup_in (a, b&#39;)) =
x</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk49"><hr></label><div class="goal-conclusion">abel_rec x = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk4a"><span class="kp">all</span>: <span class="nb">destruct</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- f (a + a&#39;) b + (f a b + f a&#39; b) = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk4b"><hr></label><div class="goal-conclusion">- f a (b + b&#39;) + (f a b + f a b&#39;) = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk4c"><span class="kp">all</span>: <span class="nb">apply</span> grp_moveL_M1^-<span class="mi">1</span>%equiv; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a + a&#39;) b = f a b + f a&#39; b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk4d"><hr></label><div class="goal-conclusion">f a (b + b&#39;) = f a b + f a b&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk4e"><span class="mi">1</span>: <span class="nb">apply</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a (b + b&#39;) = f a b + f a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk4f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply grp_homo_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>insg_g</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs g</span></span></span><br><span><var>insg_h</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs h</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>abel_rec g = <span class="mi">0</span></span></span></span><br><span><var>IHh</var><span class="hyp-type"><b>: </b><span>abel_rec h = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec (g - h) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk51"><span class="nb">rewrite</span> grp_homo_op, grp_homo_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>insg_g</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs g</span></span></span><br><span><var>insg_h</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs h</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>abel_rec g = <span class="mi">0</span></span></span></span><br><span><var>IHh</var><span class="hyp-type"><b>: </b><span>abel_rec h = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec g - abel_rec h = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk52"><span class="nb">apply</span> grp_moveL_1M^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br><span><var>abel_rec</var><span><span class="hyp-body"><b>:= </b><span>grp_homo_abel_rec
  (FreeGroup_rec (uncurry f))</span></span><span class="hyp-type"><b>: </b><span>abel (FreeGroup (A * B)) $-&gt; C</span></span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>FreeAbGroup (A * B)</span></span></span><br><span><var>insg_g</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs g</span></span></span><br><span><var>insg_h</var><span class="hyp-type"><b>: </b><span>subgroup_generated_type
  family_biadditive_pairs h</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>abel_rec g = <span class="mi">0</span></span></span></span><br><span><var>IHh</var><span class="hyp-type"><b>: </b><span>abel_rec h = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel_rec g = abel_rec h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IHg @ IHh^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Opaque</span> ab_tensor_prod_rec_helper.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk53"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_rec</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  (<span class="nv">f</span> : A -&gt; B -&gt; C)
  (<span class="nv">l</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span>, f a (b + b&#39;) = f a b + f a b&#39;)
  (<span class="nv">r</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span>, f (a + a&#39;) b = f a b + f a&#39; b) 
  : ab_tensor_prod A B $-&gt; C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk55"><span class="nb">unfold</span> ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">QuotientAbGroup (FreeAbGroup (A * B))
  subgroup_biadditive_pairs $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk56">snapply grp_quotient_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (A * B) $-&gt; C</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk57"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : FreeAbGroup (A * B),
{|
  normalsubgroup_subgroup := subgroup_biadditive_pairs;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup (FreeAbGroup (A * B))
      subgroup_biadditive_pairs
|} n -&gt; <span class="nl">?f</span> n = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (A * B) $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk59">snapply FreeAbGroup_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A * B -&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (uncurry f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : FreeAbGroup (A * B),
{|
  normalsubgroup_subgroup := subgroup_biadditive_pairs;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup (FreeAbGroup (A * B))
      subgroup_biadditive_pairs
|} n -&gt; FreeAbGroup_rec (uncurry f) n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk5b"><span class="nb">unfold</span> normalsubgroup_subgroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : FreeAbGroup (A * B),
subgroup_biadditive_pairs n -&gt;
FreeAbGroup_rec (uncurry f) n = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ab_tensor_prod_rec_helper; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A special case that arises. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk5c"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_rec&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  (<span class="nv">f</span> : A -&gt; (B $-&gt; C))
  (<span class="nv">l</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span>, f (a + a&#39;) b = f a b + f a&#39; b)
  : ab_tensor_prod A B $-&gt; C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B $-&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk5d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B $-&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk5e"><span class="nb">refine</span> (ab_tensor_prod_rec f _ l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B $-&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
f (a + a&#39;) b = f a b + f a&#39; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
f a (b + b&#39;) = f a b + f a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> a; <span class="nb">apply</span> grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We give an induction principle for an hprop-valued type family [P].  It may be surprising at first that we only require [P] to hold for the simple tensors [tensor a b] and be closed under addition.  It automatically follows that [P 0] holds (since [tensor 0 0 = 0]) and that [P] is closed under negation (since [tensor -a b = - tensor a b]). This induction principle says that the simple tensors generate the tensor product as a semigroup. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk5f"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_ind_hprop</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup}
  (<span class="nv">P</span> : ab_tensor_prod A B -&gt; <span class="kt">Type</span>)
  {<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)}
  (<span class="nv">Hin</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (tensor a b))
  (<span class="nv">Hop</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x -&gt; P y -&gt; P (x + y))
  : <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B, P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B, P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk61"><span class="nb">unfold</span> ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B, P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : QuotientAbGroup (FreeAbGroup (A * B))
      subgroup_biadditive_pairs, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk62">srapply grp_quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B, P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeAbGroup (A * B), P (grp_quotient_map x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk63">srapply Abel_ind_hprop; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B, P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeGroup (A * B),
P (grp_quotient_map (abel_in x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk64"><span class="nb">set</span> (tensor_in := grp_quotient_map $o abel_unit : FreeGroup (A * B) $-&gt; ab_tensor_prod A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B, P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeGroup (A * B),
P (grp_quotient_map (abel_in x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk65"><span class="nb">change</span> (<span class="kr">forall</span> <span class="nv">x</span>, P (tensor_in x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeGroup (A * B), P (tensor_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk66">srapply FreeGroup_ind_hprop&#39;; <span class="nb">intros</span> w; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>FreeGroup.Words (A * B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor_in (freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk67"><span class="nb">induction</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor_in (freegroup_eta nil))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>(A * B + A * B)%type</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk68"><hr></label><div class="goal-conclusion">P (tensor_in (freegroup_eta (a :: w)%list))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk69">- <span class="c">(* The goal here is [P 0], so we use [Hin 0 0 : P (tensor 0 0)]. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor_in (freegroup_eta nil))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport P (tensor_zero_l <span class="mi">0</span>) (Hin <span class="mi">0</span> <span class="mi">0</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk6a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>(A * B + A * B)%type</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor_in (freegroup_eta (a :: w)%list))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk6b"><span class="nb">change</span> (P (tensor_in (freegroup_eta [a]%list + freegroup_eta w))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>(A * B + A * B)%type</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (tensor_in
     (freegroup_eta [a]%list + freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* This [rewrite] is [reflexivity], but the [Defined] is slow if [change] is used instead. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk6c"><span class="nb">rewrite</span> grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>(A * B + A * B)%type</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (tensor_in (freegroup_eta [a]%list) +
   tensor_in (freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk6d"><span class="nb">destruct</span> a <span class="kr">as</span> [[a b]|[a b]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (tensor_in (freegroup_eta [inl (a, b)]%list) +
   tensor_in (freegroup_eta w))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk6e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk6e"><hr></label><div class="goal-conclusion">P
  (tensor_in (freegroup_eta [inr (a, b)]%list) +
   tensor_in (freegroup_eta w))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk6f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (tensor_in (freegroup_eta [inl (a, b)]%list) +
   tensor_in (freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk70"><span class="nb">change</span> (P (tensor_in (freegroup_in (a, b)) + tensor_in (freegroup_eta w))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (tensor_in (freegroup_in (a, b)) +
   tensor_in (freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk71"><span class="nb">apply</span> Hop; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor_in (freegroup_in (a, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk72">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (tensor_in (freegroup_eta [inr (a, b)]%list) +
   tensor_in (freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk73"><span class="nb">change</span> (P (tensor_in (- freegroup_in (a, b)) + tensor_in (freegroup_eta w))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (tensor_in (- freegroup_in (a, b)) +
   tensor_in (freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* This [rewrite] is reflexivity, but using [change] to achieve this is slow and slows down the Defined line. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk74"><span class="nb">rewrite</span> grp_homo_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  (- tensor_in (freegroup_in (a, b)) +
   tensor_in (freegroup_eta w))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk75"><span class="nb">apply</span> Hop; <span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (- tensor_in (freegroup_in (a, b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk76"><span class="nb">rewrite</span> &lt;- tensor_neg_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P (tensor a b)</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>tensor_in</var><span><span class="hyp-body"><b>:= </b><span>grp_quotient_map $o abel_unit
:
FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span><span class="hyp-type"><b>: </b><span>FreeGroup (A * B) $-&gt; ab_tensor_prod A B</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>list (A * B + A * B)</span></span></span><br><span><var>IHw</var><span class="hyp-type"><b>: </b><span>P (tensor_in (freegroup_eta w))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor (- a) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As a commonly occurring special case of the above induction principle, we have the case when the predicate in question is showing that two group homomorphisms out of the tensor product are homotopic. In order to do this, it suffices to show it only for simple tensors. The homotopy is closed under addition, so we don&#39;t need to hypothesise anything else. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk77"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_ind_homotopy</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">G</span> : AbGroup}
  {<span class="nv">f</span> <span class="nv">f&#39;</span> : ab_tensor_prod A B $-&gt; G}
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, f (tensor a b) = f&#39; (tensor a b))
  : f $== f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk78"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk79">napply ab_tensor_prod_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (f x = f&#39; x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk7a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk7b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
f x = f&#39; x -&gt; f y = f&#39; y -&gt; f (x + y) = f&#39; (x + y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk7c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A B, IsHProp (f x = f&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk7d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk7e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
f (tensor a b) = f&#39; (tensor a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A B,
f x = f&#39; x -&gt; f y = f&#39; y -&gt; f (x + y) = f&#39; (x + y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y; <span class="nb">apply</span> grp_homo_op_agree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As an even more specialised case, we occasionally have the second homomorphism being a sum of abelian group homomorphisms. In those cases, it is easier to use this specialised lemma. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_ind_homotopy_plus</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">G</span> : AbGroup}
  {<span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">f&#39;&#39;</span> : ab_tensor_prod A B $-&gt; G}
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, f (tensor a b) = f&#39; (tensor a b) + f&#39;&#39; (tensor a b))
  : <span class="kr">forall</span> <span class="nv">x</span>, f x = f&#39; x + f&#39;&#39; x
  := ab_tensor_prod_ind_homotopy (f&#39;:=f&#39; + f&#39;&#39;) H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here we give an induction principle for a triple tensor, a.k.a a dependent trilinear function. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk7f"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_ind_hprop_triple</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  (<span class="nv">P</span> : ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span>)
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x))
  (<span class="nv">Hin</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>, P (tensor a (tensor b c)))
  (<span class="nv">Hop</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x -&gt; P y -&gt; P (x + y))
  : <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C), P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C), P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk81">rapply (ab_tensor_prod_ind_hprop P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : ab_tensor_prod B C),
P (tensor a b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk82"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C),
P x -&gt; P y -&gt; P (x + y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : ab_tensor_prod B C),
P (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk84"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ab_tensor_prod B C, P (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk85">rapply (ab_tensor_prod_ind_hprop (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P (tensor _ x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> : B) (<span class="nv">b</span> : C), P (tensor a (tensor a0 b))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk86"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod B C,
P (tensor a x) -&gt;
P (tensor a y) -&gt; P (tensor a (x + y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk87">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> : B) (<span class="nv">b</span> : C), P (tensor a (tensor a0 b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply Hin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk88">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod B C,
P (tensor a x) -&gt;
P (tensor a y) -&gt; P (tensor a (x + y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk89"><span class="nb">intros</span> x y Hx Hy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod B C</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P (tensor a x)</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>P (tensor a y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor a (x + y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk8a"><span class="nb">rewrite</span> tensor_dist_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod B C</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P (tensor a x)</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>P (tensor a y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor a x + tensor a y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk8b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C), P (tensor a (tensor b c))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C), P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C),
P x -&gt; P y -&gt; P (x + y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Similar to before, we specialise the triple tensor induction principle for proving homotopies of trilinear/triadditive functions. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk8c"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_ind_homotopy_triple</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">G</span> : AbGroup}
  {<span class="nv">f</span> <span class="nv">f&#39;</span> : ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G}
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>, f (tensor a (tensor b c)) = f&#39; (tensor a (tensor b c)))
  : f $== f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk8e">napply ab_tensor_prod_ind_hprop_triple.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (f x = f&#39; x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk8f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) = f&#39; (tensor a (tensor b c))</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk90"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C),
f x = f&#39; x -&gt; f y = f&#39; y -&gt; f (x + y) = f&#39; (x + y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A (ab_tensor_prod B C),
IsHProp (f x = f&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk92">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) = f&#39; (tensor a (tensor b c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk93">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_tensor_prod B C) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
f (tensor a (tensor b c)) =
f&#39; (tensor a (tensor b c))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B C),
f x = f&#39; x -&gt; f y = f&#39; y -&gt; f (x + y) = f&#39; (x + y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y; <span class="nb">apply</span> grp_homo_op_agree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As explained for the biadditive and triadditive cases, we also derive an induction principle for quadruple tensors giving us dependent quadrilinear maps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk94"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_ind_hprop_quad</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : AbGroup}
  (<span class="nv">P</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span>)
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x))
  (<span class="nv">Hin</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span>, P (tensor a (tensor b (tensor c d))))
  (<span class="nv">Hop</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x -&gt; P y -&gt; P (x + y))
  : <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)), P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk95"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)), P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk96">rapply (ab_tensor_prod_ind_hprop P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A)
(<span class="nv">b</span> : ab_tensor_prod B (ab_tensor_prod C D)),
P (tensor a b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk97"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : ab_tensor_prod A
       (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk98">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A)
(<span class="nv">b</span> : ab_tensor_prod B (ab_tensor_prod C D)),
P (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk99"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ab_tensor_prod B (ab_tensor_prod C D),
P (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk9a">napply (ab_tensor_prod_ind_hprop_triple (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P (tensor _ x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod B (ab_tensor_prod C D),
IsHProp (P (tensor a x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk9b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> : B) (<span class="nv">b</span> : C) (<span class="nv">c</span> : D),
P (tensor a (tensor a0 (tensor b c)))</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk9c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod B (ab_tensor_prod C D),
P (tensor a x) -&gt;
P (tensor a y) -&gt; P (tensor a (x + y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk9d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod B (ab_tensor_prod C D),
IsHProp (P (tensor a x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; <span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk9e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> : B) (<span class="nv">b</span> : C) (<span class="nv">c</span> : D),
P (tensor a (tensor a0 (tensor b c)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply Hin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk9f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod B (ab_tensor_prod C D),
P (tensor a x) -&gt;
P (tensor a y) -&gt; P (tensor a (x + y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka0"><span class="nb">intros</span> x y Hx Hy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod B (ab_tensor_prod C D)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P (tensor a x)</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>P (tensor a y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor a (x + y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka1"><span class="nb">rewrite</span> tensor_dist_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod B (ab_tensor_prod C D)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>P (tensor a x)</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>P (tensor a y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (tensor a x + tensor a y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (P x)</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D), P (tensor a (tensor b (tensor c d)))</span></span></span><br><span><var>Hop</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : ab_tensor_prod A
       (ab_tensor_prod B (ab_tensor_prod C D)),
P x -&gt; P y -&gt; P (x + y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Hop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** To construct a homotopy between quadrilinear maps we need only check equality for the quadruple simple tensors. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka3"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_ind_homotopy_quad</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">G</span> : AbGroup}
  {<span class="nv">f</span> <span class="nv">f&#39;</span> : ab_tensor_prod A (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G}
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span>, f (tensor a (tensor b (tensor c d)))
    = f&#39; (tensor a (tensor b (tensor c d))))
  : f $== f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $== f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka5">napply (ab_tensor_prod_ind_hprop_quad (<span class="kr">fun</span> <span class="nv">_</span> =&gt; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (f x = f&#39; x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chka6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chka7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : ab_tensor_prod A
       (ab_tensor_prod B (ab_tensor_prod C D)),
f x = f&#39; x -&gt; f y = f&#39; y -&gt; f (x + y) = f&#39; (x + y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : ab_tensor_prod A
      (ab_tensor_prod B (ab_tensor_prod C D)),
IsHProp (f x = f&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chka9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkaa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A
  (ab_tensor_prod B (ab_tensor_prod C D)) $-&gt; G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
f (tensor a (tensor b (tensor c d))) =
f&#39; (tensor a (tensor b (tensor c d)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span>
 <span class="nv">y</span> : ab_tensor_prod A
       (ab_tensor_prod B (ab_tensor_prod C D)),
f x = f&#39; x -&gt; f y = f&#39; y -&gt; f (x + y) = f&#39; (x + y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y; <span class="nb">apply</span> grp_homo_op_agree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Universal Property of the Tensor Product *)</span>

<span class="sd">(** A function of two variables is biadditive if it preserves the operation in each variable. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBiadditive</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} `{SgOp A, SgOp B, SgOp C} (f : A -&gt; B -&gt; C) := {
  isbiadditive_l :: <span class="kr">forall</span> <span class="nv">b</span>, IsSemiGroupPreserving (flip f b);
  isbiadditive_r :: <span class="kr">forall</span> <span class="nv">a</span>, IsSemiGroupPreserving (f a);  
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_IsBiadditive</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} `{SgOp A, SgOp B, SgOp C}
  (f : A -&gt; B -&gt; C)
  : _ &lt;~&gt; IsBiadditive f
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The truncation level of the [IsBiadditive f] predicate is determined by the truncation level of the codomain. This will almost always be a hset. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkab"><span class="kn">Instance</span> <span class="nf">istrunc_isbiadditive</span> `{Funext}
  {A B C : <span class="kt">Type</span>} `{SgOp A, SgOp B, SgOp C}
  (f : A -&gt; B -&gt; C) n `{IsTrunc n.+<span class="mi">1</span> C}
  : IsTrunc n (IsBiadditive f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (IsBiadditive f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (IsBiadditive f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkad">napply istrunc_equiv_istrunc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; IsBiadditive f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkae"><hr></label><div class="goal-conclusion">IsTrunc n <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkaf"><span class="mi">1</span>: rapply issig_IsBiadditive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n
  {_ : <span class="kr">forall</span> <span class="nv">b</span> : B, IsSemiGroupPreserving (flip f b)
  &amp; <span class="kr">forall</span> <span class="nv">a</span> : A, IsSemiGroupPreserving (f a)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb0"><span class="nb">unfold</span> IsSemiGroupPreserving.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n
  {_
  : <span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">x</span> <span class="nv">y</span> : A),
    flip f b (x + y) = flip f b x + flip f b y &amp;
  <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">x</span> <span class="nv">y</span> : B),
  f a (x + y) = f a x + f a y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The simple tensor map is biadditive. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isbiadditive_tensor</span> (<span class="nv">A</span> <span class="nv">B</span> : AbGroup)
  : IsBiadditive (@tensor A B) := {|
  isbiadditive_l := <span class="kr">fun</span> <span class="nv">b</span> <span class="nv">a</span> <span class="nv">a&#39;</span> =&gt; tensor_dist_r a a&#39; b;
  isbiadditive_r := tensor_dist_l;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The type of biadditive maps. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">Biadditive</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) `{SgOp A, SgOp B, SgOp C} := {
  biadditive_fun :&gt; A -&gt; B -&gt; C;
  biadditive_isbiadditive :: IsBiadditive biadditive_fun;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_Biadditive</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} `{SgOp A, SgOp B, SgOp C}
  : _ &lt;~&gt; Biadditive A B C
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb1"><span class="kn">Definition</span> <span class="nf">biadditive_ab_tensor_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  : (ab_tensor_prod A B $-&gt; C) -&gt; Biadditive A B C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_tensor_prod A B $-&gt; C) -&gt; Biadditive A B C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_tensor_prod A B $-&gt; C) -&gt; Biadditive A B C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb3"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Biadditive A B C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb4"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; f (tensor x y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsBiadditive (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; f (tensor x y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb5">snapply Build_IsBiadditive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
IsSemiGroupPreserving
  (flip (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; f (tensor x y)) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkb6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
IsSemiGroupPreserving
  ((<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; f (tensor x y)) a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
IsSemiGroupPreserving
  (flip (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; f (tensor x y)) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb8"><span class="nb">intros</span> b a a&#39;; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (tensor (a + a&#39;) b) =
f (tensor a b) + f (tensor a&#39; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkb9">lhs napply (ap f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (a + a&#39;) b = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkba"><hr></label><div class="goal-conclusion">f <span class="nl">?Goal</span> = f (tensor a b) + f (tensor a&#39; b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkbb"><span class="mi">1</span>: napply tensor_dist_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (tensor a b + tensor a&#39; b) =
f (tensor a b) + f (tensor a&#39; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkbc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
IsSemiGroupPreserving
  ((<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; f (tensor x y)) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkbd"><span class="nb">intros</span> a a&#39; b; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a', b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (tensor a (a&#39; + b)) =
f (tensor a a&#39;) + f (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkbe">lhs napply (ap f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a', b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a (a&#39; + b) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a', b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkbf"><hr></label><div class="goal-conclusion">f <span class="nl">?Goal</span> = f (tensor a a&#39;) + f (tensor a b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkc0"><span class="mi">1</span>: napply tensor_dist_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a', b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (tensor a a&#39; + tensor a b) =
f (tensor a a&#39;) + f (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The universal property of the tensor product is that biadditive maps between abelian groups are in one-to-one correspondence with maps out of the tensor product. In this sense, the tensor product is the most perfect object describing biadditive maps between two abelian groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkc1"><span class="kn">Definition</span> <span class="nf">equiv_ab_tensor_prod_rec</span> `{Funext} (A B C : AbGroup)
  : Biadditive A B C &lt;~&gt; (ab_tensor_prod A B $-&gt; C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Biadditive A B C &lt;~&gt; (ab_tensor_prod A B $-&gt; C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Biadditive A B C &lt;~&gt; (ab_tensor_prod A B $-&gt; C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkc3">snapply equiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Biadditive A B C -&gt; ab_tensor_prod A B $-&gt; C</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkc4"><hr></label><div class="goal-conclusion">(ab_tensor_prod A B $-&gt; C) -&gt; Biadditive A B C</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkc5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkc5"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkc6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkc6"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkc7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Biadditive A B C -&gt; ab_tensor_prod A B $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkc8"><span class="nb">intros</span> [f [l r]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsSemiGroupPreserving (flip f b)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsSemiGroupPreserving (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ab_tensor_prod_rec f r (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> =&gt; l b a a&#39;)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkc9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_tensor_prod A B $-&gt; C) -&gt; Biadditive A B C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">snapply biadditive_ab_tensor_prod.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkca">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">X</span> : Biadditive A B C =&gt;
 (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B -&gt; C)
    (<span class="nv">biadditive_isbiadditive0</span> : IsBiadditive f) =&gt;
  (<span class="kr">fun</span>
     (<span class="nv">l</span> : <span class="kr">forall</span> <span class="nv">b</span> : B,
          IsSemiGroupPreserving (flip f b))
     (<span class="nv">r</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, IsSemiGroupPreserving (f a))
   =&gt;
   ab_tensor_prod_rec f r
     (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B) =&gt; l b a a&#39;))
    isbiadditive_l isbiadditive_r) X
   (biadditive_isbiadditive A B C X))
o biadditive_ab_tensor_prod == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkcb"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_rec (biadditive_ab_tensor_prod f)
  isbiadditive_r
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B) =&gt; isbiadditive_l b a a&#39;) =
f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkcc">snapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_rec (biadditive_ab_tensor_prod f)
  isbiadditive_r
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B) =&gt; isbiadditive_l b a a&#39;) ==
f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkcd">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
ab_tensor_prod_rec (biadditive_ab_tensor_prod f)
  isbiadditive_r
  (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b0</span> : B) =&gt; isbiadditive_l b0 a0 a&#39;)
  (tensor a b) = f (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkce"><span class="nb">intros</span> a b; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod A B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (tensor a b) = f (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkcf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">biadditive_ab_tensor_prod
o (<span class="kr">fun</span> <span class="nv">X</span> : Biadditive A B C =&gt;
   (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B -&gt; C)
      (<span class="nv">biadditive_isbiadditive0</span> : IsBiadditive f) =&gt;
    (<span class="kr">fun</span>
       (<span class="nv">l</span> : <span class="kr">forall</span> <span class="nv">b</span> : B,
            IsSemiGroupPreserving (flip f b))
       (<span class="nv">r</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, IsSemiGroupPreserving (f a))
     =&gt;
     ab_tensor_prod_rec f r
       (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B) =&gt; l b a a&#39;))
      isbiadditive_l isbiadditive_r) X
     (biadditive_isbiadditive A B C X)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd0"><span class="nb">intros</span> [f [l r]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsSemiGroupPreserving (flip f b)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsSemiGroupPreserving (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">biadditive_ab_tensor_prod
  (ab_tensor_prod_rec f r
     (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B) =&gt; l b a a&#39;)) =
{|
  biadditive_fun := f;
  biadditive_isbiadditive :=
    {| isbiadditive_l := l; isbiadditive_r := r |}
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd1">snapply (equiv_ap_inv&#39; issig_Biadditive).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsSemiGroupPreserving (flip f b)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsSemiGroupPreserving (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">issig_Biadditive^-<span class="mi">1</span>
  (biadditive_ab_tensor_prod
     (ab_tensor_prod_rec f r
        (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B) =&gt; l b a a&#39;))) =
issig_Biadditive^-<span class="mi">1</span>
  {|
    biadditive_fun := f;
    biadditive_isbiadditive :=
      {| isbiadditive_l := l; isbiadditive_r := r |}
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd2">rapply path_sigma_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsSemiGroupPreserving (flip f b)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsSemiGroupPreserving (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) =&gt; f x y) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality of the Tensor Product *)</span>

<span class="sd">(** The tensor product produces a bifunctor and we will later show that it gives a symmetric monoidal structure on the category of abelian groups. *)</span>

<span class="sd">(** Given a pair of maps, we can produce a homomorphism between the pairwise tensor products of the domains and codomains. *)</span> 
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd3"><span class="kn">Definition</span> <span class="nf">functor_ab_tensor_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span> : AbGroup}
  (<span class="nv">f</span> : A $-&gt; A&#39;) (<span class="nv">g</span> : B $-&gt; B&#39;)
  : ab_tensor_prod A B $-&gt; ab_tensor_prod A&#39; B&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; ab_tensor_prod A&#39; B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; ab_tensor_prod A&#39; B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd5">snapply ab_tensor_prod_rec&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; B $-&gt; ab_tensor_prod A&#39; B&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkd6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
<span class="nl">?f</span> (a + a&#39;) b = <span class="nl">?f</span> a b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; B $-&gt; ab_tensor_prod A&#39; B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd8"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; ab_tensor_prod A&#39; B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_tensor_l (f a) $o g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkd9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; grp_homo_tensor_l (f a0) $o g) (a + a&#39;)
  b =
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; grp_homo_tensor_l (f a0) $o g) a b +
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; grp_homo_tensor_l (f a0) $o g) a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkda"><span class="nb">intros</span> a a&#39; b; <span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_homo_tensor_l (f (a + a&#39;)) $o g) b =
(grp_homo_tensor_l (f a) $o g) b +
(grp_homo_tensor_l (f a&#39;) $o g) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkdb"><span class="nb">rewrite</span> grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_homo_tensor_l (f a + f a&#39;) $o g) b =
(grp_homo_tensor_l (f a) $o g) b +
(grp_homo_tensor_l (f a&#39;) $o g) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** 2-functoriality of the tensor product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkdc"><span class="kn">Definition</span> <span class="nf">functor2_ab_tensor_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span> : AbGroup}
  {<span class="nv">f</span> <span class="nv">f&#39;</span> : A $-&gt; A&#39;} (<span class="nv">p</span> : f $== f&#39;) {<span class="nv">g</span> <span class="nv">g&#39;</span> : B $-&gt; B&#39;} (<span class="nv">q</span> : g $== g&#39;)
  : functor_ab_tensor_prod f g $== functor_ab_tensor_prod f&#39; g&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== f&#39;</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $== g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_ab_tensor_prod f g $==
functor_ab_tensor_prod f&#39; g&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== f&#39;</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $== g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_ab_tensor_prod f g $==
functor_ab_tensor_prod f&#39; g&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkde">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== f&#39;</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $== g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
functor_ab_tensor_prod f g (tensor a b) =
functor_ab_tensor_prod f&#39; g&#39; (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkdf"><span class="nb">intros</span> a b; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== f&#39;</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $== g&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (f a) (g b) = tensor (f&#39; a) (g&#39; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011 tensor (p _) (q _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tensor product functor preserves identity morphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke0"><span class="kn">Definition</span> <span class="nf">functor_ab_tensor_prod_id</span> (<span class="nv">A</span> <span class="nv">B</span> : AbGroup)
  : functor_ab_tensor_prod (Id A) (Id B) $== Id (ab_tensor_prod A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_ab_tensor_prod (Id A) (Id B) $==
Id (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_ab_tensor_prod (Id A) (Id B) $==
Id (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke2">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
functor_ab_tensor_prod (Id A) (Id B) (tensor a b) =
Id (ab_tensor_prod A B) (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke3"><span class="nb">intros</span> a b; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a b = tensor a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tensor product functor preserves composition. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke4"><span class="kn">Definition</span> <span class="nf">functor_ab_tensor_prod_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span> <span class="nv">C&#39;</span> : AbGroup}
  (<span class="nv">f</span> : A $-&gt; B) (<span class="nv">g</span> : B $-&gt; C) (<span class="nv">f&#39;</span> : A&#39; $-&gt; B&#39;) (<span class="nv">g&#39;</span> : B&#39; $-&gt; C&#39;)
  : functor_ab_tensor_prod (g $o f) (g&#39; $o f&#39;)
    $== functor_ab_tensor_prod g g&#39; $o functor_ab_tensor_prod f f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; $-&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; C&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_ab_tensor_prod (g $o f) (g&#39; $o f&#39;) $==
functor_ab_tensor_prod g g&#39; $o
functor_ab_tensor_prod f f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; $-&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; C&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_ab_tensor_prod (g $o f) (g&#39; $o f&#39;) $==
functor_ab_tensor_prod g g&#39; $o
functor_ab_tensor_prod f f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke6">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; $-&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; C&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : A&#39;),
functor_ab_tensor_prod (g $o f) (g&#39; $o f&#39;)
  (tensor a b) =
(functor_ab_tensor_prod g g&#39; $o
 functor_ab_tensor_prod f f&#39;) (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke7"><span class="nb">intros</span> a b; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>A&#39; $-&gt; B&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; C&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (g (f a)) (g&#39; (f&#39; b)) =
tensor (g (f a)) (g&#39; (f&#39; b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tensor product functor is a 0-bifunctor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke8"><span class="kn">Instance</span> <span class="nf">is0bifunctor_ab_tensor_prod</span> : Is0Bifunctor ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Bifunctor ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chke9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Bifunctor ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkea">rapply Build_Is0Bifunctor&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (uncurry ab_tensor_prod)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkeb">snapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup * AbGroup,
(a $-&gt; b) -&gt;
uncurry ab_tensor_prod a $-&gt; uncurry ab_tensor_prod b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkec"><span class="nb">intros</span> [A B] [A&#39; B&#39;] [f g].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fst (A, B) $-&gt; fst (A&#39;, B&#39;)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>snd (A, B) $-&gt; snd (A&#39;, B&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">uncurry ab_tensor_prod (A, B) $-&gt;
uncurry ab_tensor_prod (A&#39;, B&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_ab_tensor_prod f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The tensor product functor is a bifunctor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chked"><span class="kn">Instance</span> <span class="nf">is1bifunctor_ab_tensor_prod</span> : Is1Bifunctor ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkee"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkef">rapply Build_Is1Bifunctor&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (uncurry ab_tensor_prod)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf0">snapply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbGroup * AbGroup) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt;
fmap (uncurry ab_tensor_prod) f $==
fmap (uncurry ab_tensor_prod) g</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbGroup * AbGroup,
fmap (uncurry ab_tensor_prod) (Id a) $==
Id (uncurry ab_tensor_prod a)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbGroup * AbGroup) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c),
fmap (uncurry ab_tensor_prod) (g $o f) $==
fmap (uncurry ab_tensor_prod) g $o
fmap (uncurry ab_tensor_prod) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbGroup * AbGroup) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt;
fmap (uncurry ab_tensor_prod) f $==
fmap (uncurry ab_tensor_prod) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf2"><span class="nb">intros</span> AB A&#39;B&#39; fg f&#39;g&#39; [p q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>AB, A'B'</var><span class="hyp-type"><b>: </b><span>AbGroup * AbGroup</span></span></span><br><span><var>fg, f'g'</var><span class="hyp-type"><b>: </b><span>AB $-&gt; A&#39;B&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst fg $-&gt; fst f&#39;g&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd fg $-&gt; snd f&#39;g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (uncurry ab_tensor_prod) fg $==
fmap (uncurry ab_tensor_prod) f&#39;g&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor2_ab_tensor_prod p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbGroup * AbGroup,
fmap (uncurry ab_tensor_prod) (Id a) $==
Id (uncurry ab_tensor_prod a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf4"><span class="nb">intros</span> [A B].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (uncurry ab_tensor_prod) (Id (A, B)) $==
Id (uncurry ab_tensor_prod (A, B))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_ab_tensor_prod_id A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbGroup * AbGroup) 
(<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (uncurry ab_tensor_prod) (g $o f) $==
fmap (uncurry ab_tensor_prod) g $o
fmap (uncurry ab_tensor_prod) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf6"><span class="nb">intros</span> AA&#39; BB&#39; CC&#39; [f g] [f&#39; g&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>AA', BB', CC'</var><span class="hyp-type"><b>: </b><span>AbGroup * AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fst AA&#39; $-&gt; fst BB&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>snd AA&#39; $-&gt; snd BB&#39;</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>fst BB&#39; $-&gt; fst CC&#39;</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>snd BB&#39; $-&gt; snd CC&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (uncurry ab_tensor_prod) ((f&#39;, g&#39;) $o (f, g)) $==
fmap (uncurry ab_tensor_prod) (f&#39;, g&#39;) $o
fmap (uncurry ab_tensor_prod) (f, g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_ab_tensor_prod_compose f f&#39; g g&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Symmetry of the Tensor Product *)</span>

<span class="sd">(** The tensor product is symmetric in that the order in which we take the tensor shouldn&#39;t matter up to isomorphism. *)</span>

<span class="sd">(** We can define a swap map which swaps the order of simple tensors. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf7"><span class="kn">Definition</span> <span class="nf">ab_tensor_swap</span> {<span class="nv">A</span> <span class="nv">B</span>} : ab_tensor_prod A B $-&gt; ab_tensor_prod B A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; ab_tensor_prod B A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt; ab_tensor_prod B A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkf9">snapply ab_tensor_prod_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; B -&gt; ab_tensor_prod B A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkfa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkfa"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
<span class="nl">?f</span> a (b + b&#39;) = <span class="nl">?f</span> a b + <span class="nl">?f</span> a b&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chkfb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chkfb"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
<span class="nl">?f</span> (a + a&#39;) b = <span class="nl">?f</span> a b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkfc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; B -&gt; ab_tensor_prod B A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (flip tensor).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkfd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : B),
flip tensor a (b + b&#39;) =
flip tensor a b + flip tensor a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkfe"><span class="nb">intros</span> a b b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flip tensor a (b + b&#39;) =
flip tensor a b + flip tensor a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> tensor_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chkff">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : B),
flip tensor (a + a&#39;) b =
flip tensor a b + flip tensor a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk100"><span class="nb">intros</span> a a&#39; b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flip tensor (a + a&#39;) b =
flip tensor a b + flip tensor a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> tensor_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ab_tensor_swap] is involutive. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk101"><span class="kn">Definition</span> <span class="nf">ab_tensor_swap_swap</span> {<span class="nv">A</span> <span class="nv">B</span>}
  : ab_tensor_swap $o @ab_tensor_swap A B $== Id _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_swap $o ab_tensor_swap $==
Id (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk102"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_swap $o ab_tensor_swap $==
Id (ab_tensor_prod A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk103">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
(ab_tensor_swap $o ab_tensor_swap) (tensor a b) =
Id (ab_tensor_prod A B) (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ab_tensor_swap] is natural in both arguments. This means that it also acts on tensor functors. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk104"><span class="kn">Definition</span> <span class="nf">ab_tensor_swap_natural</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; A&#39;) (<span class="nv">g</span> : B $-&gt; B&#39;)
  : ab_tensor_swap $o functor_ab_tensor_prod f g
    $== functor_ab_tensor_prod g f $o ab_tensor_swap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_swap $o functor_ab_tensor_prod f g $==
functor_ab_tensor_prod g f $o ab_tensor_swap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk105"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_swap $o functor_ab_tensor_prod f g $==
functor_ab_tensor_prod g f $o ab_tensor_swap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk106">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
(ab_tensor_swap $o functor_ab_tensor_prod f g)
  (tensor a b) =
(functor_ab_tensor_prod g f $o ab_tensor_swap)
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk107"><span class="nb">simpl</span>. <span class="c">(* This speeds up the [reflexivity] and the [Defined]. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, A', B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
tensor (g b) (f a) = tensor (g b) (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The swap map gives us a symmetric braiding on the category of abelian groups. We will later show it is a full symmetric monoidal category. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk108"><span class="kn">Instance</span> <span class="nf">symmetricbraiding_ab_tensor_prod</span> : SymmetricBraiding ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">SymmetricBraiding ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk109"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">SymmetricBraiding ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk10a">snapply Build_SymmetricBraiding.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Braiding ab_tensor_prod</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup,
<span class="nl">?braiding_symmetricbraiding</span> a b $o
<span class="nl">?braiding_symmetricbraiding</span> b a $==
Id (ab_tensor_prod b a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk10b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Braiding ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk10c">snapply Build_NatTrans.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">uncurry ab_tensor_prod $=&gt;
uncurry (flip ab_tensor_prod)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (uncurry ab_tensor_prod)
  (uncurry (flip ab_tensor_prod)) <span class="nl">?alpha</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk10d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">uncurry ab_tensor_prod $=&gt;
uncurry (flip ab_tensor_prod)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span>; <span class="bp">exact</span> ab_tensor_swap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk10e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (uncurry ab_tensor_prod)
  (uncurry (flip ab_tensor_prod))
  ((<span class="kr">fun</span> <span class="nv">a</span> : AbGroup * AbGroup =&gt; ab_tensor_swap)
   :
   uncurry ab_tensor_prod $=&gt;
   uncurry (flip ab_tensor_prod))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk10f">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : AbGroup * AbGroup) (<span class="nv">f</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup * AbGroup =&gt; ab_tensor_swap) a&#39; $o
fmap (uncurry ab_tensor_prod) f $==
fmap (uncurry (flip ab_tensor_prod)) f $o
(<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup * AbGroup =&gt; ab_tensor_swap) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; napply ab_tensor_swap_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk110">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup,
{|
  trans_nattrans :=
    (<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup * AbGroup =&gt; ab_tensor_swap)
    :
    uncurry ab_tensor_prod $=&gt;
    uncurry (flip ab_tensor_prod);
  is1natural_nattrans :=
    Build_Is1Natural
      (<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup * AbGroup =&gt; ab_tensor_swap)
      (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : AbGroup * AbGroup) (<span class="nv">f</span> : a0 $-&gt; a&#39;)
       =&gt; ab_tensor_swap_natural (fst f) (snd f))
|} a b $o
{|
  trans_nattrans :=
    (<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup * AbGroup =&gt; ab_tensor_swap)
    :
    uncurry ab_tensor_prod $=&gt;
    uncurry (flip ab_tensor_prod);
  is1natural_nattrans :=
    Build_Is1Natural
      (<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup * AbGroup =&gt; ab_tensor_swap)
      (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : AbGroup * AbGroup) (<span class="nv">f</span> : a0 $-&gt; a&#39;)
       =&gt; ab_tensor_swap_natural (fst f) (snd f))
|} b a $== Id (ab_tensor_prod b a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; napply ab_tensor_swap_swap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Twisting Triple Tensors *)</span>

<span class="sd">(** In order to construct the symmetric monoidal category, we will use what is termed the &quot;Twist construction&quot; in Monoidal.v. This simplifies the data of a symmetric monoidal category by constructing it from simpler parts. For instance, instead of having to prove full associativity [(A ‚äó B) ‚äó C $-&gt; A ‚äó (B ‚äó C)], we can provide a twist map [A ‚äó (B ‚äó C) $-&gt; B ‚äó (A ‚äó C)] and use the symmetric braiding we have so far to prove associativity. *)</span>

<span class="sd">(** In order to be more efficient whilst unfolding definitions, we break up the definition of a twist map into its components. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk111"><span class="kn">Local Definition</span> <span class="nf">ab_tensor_prod_twist_map</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  : A -&gt; (ab_tensor_prod B C $-&gt; ab_tensor_prod B (ab_tensor_prod A C)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_tensor_prod B C $-&gt;
ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_tensor_prod B C $-&gt;
ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk113"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod B C $-&gt;
ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk114">snapply ab_tensor_prod_rec&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; C $-&gt; ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk115" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk115"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : B) (<span class="nv">b</span> : C),
<span class="nl">?f</span> (a0 + a&#39;) b = <span class="nl">?f</span> a0 b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk116">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; C $-&gt; ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk117"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C $-&gt; ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_tensor_l b $o grp_homo_tensor_l a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk118">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : B) (<span class="nv">b</span> : C),
(<span class="kr">fun</span> <span class="nv">b0</span> : B =&gt;
 grp_homo_tensor_l b0 $o grp_homo_tensor_l a)
  (a0 + a&#39;) b =
(<span class="kr">fun</span> <span class="nv">b0</span> : B =&gt;
 grp_homo_tensor_l b0 $o grp_homo_tensor_l a) a0 b +
(<span class="kr">fun</span> <span class="nv">b0</span> : B =&gt;
 grp_homo_tensor_l b0 $o grp_homo_tensor_l a) a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk119"><span class="nb">intros</span> b b&#39; c; <span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_homo_tensor_l (b + b&#39;) $o grp_homo_tensor_l a) c =
(grp_homo_tensor_l b $o grp_homo_tensor_l a) c +
(grp_homo_tensor_l b&#39; $o grp_homo_tensor_l a) c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk11a"><span class="kn">Local Definition</span> <span class="nf">ab_tensor_prod_twist_map_additive_l</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : ab_tensor_prod B C)
  : ab_tensor_prod_twist_map (a + a&#39;) b
    = ab_tensor_prod_twist_map a b + ab_tensor_prod_twist_map a&#39; b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod B C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_twist_map (a + a&#39;) b =
ab_tensor_prod_twist_map a b +
ab_tensor_prod_twist_map a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk11b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>ab_tensor_prod B C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_twist_map (a + a&#39;) b =
ab_tensor_prod_twist_map a b +
ab_tensor_prod_twist_map a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">  
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk11c"><span class="nb">revert</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ab_tensor_prod B C,
ab_tensor_prod_twist_map (a + a&#39;) b =
ab_tensor_prod_twist_map a b +
ab_tensor_prod_twist_map a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk11d">napply ab_tensor_prod_ind_homotopy_plus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> : B) (<span class="nv">b</span> : C),
ab_tensor_prod_twist_map (a + a&#39;) (tensor a0 b) =
ab_tensor_prod_twist_map a (tensor a0 b) +
ab_tensor_prod_twist_map a&#39; (tensor a0 b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk11e"><span class="nb">intros</span> b c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_twist_map (a + a&#39;) (tensor b c) =
ab_tensor_prod_twist_map a (tensor b c) +
ab_tensor_prod_twist_map a&#39; (tensor b c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk11f"><span class="nb">change</span> (tensor b (tensor (a + a&#39;) c)
    = tensor b (tensor a c) + tensor b (tensor a&#39; c)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor b (tensor (a + a&#39;) c) =
tensor b (tensor a c) + tensor b (tensor a&#39; c)</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk120">rhs_V napply tensor_dist_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor b (tensor (a + a&#39;) c) =
tensor b (tensor a c + tensor a&#39; c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk121">napply (ap (tensor b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (a + a&#39;) c = tensor a c + tensor a&#39; c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a triple tensor product, we have a twist map which permutes the first two components. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk122"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_twist</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
  : ab_tensor_prod A (ab_tensor_prod B C) $-&gt; ab_tensor_prod B (ab_tensor_prod A C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A (ab_tensor_prod B C) $-&gt;
ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk123"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A (ab_tensor_prod B C) $-&gt;
ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk124">snapply ab_tensor_prod_rec&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_tensor_prod B C $-&gt;
ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk125" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk125"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : ab_tensor_prod B C),
<span class="nl">?f</span> (a + a&#39;) b = <span class="nl">?f</span> a b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk126">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_tensor_prod B C $-&gt;
ab_tensor_prod B (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ab_tensor_prod_twist_map.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk127">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : ab_tensor_prod B C),
ab_tensor_prod_twist_map (a + a&#39;) b =
ab_tensor_prod_twist_map a b +
ab_tensor_prod_twist_map a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ab_tensor_prod_twist_map_additive_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The twist map is involutive. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk128"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_twist_twist</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
  : ab_tensor_prod_twist $o @ab_tensor_prod_twist A B C $== Id _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_twist $o ab_tensor_prod_twist $==
Id (ab_tensor_prod A (ab_tensor_prod B C))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk129"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_twist $o ab_tensor_prod_twist $==
Id (ab_tensor_prod A (ab_tensor_prod B C))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk12a">snapply ab_tensor_prod_ind_homotopy_triple.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
(ab_tensor_prod_twist $o ab_tensor_prod_twist)
  (tensor a (tensor b c)) =
Id (ab_tensor_prod A (ab_tensor_prod B C))
  (tensor a (tensor b c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The twist map is natural in all 3 arguments. This means that the twist map acts on the triple tensor functor in the same way. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk12b"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_twist_natural</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">A&#39;</span> <span class="nv">B&#39;</span> <span class="nv">C&#39;</span> : AbGroup}
  (<span class="nv">f</span> : A $-&gt; A&#39;) (<span class="nv">g</span> : B $-&gt; B&#39;) (<span class="nv">h</span> : C $-&gt; C&#39;)
  : ab_tensor_prod_twist $o fmap11 ab_tensor_prod f (fmap11 ab_tensor_prod g h)
    $== fmap11 ab_tensor_prod g (fmap11 ab_tensor_prod f h) $o ab_tensor_prod_twist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; C&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_twist $o
fmap11 ab_tensor_prod f (fmap11 ab_tensor_prod g h) $==
fmap11 ab_tensor_prod g (fmap11 ab_tensor_prod f h) $o
ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk12c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; C&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_twist $o
fmap11 ab_tensor_prod f (fmap11 ab_tensor_prod g h) $==
fmap11 ab_tensor_prod g (fmap11 ab_tensor_prod f h) $o
ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk12d">snapply ab_tensor_prod_ind_homotopy_triple.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; C&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C),
(ab_tensor_prod_twist $o
 fmap11 ab_tensor_prod f (fmap11 ab_tensor_prod g h))
  (tensor a (tensor b c)) =
(fmap11 ab_tensor_prod g (fmap11 ab_tensor_prod f h) $o
 ab_tensor_prod_twist) (tensor a (tensor b c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk12e"><span class="nb">intros</span> a b c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; C&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ab_tensor_prod_twist $o
 fmap11 ab_tensor_prod f (fmap11 ab_tensor_prod g h))
  (tensor a (tensor b c)) =
(fmap11 ab_tensor_prod g (fmap11 ab_tensor_prod f h) $o
 ab_tensor_prod_twist) (tensor a (tensor b c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* This [change] speeds up the [reflexivity].  [simpl] produces a goal that looks the same, but is still slow. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk12f"><span class="nb">change</span> (tensor (g b) (tensor (f a) (h c)) = tensor (g b) (tensor (f a) (h c))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, A', B', C'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C $-&gt; C&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (g b) (tensor (f a) (h c)) =
tensor (g b) (tensor (f a) (h c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Unitality of [abgroup_Z] *)</span>

<span class="sd">(** In the symmetric monoidal structure on abelian groups, [abgroup_Z] is the unit. We show that tensoring with [abgroup_Z] on the right is isomorphic to the original group. *)</span>

<span class="sd">(** First we characterise the action of integers via [grp_pow] and their interaction on tensors. This is just a generalisation of the distributivity laws for tensors. *)</span>

<span class="sd">(** Multiplication in the first factor can be factored out. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tensor_ab_mul_l</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">z</span> : Int) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B)
  : tensor (ab_mul z a) b = ab_mul z (tensor a b)
  := ab_mul_natural (grp_homo_tensor_r b) z a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Multiplication in the second factor can be factored out. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tensor_ab_mul_r</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">z</span> : Int) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B)
  : tensor a (ab_mul z b) = ab_mul z (tensor a b)
  := ab_mul_natural (grp_homo_tensor_l a) z b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Multiplication can be transferred from one factor to the other. The tensor product of [R]-modules will include this as an extra axiom, but here we have [Z]-modules and we can prove it. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk130"><span class="kn">Definition</span> <span class="nf">tensor_ab_mul</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">z</span> : Int) (<span class="nv">a</span> : A) (<span class="nv">b</span> : B)
  : tensor (ab_mul z a) b = tensor a (ab_mul z b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (ab_mul z a) b = tensor a (ab_mul z b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk131"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (ab_mul z a) b = tensor a (ab_mul z b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk132">rhs napply tensor_ab_mul_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (ab_mul z a) b = ab_mul z (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply tensor_ab_mul_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [abgroup_Z] is a right identity for the tensor product. *)</span> 
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk133"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_Z_r</span> {<span class="nv">A</span>}
  : ab_tensor_prod A abgroup_Z $&lt;~&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A abgroup_Z $&lt;~&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk134"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A abgroup_Z $&lt;~&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Checking that the inverse map is a homomorphism is easier. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk135"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $&lt;~&gt; ab_tensor_prod A abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk136">snapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A (ab_tensor_prod A abgroup_Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk137" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk137"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk138">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A (ab_tensor_prod A abgroup_Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk139">napply grp_homo_tensor_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">1</span>%int.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk13a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (grp_homo_tensor_r <span class="mi">1</span>%int)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk13b">snapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A abgroup_Z -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk13c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk13c"><hr></label><div class="goal-conclusion">grp_homo_tensor_r <span class="mi">1</span>%int o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk13d"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o grp_homo_tensor_r <span class="mi">1</span>%int == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk13e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A abgroup_Z -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk13f">snapply ab_tensor_prod_rec&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; abgroup_Z $-&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk140" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk140"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : abgroup_Z),
<span class="nl">?f</span> (a + a&#39;) b = <span class="nl">?f</span> a b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk141">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; abgroup_Z $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_pow_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk142">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : abgroup_Z),
grp_pow_homo (a + a&#39;) b =
grp_pow_homo a b + grp_pow_homo a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk143"><span class="nb">intros</span> a a&#39; z; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow_homo (a + a&#39;) z =
grp_pow_homo a z + grp_pow_homo a&#39; z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">napply (grp_homo_op (ab_mul z)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk144">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_tensor_r <span class="mi">1</span>%int
o ab_tensor_prod_rec&#39; grp_pow_homo
    (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">z</span> : abgroup_Z) =&gt;
     grp_homo_op (ab_mul z) a a&#39;
     :
     grp_pow_homo (a + a&#39;) z =
     grp_pow_homo a z + grp_pow_homo a&#39; z) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk145"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ab_tensor_prod A abgroup_Z,
grp_homo_tensor_r <span class="mi">1</span>%int
  (ab_tensor_prod_rec&#39; grp_pow_homo
     (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">z</span> : abgroup_Z) =&gt;
      grp_homo_op (ab_mul z) a a&#39;) x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk146"><span class="nb">change</span> (<span class="kr">forall</span> <span class="nv">x</span> : <span class="nl">?A</span>, (grp_homo_map <span class="nl">?f</span>) ((grp_homo_map <span class="nl">?g</span>) x) = x)
        <span class="kr">with</span> (f $o g $== Id _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_tensor_r <span class="mi">1</span>%int $o
ab_tensor_prod_rec&#39; grp_pow_homo
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">z</span> : abgroup_Z) =&gt;
   grp_homo_op (ab_mul z) a a&#39;) $==
Id (ab_tensor_prod A abgroup_Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk147">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : abgroup_Z),
(grp_homo_tensor_r <span class="mi">1</span>%int $o
 ab_tensor_prod_rec&#39; grp_pow_homo
   (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : A) (<span class="nv">z</span> : abgroup_Z) =&gt;
    grp_homo_op (ab_mul z) a0 a&#39;)) (tensor a b) =
Id (ab_tensor_prod A abgroup_Z) (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk148"><span class="nb">intros</span> a z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(grp_homo_tensor_r <span class="mi">1</span>%int $o
 ab_tensor_prod_rec&#39; grp_pow_homo
   (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">z</span> : abgroup_Z) =&gt;
    grp_homo_op (ab_mul z) a a&#39;)) (tensor a z) =
Id (ab_tensor_prod A abgroup_Z) (tensor a z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk149"><span class="nb">change</span> (tensor (B:=abgroup_Z) (grp_pow a z) <span class="mi">1</span>%int = tensor a z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor (grp_pow a z) <span class="mi">1</span>%int = tensor a z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk14a">lhs napply tensor_ab_mul.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a (ab_mul z <span class="mi">1</span>%int) = tensor a z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk14b">napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_mul z <span class="mi">1</span>%int = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk14c">lhs napply abgroup_Z_ab_mul.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(z * <span class="mi">1</span>)%int = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> int_mul_1_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk14d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_rec&#39; grp_pow_homo
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">z</span> : abgroup_Z) =&gt;
   grp_homo_op (ab_mul z) a a&#39;
   :
   grp_pow_homo (a + a&#39;) z =
   grp_pow_homo a z + grp_pow_homo a&#39; z)
o grp_homo_tensor_r <span class="mi">1</span>%int == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We have a right unitor for the tensor product given by unit [abgroup_Z]. Naturality of [ab_tensor_prod_Z_r] is straightforward to prove. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk14e"><span class="kn">Instance</span> <span class="nf">rightunitor_ab_tensor_prod</span>
  : RightUnitor ab_tensor_prod abgroup_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">RightUnitor ab_tensor_prod abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk14f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">RightUnitor ab_tensor_prod abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk150">snapply Build_NatEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbGroup,
flip ab_tensor_prod abgroup_Z a $&lt;~&gt; idmap a</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (flip ab_tensor_prod abgroup_Z) idmap
  (<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt; <span class="nl">?e</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk151">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbGroup,
flip ab_tensor_prod abgroup_Z a $&lt;~&gt; idmap a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk152"><span class="nb">intros</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flip ab_tensor_prod abgroup_Z A $&lt;~&gt; idmap A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ab_tensor_prod_Z_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk153">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (flip ab_tensor_prod abgroup_Z) idmap
  (<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt;
   (<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk154">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : AbGroup) (<span class="nv">f</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a0))
  a&#39; $o fmap (flip ab_tensor_prod abgroup_Z) f $==
fmap idmap f $o
(<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a0))
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk155"><span class="nb">intros</span> A A&#39; f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a))
  A&#39; $o fmap (flip ab_tensor_prod abgroup_Z) f $==
fmap idmap f $o
(<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a))
  A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk156">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : abgroup_Z),
((<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup =&gt;
  cate_fun
    ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a0)) A&#39; $o
 fmap (flip ab_tensor_prod abgroup_Z) f) (tensor a b) =
(fmap idmap f $o
 (<span class="kr">fun</span> <span class="nv">a0</span> : AbGroup =&gt;
  cate_fun
    ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a0)) A)
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk157"><span class="nb">intros</span> a z; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap idmap f $o
 (<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt;
  cate_fun ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a))
   A) (tensor a z) =
((<span class="kr">fun</span> <span class="nv">a</span> : AbGroup =&gt;
  cate_fun ((<span class="kr">fun</span> <span class="nv">A</span> : AbGroup =&gt; ab_tensor_prod_Z_r) a))
   A&#39; $o fmap (flip ab_tensor_prod abgroup_Z) f)
  (tensor a z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_pow_natural _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Since we have symmetry of the tensor product, we get left unitality for free. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk158"><span class="kn">Instance</span> <span class="nf">left_unitor_ab_tensor_prod</span>
  : LeftUnitor ab_tensor_prod abgroup_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftUnitor ab_tensor_prod abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk159"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftUnitor ab_tensor_prod abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply left_unitor_twist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Symmetric Monoidal Structure of Tensor Product *)</span>

<span class="sd">(** Using the twist construction we can derive an associator for the tensor product. In other words, we have associativity of the tensor product of abelian groups natural in each factor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk15a"><span class="kn">Instance</span> <span class="nf">associator_ab_tensor_prod</span> : Associator ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Associator ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk15b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Associator ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk15c">srapply associator_twist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbGroup,
ab_tensor_prod a (ab_tensor_prod b c) $-&gt;
ab_tensor_prod b (ab_tensor_prod a c)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbGroup,
<span class="nl">?twist</span> a b c $o <span class="nl">?twist</span> b a c $==
Id (ab_tensor_prod b (ab_tensor_prod a c))</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> <span class="nv">b&#39;</span> <span class="nv">c</span> <span class="nv">c&#39;</span> : AbGroup) (<span class="nv">f</span> : a $-&gt; a&#39;)
(<span class="nv">g</span> : b $-&gt; b&#39;) (<span class="nv">h</span> : c $-&gt; c&#39;),
<span class="nl">?twist</span> a&#39; b&#39; c&#39; $o
fmap11 ab_tensor_prod f (fmap11 ab_tensor_prod g h) $==
fmap11 ab_tensor_prod g (fmap11 ab_tensor_prod f h) $o
<span class="nl">?twist</span> a b c</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk15d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbGroup,
ab_tensor_prod a (ab_tensor_prod b c) $-&gt;
ab_tensor_prod b (ab_tensor_prod a c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> @ab_tensor_prod_twist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk15e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbGroup,
ab_tensor_prod_twist $o ab_tensor_prod_twist $==
Id (ab_tensor_prod b (ab_tensor_prod a c))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; napply ab_tensor_prod_twist_twist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk15f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> <span class="nv">b&#39;</span> <span class="nv">c</span> <span class="nv">c&#39;</span> : AbGroup) (<span class="nv">f</span> : a $-&gt; a&#39;)
(<span class="nv">g</span> : b $-&gt; b&#39;) (<span class="nv">h</span> : c $-&gt; c&#39;),
ab_tensor_prod_twist $o
fmap11 ab_tensor_prod f (fmap11 ab_tensor_prod g h) $==
fmap11 ab_tensor_prod g (fmap11 ab_tensor_prod f h) $o
ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; napply ab_tensor_prod_twist_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The triangle identity is straightforward to prove using the custom induction principles we proved earlier. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk160"><span class="kn">Instance</span> <span class="nf">triangle_ab_tensor_prod</span>
  : TriangleIdentity ab_tensor_prod abgroup_Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TriangleIdentity ab_tensor_prod abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk161"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">TriangleIdentity ab_tensor_prod abgroup_Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk162">snapply triangle_twist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup,
fmap01 ab_tensor_prod a (rightunitor_ab_tensor_prod b) $==
symmetricbraiding_ab_tensor_prod b a $o
fmap01 ab_tensor_prod b (rightunitor_ab_tensor_prod a) $o
ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk163"><span class="nb">intros</span> A B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 ab_tensor_prod A (rightunitor_ab_tensor_prod B) $==
symmetricbraiding_ab_tensor_prod B A $o
fmap01 ab_tensor_prod B (rightunitor_ab_tensor_prod A) $o
ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk164">snapply ab_tensor_prod_ind_homotopy_triple.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : abgroup_Z),
fmap01 ab_tensor_prod A (rightunitor_ab_tensor_prod B)
  (tensor a (tensor b c)) =
(symmetricbraiding_ab_tensor_prod B A $o
 fmap01 ab_tensor_prod B
   (rightunitor_ab_tensor_prod A) $o
 ab_tensor_prod_twist) (tensor a (tensor b c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk165"><span class="nb">intros</span> a b z; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>abgroup_Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(symmetricbraiding_ab_tensor_prod B A $o
 fmap01 ab_tensor_prod B
   (rightunitor_ab_tensor_prod A) $o
 ab_tensor_prod_twist) (tensor a (tensor b z)) =
fmap01 ab_tensor_prod A (rightunitor_ab_tensor_prod B)
  (tensor a (tensor b z))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tensor_ab_mul z a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The hexagon identity is also straightforward to prove. We simply have to reduce all the involved functions on the simple tensors using our custom triple tensor induction principle. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk166"><span class="kn">Instance</span> <span class="nf">hexagon_ab_tensor_prod</span> : HexagonIdentity ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HexagonIdentity ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk167"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HexagonIdentity ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk168">snapply hexagon_twist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbGroup,
fmap01 ab_tensor_prod c
  (symmetricbraiding_ab_tensor_prod b a) $o
ab_tensor_prod_twist $o
fmap01 ab_tensor_prod b
  (symmetricbraiding_ab_tensor_prod a c) $==
ab_tensor_prod_twist $o
fmap01 ab_tensor_prod a
  (symmetricbraiding_ab_tensor_prod b c) $o
ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk169"><span class="nb">intros</span> A B C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 ab_tensor_prod C
  (symmetricbraiding_ab_tensor_prod B A) $o
ab_tensor_prod_twist $o
fmap01 ab_tensor_prod B
  (symmetricbraiding_ab_tensor_prod A C) $==
ab_tensor_prod_twist $o
fmap01 ab_tensor_prod A
  (symmetricbraiding_ab_tensor_prod B C) $o
ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk16a">snapply ab_tensor_prod_ind_homotopy_triple.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A) (<span class="nv">c</span> : C),
(fmap01 ab_tensor_prod C
   (symmetricbraiding_ab_tensor_prod B A) $o
 ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod B
   (symmetricbraiding_ab_tensor_prod A C))
  (tensor a (tensor b c)) =
(ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod A
   (symmetricbraiding_ab_tensor_prod B C) $o
 ab_tensor_prod_twist) (tensor a (tensor b c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk16b"><span class="nb">intros</span> b a c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap01 ab_tensor_prod C
   (symmetricbraiding_ab_tensor_prod B A) $o
 ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod B
   (symmetricbraiding_ab_tensor_prod A C))
  (tensor b (tensor a c)) =
(ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod A
   (symmetricbraiding_ab_tensor_prod B C) $o
 ab_tensor_prod_twist) (tensor b (tensor a c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk16c"><span class="nb">change</span> (tensor c (tensor a b) = tensor c (tensor a b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor c (tensor a b) = tensor c (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finally, we can prove the pentagon identity using the quadruple tensor induction principle. As we did before, the work only involves reducing the involved functions on the simple tensor redexes. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk16d"><span class="kn">Instance</span> <span class="nf">pentagon_ab_tensor_prod</span> : PentagonIdentity ab_tensor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">PentagonIdentity ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk16e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">PentagonIdentity ab_tensor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk16f">snapply pentagon_twist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : AbGroup,
fmap01 ab_tensor_prod c
  (symmetricbraiding_ab_tensor_prod
     (ab_tensor_prod a b) d) $o ab_tensor_prod_twist $o
symmetricbraiding_ab_tensor_prod (ab_tensor_prod c d)
  (ab_tensor_prod a b) $o ab_tensor_prod_twist $o
fmap01 ab_tensor_prod a
  (symmetricbraiding_ab_tensor_prod b
     (ab_tensor_prod c d)) $==
fmap01 ab_tensor_prod c ab_tensor_prod_twist $o
fmap01 ab_tensor_prod c
  (fmap01 ab_tensor_prod a
     (symmetricbraiding_ab_tensor_prod b d)) $o
ab_tensor_prod_twist $o
fmap01 ab_tensor_prod a ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk170"><span class="nb">intros</span> A B C D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 ab_tensor_prod C
  (symmetricbraiding_ab_tensor_prod
     (ab_tensor_prod A B) D) $o ab_tensor_prod_twist $o
symmetricbraiding_ab_tensor_prod (ab_tensor_prod C D)
  (ab_tensor_prod A B) $o ab_tensor_prod_twist $o
fmap01 ab_tensor_prod A
  (symmetricbraiding_ab_tensor_prod B
     (ab_tensor_prod C D)) $==
fmap01 ab_tensor_prod C ab_tensor_prod_twist $o
fmap01 ab_tensor_prod C
  (fmap01 ab_tensor_prod A
     (symmetricbraiding_ab_tensor_prod B D)) $o
ab_tensor_prod_twist $o
fmap01 ab_tensor_prod A ab_tensor_prod_twist</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk171">snapply ab_tensor_prod_ind_homotopy_quad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">d</span> : D),
(fmap01 ab_tensor_prod C
   (symmetricbraiding_ab_tensor_prod
      (ab_tensor_prod A B) D) $o ab_tensor_prod_twist $o
 symmetricbraiding_ab_tensor_prod (ab_tensor_prod C D)
   (ab_tensor_prod A B) $o ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod A
   (symmetricbraiding_ab_tensor_prod B
      (ab_tensor_prod C D)))
  (tensor a (tensor b (tensor c d))) =
(fmap01 ab_tensor_prod C ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod C
   (fmap01 ab_tensor_prod A
      (symmetricbraiding_ab_tensor_prod B D)) $o
 ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod A ab_tensor_prod_twist)
  (tensor a (tensor b (tensor c d)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk172"><span class="nb">intros</span> a b c d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap01 ab_tensor_prod C
   (symmetricbraiding_ab_tensor_prod
      (ab_tensor_prod A B) D) $o ab_tensor_prod_twist $o
 symmetricbraiding_ab_tensor_prod (ab_tensor_prod C D)
   (ab_tensor_prod A B) $o ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod A
   (symmetricbraiding_ab_tensor_prod B
      (ab_tensor_prod C D)))
  (tensor a (tensor b (tensor c d))) =
(fmap01 ab_tensor_prod C ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod C
   (fmap01 ab_tensor_prod A
      (symmetricbraiding_ab_tensor_prod B D)) $o
 ab_tensor_prod_twist $o
 fmap01 ab_tensor_prod A ab_tensor_prod_twist)
  (tensor a (tensor b (tensor c d)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk173"><span class="nb">change</span> (tensor c (tensor d (tensor a b)) = tensor c (tensor d (tensor a b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor c (tensor d (tensor a b)) =
tensor c (tensor d (tensor a b))</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We therefore have all the data of a monoidal category. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ismonoidal_ab_tensor_prod</span>
  : IsMonoidal AbGroup ab_tensor_prod abgroup_Z
  := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And furthermore, all the data of a symmetric monoidal category. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">issymmmetricmonoidal_ab_tensor_prod</span>
  : IsSymmetricMonoidal AbGroup ab_tensor_prod abgroup_Z
  := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Preservation of Coequalizers *)</span>

<span class="sd">(** The tensor product of abelian groups preserves coequalizers, meaning that the coequalizer of two tensored groups is the tensor of the coequalizer. We show this is the case on the left and the right. *)</span>

<span class="sd">(** Tensor products preserve coequalizers on the right. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk174"><span class="kn">Definition</span> <span class="nf">grp_iso_ab_tensor_prod_coeq_l</span> <span class="nv">A</span> {<span class="nv">B</span> <span class="nv">C</span> : AbGroup} (<span class="nv">f</span> <span class="nv">g</span> : B $-&gt; C)
  : ab_coeq (fmap01 ab_tensor_prod A f) (fmap01 ab_tensor_prod A g)
    $&lt;~&gt; ab_tensor_prod A (ab_coeq f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g) $&lt;~&gt;
ab_tensor_prod A (ab_coeq f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk175"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g) $&lt;~&gt;
ab_tensor_prod A (ab_coeq f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk176">snapply cate_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g) $-&gt;
ab_tensor_prod A (ab_coeq f g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk177" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk177"><hr></label><div class="goal-conclusion">ab_tensor_prod A (ab_coeq f g) $-&gt;
ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g)</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk178" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk178"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> $o <span class="nl">?g</span> $== Id (ab_tensor_prod A (ab_coeq f g))</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk179" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk179"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> $o <span class="nl">?f</span> $==
Id
  (ab_coeq (fmap01 ab_tensor_prod A f)
     (fmap01 ab_tensor_prod A g))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk17a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g) $-&gt;
ab_tensor_prod A (ab_coeq f g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk17b">snapply ab_coeq_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A C $-&gt; ab_tensor_prod A (ab_coeq f g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk17c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk17c"><hr></label><div class="goal-conclusion"><span class="nl">?i</span> $o fmap01 ab_tensor_prod A f $==
<span class="nl">?i</span> $o fmap01 ab_tensor_prod A g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk17d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A C $-&gt; ab_tensor_prod A (ab_coeq f g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk17e">rapply (fmap01 ab_tensor_prod A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C $-&gt; ab_coeq f g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply ab_coeq_in.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk17f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 ab_tensor_prod A ab_coeq_in $o
fmap01 ab_tensor_prod A f $==
fmap01 ab_tensor_prod A ab_coeq_in $o
fmap01 ab_tensor_prod A g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk180"><span class="nb">refine</span> (_^$ $@ fmap02 ab_tensor_prod _ _ $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 ab_tensor_prod A <span class="nl">?Goal0</span> $-&gt;
fmap01 ab_tensor_prod A ab_coeq_in $o
fmap01 ab_tensor_prod A f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk181" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk181"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> $== <span class="nl">?Goal1</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk182" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk182"><hr></label><div class="goal-conclusion">fmap01 ab_tensor_prod A <span class="nl">?Goal1</span> $==
fmap01 ab_tensor_prod A ab_coeq_in $o
fmap01 ab_tensor_prod A g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk183"><span class="mi">1</span>,<span class="mi">3</span>: tapply fmap01_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq_in $o f $== ab_coeq_in $o g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply ab_coeq_glue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk184">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A (ab_coeq f g) $-&gt;
ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk185">snapply ab_tensor_prod_rec&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_coeq f g $-&gt;
ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk186" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk186"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : ab_coeq f g),
<span class="nl">?f</span> (a + a&#39;) b = <span class="nl">?f</span> a b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk187">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_coeq f g $-&gt;
ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk188"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq f g $-&gt;
ab_coeq (fmap01 ab_tensor_prod A f)
  (fmap01 ab_tensor_prod A g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk189">snapply functor_ab_coeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B $-&gt; ab_tensor_prod A B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk18a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk18a"><hr></label><div class="goal-conclusion">C $-&gt; ab_tensor_prod A C</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk18b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk18b"><hr></label><div class="goal-conclusion">fmap01 ab_tensor_prod A f $o <span class="nl">?a</span> $== <span class="nl">?b</span> $o f</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk18c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk18c"><hr></label><div class="goal-conclusion">fmap01 ab_tensor_prod A g $o <span class="nl">?a</span> $== <span class="nl">?b</span> $o g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk18d"><span class="mi">1</span>,<span class="mi">2</span>: snapply (grp_homo_tensor_l a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 ab_tensor_prod A f $o grp_homo_tensor_l a $==
grp_homo_tensor_l a $o f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk18e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk18e"><hr></label><div class="goal-conclusion">fmap01 ab_tensor_prod A g $o grp_homo_tensor_l a $==
grp_homo_tensor_l a $o g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">hnf</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk18f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : ab_coeq f g),
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
 functor_ab_coeq (grp_homo_tensor_l a0)
   (grp_homo_tensor_l a0)
   ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
    :
    fmap01 ab_tensor_prod A f $o grp_homo_tensor_l a0 $==
    grp_homo_tensor_l a0 $o f)
   ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
    :
    fmap01 ab_tensor_prod A g $o grp_homo_tensor_l a0 $==
    grp_homo_tensor_l a0 $o g)) (a + a&#39;) b =
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
 functor_ab_coeq (grp_homo_tensor_l a0)
   (grp_homo_tensor_l a0)
   ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
    :
    fmap01 ab_tensor_prod A f $o grp_homo_tensor_l a0 $==
    grp_homo_tensor_l a0 $o f)
   ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
    :
    fmap01 ab_tensor_prod A g $o grp_homo_tensor_l a0 $==
    grp_homo_tensor_l a0 $o g)) a b +
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
 functor_ab_coeq (grp_homo_tensor_l a0)
   (grp_homo_tensor_l a0)
   ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
    :
    fmap01 ab_tensor_prod A f $o grp_homo_tensor_l a0 $==
    grp_homo_tensor_l a0 $o f)
   ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
    :
    fmap01 ab_tensor_prod A g $o grp_homo_tensor_l a0 $==
    grp_homo_tensor_l a0 $o g)) a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk190"><span class="nb">intros</span> a a&#39;; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ab_coeq f g,
functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
  (grp_homo_tensor_l (a + a&#39;)) (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>) b =
functor_ab_coeq (grp_homo_tensor_l a)
  (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>) b +
functor_ab_coeq (grp_homo_tensor_l a&#39;)
  (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk191">srapply ab_coeq_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : C,
(<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
 functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
   (grp_homo_tensor_l (a + a&#39;)) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
 functor_ab_coeq (grp_homo_tensor_l a)
   (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
 functor_ab_coeq (grp_homo_tensor_l a&#39;)
   (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x) (ab_coeq_in b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk192"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
 functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
   (grp_homo_tensor_l (a + a&#39;)) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
 functor_ab_coeq (grp_homo_tensor_l a)
   (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
 functor_ab_coeq (grp_homo_tensor_l a&#39;)
   (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x) (ab_coeq_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (ab_coeq_in
        (f:=fmap01 ab_tensor_prod A f)
        (g:=fmap01 ab_tensor_prod A g))
        (tensor_dist_r a a&#39; x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk193">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
  (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
    fmap02 ab_tensor_prod A ab_coeq_glue) $@
   fmap01_comp ab_tensor_prod A ab_coeq_in g) $o
ab_tensor_prod_rec&#39;
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   functor_ab_coeq (grp_homo_tensor_l a)
     (grp_homo_tensor_l a)
     ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
      :
      fmap01 ab_tensor_prod A f $o grp_homo_tensor_l a $==
      grp_homo_tensor_l a $o f)
     ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
      :
      fmap01 ab_tensor_prod A g $o grp_homo_tensor_l a $==
      grp_homo_tensor_l a $o g))
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">a&#39;</span> : A =&gt;
   ab_coeq_ind_hprop
     (<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
      functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
        (grp_homo_tensor_l (a + a&#39;)) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
      functor_ab_coeq (grp_homo_tensor_l a)
        (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
      functor_ab_coeq (grp_homo_tensor_l a&#39;)
        (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x)
     (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt;
      ap ab_coeq_in (tensor_dist_r a a&#39; x))
   :
   <span class="kr">forall</span> <span class="nv">b</span> : ab_coeq f g,
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) (a + a&#39;) b =
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) a b +
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) a&#39; b) $==
Id (ab_tensor_prod A (ab_coeq f g))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk194">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : ab_coeq f g),
(ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
   (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
     fmap02 ab_tensor_prod A ab_coeq_glue) $@
    fmap01_comp ab_tensor_prod A ab_coeq_in g) $o
 ab_tensor_prod_rec&#39;
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g))
   (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">a&#39;</span> : A =&gt;
    ab_coeq_ind_hprop
      (<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
       functor_ab_coeq (grp_homo_tensor_l (a0 + a&#39;))
         (grp_homo_tensor_l (a0 + a&#39;))
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
       functor_ab_coeq (grp_homo_tensor_l a0)
         (grp_homo_tensor_l a0) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
       functor_ab_coeq (grp_homo_tensor_l a&#39;)
         (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x)
      (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt;
       ap ab_coeq_in (tensor_dist_r a0 a&#39; x))
    :
    <span class="kr">forall</span> <span class="nv">b0</span> : ab_coeq f g,
    (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a1)
       (grp_homo_tensor_l a1)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o g)) (a0 + a&#39;) b0 =
    (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a1)
       (grp_homo_tensor_l a1)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o g)) a0 b0 +
    (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a1)
       (grp_homo_tensor_l a1)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o g)) a&#39; b0))
  (tensor a b) =
Id (ab_tensor_prod A (ab_coeq f g)) (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk195"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ab_coeq f g,
(ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
   (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
     fmap02 ab_tensor_prod A ab_coeq_glue) $@
    fmap01_comp ab_tensor_prod A ab_coeq_in g) $o
 ab_tensor_prod_rec&#39;
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a)
      (grp_homo_tensor_l a)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a $==
       grp_homo_tensor_l a $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a $==
       grp_homo_tensor_l a $o g))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">a&#39;</span> : A =&gt;
    ab_coeq_ind_hprop
      (<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
       functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
         (grp_homo_tensor_l (a + a&#39;))
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
       functor_ab_coeq (grp_homo_tensor_l a)
         (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
       functor_ab_coeq (grp_homo_tensor_l a&#39;)
         (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x)
      (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt;
       ap ab_coeq_in (tensor_dist_r a a&#39; x))
    :
    <span class="kr">forall</span> <span class="nv">b0</span> : ab_coeq f g,
    (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a0)
       (grp_homo_tensor_l a0)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a0 $==
        grp_homo_tensor_l a0 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a0 $==
        grp_homo_tensor_l a0 $o g)) (a + a&#39;) b0 =
    (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a0)
       (grp_homo_tensor_l a0)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a0 $==
        grp_homo_tensor_l a0 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a0 $==
        grp_homo_tensor_l a0 $o g)) a b0 +
    (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a0)
       (grp_homo_tensor_l a0)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a0 $==
        grp_homo_tensor_l a0 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a0 $==
        grp_homo_tensor_l a0 $o g)) a&#39; b0))
  (tensor a b) =
Id (ab_tensor_prod A (ab_coeq f g)) (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk196">srapply ab_coeq_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : C,
(<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
 (ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
    (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
      fmap02 ab_tensor_prod A ab_coeq_glue) $@
     fmap01_comp ab_tensor_prod A ab_coeq_in g) $o
  ab_tensor_prod_rec&#39;
    (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a)
       (grp_homo_tensor_l a)
       ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a $==
        grp_homo_tensor_l a $o f)
       ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a $==
        grp_homo_tensor_l a $o g))
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">a&#39;</span> : A =&gt;
     ab_coeq_ind_hprop
       (<span class="kr">fun</span> <span class="nv">x0</span> : ab_coeq f g =&gt;
        functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
          (grp_homo_tensor_l (a + a&#39;))
          (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) x0 =
        functor_ab_coeq (grp_homo_tensor_l a)
          (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>)
          (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) x0 +
        functor_ab_coeq (grp_homo_tensor_l a&#39;)
          (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>)
          (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) x0)
       (<span class="kr">fun</span> <span class="nv">x0</span> : C =&gt;
        ap ab_coeq_in (tensor_dist_r a a&#39; x0))
     :
     <span class="kr">forall</span> <span class="nv">b0</span> : ab_coeq f g,
     (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
      functor_ab_coeq (grp_homo_tensor_l a0)
        (grp_homo_tensor_l a0)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A f $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o f)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A g $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o g)) (a + a&#39;) b0 =
     (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
      functor_ab_coeq (grp_homo_tensor_l a0)
        (grp_homo_tensor_l a0)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A f $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o f)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A g $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o g)) a b0 +
     (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
      functor_ab_coeq (grp_homo_tensor_l a0)
        (grp_homo_tensor_l a0)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A f $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o f)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A g $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o g)) a&#39; b0))
   (tensor a x) =
 Id (ab_tensor_prod A (ab_coeq f g)) (tensor a x))
  (ab_coeq_in b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk197"><span class="nb">intros</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
 (ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
    (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
      fmap02 ab_tensor_prod A ab_coeq_glue) $@
     fmap01_comp ab_tensor_prod A ab_coeq_in g) $o
  ab_tensor_prod_rec&#39;
    (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a)
       (grp_homo_tensor_l a)
       ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a $==
        grp_homo_tensor_l a $o f)
       ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a $==
        grp_homo_tensor_l a $o g))
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">a&#39;</span> : A =&gt;
     ab_coeq_ind_hprop
       (<span class="kr">fun</span> <span class="nv">x0</span> : ab_coeq f g =&gt;
        functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
          (grp_homo_tensor_l (a + a&#39;))
          (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) x0 =
        functor_ab_coeq (grp_homo_tensor_l a)
          (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>)
          (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) x0 +
        functor_ab_coeq (grp_homo_tensor_l a&#39;)
          (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>)
          (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt; <span class="mi">1</span>) x0)
       (<span class="kr">fun</span> <span class="nv">x0</span> : C =&gt;
        ap ab_coeq_in (tensor_dist_r a a&#39; x0))
     :
     <span class="kr">forall</span> <span class="nv">b</span> : ab_coeq f g,
     (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
      functor_ab_coeq (grp_homo_tensor_l a0)
        (grp_homo_tensor_l a0)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A f $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o f)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A g $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o g)) (a + a&#39;) b =
     (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
      functor_ab_coeq (grp_homo_tensor_l a0)
        (grp_homo_tensor_l a0)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A f $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o f)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A g $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o g)) a b +
     (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
      functor_ab_coeq (grp_homo_tensor_l a0)
        (grp_homo_tensor_l a0)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A f $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o f)
        ((<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         :
         fmap01 ab_tensor_prod A g $o
         grp_homo_tensor_l a0 $==
         grp_homo_tensor_l a0 $o g)) a&#39; b))
   (tensor a x) =
 Id (ab_tensor_prod A (ab_coeq f g)) (tensor a x))
  (ab_coeq_in c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk198">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_rec&#39;
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   functor_ab_coeq (grp_homo_tensor_l a)
     (grp_homo_tensor_l a)
     ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
      :
      fmap01 ab_tensor_prod A f $o grp_homo_tensor_l a $==
      grp_homo_tensor_l a $o f)
     ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
      :
      fmap01 ab_tensor_prod A g $o grp_homo_tensor_l a $==
      grp_homo_tensor_l a $o g))
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">a&#39;</span> : A =&gt;
   ab_coeq_ind_hprop
     (<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
      functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
        (grp_homo_tensor_l (a + a&#39;)) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
      functor_ab_coeq (grp_homo_tensor_l a)
        (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
      functor_ab_coeq (grp_homo_tensor_l a&#39;)
        (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x)
     (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt;
      ap ab_coeq_in (tensor_dist_r a a&#39; x))
   :
   <span class="kr">forall</span> <span class="nv">b</span> : ab_coeq f g,
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) (a + a&#39;) b =
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) a b +
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) a&#39; b) $o
ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
  (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
    fmap02 ab_tensor_prod A ab_coeq_glue) $@
   fmap01_comp ab_tensor_prod A ab_coeq_in g) $==
Id
  (ab_coeq (fmap01 ab_tensor_prod A f)
     (fmap01 ab_tensor_prod A g))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk199">snapply ab_coeq_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod_rec&#39;
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   functor_ab_coeq (grp_homo_tensor_l a)
     (grp_homo_tensor_l a)
     ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
      :
      fmap01 ab_tensor_prod A f $o grp_homo_tensor_l a $==
      grp_homo_tensor_l a $o f)
     ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
      :
      fmap01 ab_tensor_prod A g $o grp_homo_tensor_l a $==
      grp_homo_tensor_l a $o g))
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">a&#39;</span> : A =&gt;
   ab_coeq_ind_hprop
     (<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
      functor_ab_coeq (grp_homo_tensor_l (a + a&#39;))
        (grp_homo_tensor_l (a + a&#39;)) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
      functor_ab_coeq (grp_homo_tensor_l a)
        (grp_homo_tensor_l a) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
      functor_ab_coeq (grp_homo_tensor_l a&#39;)
        (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x)
     (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt;
      ap ab_coeq_in (tensor_dist_r a a&#39; x))
   :
   <span class="kr">forall</span> <span class="nv">b</span> : ab_coeq f g,
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) (a + a&#39;) b =
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) a b +
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g)) a&#39; b) $o
ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
  (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
    fmap02 ab_tensor_prod A ab_coeq_glue) $@
   fmap01_comp ab_tensor_prod A ab_coeq_in g) $o
ab_coeq_in $==
Id
  (ab_coeq (fmap01 ab_tensor_prod A f)
     (fmap01 ab_tensor_prod A g)) $o ab_coeq_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk19a">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : C),
(ab_tensor_prod_rec&#39;
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    functor_ab_coeq (grp_homo_tensor_l a0)
      (grp_homo_tensor_l a0)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A f $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o f)
      ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
       :
       fmap01 ab_tensor_prod A g $o
       grp_homo_tensor_l a0 $==
       grp_homo_tensor_l a0 $o g))
   (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">a&#39;</span> : A =&gt;
    ab_coeq_ind_hprop
      (<span class="kr">fun</span> <span class="nv">x</span> : ab_coeq f g =&gt;
       functor_ab_coeq (grp_homo_tensor_l (a0 + a&#39;))
         (grp_homo_tensor_l (a0 + a&#39;))
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x =
       functor_ab_coeq (grp_homo_tensor_l a0)
         (grp_homo_tensor_l a0) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x +
       functor_ab_coeq (grp_homo_tensor_l a&#39;)
         (grp_homo_tensor_l a&#39;) (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; <span class="mi">1</span>) x)
      (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt;
       ap ab_coeq_in (tensor_dist_r a0 a&#39; x))
    :
    <span class="kr">forall</span> <span class="nv">b0</span> : ab_coeq f g,
    (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a1)
       (grp_homo_tensor_l a1)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o g)) (a0 + a&#39;) b0 =
    (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a1)
       (grp_homo_tensor_l a1)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o g)) a0 b0 +
    (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt;
     functor_ab_coeq (grp_homo_tensor_l a1)
       (grp_homo_tensor_l a1)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A f $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o f)
       ((<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; <span class="mi">1</span>)
        :
        fmap01 ab_tensor_prod A g $o
        grp_homo_tensor_l a1 $==
        grp_homo_tensor_l a1 $o g)) a&#39; b0) $o
 ab_coeq_rec (fmap01 ab_tensor_prod A ab_coeq_in)
   (((fmap01_comp ab_tensor_prod A ab_coeq_in f)^$ $@
     fmap02 ab_tensor_prod A ab_coeq_glue) $@
    fmap01_comp ab_tensor_prod A ab_coeq_in g) $o
 ab_coeq_in) (tensor a b) =
(Id
   (ab_coeq (fmap01 ab_tensor_prod A f)
      (fmap01 ab_tensor_prod A g)) $o ab_coeq_in)
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The equivalence respects the natural maps from [ab_tensor_prod A C]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk19b"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_coeq_l_triangle</span> <span class="nv">A</span> {<span class="nv">B</span> <span class="nv">C</span> : AbGroup} (<span class="nv">f</span> <span class="nv">g</span> : B $-&gt; C)
  : grp_iso_ab_tensor_prod_coeq_l A f g $o ab_coeq_in
    $== fmap01 ab_tensor_prod A ab_coeq_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_ab_tensor_prod_coeq_l A f g $o ab_coeq_in $==
fmap01 ab_tensor_prod A ab_coeq_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk19c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_ab_tensor_prod_coeq_l A f g $o ab_coeq_in $==
fmap01 ab_tensor_prod A ab_coeq_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk19d">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : C),
(grp_iso_ab_tensor_prod_coeq_l A f g $o ab_coeq_in)
  (tensor a b) =
fmap01 ab_tensor_prod A ab_coeq_in (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Tensor products preserve coequalizers on the left. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk19e"><span class="kn">Definition</span> <span class="nf">grp_iso_ab_tensor_prod_coeq_r</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> <span class="nv">g</span> : A $-&gt; B) <span class="nv">C</span>
  : ab_coeq (fmap10 ab_tensor_prod f C) (fmap10 ab_tensor_prod g C)
    $&lt;~&gt; ab_tensor_prod (ab_coeq f g) C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap10 ab_tensor_prod f C)
  (fmap10 ab_tensor_prod g C) $&lt;~&gt;
ab_tensor_prod (ab_coeq f g) C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk19f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap10 ab_tensor_prod f C)
  (fmap10 ab_tensor_prod g C) $&lt;~&gt;
ab_tensor_prod (ab_coeq f g) C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1a0"><span class="nb">refine</span> (braide _ _ $oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap10 ab_tensor_prod f C)
  (fmap10 ab_tensor_prod g C) $&lt;~&gt;
ab_tensor_prod C (ab_coeq f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1a1">nrefine (grp_iso_ab_tensor_prod_coeq_l _ f g $oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_coeq (fmap10 ab_tensor_prod f C)
  (fmap10 ab_tensor_prod g C) $&lt;~&gt;
ab_coeq (fmap01 ab_tensor_prod C f)
  (fmap01 ab_tensor_prod C g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1a2">snapply grp_iso_ab_coeq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A C $&lt;~&gt; ab_tensor_prod C A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1a3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1a3"><hr></label><div class="goal-conclusion">ab_tensor_prod B C $&lt;~&gt; ab_tensor_prod C B</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1a4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1a4"><hr></label><div class="goal-conclusion">fmap01 ab_tensor_prod C f $o <span class="nl">?a</span> $==
<span class="nl">?b</span> $o fmap10 ab_tensor_prod f C</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1a5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1a5"><hr></label><div class="goal-conclusion">fmap01 ab_tensor_prod C g $o <span class="nl">?a</span> $==
<span class="nl">?b</span> $o fmap10 ab_tensor_prod g C</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1a6"><span class="mi">1</span>,<span class="mi">2</span>: rapply braide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap01 ab_tensor_prod C f $o braide A C $==
braide B C $o fmap10 ab_tensor_prod f C</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1a7"><hr></label><div class="goal-conclusion">fmap01 ab_tensor_prod C g $o braide A C $==
braide B C $o fmap10 ab_tensor_prod g C</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">symmetry</span>; napply ab_tensor_swap_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The equivalence respects the natural maps from [ab_tensor_prod B C]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1a8"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_coeq_r_triangle</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> <span class="nv">g</span> : A $-&gt; B) <span class="nv">C</span>
  : grp_iso_ab_tensor_prod_coeq_r f g C $o ab_coeq_in
    $== fmap10 ab_tensor_prod ab_coeq_in C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_ab_tensor_prod_coeq_r f g C $o ab_coeq_in $==
fmap10 ab_tensor_prod ab_coeq_in C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1a9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_ab_tensor_prod_coeq_r f g C $o ab_coeq_in $==
fmap10 ab_tensor_prod ab_coeq_in C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1aa">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : C),
(grp_iso_ab_tensor_prod_coeq_r f g C $o ab_coeq_in)
  (tensor a b) =
fmap10 ab_tensor_prod ab_coeq_in C (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Tensor Product of Free Abelian Groups *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ab"><span class="kn">Definition</span> <span class="nf">equiv_ab_tensor_prod_freeabgroup</span> <span class="nv">X</span> <span class="nv">Y</span>
  : FreeAbGroup (X * Y) $&lt;~&gt; ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (X * Y) $&lt;~&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (X * Y) $&lt;~&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ad">srefine (<span class="kr">let</span> <span class="nv">f</span>:=_ <span class="kr">in</span> <span class="kr">let</span> <span class="nv">g</span>:=_ <span class="kr">in</span> cate_adjointify f g _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1ae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1ae"><hr></label><div class="goal-conclusion">ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1af" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal0</span></span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1af"><hr></label><div class="goal-conclusion">f $o g $==
Id (ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y))</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal0</span></span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1b0"><hr></label><div class="goal-conclusion">g $o f $== Id (FreeAbGroup (X * Y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b2">snapply FreeAbGroup_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X * Y -&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b3"><span class="nb">intros</span> [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tensor (freeabgroup_in x) (freeabgroup_in y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b5">snapply ab_tensor_prod_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup X -&gt; FreeAbGroup Y -&gt; FreeAbGroup (X * Y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1b6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1b6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : FreeAbGroup X) (<span class="nv">b</span> <span class="nv">b&#39;</span> : FreeAbGroup Y),
<span class="nl">?f</span> a (b + b&#39;) = <span class="nl">?f</span> a b + <span class="nl">?f</span> a b&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1b7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1b7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : FreeAbGroup X) (<span class="nv">b</span> : FreeAbGroup Y),
<span class="nl">?f</span> (a + a&#39;) b = <span class="nl">?f</span> a b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup X -&gt; FreeAbGroup Y -&gt; FreeAbGroup (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1b9"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup Y -&gt; FreeAbGroup (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ba">snapply FreeAbGroup_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; FreeAbGroup (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1bb"><span class="nb">intros</span> y; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup X -&gt; FreeAbGroup (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1bc"><span class="nb">unfold</span> FreeAbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel (FreeGroup X) -&gt; abel (FreeGroup (X * Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1bd">snapply FreeAbGroup_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; abel (FreeGroup (X * Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1be"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abel (FreeGroup (X * Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1bf"><span class="nb">apply</span> abel_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeGroup (X * Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c0"><span class="nb">apply</span> freegroup_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X * Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (x, y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : FreeAbGroup X) (<span class="nv">b</span> <span class="nv">b&#39;</span> : FreeAbGroup Y),
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) a
  (b + b&#39;) =
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) a b +
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) a
  b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c2"><span class="nb">intros</span> x y y&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) x
  (y + y&#39;) =
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) x y +
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) x
  y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">snapply grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : FreeAbGroup X) (<span class="nv">b</span> : FreeAbGroup Y),
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x)))
  (a + a&#39;) b =
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) a b +
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) a&#39;
  b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c4"><span class="nb">intros</span> x x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : FreeAbGroup Y,
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x)))
  (x + x&#39;) b =
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) x b +
(<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
 grp_homo_map
   (FreeAbGroup_rec
      (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
       (FreeAbGroup_rec
          (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
           <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
           X0 (freegroup_in (x0, y)))
        :
        FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))) x&#39;
  b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c5">rapply Abel_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : FreeGroup Y,
FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
      <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
      X0 (freegroup_in (x, y))) (x + x&#39;)) (abel_in x0) =
FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
      <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
      X0 (freegroup_in (x, y))) x) (abel_in x0) +
FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
      <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
      X0 (freegroup_in (x, y))) x&#39;) (abel_in x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c6">snapply (FreeGroup_ind_homotopy _ (f&#39; := sgop_hom _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : Y,
FreeGroup_rec
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
      <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
      X0 (freegroup_in (x, y))) (x + x&#39;))
  (freegroup_in x0) =
sgop_hom
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x))
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x&#39;))
  (freegroup_in x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c7"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeGroup_rec
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
      <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
      X0 (freegroup_in (x, y))) (x + x&#39;))
  (freegroup_in y) =
sgop_hom
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x))
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x&#39;))
  (freegroup_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c8">lhs napply FreeGroup_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
   X0 (freegroup_in (x, y))) (x + x&#39;) =
sgop_hom
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x))
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x&#39;))
  (freegroup_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1c9">lhs napply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
   X0 (freegroup_in (x, y))) x +
FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
   X0 (freegroup_in (x, y))) x&#39; =
sgop_hom
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x))
  (FreeGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
         <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
         X0 (freegroup_in (x, y))) x&#39;))
  (freegroup_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ca">snapply (ap011 (+) _^ _^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_id
  (fst
     (grp_prod_corec
        (FreeGroup_rec
           (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x, y))) x))
        (FreeGroup_rec
           (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x, y))) x&#39;))
        (freegroup_in y))) =
FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
   X0 (freegroup_in (x, y))) x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1cb"><hr></label><div class="goal-conclusion">grp_homo_id
  (snd
     (grp_prod_corec
        (FreeGroup_rec
           (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x, y))) x))
        (FreeGroup_rec
           (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x, y))) x&#39;))
        (freegroup_in y))) =
FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
   X0 (freegroup_in (x, y))) x&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: napply FreeGroup_rec_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1cc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $==
Id (ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1cd">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : FreeAbGroup X) (<span class="nv">b</span> : FreeAbGroup Y),
(f $o g) (tensor a b) =
Id (ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y))
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ce"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : FreeAbGroup Y,
(f $o g) (tensor x b) =
Id (ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y))
  (tensor x b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1cf"><span class="nb">change</span> (f $o g $o grp_homo_tensor_l x $== grp_homo_tensor_l x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $o grp_homo_tensor_l x $== grp_homo_tensor_l x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d0">rapply Abel_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : FreeGroup Y,
(f $o g $o grp_homo_tensor_l x) (abel_in x0) =
grp_homo_tensor_l x (abel_in x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d1"><span class="nb">change</span> (@abel_in <span class="nl">?G</span>) <span class="kr">with</span> (grp_homo_map (@abel_unit G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : FreeGroup Y,
(f $o g $o grp_homo_tensor_l x) (abel_unit x0) =
grp_homo_tensor_l x (abel_unit x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d2"><span class="kp">repeat</span> <span class="nb">change</span> (cat_comp (A:=AbGroup) <span class="nl">?f</span> <span class="nl">?g</span>) <span class="kr">with</span> (cat_comp (A:=Group) f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : FreeGroup Y,
(f $o g $o grp_homo_tensor_l x) (abel_unit x0) =
grp_homo_tensor_l x (abel_unit x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d3"><span class="nb">change</span> (<span class="kr">forall</span> <span class="nv">y</span>, grp_homo_map <span class="nl">?f</span> (abel_unit y) = grp_homo_map <span class="nl">?g</span> (abel_unit y))
      <span class="kr">with</span> (cat_comp (A:=Group) f abel_unit $== cat_comp (A:=Group) g abel_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $o grp_homo_tensor_l x $o abel_unit $==
grp_homo_tensor_l x $o abel_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d4">rapply FreeGroup_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>FreeAbGroup X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : Y,
(f $o g $o grp_homo_tensor_l x $o abel_unit)
  (freegroup_in x0) =
(grp_homo_tensor_l x $o abel_unit) (freegroup_in x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d5"><span class="nb">intros</span> y; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeAbGroup X,
(f $o g $o grp_homo_tensor_l x $o abel_unit)
  (freegroup_in y) =
(grp_homo_tensor_l x $o abel_unit) (freegroup_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d6"><span class="nb">change</span> (f $o g $o grp_homo_tensor_r (freeabgroup_in y) $== grp_homo_tensor_r (freeabgroup_in y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $o grp_homo_tensor_r (freeabgroup_in y) $==
grp_homo_tensor_r (freeabgroup_in y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d7">rapply Abel_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeGroup X,
(f $o g $o grp_homo_tensor_r (freeabgroup_in y))
  (abel_in x) =
grp_homo_tensor_r (freeabgroup_in y) (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d8"><span class="nb">change</span> (@abel_in <span class="nl">?G</span>) <span class="kr">with</span> (grp_homo_map (@abel_unit G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeGroup X,
(f $o g $o grp_homo_tensor_r (freeabgroup_in y))
  (abel_unit x) =
grp_homo_tensor_r (freeabgroup_in y) (abel_unit x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1d9"><span class="kp">repeat</span> <span class="nb">change</span> (cat_comp (A:=AbGroup) <span class="nl">?f</span> <span class="nl">?g</span>) <span class="kr">with</span> (cat_comp (A:=Group) f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeGroup X,
(f $o g $o grp_homo_tensor_r (freeabgroup_in y))
  (abel_unit x) =
grp_homo_tensor_r (freeabgroup_in y) (abel_unit x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1da"><span class="nb">change</span> (<span class="kr">forall</span> <span class="nv">y</span>, grp_homo_map <span class="nl">?f</span> (abel_unit y) = grp_homo_map <span class="nl">?g</span> (abel_unit y))
      <span class="kr">with</span> (cat_comp (A:=Group) f abel_unit $== cat_comp (A:=Group) g abel_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $o grp_homo_tensor_r (freeabgroup_in y) $o
abel_unit $==
grp_homo_tensor_r (freeabgroup_in y) $o abel_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1db">rapply FreeGroup_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
(f $o g $o grp_homo_tensor_r (freeabgroup_in y) $o
 abel_unit) (freegroup_in x) =
(grp_homo_tensor_r (freeabgroup_in y) $o abel_unit)
  (freegroup_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1dc"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f $o g $o grp_homo_tensor_r (freeabgroup_in y) $o
 abel_unit) (freegroup_in x) =
(grp_homo_tensor_r (freeabgroup_in y) $o abel_unit)
  (freegroup_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1dd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $o f $== Id (FreeAbGroup (X * Y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1de">rapply Abel_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : FreeGroup (X * Y),
(g $o f) (abel_in x) =
Id (FreeAbGroup (X * Y)) (abel_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1df"><span class="nb">change</span> (GpdHom (A:=Hom(A:=Group) (FreeGroup (X * Y)) _)
      (cat_comp (A:=Group) (g $o f) (@abel_unit (FreeGroup (X * Y))))
      (@abel_unit (FreeGroup (X * Y)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $o f $o abel_unit $== abel_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1e0">snapply FreeGroup_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>FreeAbGroup_rec
  (<span class="kr">fun</span> <span class="nv">X0</span> : X * Y =&gt;
   (<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) =&gt;
    tensor (freeabgroup_in x) (freeabgroup_in y))
     (fst X0) (snd X0))</span></span><span class="hyp-type"><b>: </b><span>FreeAbGroup (X * Y) $-&gt;
ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> <span class="nv">x</span> : FreeAbGroup X =&gt;
   FreeAbGroup_rec
     (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
      (FreeAbGroup_rec
         (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
          <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
          X0 (freegroup_in (x0, y)))
       :
       FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
  (<span class="kr">fun</span> (<span class="nv">x</span> : FreeAbGroup X) (<span class="nv">y</span> <span class="nv">y&#39;</span> : FreeAbGroup Y)
   =&gt;
   grp_homo_op
     (FreeAbGroup_rec
        (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
             <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
             X0 (freegroup_in (x0, y0)))
          :
          FreeAbGroup X -&gt; FreeAbGroup (X * Y)) x))
     y y&#39;)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : FreeAbGroup X =&gt;
   Abel_ind_hprop (FreeGroup Y)
     (<span class="kr">fun</span> <span class="nv">x0</span> : Abel (FreeGroup Y) =&gt;
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) (x + x&#39;) x0 =
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x x0 +
      (<span class="kr">fun</span> <span class="nv">x1</span> : FreeAbGroup X =&gt;
       grp_homo_map
         (FreeAbGroup_rec
            (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
             (FreeAbGroup_rec
                (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt;
                 <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                   <span class="kr">in</span>
                 X0 (freegroup_in (x2, y)))
              :
              FreeAbGroup X -&gt; FreeAbGroup (X * Y))
               x1))) x&#39; x0)
     (FreeGroup_ind_homotopy
        (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
         FreeGroup_rec_beta Y
           (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
            FreeAbGroup_rec
              (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
               <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
               X0 (freegroup_in (x0, y0))) (x + x&#39;))
           y @
         (grp_homo_op
            (FreeAbGroup_rec
               (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit <span class="kr">in</span>
                X0 (freegroup_in (x0, y)))) x x&#39; @
          ap011 sg_op
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x) y)^
            (FreeGroup_rec_beta Y
               (<span class="kr">fun</span> <span class="nv">y0</span> : Y =&gt;
                FreeAbGroup_rec
                  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
                   <span class="kr">let</span> <span class="nv">X0</span> := grp_homo_map abel_unit
                     <span class="kr">in</span>
                   X0 (freegroup_in (x0, y0))) x&#39;)
               y)^))))</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod (FreeAbGroup X) (FreeAbGroup Y) $-&gt;
FreeAbGroup (X * Y)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X * Y,
(g $o f $o abel_unit) (freegroup_in x) =
abel_unit (freegroup_in x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Tensor products distribute over direct sums *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1e1"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_dist_l</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  : ab_tensor_prod A (ab_biprod B C)
    $&lt;~&gt; ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A (ab_biprod B C) $&lt;~&gt;
ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1e2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A (ab_biprod B C) $&lt;~&gt;
ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1e3">stapply (<span class="kr">let</span> <span class="nv">f</span> := _ <span class="kr">in</span> <span class="kr">let</span> <span class="nv">g</span> := _ <span class="kr">in</span> cate_adjointify f g _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1e4"><hr></label><div class="goal-conclusion">ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1e5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal0</span></span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1e5"><hr></label><div class="goal-conclusion">f $o g $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C))</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal0</span></span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1e6"><hr></label><div class="goal-conclusion">g $o f $== Id (ab_tensor_prod A (ab_biprod B C))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1e7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1e8">snapply ab_tensor_prod_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_biprod B C -&gt;
ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1e9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1e9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : ab_biprod B C),
<span class="nl">?f</span> a (b + b&#39;) = <span class="nl">?f</span> a b + <span class="nl">?f</span> a b&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1ea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1ea"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : ab_biprod B C),
<span class="nl">?f</span> (a + a&#39;) b = <span class="nl">?f</span> a b + <span class="nl">?f</span> a&#39; b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1eb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;
ab_biprod B C -&gt;
ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ec"><span class="nb">intros</span> a bc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>ab_biprod B C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tensor a (fst bc), tensor a (snd bc)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ed">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> <span class="nv">b&#39;</span> : ab_biprod B C),
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
 (tensor a0 (fst bc), tensor a0 (snd bc))) a (b + b&#39;) =
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
 (tensor a0 (fst bc), tensor a0 (snd bc))) a b +
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
 (tensor a0 (fst bc), tensor a0 (snd bc))) a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ee"><span class="nb">intros</span> a bc bc&#39;; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bc, bc'</var><span class="hyp-type"><b>: </b><span>ab_biprod B C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(tensor a (fst (bc + bc&#39;)), tensor a (snd (bc + bc&#39;))) =
(tensor a (fst bc), tensor a (snd bc)) +
(tensor a (fst bc&#39;), tensor a (snd bc&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">snapply path_prod&#39;; snapply tensor_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ef">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">b</span> : ab_biprod B C),
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
 (tensor a0 (fst bc), tensor a0 (snd bc))) (a + a&#39;) b =
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
 (tensor a0 (fst bc), tensor a0 (snd bc))) a b +
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
 (tensor a0 (fst bc), tensor a0 (snd bc))) a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f0"><span class="nb">intros</span> a a&#39; bc; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>bc</var><span class="hyp-type"><b>: </b><span>ab_biprod B C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(tensor (a + a&#39;) (fst bc), tensor (a + a&#39;) (snd bc)) =
(tensor a (fst bc), tensor a (snd bc)) +
(tensor a&#39; (fst bc), tensor a&#39; (snd bc))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">snapply path_prod; snapply tensor_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f2">snapply ab_biprod_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt;
ab_tensor_prod A (ab_biprod B C)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1f3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1f3"><hr></label><div class="goal-conclusion">ab_tensor_prod A C $-&gt;
ab_tensor_prod A (ab_biprod B C)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A B $-&gt;
ab_tensor_prod A (ab_biprod B C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap01 ab_tensor_prod A ab_biprod_inl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod A C $-&gt;
ab_tensor_prod A (ab_biprod B C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap01 ab_tensor_prod A ab_biprod_inr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f7">snapply ab_biprod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $o ab_biprod_inl $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inl</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1f8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1f8"><hr></label><div class="goal-conclusion">f $o g $o ab_biprod_inr $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1f9">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $o ab_biprod_inl $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1fa"><span class="nb">refine</span> (cat_assoc _ _ _ $@ (_ $@L _) $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $o ab_biprod_inl $== <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk1fb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk1fb"><hr></label><div class="goal-conclusion">f $o <span class="nl">?Goal</span> $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inl</div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1fc"><span class="mi">1</span>: snapply ab_biprod_rec_beta_inl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o fmap01 ab_tensor_prod A ab_biprod_inl $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1fd">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
(f $o fmap01 ab_tensor_prod A ab_biprod_inl)
  (tensor a b) =
(Id
   (ab_biprod (ab_tensor_prod A B)
      (ab_tensor_prod A C)) $o ab_biprod_inl)
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1fe"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f $o fmap01 ab_tensor_prod A ab_biprod_inl)
  (tensor a b) =
(Id
   (ab_biprod (ab_tensor_prod A B)
      (ab_tensor_prod A C)) $o ab_biprod_inl)
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk1ff">snapply path_prod; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a b = tensor a b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk200" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk200"><hr></label><div class="goal-conclusion">tensor a group_unit = congquot_mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk201">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a b = tensor a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk202">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a group_unit = congquot_mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">snapply tensor_zero_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk203">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o g $o ab_biprod_inr $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk204"><span class="nb">refine</span> (cat_assoc _ _ _ $@ (_ $@L _) $@ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $o ab_biprod_inr $== <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk205" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk205"><hr></label><div class="goal-conclusion">f $o <span class="nl">?Goal</span> $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk206"><span class="mi">1</span>: snapply ab_biprod_rec_beta_inr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f $o fmap01 ab_tensor_prod A ab_biprod_inr $==
Id
  (ab_biprod (ab_tensor_prod A B) (ab_tensor_prod A C)) $o
ab_biprod_inr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk207">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : C),
(f $o fmap01 ab_tensor_prod A ab_biprod_inr)
  (tensor a b) =
(Id
   (ab_biprod (ab_tensor_prod A B)
      (ab_tensor_prod A C)) $o ab_biprod_inr)
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk208"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f $o fmap01 ab_tensor_prod A ab_biprod_inr)
  (tensor a b) =
(Id
   (ab_biprod (ab_tensor_prod A B)
      (ab_tensor_prod A C)) $o ab_biprod_inr)
  (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk209">snapply path_prod; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a group_unit = congquot_mon_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tensorproduct-v-chk20a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><label class="goal-separator" for="tensorproduct-v-chk20a"><hr></label><div class="goal-conclusion">tensor a b = tensor a b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk20b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a group_unit = congquot_mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">snapply tensor_zero_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk20c">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a b = tensor a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk20d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g $o f $== Id (ab_tensor_prod A (ab_biprod B C))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk20e">snapply ab_tensor_prod_ind_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : ab_biprod B C),
(g $o f) (tensor a b) =
Id (ab_tensor_prod A (ab_biprod B C)) (tensor a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk20f"><span class="nb">intros</span> a [b c].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g $o f) (tensor a (b, c)) =
Id (ab_tensor_prod A (ab_biprod B C))
  (tensor a (b, c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk210">lhs_V napply tensor_dist_l; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tensor a ((b, group_unit) + (group_unit, c)) =
tensor a (b, c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk211">snapply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>ab_tensor_prod_rec
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   (tensor a (fst bc), tensor a (snd bc)))
  (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">bc</span> <span class="nv">bc&#39;</span> : ab_biprod B C) =&gt;
   path_prod&#39; (tensor_dist_l a (fst bc) (fst bc&#39;))
     (tensor_dist_l a (snd bc) (snd bc&#39;))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     (bc + bc&#39;) =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">bc</span> : ab_biprod B C) =&gt;
   path_prod
     (tensor (a + a&#39;) (fst bc),
     tensor (a + a&#39;) (snd bc))
     ((tensor a (fst bc), tensor a (snd bc)) +
      (tensor a&#39; (fst bc), tensor a&#39; (snd bc)))
     (tensor_dist_r a a&#39; (fst bc))
     (tensor_dist_r a a&#39; (snd bc))
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0)))
     (a + a&#39;) bc =
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a
     bc +
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">bc0</span> : ab_biprod B C) =&gt;
    (tensor a0 (fst bc0), tensor a0 (snd bc0))) a&#39;
     bc)</span></span><span class="hyp-type"><b>: </b><span>ab_tensor_prod A (ab_biprod B C) $-&gt;
ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C)</span></span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>ab_biprod_rec
  (fmap01 ab_tensor_prod A ab_biprod_inl)
  (fmap01 ab_tensor_prod A ab_biprod_inr)</span></span><span class="hyp-type"><b>: </b><span>ab_biprod (ab_tensor_prod A B)
  (ab_tensor_prod A C) $-&gt;
ab_tensor_prod A (ab_biprod B C)</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(b, group_unit) + (group_unit, c) = (b, c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> grp_prod_decompose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk212"><span class="kn">Definition</span> <span class="nf">ab_tensor_prod_dist_r</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
  : ab_tensor_prod (ab_biprod A B) C
    $&lt;~&gt; ab_biprod (ab_tensor_prod A C) (ab_tensor_prod B C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod (ab_biprod A B) C $&lt;~&gt;
ab_biprod (ab_tensor_prod A C) (ab_tensor_prod B C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk213"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod (ab_biprod A B) C $&lt;~&gt;
ab_biprod (ab_tensor_prod A C) (ab_tensor_prod B C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tensorproduct-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="tensorproduct-v-chk214"><span class="nb">refine</span> (emap11 ab_biprod (braide _ _) (braide _ _)
    $oE _ $oE braide _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_tensor_prod C (ab_biprod A B) $&lt;~&gt;
ab_biprod (ab_tensor_prod C A) (ab_tensor_prod C B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">snapply ab_tensor_prod_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: Show that the category of abelian groups is symmetric closed and therefore we have adjoint pair with the tensor and internal hom. This should allow us to prove lemmas such as tensors distributing over coproducts. *)</span></span></pre>
</div>
</div></body>
</html>
