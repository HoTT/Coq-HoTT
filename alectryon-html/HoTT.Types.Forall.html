<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Forall.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Theorems about dependent products *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Equivalences Basics.PathGroupoids
               Basics.Tactics Basics.Contractible Basics.Iff.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Basics.Trunc (istrunc_forall).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B C f g e n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AssumeFunext</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Paths *)</span>

<span class="sd">(** Paths [p : f = g] in a function type [forall x:X, P x] are equivalent to functions taking values in path types, [H : forall x:X, f x = g x], or concisely, [H : f == g].</span>

<span class="sd">This equivalence, however, is just the combination of [apD10] and function extensionality [funext], and as such, [path_forall], et seq. are given in the [Overture]:  *)</span>

<span class="sd">(** Now we show how these things compute. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apD10_path_forall</span> `{P : A -&gt; <span class="kt">Type</span>}
  (f g : <span class="kr">forall</span> <span class="nv">x</span>, P x) (h : f == g)
  : apD10 (path_forall _ _ h) == h
  := apD10 (eisretr apD10 h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta_path_forall</span> `{P : A -&gt; <span class="kt">Type</span>}
  (f g : <span class="kr">forall</span> <span class="nv">x</span>, P x) (p : f = g)
  : path_forall _ _ (apD10 p) = p
  := eissect apD10 p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_forall_1</span> `{P : A -&gt; <span class="kt">Type</span>} (f : <span class="kr">forall</span> <span class="nv">x</span>, P x)
  : (path_forall f f (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">1</span>)) = <span class="mi">1</span>
  := eta_path_forall f f <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identification of the path space of a dependent function space, up to equivalence, is of course just funext. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_apD10</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) <span class="nv">f</span> <span class="nv">g</span>
: (f = g) &lt;~&gt; (f == g)
  := Build_Equiv _ _ (@apD10 A P f g) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_path_forall</span> `{P : A -&gt; <span class="kt">Type</span>} (f g : <span class="kr">forall</span> <span class="nv">x</span>, P x)
  : IsEquiv (path_forall f g) | <span class="mi">0</span>
  := @isequiv_inverse _ _ (@apD10 A P f g) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_forall</span> `{P : A -&gt; <span class="kt">Type</span>} (f g : <span class="kr">forall</span> <span class="nv">x</span>, P x)
  : (f == g)  &lt;~&gt;  (f = g)
  := Build_Equiv _ _ (path_forall f g) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> equiv_path_forall {A%_type_scope P} (f g)%_function_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Path algebra *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk1"><span class="kn">Definition</span> <span class="nf">path_forall_pp</span> `{P : A -&gt; <span class="kt">Type</span>} (f g h : <span class="kr">forall</span> <span class="nv">x</span>, P x)
           (p : f == g) (q : g == h)
: path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> =&gt; p x @ q x) = path_forall f g p @ path_forall g h q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g == h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; p x @ q x) =
path_forall f g p @ path_forall g h q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g == h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; p x @ q x) =
path_forall f g p @ path_forall g h q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk3"><span class="nb">revert</span> p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : f == g) (<span class="nv">q</span> : g == h),
path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; p x @ q x) =
path_forall f g p @ path_forall g h q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk4">equiv_intro (@apD10 A P f g) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">q</span> : g == h,
path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; apD10 p x @ q x) =
path_forall f g (apD10 p) @ path_forall g h q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk5">equiv_intro (@apD10 A P g h) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; apD10 p x @ apD10 q x) =
path_forall f g (apD10 p) @ path_forall g h (apD10 q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk6"><span class="nb">transitivity</span> (path_forall f h (apD10 (p @ q))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; apD10 p x @ apD10 q x) =
path_forall f h (apD10 (p @ q))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="forall-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><label class="goal-separator" for="forall-v-chk7"><hr></label><div class="goal-conclusion">path_forall f h (apD10 (p @ q)) =
path_forall f g (apD10 p) @ path_forall g h (apD10 q)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall f h (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; apD10 p x @ apD10 q x) =
path_forall f h (apD10 (p @ q))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk9"><span class="nb">apply</span> ap, path_forall; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 p x @ apD10 q x = apD10 (p @ q) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> apD10_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall f h (apD10 (p @ q)) =
path_forall f g (apD10 p) @ path_forall g h (apD10 q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chkb"><span class="nb">refine</span> (eta_path_forall _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g, h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p @ q =
path_forall f g (apD10 p) @ path_forall g h (apD10 q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat2; <span class="nb">symmetry</span>; <span class="nb">apply</span> eta_path_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chkc"><span class="kn">Definition</span> <span class="nf">path_forall_V</span> `{P : A -&gt; <span class="kt">Type</span>} (f g : <span class="kr">forall</span> <span class="nv">x</span>, P x)
           (p : f == g)
  : path_forall _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (p x)^) = (path_forall _ _ p)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) =
(path_forall f g p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) =
(path_forall f g p)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chke"><span class="nb">transitivity</span> (path_forall _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (apD10 (path_forall _ _ p) x)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) =
path_forall g f
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="forall-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="forall-v-chkf"><hr></label><div class="goal-conclusion">path_forall g f
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^) =
(path_forall f g p)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) =
path_forall g f
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk11">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk12"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^) =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk13"><span class="nb">apply</span> (@ap _ _ (<span class="kr">fun</span> <span class="nv">h</span> <span class="nv">x</span> =&gt; (h x)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 (path_forall f g p) = p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^) =
(path_forall f g p)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk15"><span class="nb">transitivity</span> (path_forall _ _ (apD10 (path_forall _ _ p)^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^) =
path_forall g f (apD10 (path_forall f g p)^)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="forall-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="forall-v-chk16"><hr></label><div class="goal-conclusion">path_forall g f (apD10 (path_forall f g p)^) =
(path_forall f g p)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk17">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^) =
path_forall g f (apD10 (path_forall f g p)^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk18"><span class="nb">apply</span> ap, inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 (path_forall f g p)^ =
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (apD10 (path_forall f g p) x)^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk19"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10 (path_forall f g p)^ x =
(apD10 (path_forall f g p) x)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> apD10_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk1a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall g f (apD10 (path_forall f g p)^) =
(path_forall f g p)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Transport *)</span>

<span class="sd">(** The concrete description of transport in sigmas and pis is rather trickier than in the other types. In particular, these cannot be described just in terms of transport in simpler types; they require the full Id-elim rule by way of &quot;dependent transport&quot; [transportD].</span>

<span class="sd">  In particular this indicates why &quot;transport&quot; alone cannot be fully defined by induction on the structure of types, although Id-elim/[transportD] can be (cf. Observational Type Theory). A more thorough set of lemmas, along the lines of the present ones but dealing with Id-elim rather than just transport, might be nice to have eventually? *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_forall</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; <span class="kt">Type</span>}
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">y</span> : P x1, C x1 y)
  : (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span> : P x, C x y) p f)
    == (<span class="kr">fun</span> <span class="nv">y</span> =&gt;
       transport (C x2) (transport_pV _ _ _) (transportD _ _ p _ (f (p^ # y))))
  := <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A special case of [transport_forall] where the type [P] does not depend on [A],</span>
<span class="sd">    and so it is just a fixed type [B]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_forall_constant</span>
  {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">C</span> : A -&gt; B -&gt; <span class="kt">Type</span>}
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, C x1 y)
  : (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B, C x y) p f)
    == (<span class="kr">fun</span> <span class="nv">y</span> =&gt; transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C x y) p (f y))
  := <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk1b"><span class="kn">Definition</span> <span class="nf">apD_transport_forall_constant</span>
  {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">C</span> : A -&gt; B -&gt; <span class="kt">Type</span>)
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, C x1 y)
  {<span class="nv">y1</span> <span class="nv">y2</span> : B} (<span class="nv">q</span> : y1 = y2)
: apD (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B, C x y) p f) q
  = ap (transport (C x2) q) (transport_forall_constant p f y1)
    @ transport_transport C p q (f y1)
    @ ap (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y2) p) (apD f q)
    @ (transport_forall_constant p f y2)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : B, C x1 y</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B, C x y) p f)
  q =
((ap (transport (C x2) q)
    (transport_forall_constant p f y1) @
  transport_transport C p q (f y1)) @
 ap (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y2) p) (apD f q)) @
(transport_forall_constant p f y2)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : B, C x1 y</span></span></span><br><span><var>y1, y2</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>y1 = y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B, C x y) p f)
  q =
((ap (transport (C x2) q)
    (transport_forall_constant p f y1) @
  transport_transport C p q (f y1)) @
 ap (transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y2) p) (apD f q)) @
(transport_forall_constant p f y2)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p, q; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Maps on paths *)</span>

<span class="sd">(** The action of maps given by application. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_apply_lD</span> {<span class="nv">A</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x} (<span class="nv">p</span> : f = g) (<span class="nv">z</span> : A)
  : ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f z) p = apD10 p z
:= <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk1d"><span class="kn">Definition</span> <span class="nf">ap_apply_lD2</span> {<span class="nv">A</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} { <span class="nv">C</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x -&gt; <span class="kt">Type</span>}
           {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, C x y} (<span class="nv">p</span> : f = g) (<span class="nv">z1</span> : A) (<span class="nv">z2</span> : B z1)
  : ap (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f z1 z2) p = apD10 (apD10 p z1) z2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B x), C x y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>z1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z2</var><span class="hyp-type"><b>: </b><span>B z1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">x0</span> : B x), C x x0 =&gt;
   f z1 z2) p = apD10 (apD10 p z1) z2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : B x), C x y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br><span><var>z1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>z2</var><span class="hyp-type"><b>: </b><span>B z1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">x0</span> : B x), C x x0 =&gt;
   f z1 z2) p = apD10 (apD10 p z1) z2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> path_induction.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** The action of maps given by lambda. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk1f"><span class="kn">Definition</span> <span class="nf">ap_lambdaD</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">C</span> : B -&gt; <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">M</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, C b)
  : ap (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; M a b) p =
      path_forall _ _ (<span class="kr">fun</span> <span class="nv">b</span> =&gt; ap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; M a b) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kr">forall</span> <span class="nv">b</span> : B, C b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) =&gt; M a b) p =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; M a b) x)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; M a b) y)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; ap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; M a b) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kr">forall</span> <span class="nv">b</span> : B, C b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) =&gt; M a b) p =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; M a b) x)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; M a b) y)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; ap (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; M a b) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p;
  <span class="nb">symmetry</span>;
  <span class="nb">simpl</span>; <span class="nb">apply</span> path_forall_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The action of pre-composition on a path between dependent functions.  See also [ap10_ap_precompose] in PathGroupoids.v and [ap_precompose] in Arrow.v. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap_precomposeD</span> {<span class="nv">B</span> <span class="nv">Q</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : Q -&gt; <span class="kt">Type</span>}
  {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">q</span>, P q} (<span class="nv">h</span> : f = g) (<span class="nv">i</span> : B -&gt; Q)
  : ap (<span class="kr">fun</span> (<span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">q</span>, P q) =&gt; k oD i) h
    = path_forall (f oD i) (g oD i) (apD10 h oD i)
  := ap_lambdaD _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Dependent paths *)</span>

<span class="sd">(** Usually, a dependent path over [p:x1=x2] in [P:A-&gt;Type] between [y1:P x1] and [y2:P x2] is a path [transport P p y1 = y2] in [P x2].  However, when [P] is a function space, these dependent paths have a more convenient description: rather than transporting the argument of [y1] forwards and backwards, we transport only forwards but on both sides of the equation, yielding a &quot;naturality square&quot;. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk21"><span class="kn">Definition</span> <span class="nf">dpath_forall</span>
  {<span class="nv">A</span>:<span class="kt">Type</span>} (<span class="nv">B</span>:A -&gt; <span class="kt">Type</span>) (<span class="nv">C</span>:<span class="kr">forall</span> <span class="nv">a</span>, B a -&gt; <span class="kt">Type</span>) (<span class="nv">x1</span> <span class="nv">x2</span>:A) (<span class="nv">p</span>:x1=x2)
  (<span class="nv">f</span>:<span class="kr">forall</span> <span class="nv">y1</span>:B x1, C x1 y1) (<span class="nv">g</span>:<span class="kr">forall</span> (<span class="nv">y2</span>:B x2), C x2 y2)
  : (<span class="kr">forall</span> (<span class="nv">y1</span>:B x1), transportD B C p y1 (f y1) = g (transport B p y1))
  &lt;~&gt;
  (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span>:B x, C x y) p f = g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y1</span> : B x1, C x1 y1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y2</span> : B x2, C x2 y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y1</span> : B x1,
 transportD B C p y1 (f y1) = g (transport B p y1)) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B x, C x y) p f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y1</span> : B x1, C x1 y1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y2</span> : B x2, C x2 y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y1</span> : B x1,
 transportD B C p y1 (f y1) = g (transport B p y1)) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B x, C x y) p f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk23"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y2</span> : B x1, C x1 y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y1</span> : B x1,
 transportD B C <span class="mi">1</span> y1 (f y1) = g (transport B <span class="mi">1</span> y1)) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B x, C x y) <span class="mi">1</span> f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk24"><span class="kn">Definition</span> <span class="nf">dpath_forall_constant</span>
  {<span class="nv">A</span> <span class="nv">B</span>:<span class="kt">Type</span>} (<span class="nv">C</span> : A -&gt; B -&gt; <span class="kt">Type</span>) (<span class="nv">x1</span> <span class="nv">x2</span>:A) (<span class="nv">p</span>:x1=x2)
  (<span class="nv">f</span>:<span class="kr">forall</span> (<span class="nv">y1</span>:B), C x1 y1) (<span class="nv">g</span>:<span class="kr">forall</span> (<span class="nv">y2</span>:B), C x2 y2)
  : (<span class="kr">forall</span> (<span class="nv">y1</span>:B), transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C x y1) p (f y1) = g y1)
  &lt;~&gt;
  (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span>:B, C x y) p f = g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y1</span> : B, C x1 y1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y2</span> : B, C x2 y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y1</span> : B,
 transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y1) p (f y1) = g y1) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B, C x y) p f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y1</span> : B, C x1 y1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y2</span> : B, C x2 y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y1</span> : B,
 transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y1) p (f y1) = g y1) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B, C x y) p f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk26"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y2</span> : B, C x1 y2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y1</span> : B,
 transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; C x y1) <span class="mi">1</span> (f y1) = g y1) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="kr">forall</span> <span class="nv">y</span> : B, C x y) <span class="mi">1</span> f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functorial action *)</span>

<span class="sd">(** The functoriality of [forall] is slightly subtle: it is contravariant in the domain type and covariant in the codomain, but the codomain is dependent on the domain. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_forall</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
    (f0 : B -&gt; A) (f1 : <span class="kr">forall</span> <span class="nv">b</span>:B, P (f0 b) -&gt; Q b)
  : (<span class="kr">forall</span> <span class="nv">a</span>:A, P a) -&gt; (<span class="kr">forall</span> <span class="nv">b</span>:B, Q b)
  := (<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">b</span> =&gt; f1 _ (g (f0 b))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk27"><span class="kn">Definition</span> <span class="nf">ap_functor_forall</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
    (f0 : B -&gt; A) (f1 : <span class="kr">forall</span> <span class="nv">b</span>:B, P (f0 b) -&gt; Q b)
    (g g&#39; : <span class="kr">forall</span> <span class="nv">a</span>:A, P a) (h : g == g&#39;)
  : ap (functor_forall f0 f1) (path_forall _ _ h)
    = path_forall _ _ (<span class="kr">fun</span> <span class="nv">b</span>:B =&gt; (ap (f1 b) (h (f0 b)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g == g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_forall f0 f1) (path_forall g g&#39; h) =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g&#39; (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; ap (f1 b) (h (f0 b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g == g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_forall f0 f1) (path_forall g g&#39; h) =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g&#39; (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; ap (f1 b) (h (f0 b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk29"><span class="nb">revert</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> : g == g&#39;,
ap (functor_forall f0 f1) (path_forall g g&#39; h) =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g&#39; (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; ap (f1 b) (h (f0 b)))</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk2a">equiv_intro (@apD10 A P g g&#39;) h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g = g&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_forall f0 f1) (path_forall g g&#39; (apD10 h)) =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g&#39; (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; ap (f1 b) (apD10 h (f0 b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk2b"><span class="nb">destruct</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_forall f0 f1) (path_forall g g (apD10 <span class="mi">1</span>)) =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; ap (f1 b) (apD10 <span class="mi">1</span> (f0 b)))</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk2c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_forall f0 f1) (path_forall g g (apD10 <span class="mi">1</span>)) =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b))) (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk2d"><span class="nb">transitivity</span> (idpath (functor_forall f0 f1 g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_forall f0 f1) (path_forall g g (apD10 <span class="mi">1</span>)) =
<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="forall-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><label class="goal-separator" for="forall-v-chk2e"><hr></label><div class="goal-conclusion"><span class="mi">1</span> =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b))) (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_forall f0 f1) (path_forall g g (apD10 <span class="mi">1</span>)) =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (ap (functor_forall f0 f1)) (path_forall_1 g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> =
path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b))) (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk31"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0 b) -&gt; Q b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_forall (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b)))
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; f1 b (g (f0 b))) (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_forall_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_forall_compose</span>
           `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>} `{R : C -&gt; <span class="kt">Type</span>}
           (f0 : B -&gt; A) (f1 : <span class="kr">forall</span> <span class="nv">b</span>:B, P (f0 b) -&gt; Q b)
           (g0 : C -&gt; B) (g1 : <span class="kr">forall</span> <span class="nv">c</span>:C, Q (g0 c) -&gt; R c)
           (k : <span class="kr">forall</span> <span class="nv">a</span>, P a)
  : functor_forall g0 g1 (functor_forall f0 f1 k) == functor_forall (f0 o g0) (<span class="kr">fun</span> <span class="nv">c</span> =&gt; g1 c o f1 (g0 c)) k
  := <span class="kr">fun</span> <span class="nv">a</span> =&gt; <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Some special cases appear when one or the other of the maps are equivalences. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_forall_id</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : A -&gt; <span class="kt">Type</span>}
    (f1 : <span class="kr">forall</span> <span class="nv">a</span>:A, P a -&gt; Q a)
  : (<span class="kr">forall</span> <span class="nv">a</span>:A, P a) -&gt; (<span class="kr">forall</span> <span class="nv">a</span>:A, Q a)
  := functor_forall idmap f1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_forall_pb</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{P : A -&gt; <span class="kt">Type</span>}
    (f0 : B -&gt; A)
  : (<span class="kr">forall</span> <span class="nv">a</span>:A, P a) -&gt; (<span class="kr">forall</span> <span class="nv">b</span>:B, P (f0 b))
  := functor_forall f0 (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idmap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [f0] is an equivalence, then we can simply apply [functor_forall] to its inverse.  However, in this case it is sometimes more convenient to place the substitution on the other side of [f1]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk32"><span class="kn">Definition</span> <span class="nf">functor_forall_equiv</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
    (f0 : A -&gt; B) `{!IsEquiv f0} (f1 : <span class="kr">forall</span> <span class="nv">a</span>:A, P a -&gt; Q (f0 a))
  : (<span class="kr">forall</span> <span class="nv">a</span>:A, P a) -&gt; (<span class="kr">forall</span> <span class="nv">b</span>:B, Q b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f0</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f0 a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, P a) -&gt; <span class="kr">forall</span> <span class="nv">b</span> : B, Q b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f0</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f0 a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, P a) -&gt; <span class="kr">forall</span> <span class="nv">b</span> : B, Q b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk34">napply (functor_forall f0^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f0</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f0 a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, P (f0^-<span class="mi">1</span> b) -&gt; Q b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk35"><span class="nb">intros</span> b u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f0</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f0 a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P (f0^-<span class="mi">1</span> b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk36"><span class="nb">refine</span> ((eisretr f0 b) # _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f0</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q (f0 a)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>P (f0^-<span class="mi">1</span> b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q (f0 (f0^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f1 _ u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_forall_equiv_pb</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
    (f0 : A -&gt; B) `{!IsEquiv f0}
  : (<span class="kr">forall</span> <span class="nv">a</span>:A, Q (f0 a)) -&gt; (<span class="kr">forall</span> <span class="nv">b</span>:B, Q b)
  := functor_forall_equiv f0 (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idmap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Since there&#39;s a nontrivial transport here, it&#39;s useful to have a computation lemma. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk37"><span class="kn">Definition</span> <span class="nf">functor_forall_equiv_pb_beta</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : B -&gt; <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  `{!IsEquiv f} (h : <span class="kr">forall</span> <span class="nv">a</span>, P (f a))
  : <span class="kr">forall</span> <span class="nv">a</span>, functor_forall_equiv_pb f h (f a) = h a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, functor_forall_equiv_pb f h (f a) = h a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, functor_forall_equiv_pb f h (f a) = h a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk39"><span class="nb">intro</span> a; srapply (_ @ apD h (eissect f a)); srapply (_ @ (transport_compose _ _ _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_forall_equiv_pb f h (f a) =
transport P (ap f (eissect f a)) (h (f^-<span class="mi">1</span> (f a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply ap10; <span class="nb">apply</span> ap; <span class="nb">apply</span> eisadj.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalences *)</span>

<span class="sd">(** If *both* maps in [functor_forall] are equivalences, then so is the output. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk3a">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_functor_forall</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  `{IsEquiv B A f} `{<span class="kr">forall</span> <span class="nv">b</span>, @IsEquiv (P (f b)) (Q b) (g b)}
  : IsEquiv (functor_forall f g) | <span class="mi">1000</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_forall f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk3b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_forall f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk3c">snapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B, Q b) -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, P a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="forall-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><label class="goal-separator" for="forall-v-chk3d"><hr></label><div class="goal-conclusion">functor_forall f g o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="forall-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><label class="goal-separator" for="forall-v-chk3e"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o functor_forall f g == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B, Q b) -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, P a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_forall (f^-<span class="mi">1</span>)
      (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : Q (f^-<span class="mi">1</span> x)) =&gt; eisretr f x # (g (f^-<span class="mi">1</span> x))^-<span class="mi">1</span> y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk40">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_forall f g
o functor_forall f^-<span class="mi">1</span>
    (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : Q (f^-<span class="mi">1</span> x)) =&gt;
     transport P (eisretr f x) ((g (f^-<span class="mi">1</span> x))^-<span class="mi">1</span> y)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk41"><span class="nb">intro</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_forall f g
  (functor_forall f^-<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : Q (f^-<span class="mi">1</span> x)) =&gt;
      transport P (eisretr f x) ((g (f^-<span class="mi">1</span> x))^-<span class="mi">1</span> y)) h) =
h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk42"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> b; <span class="nb">unfold</span> functor_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g b
  (transport P (eisretr f (f b))
     ((g (f^-<span class="mi">1</span> (f b)))^-<span class="mi">1</span> (h (f^-<span class="mi">1</span> (f b))))) = h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk43">lhs napply (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; g b (transport P p _)) (eisadj f b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g b
  (transport P (ap f (eissect f b))
     ((g (f^-<span class="mi">1</span> (f b)))^-<span class="mi">1</span> (h (f^-<span class="mi">1</span> (f b))))) = h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk44">lhs_V napply (ap _ (transport_compose _ _ _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g b
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; P (f x)) (eissect f b)
     ((g (f^-<span class="mi">1</span> (f b)))^-<span class="mi">1</span> (h (f^-<span class="mi">1</span> (f b))))) = h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk45">lhs napply ap_transport.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Q (eissect f b)
  (g (f^-<span class="mi">1</span> (f b))
     ((g (f^-<span class="mi">1</span> (f b)))^-<span class="mi">1</span> (h (f^-<span class="mi">1</span> (f b))))) = h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk46">lhs napply (ap _ (eisretr (g _) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Q (eissect f b) (h (f^-<span class="mi">1</span> (f b))) = h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> apD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_forall f^-<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : Q (f^-<span class="mi">1</span> x)) =&gt;
   transport P (eisretr f x) ((g (f^-<span class="mi">1</span> x))^-<span class="mi">1</span> y))
o functor_forall f g == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk48"><span class="nb">intro</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_forall f^-<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">x</span> : A) (<span class="nv">y</span> : Q (f^-<span class="mi">1</span> x)) =&gt;
   transport P (eisretr f x) ((g (f^-<span class="mi">1</span> x))^-<span class="mi">1</span> y))
  (functor_forall f g h) = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk49"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> a; <span class="nb">unfold</span> functor_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (eisretr f a)
  ((g (f^-<span class="mi">1</span> a))^-<span class="mi">1</span> (g (f^-<span class="mi">1</span> a) (h (f (f^-<span class="mi">1</span> a))))) =
h a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk4a">lhs napply (ap _ (eissect (g _) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : B, P (f x) -&gt; Q x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsEquiv (g b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (eisretr f a) (h (f (f^-<span class="mi">1</span> a))) = h a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> apD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_forall</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  (f : B -&gt; A) `{IsEquiv B A f}
  (g : <span class="kr">forall</span> <span class="nv">b</span>, P (f b) -&gt; Q b)
  `{<span class="kr">forall</span> <span class="nv">b</span>, @IsEquiv (P (f b)) (Q b) (g b)}
  : (<span class="kr">forall</span> <span class="nv">a</span>, P a) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">b</span>, Q b)
  := Build_Equiv _ _ (functor_forall f g) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_forall&#39;</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
  (f : B &lt;~&gt; A) (g : <span class="kr">forall</span> <span class="nv">b</span>, P (f b) &lt;~&gt; Q b)
  : (<span class="kr">forall</span> <span class="nv">a</span>, P a) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">b</span>, Q b)
  := equiv_functor_forall f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_forall_id</span> `{P : A -&gt; <span class="kt">Type</span>} `{Q : A -&gt; <span class="kt">Type</span>}
  (g : <span class="kr">forall</span> <span class="nv">a</span>, P a &lt;~&gt; Q a)
  : (<span class="kr">forall</span> <span class="nv">a</span>, P a) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">a</span>, Q a)
  := equiv_functor_forall (equiv_idmap A) g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_forall_pb</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>}
  (<span class="nv">f</span> : B &lt;~&gt; A)
  : (<span class="kr">forall</span> <span class="nv">a</span>, P a) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">b</span>, P (f b))
  := equiv_functor_forall&#39; (Q := P o f) f (<span class="kr">fun</span> <span class="nv">b</span> =&gt; equiv_idmap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Similarly, we have a version of [functor_forall_equiv] that acts on on equivalences both upstairs and downstairs. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_forall_covariant</span>
           `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>}
           (f : A &lt;~&gt; B) (g : <span class="kr">forall</span> <span class="nv">a</span>, P a &lt;~&gt; Q (f a))
  : (<span class="kr">forall</span> <span class="nv">a</span>, P a) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">b</span>, Q b)
  := (equiv_functor_forall&#39; f (<span class="kr">fun</span> <span class="nv">a</span> =&gt; (g a)^-<span class="mi">1</span>%equiv))^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk4b"><span class="kn">Definition</span> <span class="nf">equiv_functor_forall_covariant_compose</span>
           `{P : A -&gt; <span class="kt">Type</span>} `{Q : B -&gt; <span class="kt">Type</span>} `{R : C -&gt; <span class="kt">Type</span>}
           (f0 : A &lt;~&gt; B) (f1 : <span class="kr">forall</span> <span class="nv">a</span>, P a &lt;~&gt; Q (f0 a))
           (g0 : B &lt;~&gt; C) (g1 : <span class="kr">forall</span> <span class="nv">b</span>, Q b &lt;~&gt; R (g0 b))
           (h : <span class="kr">forall</span> <span class="nv">a</span>, P a)
  : equiv_functor_forall_covariant g0 g1 (equiv_functor_forall_covariant f0 f1 h)
    == equiv_functor_forall_covariant (g0 oE f0) (<span class="kr">fun</span> <span class="nv">a</span> =&gt; g1 (f0 a) oE f1 a) h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a &lt;~&gt; Q (f0 a)</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b &lt;~&gt; R (g0 b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_forall_covariant g0 g1
  (equiv_functor_forall_covariant f0 f1 h) ==
equiv_functor_forall_covariant (g0 oE f0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; g1 (f0 a) oE f1 a) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a &lt;~&gt; Q (f0 a)</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b &lt;~&gt; R (g0 b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_forall_covariant g0 g1
  (equiv_functor_forall_covariant f0 f1 h) ==
equiv_functor_forall_covariant (g0 oE f0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; g1 (f0 a) oE f1 a) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk4d"><span class="nb">apply</span> apD10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a &lt;~&gt; Q (f0 a)</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b &lt;~&gt; R (g0 b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_forall_covariant g0 g1
  (equiv_functor_forall_covariant f0 f1 h) =
equiv_functor_forall_covariant (g0 oE f0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; g1 (f0 a) oE f1 a) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk4e"><span class="nb">refine</span> ((equiv_inverse_compose
             (equiv_functor_forall&#39; g0 (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (g1 a)^-<span class="mi">1</span>%equiv))
             (equiv_functor_forall&#39; f0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (f1 a)^-<span class="mi">1</span>%equiv))
             h)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a &lt;~&gt; Q (f0 a)</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b &lt;~&gt; R (g0 b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_functor_forall&#39; f0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (f1 a)^-<span class="mi">1</span>)
 oE equiv_functor_forall&#39; g0 (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (g1 a)^-<span class="mi">1</span>))^-<span class="mi">1</span>
  h =
equiv_functor_forall_covariant (g0 oE f0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; g1 (f0 a) oE f1 a) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk4f"><span class="nb">revert</span> h; <span class="nb">apply</span> equiv_inverse_homotopy; <span class="nb">intros</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a &lt;~&gt; Q (f0 a)</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b &lt;~&gt; R (g0 b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : C, R a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_forall&#39; (g0 oE f0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (g1 (f0 a) oE f1 a)^-<span class="mi">1</span>%equiv) h =
(equiv_functor_forall&#39; f0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (f1 a)^-<span class="mi">1</span>)
 oE equiv_functor_forall&#39; g0 (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (g1 a)^-<span class="mi">1</span>))
  h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk50"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>C -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a &lt;~&gt; Q (f0 a)</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, Q b &lt;~&gt; R (g0 b)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : C, R a</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_forall&#39; (g0 oE f0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (g1 (f0 a) oE f1 a)^-<span class="mi">1</span>%equiv) h c =
(equiv_functor_forall&#39; f0 (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (f1 a)^-<span class="mi">1</span>)
 oE equiv_functor_forall&#39; g0 (<span class="kr">fun</span> <span class="nv">a</span> : B =&gt; (g1 a)^-<span class="mi">1</span>))
  h c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; rapply functor_forall_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality on logical equivalences *)</span>

<span class="sd">(** At least over a fixed base *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">iff_functor_forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>}
           (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a &lt;-&gt; Q a)
  : (<span class="kr">forall</span> <span class="nv">a</span>, P a) &lt;-&gt; (<span class="kr">forall</span> <span class="nv">a</span>, Q a)
  := (functor_forall idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; fst (f a)),
    functor_forall idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; snd (f a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Two variable versions for function extensionality. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_forall11</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P a b)
  : (<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a), f a b = g a b) &lt;~&gt; f = g
  := (equiv_path_forall f g) oE (equiv_functor_forall_id (<span class="kr">fun</span> <span class="nv">a</span> =&gt; equiv_path_forall (f a) (g a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_forall11</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P a b)
  : (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x y = g x y) -&gt; f = g
  := equiv_path_forall11 f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_path_forall11</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>} `{P : <span class="kr">forall</span> <span class="nv">a</span> : A, B a -&gt; <span class="kt">Type</span>} (f g : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P a b)
  : IsEquiv (path_forall11 f g) | <span class="mi">0</span>
  := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> equiv_path_forall11 {A B}%_type_scope {P} (f g)%_function_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> path_forall11 {A B}%_type_scope {P} (f g)%_function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Truncatedness: any dependent product of n-types is an n-type: see [contr_forall] and [istrunc_forall] in Basics.Trunc. *)</span>

<span class="sd">(** ** Contractibility: A product over a contractible type is equivalent to the fiber over the center. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk51"><span class="kn">Definition</span> <span class="nf">equiv_contr_forall</span> `{Contr A} `(P : A -&gt; <span class="kt">Type</span>)
: (<span class="kr">forall</span> <span class="nv">a</span>, P a) &lt;~&gt; P (center A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, P a) &lt;~&gt; P (center A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, P a) &lt;~&gt; P (center A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk53"><span class="nb">simple refine</span> (equiv_adjointify (<span class="kr">fun</span> (<span class="nv">f</span>:<span class="kr">forall</span> <span class="nv">a</span>, P a) =&gt; f (center A)) _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (center A) -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, P a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="forall-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="forall-v-chk54"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P a =&gt; f (center A)) o <span class="nl">?g</span> ==
idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="forall-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="forall-v-chk55"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P a =&gt; f (center A)) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (center A) -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, P a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> p a; <span class="bp">exact</span> (transport P (path_contr _ _) p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk57">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P a =&gt; f (center A))
o (<span class="kr">fun</span> (<span class="nv">p</span> : P (center A)) (<span class="nv">a</span> : A) =&gt;
   transport P (path_contr (center A) a) p) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk58"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (center A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (path_contr (center A) (center A)) p = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk59"><span class="nb">refine</span> (transport2 P (q := <span class="mi">1</span>) _ p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P (center A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_contr (center A) (center A) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">p</span> : P (center A)) (<span class="nv">a</span> : A) =&gt;
 transport P (path_contr (center A) a) p)
o (<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P a =&gt; f (center A)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk5b"><span class="nb">intros</span> f; <span class="nb">apply</span> path_forall; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (path_contr (center A) a) (f (center A)) =
f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> apD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AssumeFunext</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Symmetry of curried arguments *)</span>

<span class="sd">(** [flip] is defined in Overture.v *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk5c"><span class="kn">Instance</span> <span class="nf">isequiv_flip</span> `{P : A -&gt; B -&gt; <span class="kt">Type</span>}
  : IsEquiv (@flip _ _ P) | <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv flip</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk5d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv flip</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk5e"><span class="nb">set</span> (flip_P := @flip _ _ P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>flip_P</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A), P a b</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv flip_P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk5f"><span class="nb">set</span> (flip_P_inv := @flip _ _ (flip P)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>flip_P</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A), P a b</span></span></span></span><br><span><var>flip_P_inv</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A), flip P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : B), flip P a b</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv flip_P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk60"><span class="nb">set</span> (flip_P_is_sect := (<span class="kr">fun</span> <span class="nv">f</span> =&gt; <span class="mi">1</span>) : flip_P_inv o flip_P == idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>flip_P</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A), P a b</span></span></span></span><br><span><var>flip_P_inv</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A), flip P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : B), flip P a b</span></span></span></span><br><span><var>flip_P_is_sect</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b
 =&gt; <span class="mi">1</span>)
:
flip_P_inv o flip_P == idmap</span></span><span class="hyp-type"><b>: </b><span>flip_P_inv o flip_P == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv flip_P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk61"><span class="nb">set</span> (flip_P_is_retr := (<span class="kr">fun</span> <span class="nv">g</span> =&gt; <span class="mi">1</span>) : flip_P o flip_P_inv == idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>flip_P</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A), P a b</span></span></span></span><br><span><var>flip_P_inv</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A), flip P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : B), flip P a b</span></span></span></span><br><span><var>flip_P_is_sect</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b
 =&gt; <span class="mi">1</span>)
:
flip_P_inv o flip_P == idmap</span></span><span class="hyp-type"><b>: </b><span>flip_P_inv o flip_P == idmap</span></span></span></span><br><span><var>flip_P_is_retr</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span>
   <span class="nv">g</span> : <span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A),
       flip P a b =&gt; <span class="mi">1</span>)
:
flip_P o flip_P_inv == idmap</span></span><span class="hyp-type"><b>: </b><span>flip_P o flip_P_inv == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv flip_P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk62"><span class="kr">exists</span> <span class="nv">flip_P_inv</span> <span class="nv">flip_P_is_retr</span> <span class="nv">flip_P_is_sect</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>flip_P</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A), P a b</span></span></span></span><br><span><var>flip_P_inv</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A), flip P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : B), flip P a b</span></span></span></span><br><span><var>flip_P_is_sect</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b
 =&gt; <span class="mi">1</span>)
:
flip_P_inv o flip_P == idmap</span></span><span class="hyp-type"><b>: </b><span>flip_P_inv o flip_P == idmap</span></span></span></span><br><span><var>flip_P_is_retr</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span>
   <span class="nv">g</span> : <span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A),
       flip P a b =&gt; <span class="mi">1</span>)
:
flip_P o flip_P_inv == idmap</span></span><span class="hyp-type"><b>: </b><span>flip_P o flip_P_inv == idmap</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : <span class="kr">forall</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : B), flip P a b,
flip_P_is_retr (flip_P x) =
ap flip_P (flip_P_is_sect x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="forall-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="forall-v-chk63"><span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>flip_P</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : B) (<span class="nv">a</span> : A), P a b</span></span></span></span><br><span><var>flip_P_inv</var><span><span class="hyp-body"><b>:= </b><span>flip</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A), flip P a b) -&gt;
<span class="kr">forall</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : B), flip P a b</span></span></span></span><br><span><var>flip_P_is_sect</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span> <span class="nv">f</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b
 =&gt; <span class="mi">1</span>)
:
flip_P_inv o flip_P == idmap</span></span><span class="hyp-type"><b>: </b><span>flip_P_inv o flip_P == idmap</span></span></span></span><br><span><var>flip_P_is_retr</var><span><span class="hyp-body"><b>:= </b><span>(<span class="kr">fun</span>
   <span class="nv">g</span> : <span class="kr">forall</span> (<span class="nv">a</span> : B) (<span class="nv">b</span> : A),
       flip P a b =&gt; <span class="mi">1</span>)
:
flip_P o flip_P_inv == idmap</span></span><span class="hyp-type"><b>: </b><span>flip_P o flip_P_inv == idmap</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">b</span> : A) (<span class="nv">a</span> : B), flip P a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flip_P_is_retr (flip_P g) =
ap flip_P (flip_P_is_sect g)</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_flip</span> `(P : A -&gt; B -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P a b) &lt;~&gt; (<span class="kr">forall</span> <span class="nv">b</span> <span class="nv">a</span>, P a b)
  := Build_Equiv _ _ (@flip _ _ P) _.</span></span></pre>
</div>
</div></body>
</html>
