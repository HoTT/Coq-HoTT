<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Suspension.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Cubical.DPath Cubical.DPathSquare.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Pushout.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.NullHomotopy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Extensions.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The suspension of a type *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">X</span> A B f g n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ** Definition of suspension *)</span>

<span class="sd">(** We define the suspension of a type X as the pushout of 1 &lt;- X -&gt; 1 *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp</span> (<span class="nv">X</span> : <span class="kt">Type</span>) := Pushout@{_ <span class="kt">Set</span> <span class="kt">Set</span> _} (const_tt X) (const_tt X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">North</span> {<span class="nv">X</span>} : Susp X := pushl tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">South</span> {<span class="nv">X</span>} : Susp X := pushr tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">merid</span> {<span class="nv">X</span>} (<span class="nv">x</span> : X) : North = South := pglue x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We think of this as the HIT with two points [North] and [South] and a path [merid] between them *)</span>

<span class="sd">(** We can derive an induction principle for the suspension *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk1"><span class="kn">Definition</span> <span class="nf">Susp_ind</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : Susp X -&gt; <span class="kt">Type</span>)
  (<span class="nv">H_N</span> : P North) (<span class="nv">H_S</span> : P South)
  (<span class="nv">H_merid</span> : <span class="kr">forall</span> <span class="nv">x</span>:X, (merid x) # H_N = H_S)
  : <span class="kr">forall</span> (<span class="nv">y</span> : Susp X), P y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk3">srapply Pushout_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit, P (pushl b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk4"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : Unit, P (pushr c)</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
transport P (pglue a) (<span class="nl">?pushb</span> (const_tt X a)) =
<span class="nl">?pushc</span> (const_tt X a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Unit, P (pushl b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Unit_ind H_N).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : Unit, P (pushr c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Unit_ind H_S).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
transport P (pglue a) (Unit_ind H_N (const_tt X a)) =
Unit_ind H_S (const_tt X a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H_merid).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can also derive the computation rule *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk9"><span class="kn">Definition</span> <span class="nf">Susp_ind_beta_merid</span> {<span class="nv">X</span> : <span class="kt">Type</span>}
  (<span class="nv">P</span> : Susp X -&gt; <span class="kt">Type</span>) (<span class="nv">H_N</span> : P North) (<span class="nv">H_S</span> : P South)
  (<span class="nv">H_merid</span> : <span class="kr">forall</span> <span class="nv">x</span>:X, (merid x) # H_N = H_S) (<span class="nv">x</span> : X)
  : apD (Susp_ind P H_N H_S H_merid) (merid x) = H_merid x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Susp_ind P H_N H_S H_merid) (merid x) = H_merid x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H_N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>H_S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (merid x) H_N = H_S</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Susp_ind P H_N H_S H_merid) (merid x) = H_merid x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply Pushout_ind_beta_pglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We want to allow the user to forget that we&#39;ve defined suspension as a pushout and make it look like it was defined directly as a HIT. This has the advantage of not having to assume any new HITs but allowing us to have conceptual clarity. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Susp : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> North : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> South : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> merid : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Susp_ind_beta_merid : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version of [Susp_ind] specifically for proving that two functions defined on a suspension are homotopic. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb"><span class="kn">Definition</span> <span class="nf">Susp_ind_FlFr</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : Susp X -&gt; Y)
  (<span class="nv">HN</span> : f North = g North)
  (<span class="nv">HS</span> : f South = g South)
  (<span class="nv">Hmerid</span> : <span class="kr">forall</span> <span class="nv">x</span>, ap f (merid x) @ HS = HN @ ap g (merid x))
  : f == g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>f North = g North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>f South = g South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap f (merid x) @ HS = HN @ ap g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>f North = g North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>f South = g South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap f (merid x) @ HS = HN @ ap g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd">snapply (Susp_ind _ HN HS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>f North = g North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>f South = g South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap f (merid x) @ HS = HN @ ap g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; f y = g y) (merid x) HN =
HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>f North = g North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>f South = g South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap f (merid x) @ HS = HN @ ap g (merid x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; f y = g y) (merid x) HN =
HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf">transport_paths FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>f North = g North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>f South = g South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap f (merid x) @ HS = HN @ ap g (merid x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (merid x) @ HS = HN @ ap g (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hmerid x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version of [Susp_ind] specifically for proving that the composition of two functions to and from a suspension are homotopic to the identity map. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk10"><span class="kn">Definition</span> <span class="nf">Susp_ind_FFlr</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Susp X -&gt; Y) (<span class="nv">g</span> : Y -&gt; Susp X)
  (<span class="nv">HN</span> : g (f North) = North)
  (<span class="nv">HS</span> : g (f South) = South)
  (<span class="nv">Hmerid</span> : <span class="kr">forall</span> <span class="nv">x</span>, ap g (ap f (merid x)) @ HS = HN @ merid x)
  : g o f == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Susp X</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS = HN @ merid x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Susp X</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS = HN @ merid x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk12">snapply (Susp_ind _ HN HS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Susp X</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS = HN @ merid x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; (g o f) y = idmap y)
  (merid x) HN = HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk13"><span class="nb">intros</span> x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Susp X</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS = HN @ merid x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; g (f y) = y) (merid x) HN =
HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk14">transport_paths FFlr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Susp X</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS = HN @ merid x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (merid x)) @ HS = HN @ merid x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hmerid x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk15"><span class="kn">Definition</span> <span class="nf">Susp_ind_FFlFr</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : Susp X -&gt; Y) (<span class="nv">g</span> : Y -&gt; Z) (<span class="nv">h</span> : Susp X -&gt; Z)
  (<span class="nv">HN</span> : g (f North) = h North)
  (<span class="nv">HS</span> : g (f South) = h South)
  (<span class="nv">Hmerid</span> : <span class="kr">forall</span> <span class="nv">x</span>, ap g (ap f (merid x)) @ HS = HN @ ap h (merid x))
  : g o f == h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = h North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = h South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap h (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = h North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = h South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap h (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk17">snapply (Susp_ind _ HN HS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = h North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = h South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap h (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; (g o f) y = h y)
  (merid x) HN = HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk18"><span class="nb">intros</span> x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = h North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = h South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap h (merid x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; g (f y) = h y) (merid x)
  HN = HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk19">transport_paths FFlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = h North</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = h South</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap h (merid x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (merid x)) @ HS = HN @ ap h (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hmerid x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version of [Susp_ind] specifically for proving a composition square from a suspension. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk1a"><span class="kn">Definition</span> <span class="nf">Susp_ind_FFlFFr</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Y&#39;</span> <span class="nv">Z</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : Susp X -&gt; Y) (<span class="nv">f&#39;</span> : Susp X -&gt; Y&#39;) (<span class="nv">g</span> : Y -&gt; Z) (<span class="nv">g&#39;</span> : Y&#39; -&gt; Z)
  (<span class="nv">HN</span> : g (f North) = g&#39; (f&#39; North)) (<span class="nv">HS</span> : g (f South) = g&#39; (f&#39; South))
  (<span class="nv">Hmerid</span> : <span class="kr">forall</span> <span class="nv">x</span>, ap g (ap f (merid x)) @ HS = HN @ ap g&#39; (ap f&#39; (merid x)))
  : g o f == g&#39; o f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Y', Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y&#39; -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = g&#39; (f&#39; North)</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = g&#39; (f&#39; South)</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap g&#39; (ap f&#39; (merid x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == g&#39; o f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Y', Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y&#39; -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = g&#39; (f&#39; North)</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = g&#39; (f&#39; South)</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap g&#39; (ap f&#39; (merid x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == g&#39; o f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk1c">snapply (Susp_ind _ HN HS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Y', Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y&#39; -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = g&#39; (f&#39; North)</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = g&#39; (f&#39; South)</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap g&#39; (ap f&#39; (merid x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; (g o f) y = (g&#39; o f&#39;) y)
  (merid x) HN = HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk1d"><span class="nb">intros</span> x; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Y', Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y&#39; -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = g&#39; (f&#39; North)</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = g&#39; (f&#39; South)</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap g&#39; (ap f&#39; (merid x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; g (f y) = g&#39; (f&#39; y))
  (merid x) HN = HS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk1e">transport_paths FFlFFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Y', Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y&#39;</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>g'</var><span class="hyp-type"><b>: </b><span>Y&#39; -&gt; Z</span></span></span><br><span><var>HN</var><span class="hyp-type"><b>: </b><span>g (f North) = g&#39; (f&#39; North)</span></span></span><br><span><var>HS</var><span class="hyp-type"><b>: </b><span>g (f South) = g&#39; (f&#39; South)</span></span></span><br><span><var>Hmerid</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X,
ap g (ap f (merid x)) @ HS =
HN @ ap g&#39; (ap f&#39; (merid x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (merid x)) @ HS =
HN @ ap g&#39; (ap f&#39; (merid x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hmerid x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ** Non-dependent eliminator. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp_rec</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>}
  (<span class="nv">H_N</span> <span class="nv">H_S</span> : Y) (<span class="nv">H_merid</span> : X -&gt; H_N = H_S)
  : Susp X -&gt; Y
  := Pushout_rec (f:=const_tt X) (g:=const_tt X) Y (Unit_ind H_N) (Unit_ind H_S) H_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> Susp_rec {X Y}%_type_scope H_N H_S H_merid%_function_scope _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk1f"><span class="kn">Definition</span> <span class="nf">Susp_rec_beta_merid</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>}
  {<span class="nv">H_N</span> <span class="nv">H_S</span> : Y} {<span class="nv">H_merid</span> : X -&gt; H_N = H_S} (<span class="nv">x</span>:X)
  : ap (Susp_rec H_N H_S H_merid) (merid x) = H_merid x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec H_N H_S H_merid) (merid x) = H_merid x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec H_N H_S H_merid) (merid x) = H_merid x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply Pushout_rec_beta_pglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk21"><span class="kn">Definition</span> <span class="nf">Susp_rec_beta_zigzag</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>}
  {<span class="nv">H_N</span> <span class="nv">H_S</span> : Y} {<span class="nv">H_merid</span> : X -&gt; H_N = H_S} (<span class="nv">x</span> <span class="nv">x&#39;</span> : X)
  : ap (Susp_rec H_N H_S H_merid) (merid x @ (merid x&#39;)^) = H_merid x @ (H_merid x&#39;)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec H_N H_S H_merid) (merid x @ (merid x&#39;)^) =
H_merid x @ (H_merid x&#39;)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec H_N H_S H_merid) (merid x @ (merid x&#39;)^) =
H_merid x @ (H_merid x&#39;)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk23">lhs napply ap_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>H_merid</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec H_N H_S H_merid) (merid x) @
(ap (Susp_rec H_N H_S H_merid) (merid x&#39;))^ =
H_merid x @ (H_merid x&#39;)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_rec_beta_merid x @@ inverse2 (Susp_rec_beta_merid x&#39;)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A variant of [Susp_ind_FlFr] specifically for two functions both defined using [Susp_rec]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk24"><span class="kn">Definition</span> <span class="nf">Susp_rec_homotopic</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">N</span> <span class="nv">S</span> <span class="nv">N&#39;</span> <span class="nv">S&#39;</span> : Y)
  (<span class="nv">f</span> : X -&gt; N = S) (<span class="nv">f&#39;</span> : X -&gt; N&#39; = S&#39;)
  (<span class="nv">p</span> : N = N&#39;) (<span class="nv">q</span> : S = S&#39;) (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">x</span>, f x @ q = p @ f&#39; x)
  : Susp_rec N S f == Susp_rec N&#39; S&#39; f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec N S f == Susp_rec N&#39; S&#39; f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec N S f == Susp_rec N&#39; S&#39; f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk26">snapply Susp_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec N S f North = Susp_rec N&#39; S&#39; f&#39; North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk27"><hr></label><div class="goal-conclusion">Susp_rec N S f South = Susp_rec N&#39; S&#39; f&#39; South</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk28"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (Susp_rec N S f) (merid x) @ <span class="nl">?HS</span> =
<span class="nl">?HN</span> @ ap (Susp_rec N&#39; S&#39; f&#39;) (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec N S f North = Susp_rec N&#39; S&#39; f&#39; North</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec N S f South = Susp_rec N&#39; S&#39; f&#39; South</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (Susp_rec N S f) (merid x) @ q =
p @ ap (Susp_rec N&#39; S&#39; f&#39;) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk2c"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec N S f) (merid x) @ q =
p @ ap (Susp_rec N&#39; S&#39; f&#39;) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk2d">lhs napply (Susp_rec_beta_merid x @@ <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x @ q = p @ ap (Susp_rec N&#39; S&#39; f&#39;) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk2e">rhs napply (<span class="mi">1</span> @@ Susp_rec_beta_merid x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S, N', S'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X -&gt; N&#39; = S&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>N = N&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>S = S&#39;</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ q = p @ f&#39; x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x @ q = p @ f&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And the special case where the two functions agree definitionally on [North] and [South]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk2f"><span class="kn">Definition</span> <span class="nf">Susp_rec_homotopic&#39;</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">N</span> <span class="nv">S</span> : Y)
  (<span class="nv">f</span> <span class="nv">g</span> : X -&gt; N = S) (<span class="nv">H</span> : f == g)
  : Susp_rec N S f == Susp_rec N S g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec N S f == Susp_rec N S g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec N S f == Susp_rec N S g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk31">snapply Susp_rec_homotopic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N = N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk32"><hr></label><div class="goal-conclusion">S = S</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk33"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ <span class="nl">?q</span> = <span class="nl">?p</span> @ g x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk34"><span class="mi">1</span>, <span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; N = S</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, f x @ <span class="mi">1</span> = <span class="mi">1</span> @ g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; <span class="nb">apply</span> equiv_p1_1q, H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Eta-rule. *)</span>

<span class="sd">(** The eta-rule for suspension states that any function out of a suspension is equal to one defined by [Susp_ind] in the obvious way. We give it first in a weak form, producing just a pointwise equality, and then turn this into an actual equality using [Funext]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk35"><span class="kn">Definition</span> <span class="nf">Susp_ind_eta_homotopic</span> {<span class="nv">X</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : Susp X -&gt; <span class="kt">Type</span>} (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">y</span>, P y)
  : f == Susp_ind P (f North) (f South) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; apD f (merid x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==
Susp_ind P (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==
Susp_ind P (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk37"><span class="nb">unfold</span> pointwise_paths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Susp X,
f x =
Susp_ind P (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; apD f (merid x0)) x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk38"><span class="nb">refine</span> (Susp_ind _ <span class="mi">1</span> <span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   f y =
   Susp_ind P (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; apD f (merid x0)) y) (merid x) <span class="mi">1</span> =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk39"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt;
   f y =
   Susp_ind P (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) y) (merid x) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk3a"><span class="nb">refine</span> (transport_paths_FlFr_D
    (g := Susp_ind P (f North) (f South) (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)))
    _ _ @ _); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((apD f (merid x))^ @ <span class="mi">1</span>) @
apD
  (Susp_ind P (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x))) (merid x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk3b"><span class="nb">apply</span> moveR_pM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD f (merid x))^ @ <span class="mi">1</span> =
<span class="mi">1</span> @
(apD
   (Susp_ind P (f North) (f South)
      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x))) (merid x))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk3c"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD f (merid x))^ =
(apD
   (Susp_ind P (f North) (f South)
      (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x))) (merid x))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk3d"><span class="nb">apply</span> ap, inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp X, P y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD
  (Susp_ind P (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x))) (merid x) =
apD f (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_ind_beta_merid _ _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk3e"><span class="kn">Definition</span> <span class="nf">Susp_rec_eta_homotopic</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Susp X -&gt; Y)
  : f == Susp_rec (f North) (f South) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap f (merid x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==
Susp_rec (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==
Susp_rec (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk40">snapply Susp_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f North =
Susp_rec (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x)) North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk41"><hr></label><div class="goal-conclusion">f South =
Susp_rec (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x)) South</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk42"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap f (merid x) @ <span class="nl">?HS</span> =
<span class="nl">?HN</span> @
ap
  (Susp_rec (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; ap f (merid x0))) (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk43"><span class="mi">1</span>, <span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap f (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @
ap
  (Susp_rec (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; ap f (merid x0))) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk44"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @
ap
  (Susp_rec (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk45"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (merid x) =
ap
  (Susp_rec (f North) (f South)
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_rec_beta_merid _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp_ind_eta</span> `{Funext}
  {X : <span class="kt">Type</span>} {P : Susp X -&gt; <span class="kt">Type</span>} (f : <span class="kr">forall</span> <span class="nv">y</span>, P y)
  : f = Susp_ind P (f North) (f South) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; apD f (merid x))
  := path_forall _ _ (Susp_ind_eta_homotopic f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp_rec_eta</span> `{Funext} {X Y : <span class="kt">Type</span>} (f : Susp X -&gt; Y)
  : f = Susp_rec (f North) (f South) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap f (merid x))
  := path_forall _ _ (Susp_rec_eta_homotopic f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk46"><span class="kn">Definition</span> <span class="nf">functor_susp</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y)
  : Susp X -&gt; Susp Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp X -&gt; Susp Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp X -&gt; Susp Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk48">srapply Susp_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk49"><hr></label><div class="goal-conclusion">Susp Y</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk4a"><hr></label><div class="goal-conclusion">X -&gt; <span class="nl">?H_N</span> = <span class="nl">?H_S</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> North.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> South.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; North = South</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">exact</span> (merid (f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk4e"><span class="kn">Definition</span> <span class="nf">functor_susp_beta_merid</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">x</span> : X)
  : ap (functor_susp f) (merid x) = merid (f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp f) (merid x) = merid (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp f) (merid x) = merid (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply Susp_rec_beta_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk50"><span class="kn">Definition</span> <span class="nf">functor_susp_compose</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>}
  (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">g</span> : Y -&gt; Z)
  : functor_susp (g o f) == functor_susp g o functor_susp f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp (g o f) ==
functor_susp g o functor_susp f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp (g o f) ==
functor_susp g o functor_susp f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk52">snapply Susp_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp (g o f) North =
(<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; functor_susp g (functor_susp f x))
  North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk53"><hr></label><div class="goal-conclusion">functor_susp (g o f) South =
(<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; functor_susp g (functor_susp f x))
  South</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk54"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (functor_susp (g o f)) (merid x) @ <span class="nl">?HS</span> =
<span class="nl">?HN</span> @
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : Susp X =&gt;
   functor_susp g (functor_susp f x0)) (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk55"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (functor_susp (g o f)) (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : Susp X =&gt;
   functor_susp g (functor_susp f x0)) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk56"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp (g o f)) (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; functor_susp g (functor_susp f x))
  (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk57"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (f x))) (merid x) =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; functor_susp g (functor_susp f x))
  (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk58">lhs napply functor_susp_beta_merid; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; functor_susp g (functor_susp f x))
  (merid x) = merid (g (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk59">lhs nrefine (ap_compose (functor_susp f) _ (merid x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp g) (ap (functor_susp f) (merid x)) =
merid (g (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk5a">lhs nrefine (ap _ (functor_susp_beta_merid _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp g) (merid (f x)) = merid (g (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> functor_susp_beta_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk5b"><span class="kn">Definition</span> <span class="nf">functor_susp_idmap</span> {<span class="nv">X</span>}
  : functor_susp idmap == (idmap : Susp X -&gt; Susp X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp idmap == (idmap : Susp X -&gt; Susp X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp idmap == (idmap : Susp X -&gt; Susp X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk5d">snapply Susp_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp idmap North = idmap North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk5e"><hr></label><div class="goal-conclusion">functor_susp idmap South = idmap South</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk5f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (functor_susp idmap) (merid x) @ <span class="nl">?HS</span> =
<span class="nl">?HN</span> @ ap idmap (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk60"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (functor_susp idmap) (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @ ap idmap (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk61"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp idmap) (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @ ap idmap (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk62"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp idmap) (merid x) = ap idmap (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk63">lhs napply functor_susp_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid x = ap idmap (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> ap_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk64"><span class="kn">Definition</span> <span class="nf">functor2_susp</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">f</span> <span class="nv">g</span> : X -&gt; Y} (<span class="nv">h</span> : f == g)
  : functor_susp f == functor_susp g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp f == functor_susp g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp f == functor_susp g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk66">srapply Susp_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp f North = functor_susp g North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk67"><hr></label><div class="goal-conclusion">functor_susp f South = functor_susp g South</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk68"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (functor_susp f) (merid x) @ <span class="nl">?HS</span> =
<span class="nl">?HN</span> @ ap (functor_susp g) (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk69"><span class="mi">1</span>, <span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
ap (functor_susp f) (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @ ap (functor_susp g) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk6a"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp f) (merid x) @ <span class="mi">1</span> =
<span class="mi">1</span> @ ap (functor_susp g) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk6b"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp f) (merid x) =
ap (functor_susp g) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk6c">lhs napply (functor_susp_beta_merid f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid (f x) = ap (functor_susp g) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk6d">rhs napply (functor_susp_beta_merid g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid (f x) = merid (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is0functor_susp</span> : Is0Functor Susp
  := Build_Is0Functor _ _ _ _ Susp (@functor_susp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is1functor_susp</span> : Is1Functor Susp
  := Build_Is1Functor _ _ _ _ _ _ _ _ _ _ Susp _
      (@functor2_susp) (@functor_susp_idmap) (@functor_susp_compose).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Universal property *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk6e"><span class="kn">Definition</span> <span class="nf">equiv_Susp_rec</span> `{Funext} (X Y : <span class="kt">Type</span>)
  : (Susp X -&gt; Y) &lt;~&gt; { NS : Y * Y &amp; X -&gt; fst NS = snd NS }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Susp X -&gt; Y) &lt;~&gt; {NS : Y * Y &amp; X -&gt; fst NS = snd NS}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Susp X -&gt; Y) &lt;~&gt; {NS : Y * Y &amp; X -&gt; fst NS = snd NS}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk70">snapply equiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Susp X -&gt; Y) -&gt; {NS : Y * Y &amp; X -&gt; fst NS = snd NS}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk71"><hr></label><div class="goal-conclusion">{NS : Y * Y &amp; X -&gt; fst NS = snd NS} -&gt; Susp X -&gt; Y</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk72"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk73"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk74">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Susp X -&gt; Y) -&gt; {NS : Y * Y &amp; X -&gt; fst NS = snd NS}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk75"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{NS : Y * Y &amp; X -&gt; fst NS = snd NS}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk76"><span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">North</span>, f South).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; fst (f North, f South) = snd (f North, f South)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="bp">exact</span> (ap f (merid x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk77">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{NS : Y * Y &amp; X -&gt; fst NS = snd NS} -&gt; Susp X -&gt; Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk78"><span class="nb">intros</span> [[N S] m].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>X -&gt; fst (N, S) = snd (N, S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp X -&gt; Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_rec N S m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : Susp X -&gt; Y =&gt;
 ((f North, f South); <span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x)))
o (<span class="kr">fun</span> <span class="nv">X0</span> : {NS : Y * Y &amp; X -&gt; fst NS = snd NS} =&gt;
   (<span class="kr">fun</span> <span class="nv">proj1</span> : Y * Y =&gt;
    (<span class="kr">fun</span> (<span class="nv">N</span> <span class="nv">S</span> : Y) (<span class="nv">m</span> : X -&gt; fst (N, S) = snd (N, S))
     =&gt; Susp_rec N S m) (fst proj1) (snd proj1)) X0.<span class="mi">1</span>
     X0.<span class="mi">2</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk7a"><span class="nb">intros</span> [[N S] m].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>X -&gt; fst (N, S) = snd (N, S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Susp_rec N S m North, Susp_rec N S m South);
<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap (Susp_rec N S m) (merid x)) =
((N, S); m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk7b"><span class="nb">apply</span> ap, path_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>N, S</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>X -&gt; fst (N, S) = snd (N, S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap (Susp_rec N S m) (merid x)) == m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> Susp_rec_beta_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk7c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">X0</span> : {NS : Y * Y &amp; X -&gt; fst NS = snd NS} =&gt;
 (<span class="kr">fun</span> <span class="nv">proj1</span> : Y * Y =&gt;
  (<span class="kr">fun</span> (<span class="nv">N</span> <span class="nv">S</span> : Y) (<span class="nv">m</span> : X -&gt; fst (N, S) = snd (N, S)) =&gt;
   Susp_rec N S m) (fst proj1) (snd proj1)) X0.<span class="mi">1</span> X0.<span class="mi">2</span>)
o (<span class="kr">fun</span> <span class="nv">f</span> : Susp X -&gt; Y =&gt;
   ((f North, f South); <span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk7d"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_rec (f North) (f South)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x)) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> Susp_rec_eta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Using wild 0-groupoids, the universal property can be proven without funext.  A simple equivalence of 0-groupoids between [Susp X -&gt; Y] and [{ NS : Y * Y &amp; X -&gt; fst NS = snd NS }] would not carry all the higher-dimensional information, but if we generalize it to dependent functions, then it does suffice. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UnivProp</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">X</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : Susp X -&gt; <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is the domain of the equivalence: sections of [P] over [Susp X]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp_ind_type</span> := <span class="kr">forall</span> <span class="nv">z</span>:Susp X, P z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** [isgraph_paths] is not a global instance, so we define this by hand.  The fact that this is a 01cat and a 0gpd is obtained using global instances. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk7e"><span class="kn">Local Instance</span> <span class="nf">isgraph_Susp_ind_type</span> : IsGraph Susp_ind_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGraph Susp_ind_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGraph Susp_ind_type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isgraph_forall; <span class="nb">intros</span>; <span class="nb">apply</span> isgraph_paths.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The codomain is a sigma-groupoid of this family, consisting of input data for [Susp_ind]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp_ind_data&#39;</span> (<span class="nv">NS</span> : P North * P South)
    := <span class="kr">forall</span> <span class="nv">x</span>:X, DPath P (merid x) (fst NS) (snd NS).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Again, the rest of the wild category structure is obtained using global instances. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk80"><span class="kn">Local Instance</span> <span class="nf">isgraph_Susp_ind_data&#39;</span> <span class="nv">NS</span> : IsGraph (Susp_ind_data&#39; NS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGraph (Susp_ind_data&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk81"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGraph (Susp_ind_data&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isgraph_forall; <span class="nb">intros</span>; <span class="nb">apply</span> isgraph_paths.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is the codomain itself.  This is a 01cat and a 0gpd via global instances. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp_ind_data</span> := sig Susp_ind_data&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is the functor. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk82"><span class="kn">Definition</span> <span class="nf">Susp_ind_inv</span> : Susp_ind_type -&gt; Susp_ind_data.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_type -&gt; Susp_ind_data</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_type -&gt; Susp_ind_data</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk84"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_data</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk85"><span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">North</span>,f South).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_data&#39; (f North, f South)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk86"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath P (merid x) (fst (f North, f South))
  (snd (f North, f South))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (apD f (merid x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk87"><span class="kn">Local Instance</span> <span class="nf">is0functor_susp_ind_inv</span> : Is0Functor Susp_ind_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor Susp_ind_inv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor Susp_ind_inv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk89"><span class="nb">constructor</span>; <span class="nb">unfold</span> Susp_ind_type; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : <span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z,
(<span class="kr">forall</span> <span class="nv">a0</span> : Susp X, a a0 = b a0) -&gt;
{p : (a North, a South) = (b North, b South) &amp;
<span class="kr">forall</span> <span class="nv">a0</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD a (merid x)) a0 = apD b (merid a0)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk8a"><span class="nb">intros</span> f g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : (f North, f South) = (g North, g South) &amp;
<span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a = apD g (merid a)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk8b"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f North, f South) = (g North, g South)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk8c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; <span class="nl">?p</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a = apD g (merid a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk8d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f North, f South) = (g North, g South)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk8e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39;
  (path_prod (f North, f South) (g North, g South)
     (p North) (p South))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a = apD g (merid a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk8f"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Susp_ind_data&#39;
  (path_prod (f North, f South) (g North, g South)
     (p North) (p South))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) x = apD g (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk90"><span class="nb">rewrite</span> transport_path_prod, !transport_forall_constant; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x0</span> : P North =&gt;
   transport P (merid x) x0 = g South) (p North)
  (transport
     (<span class="kr">fun</span> <span class="nv">x0</span> : P South =&gt;
      transport P (merid x) (f North) = x0) (p South)
     (apD f (merid x))) = apD g (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk91"><span class="nb">apply</span> ds_transport_dpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : Susp X, P z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare P (PathSquare.sq_refl_h (merid x))
  (apD f (merid x)) (apD g (merid x)) (p North)
  (p South)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (dp_apD_nat p (merid x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And now we can prove that it&#39;s an equivalence of 0-groupoids, using the definition from WildCat/EquivGpd. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk92"><span class="kn">Definition</span> <span class="nf">issurjinj_Susp_ind_inv</span> : IsSurjInj Susp_ind_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj Susp_ind_inv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk93"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj Susp_ind_inv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk94"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj Susp_ind_inv</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk95" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk95"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Susp_ind_type,
Susp_ind_inv x $== Susp_ind_inv y -&gt; x $== y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk96">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj Susp_ind_inv</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk97"><span class="nb">intros</span> [[n s] g].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; (n, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : Susp_ind_type &amp; Susp_ind_inv a $== ((n, s); g)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk98"><span class="kr">exists</span> (<span class="nv">Susp_ind</span> <span class="nv">P</span> <span class="nv">n</span> <span class="nv">s</span> <span class="nv">g</span>); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; (n, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p
: (Susp_ind P n s g North, Susp_ind P n s g South) =
  (n, s) &amp;
<span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD (Susp_ind P n s g) (merid x)) a =
g a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk99"><span class="kr">exists</span> <span class="nv">idpath</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; (n, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD (Susp_ind P n s g) (merid x)) a =
g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk9a"><span class="nb">intros</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; (n, s)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Susp_ind P n s g) (merid x) = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Susp_ind_beta_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk9b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Susp_ind_type,
Susp_ind_inv x $== Susp_ind_inv y -&gt; x $== y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk9c"><span class="nb">intros</span> f g [p q]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a =
apD g (merid a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Susp X, f a = g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk9d">srapply Susp_ind; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a =
apD g (merid a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f North = g North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk9e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a =
apD g (merid a)</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk9e"><hr></label><div class="goal-conclusion">f South = g South</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a =
apD g (merid a)</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk9f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; f y = g y) (merid x)
  <span class="nl">?Goal</span> = <span class="nl">?Goal0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka0"><span class="mi">1</span>: <span class="bp">exact</span> (ap fst p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a =
apD g (merid a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f South = g South</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a =
apD g (merid a)</span></span></span><br></div><label class="goal-separator" for="suspension-v-chka1"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; f y = g y) (merid x)
  (ap fst p) = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka2"><span class="mi">1</span>: <span class="bp">exact</span> (ap snd p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X,
transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) a =
apD g (merid a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; f y = g y) (merid x)
  (ap fst p) = ap snd p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka3"><span class="nb">intros</span> x; <span class="nb">specialize</span> (q x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) x =
apD g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; f y = g y) (merid x)
  (ap fst p) = ap snd p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka4"><span class="nb">apply</span> ds_dp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) x =
apD g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare P (PathSquare.sq_refl_h (merid x))
  (apD f (merid x)) (apD g (merid x)) (ap fst p)
  (ap snd p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka5"><span class="nb">apply</span> ds_transport_dpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport Susp_ind_data&#39; p
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; apD f (merid x)) x =
apD g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : P North =&gt; DPath P (merid x) y (g South))
  (ap fst p)
  (transport
     (<span class="kr">fun</span> <span class="nv">y</span> : P South =&gt; DPath P (merid x) (f North) y)
     (ap snd p) (apD f (merid x))) = apD g (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka6"><span class="nb">rewrite</span> transport_forall_constant <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x0</span> : P North * P South =&gt;
   DPath P (merid x) (fst x0) (snd x0)) p
  (apD f (merid x)) = apD g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : P North =&gt; DPath P (merid x) y (g South))
  (ap fst p)
  (transport
     (<span class="kr">fun</span> <span class="nv">y</span> : P South =&gt; DPath P (merid x) (f North) y)
     (ap snd p) (apD f (merid x))) = apD g (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka7"><span class="nb">rewrite</span> &lt;- (eta_path_prod p) <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x0</span> : P North * P South =&gt;
   DPath P (merid x) (fst x0) (snd x0))
  (path_prod (f North, f South) (g North, g South)
     (ap fst p) (ap snd p)) (apD f (merid x)) =
apD g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : P North =&gt; DPath P (merid x) y (g South))
  (ap fst p)
  (transport
     (<span class="kr">fun</span> <span class="nv">y</span> : P South =&gt; DPath P (merid x) (f North) y)
     (ap snd p) (apD f (merid x))) = apD g (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka8"><span class="nb">rewrite</span> transport_path_prod <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(f North, f South) = (g North, g South)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>transport
  (<span class="kr">fun</span> <span class="nv">x0</span> : P North =&gt;
   DPath P (merid x)
     (fst (x0, snd (g North, g South)))
     (snd (x0, snd (g North, g South))))
  (ap fst p)
  (transport
     (<span class="kr">fun</span> <span class="nv">y</span> : P South =&gt;
      DPath P (merid x)
        (fst (fst (f North, f South), y))
        (snd (fst (f North, f South), y)))
     (ap snd p) (apD f (merid x))) =
apD g (merid x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y</span> : P North =&gt; DPath P (merid x) y (g South))
  (ap fst p)
  (transport
     (<span class="kr">fun</span> <span class="nv">y</span> : P South =&gt; DPath P (merid x) (f North) y)
     (ap snd p) (apD f (merid x))) = apD g (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UnivProp</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The full non-funext version of the universal property should be formulated with respect to a notion of &quot;wild hom-oo-groupoid&quot;, which we don&#39;t currently have.  However, we can deduce statements about full higher universal properties that we do have, for instance the statement that a type is local for [functor_susp f] -- expressed in terms of [ooExtendableAlong] -- if and only if all its identity types are local for [f].  (We will use this in [Modalities.Localization] for separated subuniverses.)  To prove this, we again generalize it to the case of dependent types, starting with naturality of the above 0-dimensional universal property. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UnivPropNat</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We will show that [Susp_ind_inv] for [X] and [Y] commute with precomposition with [f] and [functor_susp f]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We recall these instances from the previous section. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> Existing Instances isgraph_Susp_ind_type isgraph_Susp_ind_data&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is an intermediate family of groupoids that we have to use, since precomposition with [f] doesn&#39;t land in quite the right place. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Susp_ind_data&#39;&#39;</span> (<span class="nv">NS</span> : P North * P South)
    := <span class="kr">forall</span> <span class="nv">x</span>:X, DPath P (merid (f x)) (fst NS) (snd NS).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This is a 01cat and a 0gpd via global instances. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chka9"><span class="kn">Local Instance</span> <span class="nf">isgraph_Susp_ind_data&#39;&#39;</span> <span class="nv">NS</span> : IsGraph (Susp_ind_data&#39;&#39; NS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGraph (Susp_ind_data&#39;&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGraph (Susp_ind_data&#39;&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isgraph_forall; <span class="nb">intros</span>; <span class="nb">apply</span> isgraph_paths.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We decompose &quot;precomposition with [f]&quot; into a functor_sigma of two fiberwise functors.  Here is the first. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_Susp_ind_data&#39;&#39;</span> (<span class="nv">NS</span> : P North * P South)
    : Susp_ind_data&#39; Y P NS -&gt; Susp_ind_data&#39;&#39; NS
    := <span class="kr">fun</span> <span class="nv">g</span> <span class="nv">x</span> =&gt; g (f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkab"><span class="kn">Local Instance</span> <span class="nf">is0functor_functor_Susp_ind_data&#39;&#39;</span> <span class="nv">NS</span>
    : Is0Functor (functor_Susp_ind_data&#39;&#39; NS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (functor_Susp_ind_data&#39;&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (functor_Susp_ind_data&#39;&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkad"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Susp_ind_data&#39; Y P NS,
(a $-&gt; b) -&gt;
functor_Susp_ind_data&#39;&#39; NS a $-&gt;
functor_Susp_ind_data&#39;&#39; NS b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkae"><span class="nb">intros</span> g h p a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; Y P NS</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Susp_ind_data&#39;&#39; NS g a $-&gt;
functor_Susp_ind_data&#39;&#39; NS h a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p (f a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And here is the second.  This one is actually a fiberwise equivalence of types at each [x]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkaf"><span class="kn">Definition</span> <span class="nf">equiv_Susp_ind_data&#39;</span> (<span class="nv">NS</span> : P North * P South) (<span class="nv">x</span> : X)
    : DPath P (merid (f x)) (fst NS) (snd NS)
      &lt;~&gt; DPath (P o functor_susp f) (merid x) (fst NS) (snd NS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath P (merid (f x)) (fst NS) (snd NS) &lt;~&gt;
DPath (P o functor_susp f) (merid x) (fst NS) (snd NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath P (merid (f x)) (fst NS) (snd NS) &lt;~&gt;
DPath (P o functor_susp f) (merid x) (fst NS) (snd NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb1"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath P (merid (f x)) (fst NS) (snd NS) &lt;~&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="suspension-v-chkb2"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt;
DPath (P o functor_susp f) (merid x) (fst NS) (snd NS)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath P (merid (f x)) (fst NS) (snd NS) &lt;~&gt; <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb4">napply (equiv_transport (<span class="kr">fun</span> <span class="nv">p</span> =&gt; DPath P p (fst NS) (snd NS))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid (f x) = <span class="nl">?Goal0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> functor_susp_beta_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath P (ap (functor_susp f) (merid x)) (fst NS)
  (snd NS) &lt;~&gt;
DPath (P o functor_susp f) (merid x) (fst NS) (snd NS)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb6"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath (P o functor_susp f) (merid x) (fst NS) (snd NS) &lt;~&gt;
DPath P (ap (functor_susp f) (merid x)) (fst NS)
  (snd NS)</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (dp_compose (functor_susp f) P (merid x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb7"><span class="kn">Definition</span> <span class="nf">functor_Susp_ind_data&#39;</span> (<span class="nv">NS</span> : P North * P South)
    : Susp_ind_data&#39;&#39; NS -&gt; Susp_ind_data&#39; X (P o functor_susp f) NS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_data&#39;&#39; NS -&gt;
Susp_ind_data&#39; X (P o functor_susp f) NS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_data&#39;&#39; NS -&gt;
Susp_ind_data&#39; X (P o functor_susp f) NS</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkb9">srapply (functor_forall idmap); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : X =&gt; DPath P (merid (f a)) (fst NS) (snd NS))
  (idmap x) -&gt;
(<span class="kr">fun</span> <span class="nv">b</span> : X =&gt;
 DPath (P o functor_susp f) (merid b) (fst NS)
   (snd NS)) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_Susp_ind_data&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkba"><span class="kn">Local Instance</span> <span class="nf">is0functor_functor_Susp_ind_data&#39;</span> <span class="nv">NS</span>
    : Is0Functor (functor_Susp_ind_data&#39; NS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (functor_Susp_ind_data&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (functor_Susp_ind_data&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkbc"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Susp_ind_data&#39;&#39; NS,
(a $-&gt; b) -&gt;
functor_Susp_ind_data&#39; NS a $-&gt;
functor_Susp_ind_data&#39; NS b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkbd"><span class="nb">intros</span> g h q x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39;&#39; NS</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Susp_ind_data&#39; NS g x $-&gt;
functor_Susp_ind_data&#39; NS h x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkbe"><span class="nb">cbn</span>; <span class="nb">apply</span> ap, ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39;&#39; NS</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g x = h x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (q x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And therefore a fiberwise equivalence of 0-groupoids. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkbf"><span class="kn">Local Instance</span> <span class="nf">issurjinj_functor_Susp_ind_data&#39;</span> <span class="nv">NS</span>
    : IsSurjInj (functor_Susp_ind_data&#39; NS).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj (functor_Susp_ind_data&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj (functor_Susp_ind_data&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc1"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (functor_Susp_ind_data&#39; NS)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chkc2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><label class="goal-separator" for="suspension-v-chkc2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Susp_ind_data&#39;&#39; NS,
functor_Susp_ind_data&#39; NS x $==
functor_Susp_ind_data&#39; NS y -&gt; x $== y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (functor_Susp_ind_data&#39; NS)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc4"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : Susp_ind_data&#39;&#39; NS &amp;
functor_Susp_ind_data&#39; NS a $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc5"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_data&#39;&#39; NS</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chkc6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br></div><label class="goal-separator" for="suspension-v-chkc6"><hr></label><div class="goal-conclusion">functor_Susp_ind_data&#39; NS <span class="nl">?a</span> $== g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_data&#39;&#39; NS</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc8"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath P (merid (f x)) (fst NS) (snd NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkc9"><span class="nb">apply</span> ((equiv_Susp_ind_data&#39; NS x)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x))
  (merid x) (fst NS) (snd NS)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (g x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkca">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Susp_ind_data&#39; NS
  ((<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (equiv_Susp_ind_data&#39; NS x)^-<span class="mi">1</span> (g x))
   :
   Susp_ind_data&#39;&#39; NS) $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkcb"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39; X
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)) NS</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Susp_ind_data&#39; NS
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; (equiv_Susp_ind_data&#39; NS x)^-<span class="mi">1</span> (g x))
  x $-&gt; g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkcc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Susp_ind_data&#39;&#39; NS,
functor_Susp_ind_data&#39; NS x $==
functor_Susp_ind_data&#39; NS y -&gt; x $== y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkcd"><span class="nb">intros</span> g h p x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39;&#39; NS</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>functor_Susp_ind_data&#39; NS g $==
functor_Susp_ind_data&#39; NS h</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g x $-&gt; h x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkce"><span class="nb">apply</span> (equiv_inj (equiv_Susp_ind_data&#39; NS x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Susp_ind_data&#39;&#39; NS</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>functor_Susp_ind_data&#39; NS g $==
functor_Susp_ind_data&#39; NS h</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_Susp_ind_data&#39; NS x (g x) =
equiv_Susp_ind_data&#39; NS x (h x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we put them together. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_Susp_ind_data</span>
    : Susp_ind_data Y P -&gt; Susp_ind_data X (P o functor_susp f)
    := <span class="kr">fun</span> <span class="nv">NSg</span> =&gt; (NSg.<span class="mi">1</span> ; (functor_Susp_ind_data&#39; NSg.<span class="mi">1</span> o
                             (functor_Susp_ind_data&#39;&#39; NSg.<span class="mi">1</span>)) NSg.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkcf"><span class="kn">Local Instance</span> <span class="nf">is0functor_functor_Susp_ind_data</span>
    : Is0Functor functor_Susp_ind_data.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor functor_Susp_ind_data</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor functor_Susp_ind_data</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (is0functor_sigma _ _
           (<span class="kr">fun</span> <span class="nv">NS</span> =&gt; functor_Susp_ind_data&#39; NS o functor_Susp_ind_data&#39;&#39; NS)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is the &quot;precomposition with [functor_susp f]&quot; functor. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_Susp_ind_type</span>
    : Susp_ind_type Y P -&gt; Susp_ind_type X (P o functor_susp f)
    := <span class="kr">fun</span> <span class="nv">g</span> =&gt; g o functor_susp f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd1"><span class="kn">Local Instance</span> <span class="nf">is0functor_functor_Susp_ind_type</span>
    : Is0Functor functor_Susp_ind_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor functor_Susp_ind_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor functor_Susp_ind_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd3"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Susp_ind_type Y P,
(a $-&gt; b) -&gt;
functor_Susp_ind_type a $-&gt; functor_Susp_ind_type b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd4"><span class="nb">intros</span> g h p a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Susp_ind_type Y P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Susp X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_Susp_ind_type g a $-&gt;
functor_Susp_ind_type h a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p (functor_susp f a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And here is the desired naturality square. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd5"><span class="kn">Definition</span> <span class="nf">Susp_ind_inv_nat</span>
    : (Susp_ind_inv X (P o functor_susp f)) o functor_Susp_ind_type
      $=&gt; functor_Susp_ind_data o (Susp_ind_inv Y P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_inv X (P o functor_susp f)
o functor_Susp_ind_type $=&gt;
functor_Susp_ind_data o Susp_ind_inv Y P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Susp_ind_inv X (P o functor_susp f)
o functor_Susp_ind_type $=&gt;
functor_Susp_ind_data o Susp_ind_inv Y P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd7"><span class="nb">intros</span> g; <span class="kr">exists</span> <span class="nv">idpath</span>; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type Y P</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (Susp_ind_data&#39; X
     (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x))) <span class="mi">1</span>
  (Susp_ind_inv X
     (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x))
     (functor_Susp_ind_type g)).<span class="mi">2</span> x $-&gt;
(functor_Susp_ind_data (Susp_ind_inv Y P g)).<span class="mi">2</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd8"><span class="nb">change</span> (apD (<span class="kr">fun</span> <span class="nv">x0</span> : Susp X =&gt; g (functor_susp f x0)) (merid x) =
            (functor_Susp_ind_data (Susp_ind_inv Y P g)).<span class="mi">2</span> x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type Y P</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (<span class="kr">fun</span> <span class="nv">x0</span> : Susp X =&gt; g (functor_susp f x0))
  (merid x) =
(functor_Susp_ind_data (Susp_ind_inv Y P g)).<span class="mi">2</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkd9"><span class="nb">refine</span> (dp_apD_compose (functor_susp f) P (merid x) g @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type Y P</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(dp_compose (functor_susp f) P (merid x))^-<span class="mi">1</span>
  (apD g (ap (functor_susp f) (merid x))) =
(functor_Susp_ind_data (Susp_ind_inv Y P g)).<span class="mi">2</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkda"><span class="nb">cbn</span>; <span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type Y P</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD g (ap (functor_susp f) (merid x)) =
transport
  (<span class="kr">fun</span> <span class="nv">p</span> : North = South =&gt;
   transport P p (g North) = g South)
  (functor_susp_beta_merid f x)^ (apD g (merid (f x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkdb"><span class="nb">apply</span> (moveL_transport_V (<span class="kr">fun</span> <span class="nv">p</span> =&gt; DPath P p (g North) (g South))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Susp_ind_type Y P</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">p</span> : North = South =&gt;
   DPath P p (g North) (g South))
  (functor_susp_beta_merid f x)
  (apD g (ap (functor_susp f) (merid x))) =
apD g (merid (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (apD (apD g) (functor_susp_beta_merid f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** From this we can deduce a equivalence between extendability, which is definitionally equal to split essential surjectivity of a functor between forall 0-groupoids. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkdc"><span class="kn">Definition</span> <span class="nf">extension_iff_functor_susp</span>
    : (<span class="kr">forall</span> <span class="nv">g</span>, ExtensionAlong (functor_susp f) P g)
      &lt;-&gt; (<span class="kr">forall</span> <span class="nv">NS</span> <span class="nv">g</span>, ExtensionAlong f (<span class="kr">fun</span> <span class="nv">x</span> =&gt; DPath P (merid x) (fst NS) (snd NS)) g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : Susp X, P (functor_susp f x),
 ExtensionAlong (functor_susp f) P g) &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkdd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : Susp X, P (functor_susp f x),
 ExtensionAlong (functor_susp f) P g) &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** The proof is by chaining logical equivalences. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkde"><span class="nb">transitivity</span> (SplEssSurj functor_Susp_ind_type).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : Susp X, P (functor_susp f x),
 ExtensionAlong (functor_susp f) P g) &lt;-&gt;
SplEssSurj functor_Susp_ind_type</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chkdf"><hr></label><div class="goal-conclusion">SplEssSurj functor_Susp_ind_type &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke0">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : Susp X, P (functor_susp f x),
 ExtensionAlong (functor_susp f) P g) &lt;-&gt;
SplEssSurj functor_Susp_ind_type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke1">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj functor_Susp_ind_type &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke2"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj functor_Susp_ind_type &lt;-&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chke3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chke3"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj functor_Susp_ind_type &lt;-&gt; <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke5"><span class="nb">refine</span> (isesssurj_iff_commsq Susp_ind_inv_nat); <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSurjInj (Susp_ind_inv Y P)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chke6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chke6"><hr></label><div class="goal-conclusion">IsSurjInj
  (Susp_ind_inv X
     (<span class="kr">fun</span> <span class="nv">x</span> : Susp X =&gt; P (functor_susp f x)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>:<span class="nb">apply</span> issurjinj_Susp_ind_inv.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj functor_Susp_ind_data &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chke8"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj functor_Susp_ind_data &lt;-&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chke9"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkea">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj functor_Susp_ind_data &lt;-&gt; <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isesssurj_iff_sigma _ _ 
                (<span class="kr">fun</span> <span class="nv">NS</span> =&gt; functor_Susp_ind_data&#39; NS o functor_Susp_ind_data&#39;&#39; NS)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkeb">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : P North * P South,
 SplEssSurj
   ((<span class="kr">fun</span> <span class="nv">NS</span> : P North * P South =&gt;
     functor_Susp_ind_data&#39; NS
     o functor_Susp_ind_data&#39;&#39; NS) a)) &lt;-&gt;
(<span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
 (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
      (<span class="kr">fun</span> <span class="nv">x0</span> : Y =&gt;
       DPath P (merid x0) (fst NS) (snd NS)) (f x)),
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))
   g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkec"><span class="nb">apply</span> iff_functor_forall; <span class="nb">intros</span> [N S]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp_ind_data&#39; Y P (N, S) =&gt;
   functor_Susp_ind_data&#39; (N, S)
     (functor_Susp_ind_data&#39;&#39; (N, S) x)) &lt;-&gt;
(<span class="kr">forall</span>
 <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X, transport P (merid (f x)) N = S,
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) N = S) g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chked"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp_ind_data&#39; Y P (N, S) =&gt;
   functor_Susp_ind_data&#39; (N, S)
     (functor_Susp_ind_data&#39;&#39; (N, S) x)) &lt;-&gt; <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><label class="goal-separator" for="suspension-v-chkee"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;-&gt;
(<span class="kr">forall</span>
 <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X, transport P (merid (f x)) N = S,
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) N = S) g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkef">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp_ind_data&#39; Y P (N, S) =&gt;
   functor_Susp_ind_data&#39; (N, S)
     (functor_Susp_ind_data&#39;&#39; (N, S) x)) &lt;-&gt; <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> iffL_isesssurj; <span class="bp">exact</span> _.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SplEssSurj (functor_Susp_ind_data&#39;&#39; (N, S)) &lt;-&gt;
(<span class="kr">forall</span>
 <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X, transport P (merid (f x)) N = S,
 ExtensionAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) N = S) g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We have to close the section now because we have to generalize [extension_iff_functor_susp] over [P]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UnivPropNat</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now we can iterate, deducing [n]-extendability. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf1"><span class="kn">Definition</span> <span class="nf">extendable_iff_functor_susp</span>
           {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>) (<span class="nv">n</span> : nat)
  : (ExtendableAlong n (functor_susp f) P)
    &lt;-&gt; (<span class="kr">forall</span> <span class="nv">NS</span>, ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> =&gt; DPath P (merid x) (fst NS) (snd NS))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ExtendableAlong n f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ExtendableAlong n f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf3"><span class="nb">revert</span> P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ExtendableAlong n f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf4"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn]; <span class="nb">intros</span> P; [ <span class="nb">split</span>; <span class="nb">intros</span>; <span class="bp">exact</span> tt | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n.+<span class="mi">1</span> (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ExtendableAlong n.+<span class="mi">1</span> f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** It would be nice to be able to do this proof by chaining logical equivalences too, especially since the two parts seem very similar.  But I haven&#39;t managed to make that work. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf5"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n.+<span class="mi">1</span> (functor_susp f) P -&gt;
<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chkf6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chkf6"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ExtendableAlong n.+<span class="mi">1</span> f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))) -&gt;
ExtendableAlong n.+<span class="mi">1</span> (functor_susp f) P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n.+<span class="mi">1</span> (functor_susp f) P -&gt;
<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkf8"><span class="nb">intros</span> [e1 en] [N S]; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : X,
    DPath P (merid (f a)) (fst (N, S)) (snd (N, S)),
ExtensionAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst (N, S)) (snd (N, S))) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chkf9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><label class="goal-separator" for="suspension-v-chkf9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">h</span>
 <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
     DPath P (merid b) (fst (N, S)) (snd (N, S)),
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkfa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : X,
    DPath P (merid (f a)) (fst (N, S)) (snd (N, S)),
ExtensionAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst (N, S)) (snd (N, S))) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkfb"><span class="nb">apply</span> extension_iff_functor_susp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : Susp X, P (functor_susp f x),
ExtensionAlong (functor_susp f) P g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> e1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkfc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">h</span>
 <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
     DPath P (merid b) (fst (N, S)) (snd (N, S)),
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkfd"><span class="nb">cbn</span>; <span class="nb">intros</span> h k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkfe"><span class="nb">pose</span> (h&#39; := Susp_ind P N S h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chkff"><span class="nb">pose</span> (k&#39; := Susp_ind P N S k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk100"><span class="nb">specialize</span> (en h&#39; k&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>en</var><span class="hyp-type"><b>: </b><span>ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h&#39; b = k&#39; b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk101"><span class="nb">assert</span> (IH := fst (IHn _) en (<span class="mi">1</span>,<span class="mi">1</span>)); <span class="nb">clear</span> IHn en.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h&#39; b = k&#39; b)
     (merid x) (fst (<span class="mi">1</span>, <span class="mi">1</span>)) (snd (<span class="mi">1</span>, <span class="mi">1</span>)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk102"><span class="nb">cbn</span> <span class="kr">in</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   transport (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h&#39; b = k&#39; b)
     (merid x) <span class="mi">1</span> = <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk103"><span class="nb">refine</span> (extendable_postcompose&#39; n _ _ f _ IH); <span class="nb">clear</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y,
transport (<span class="kr">fun</span> <span class="nv">b0</span> : Susp Y =&gt; h&#39; b0 = k&#39; b0) (merid b)
  <span class="mi">1</span> = <span class="mi">1</span> &lt;~&gt; h b = k b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk104"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h&#39; b = k&#39; b) (merid y) <span class="mi">1</span> =
<span class="mi">1</span> &lt;~&gt; h y = k y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk105"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h&#39; b = k&#39; b) (merid y) <span class="mi">1</span> =
<span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk106" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk106"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> &lt;~&gt; h y = k y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk107"><span class="mi">1</span>: napply ds_dp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare P (PathSquare.sq_refl_h (merid y))
  (apD h&#39; (merid y)) (apD k&#39; (merid y)) <span class="mi">1</span> <span class="mi">1</span> &lt;~&gt;
h y = k y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk108"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare P (PathSquare.sq_refl_h (merid y))
  (apD h&#39; (merid y)) (apD k&#39; (merid y)) <span class="mi">1</span> <span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk109" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk109"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> &lt;~&gt; h y = k y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk10a"><span class="mi">1</span>: <span class="nb">apply</span> ds_transport_dpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>h'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S h</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>k'</var><span><span class="hyp-body"><b>:= </b><span>Susp_ind P N S k</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Susp Y, P y</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y0</span> : P North =&gt; DPath P (merid y) y0 (k&#39; South))
  <span class="mi">1</span>
  (transport
     (<span class="kr">fun</span> <span class="nv">y0</span> : P South =&gt;
      DPath P (merid y) (h&#39; North) y0) <span class="mi">1</span>
     (apD h&#39; (merid y))) = apD k&#39; (merid y) &lt;~&gt;
h y = k y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk10b"><span class="nb">subst</span> h&#39; k&#39;; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Susp_ind P N S h) (merid y) =
apD (Susp_ind P N S k) (merid y) &lt;~&gt; h y = k y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk10c"><span class="nb">apply</span> equiv_concat_lr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h y = apD (Susp_ind P N S h) (merid y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk10d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk10d"><hr></label><div class="goal-conclusion">apD (Susp_ind P N S k) (merid y) = k y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk10e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h y = apD (Susp_ind P N S h) (merid y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk10f"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Susp_ind P N S h) (merid y) = h y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_ind_beta_merid P N S h y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk110">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>P North</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>P South</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, transport P (merid b) N = S</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Susp_ind P N S k) (merid y) = k y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Susp_ind_beta_merid P N S k y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk111">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ExtendableAlong n.+<span class="mi">1</span> f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))) -&gt;
ExtendableAlong n.+<span class="mi">1</span> (functor_susp f) P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk112"><span class="nb">intros</span> e; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk113" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk113"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk114">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : Susp X, P (functor_susp f a),
ExtensionAlong (functor_susp f) P g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk115"><span class="nb">apply</span> extension_iff_functor_susp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">NS</span> : P North * P South)
(<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : X,
     DPath P (merid (f x)) (fst NS) (snd NS)),
ExtensionAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> NS; <span class="bp">exact</span> (fst (e NS)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk116">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b,
ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk117"><span class="nb">intros</span> h k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (functor_susp f)
  (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk118"><span class="nb">apply</span> (IHn _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">NS</span> : (h North = k North) * (h South = k South),
ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b) (merid x)
     (fst NS) (snd NS))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk119"><span class="nb">intros</span> [p q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b) (merid x)
     (fst (p, q)) (snd (p, q)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk11a"><span class="nb">specialize</span> (e (h North, k South)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ExtendableAlong n.+<span class="mi">1</span> f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst (h North, k South))
     (snd (h North, k South)))</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b) (merid x)
     (fst (p, q)) (snd (p, q)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk11b"><span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">apply</span> snd <span class="kr">in</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   transport (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b) (merid x) p =
   q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk11c"><span class="nb">refine</span> (extendable_postcompose&#39; n _ _ f _ (e _ _)); <span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b) (merid y) p =
q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk11d"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b) (merid y) p =
q &lt;~&gt; <span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk11e"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">b</span> : Susp Y =&gt; h b = k b) (merid y) p =
q &lt;~&gt; <span class="nl">?Goal1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk11f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk11f"><hr></label><div class="goal-conclusion"><span class="nl">?Goal1</span> &lt;~&gt; <span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk120"><span class="mi">1</span>: napply ds_dp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare P (PathSquare.sq_refl_h (merid y))
  (apD h (merid y)) (apD k (merid y)) p q &lt;~&gt;
<span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk121"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare P (PathSquare.sq_refl_h (merid y))
  (apD h (merid y)) (apD k (merid y)) p q &lt;~&gt; <span class="nl">?Goal1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk122" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk122"><hr></label><div class="goal-conclusion"><span class="nl">?Goal1</span> &lt;~&gt; <span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk123"><span class="mi">1</span>: <span class="nb">apply</span> ds_transport_dpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y0</span> : P North =&gt; DPath P (merid y) y0 (k South))
  p
  (transport
     (<span class="kr">fun</span> <span class="nv">y0</span> : P South =&gt;
      DPath P (merid y) (h North) y0) q
     (apD h (merid y))) = apD k (merid y) &lt;~&gt;
<span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk124"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y0</span> : P North =&gt; DPath P (merid y) y0 (k South))
  p
  (transport
     (<span class="kr">fun</span> <span class="nv">y0</span> : P South =&gt;
      DPath P (merid y) (h North) y0) q
     (apD h (merid y))) = apD k (merid y) &lt;~&gt; <span class="nl">?Goal1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk125" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk125"><hr></label><div class="goal-conclusion"><span class="nl">?Goal1</span> &lt;~&gt; <span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk126"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">y0</span> : P North =&gt; DPath P (merid y) y0 (k South))
  p
  (transport
     (<span class="kr">fun</span> <span class="nv">y0</span> : P South =&gt;
      DPath P (merid y) (h North) y0) q
     (apD h (merid y))) = apD k (merid y) &lt;~&gt;
<span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk127"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>,
ExtendableAlong n (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; transport P (merid x) (fst NS) = snd NS))</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Susp Y, P b</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
<span class="nv">h0</span>
 <span class="nv">k0</span> : <span class="kr">forall</span> <span class="nv">b</span> : Y,
      transport P (merid b) (h North) = k South,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; h0 b = k0 b)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h North = k North</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>h South = k South</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> y = <span class="nl">?Goal0</span> y &lt;~&gt;
transport
  (<span class="kr">fun</span> <span class="nv">y0</span> : P North =&gt; DPath P (merid y) y0 (k South))
  p
  (transport
     (<span class="kr">fun</span> <span class="nv">y0</span> : P South =&gt;
      DPath P (merid y) (h North) y0) q
     (apD h (merid y))) = apD k (merid y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (equiv_moveR_transport_p (<span class="kr">fun</span> <span class="nv">y0</span> : P North =&gt; DPath P (merid y) y0 (k South))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As usual, deducing oo-extendability is trivial. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk128"><span class="kn">Definition</span> <span class="nf">ooextendable_iff_functor_susp</span>
           {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">P</span> : Susp Y -&gt; <span class="kt">Type</span>)
  : (ooExtendableAlong (functor_susp f) P)
    &lt;-&gt; (<span class="kr">forall</span> <span class="nv">NS</span>, ooExtendableAlong f (<span class="kr">fun</span> <span class="nv">x</span> =&gt; DPath P (merid x) (fst NS) (snd NS))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ooExtendableAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk129"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (functor_susp f) P &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
 ooExtendableAlong f
   (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk12a"><span class="nb">split</span>; <span class="nb">intros</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ooExtendableAlong (functor_susp f) P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ooExtendableAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk12b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ooExtendableAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk12b"><hr></label><div class="goal-conclusion">ooExtendableAlong (functor_susp f) P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk12c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ooExtendableAlong (functor_susp f) P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ooExtendableAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk12d"><span class="nb">intros</span> NS n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ooExtendableAlong (functor_susp f) P</span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk12e"><span class="nb">apply</span> extendable_iff_functor_susp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>ooExtendableAlong (functor_susp f) P</span></span></span><br><span><var>NS</var><span class="hyp-type"><b>: </b><span>P North * P South</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (functor_susp f) P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (e n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk12f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ooExtendableAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (functor_susp f) P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk130"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ooExtendableAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n (functor_susp f) P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk131"><span class="nb">apply</span> extendable_iff_functor_susp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Susp Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ooExtendableAlong f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt;
   DPath P (merid x) (fst NS) (snd NS))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">NS</span> : P North * P South,
ExtendableAlong n f
  (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; DPath P (merid x) (fst NS) (snd NS))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> NS; <span class="bp">exact</span> (e NS n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Nullhomotopies of maps out of suspensions *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk132"><span class="kn">Definition</span> <span class="nf">nullhomot_susp_from_paths</span> {<span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Susp X -&gt; Z)
  (<span class="nv">n</span> : NullHomotopy (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap f (merid x)))
: NullHomotopy f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk133"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk134"><span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">North</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Susp X, f x = f North</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk135"><span class="nb">refine</span> (Susp_ind _ <span class="mi">1</span> n.<span class="mi">1</span>^ _); <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">y</span> : Susp X =&gt; f y = f North) (merid x)
  <span class="mi">1</span> = (n.<span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk136"><span class="nb">refine</span> (transport_paths_Fl _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (merid x))^ @ <span class="mi">1</span> = (n.<span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk137"><span class="nb">apply</span> (concat (concat_p1 _)), ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap f (merid x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (merid x) = n.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> n.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk138"><span class="kn">Definition</span> <span class="nf">nullhomot_paths_from_susp</span> {<span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">H_N</span> <span class="nv">H_S</span> : Z) (<span class="nv">f</span> : X -&gt; H_N = H_S)
  (<span class="nv">n</span> : NullHomotopy (Susp_rec H_N H_S f))
: NullHomotopy f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk139"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk13a"><span class="kr">exists</span> (<span class="nv">n</span>.<span class="mi">2</span> North @ (n.<span class="mi">2</span> South)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X, f x = n.<span class="mi">2</span> North @ (n.<span class="mi">2</span> South)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk13b"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = n.<span class="mi">2</span> North @ (n.<span class="mi">2</span> South)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk13c"><span class="nb">apply</span> moveL_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x @ n.<span class="mi">2</span> South = n.<span class="mi">2</span> North</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk13d"><span class="nb">transitivity</span> (ap (Susp_rec H_N H_S f) (merid x) @ n.<span class="mi">2</span> South).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x @ n.<span class="mi">2</span> South =
ap (Susp_rec H_N H_S f) (merid x) @ n.<span class="mi">2</span> South</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk13e"><hr></label><div class="goal-conclusion">ap (Susp_rec H_N H_S f) (merid x) @ n.<span class="mi">2</span> South =
n.<span class="mi">2</span> North</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk13f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x @ n.<span class="mi">2</span> South =
ap (Susp_rec H_N H_S f) (merid x) @ n.<span class="mi">2</span> South</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> whiskerR, inverse, Susp_rec_beta_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk140">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Susp_rec H_N H_S f) (merid x) @ n.<span class="mi">2</span> South =
n.<span class="mi">2</span> North</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk141">lhs napply (concat_Ap n.<span class="mi">2</span> (merid x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.<span class="mi">2</span> North @ ap (<span class="kr">fun</span> <span class="nv">_</span> : Susp X =&gt; n.<span class="mi">1</span>) (merid x) =
n.<span class="mi">2</span> North</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk142">rhs_V napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H_N, H_S</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; H_N = H_S</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>NullHomotopy (Susp_rec H_N H_S f)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.<span class="mi">2</span> North @ ap (<span class="kr">fun</span> <span class="nv">_</span> : Susp X =&gt; n.<span class="mi">1</span>) (merid x) =
n.<span class="mi">2</span> North @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> whiskerL, ap_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Contractibility of the suspension *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk143"><span class="kn">Instance</span> <span class="nf">contr_susp</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `{Contr A}
  : Contr (Susp A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Susp A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk144"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Susp A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> Susp; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Connectedness of the suspension *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk145"><span class="kn">Instance</span> <span class="nf">isconnected_susp</span> {<span class="nv">n</span> : trunc_index} {<span class="nv">X</span> : <span class="kt">Type</span>}
  `{H : IsConnected n X} : IsConnected n.+<span class="mi">1</span> (Susp X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) (Susp X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk146"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) (Susp X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk147"><span class="nb">apply</span> isconnected_from_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
In (Tr n.+<span class="mi">1</span>) C -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : Susp X -&gt; C, NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk148"><span class="nb">intros</span> C H&#39; f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk149"><span class="kr">exists</span> (<span class="nv">f</span> <span class="nv">North</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Susp X, f x = f North</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk14a"><span class="nb">assert</span> ({ p0 : f North = f South &amp; <span class="kr">forall</span> <span class="nv">x</span>:X, ap f (merid x) = p0 })
    <span class="kr">as</span> [p0 allpath_p0] <span class="bp">by</span> (<span class="nb">apply</span> (isconnected_elim n); rapply H&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; C</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f North = f South</span></span></span><br><span><var>allpath_p0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (merid x) = p0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Susp X, f x = f North</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk14b"><span class="nb">apply</span> (Susp_ind (<span class="kr">fun</span> <span class="nv">a</span> =&gt; f a = f North) <span class="mi">1</span> p0^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; C</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f North = f South</span></span></span><br><span><var>allpath_p0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (merid x) = p0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">a</span> : Susp X =&gt; f a = f North) 
  (merid x) <span class="mi">1</span> = p0^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk14c"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; C</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f North = f South</span></span></span><br><span><var>allpath_p0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (merid x) = p0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">a</span> : Susp X =&gt; f a = f North) 
  (merid x) <span class="mi">1</span> = p0^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk14d"><span class="nb">apply</span> (concat (transport_paths_Fl _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; C</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f North = f South</span></span></span><br><span><var>allpath_p0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (merid x) = p0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (merid x))^ @ <span class="mi">1</span> = p0^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk14e"><span class="nb">apply</span> (concat (concat_p1 _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Susp X -&gt; C</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f North = f South</span></span></span><br><span><var>allpath_p0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, ap f (merid x) = p0</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (merid x))^ = p0^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, allpath_p0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Negation map *)</span>

<span class="sd">(** The negation map on the suspension is defined by sending [North] to [South] and vice versa, and acting by flipping on the meridians. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">susp_neg</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : Susp A -&gt; Susp A
  := Susp_rec South North (<span class="kr">fun</span> <span class="nv">a</span> =&gt; (merid a)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The negation map is an involution. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk14f"><span class="kn">Definition</span> <span class="nf">susp_neg_inv</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : susp_neg A o susp_neg A == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">susp_neg A o susp_neg A == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk150"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">susp_neg A o susp_neg A == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk151">snapply Susp_ind_FFlr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">susp_neg A (susp_neg A North) = North</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk152" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk152"><hr></label><div class="goal-conclusion">susp_neg A (susp_neg A South) = South</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk153" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk153"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
ap (susp_neg A) (ap (susp_neg A) (merid x)) @ <span class="nl">?HS</span> =
<span class="nl">?HN</span> @ merid x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk154"><span class="mi">1</span>, <span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
ap (susp_neg A) (ap (susp_neg A) (merid x)) @ <span class="mi">1</span> =
<span class="mi">1</span> @ merid x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk155"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg A) (ap (susp_neg A) (merid a)) @ <span class="mi">1</span> =
<span class="mi">1</span> @ merid a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk156"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg A) (ap (susp_neg A) (merid a)) = merid a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk157">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg A) (merid a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk158" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk158"><hr></label><div class="goal-conclusion">ap (susp_neg A) <span class="nl">?Goal</span> = merid a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk159"><span class="mi">1</span>: snapply Susp_rec_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg A) (merid a)^ = merid a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk15a">lhs napply (ap_V _ (merid a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (susp_neg A) (merid a))^ = merid a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk15b">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg A) (merid a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk15c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk15c"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span>^ = merid a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk15d"><span class="mi">1</span>: snapply Susp_rec_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((merid a)^)^ = merid a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply inv_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isequiv_susp_neg</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : IsEquiv (susp_neg A)
  := isequiv_involution (susp_neg A) (susp_neg_inv A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_susp_neg</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : Susp A &lt;~&gt; Susp A
  := Build_Equiv _ _ (susp_neg A) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** By using the suspension functor, we can also define another negation map on [Susp (Susp A))]. It turns out these are homotopic. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk15e"><span class="kn">Definition</span> <span class="nf">susp_neg_stable</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  : functor_susp (susp_neg A) == susp_neg (Susp A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp (susp_neg A) == susp_neg (Susp A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk15f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_susp (susp_neg A) == susp_neg (Susp A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk160">snapply Susp_ind_FlFr; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">North = South</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk161" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk161"><hr></label><div class="goal-conclusion">South = North</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk162" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk162"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Susp A,
ap (functor_susp (susp_neg A)) (merid x) @ <span class="nl">?Goal0</span> =
<span class="nl">?Goal</span> @ ap (susp_neg (Susp A)) (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk163">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">North = South</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (merid North).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk164">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">South = North</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (merid South)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk165">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Susp A,
ap (functor_susp (susp_neg A)) (merid x) @
(merid South)^ =
merid North @ ap (susp_neg (Susp A)) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk166"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Susp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp (susp_neg A)) (merid x) @
(merid South)^ =
merid North @ ap (susp_neg (Susp A)) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk167">lhs napply whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Susp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_susp (susp_neg A)) (merid x) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Susp A</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk168"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> @ (merid South)^ =
merid North @ ap (susp_neg (Susp A)) (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk169"><span class="mi">1</span>: napply functor_susp_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Susp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid (susp_neg A x) @ (merid South)^ =
merid North @ ap (susp_neg (Susp A)) (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk16a">rhs napply whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Susp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid (susp_neg A x) @ (merid South)^ =
merid North @ <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk16b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Susp A</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk16b"><hr></label><div class="goal-conclusion">ap (susp_neg (Susp A)) (merid x) = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk16c"><span class="mi">2</span>: napply Susp_rec_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Susp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid (susp_neg A x) @ (merid South)^ =
merid North @ (merid x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk16d"><span class="nb">revert</span> x; snapply Susp_ind_FlFr; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid South @ (merid South)^ =
merid North @ (merid North)^</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk16e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk16e"><hr></label><div class="goal-conclusion">merid North @ (merid South)^ =
merid North @ (merid South)^</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk16f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="suspension-v-chk16f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : Susp A =&gt;
   merid (susp_neg A x0) @ (merid South)^) (merid x) @
<span class="nl">?Goal0</span> =
<span class="nl">?Goal</span> @
ap (<span class="kr">fun</span> <span class="nv">x0</span> : Susp A =&gt; merid North @ (merid x0)^)
  (merid x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk170">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid South @ (merid South)^ =
merid North @ (merid North)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (concat_pV _ @ (concat_pV _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk171">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merid North @ (merid South)^ =
merid North @ (merid South)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk172">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
ap
  (<span class="kr">fun</span> <span class="nv">x0</span> : Susp A =&gt;
   merid (susp_neg A x0) @ (merid South)^) (merid x) @
<span class="mi">1</span> =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x0</span> : Susp A =&gt; merid North @ (merid x0)^)
  (merid x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk173"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt;
   merid (susp_neg A x) @ (merid South)^) (merid a) @
<span class="mi">1</span> =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^)
  (merid a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk174">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt;
   merid (susp_neg A x) @ (merid South)^) (merid a) =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^)
  (merid a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk175">lhs napply (ap_compose _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; merid y @ _) (merid a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : Susp A =&gt; merid y @ (merid South)^)
  (ap (susp_neg A) (merid a)) =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^)
  (merid a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk176">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg A) (merid a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk177" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk177"><hr></label><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : Susp A =&gt; merid y @ (merid South)^) <span class="nl">?Goal</span> =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^)
  (merid a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk178"><span class="mi">1</span>: napply Susp_rec_beta_merid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : Susp A =&gt; merid y @ (merid South)^)
  (merid a)^ =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^)
  (merid a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk179"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : Susp A =&gt; merid y @ (merid South)^)
  (merid a)^ =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^)
  (merid a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk17a"><span class="nb">generalize</span> (merid a) <span class="kr">as</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : North = South,
ap (<span class="kr">fun</span> <span class="nv">y</span> : Susp A =&gt; merid y @ (merid South)^) p^ =
(concat_pV (merid South) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk17b"><span class="nb">generalize</span> (@South A) <span class="kr">as</span> s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">s</span> : Susp A) (<span class="nv">p</span> : North = s),
ap (<span class="kr">fun</span> <span class="nv">y</span> : Susp A =&gt; merid y @ (merid s)^) p^ =
(concat_pV (merid s) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk17c"><span class="nb">intros</span> s p; <span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">y</span> : Susp A =&gt; merid y @ (merid North)^) <span class="mi">1</span>^ =
(concat_pV (merid North) @ (concat_pV (merid North))^) @
ap (<span class="kr">fun</span> <span class="nv">x</span> : Susp A =&gt; merid North @ (merid x)^) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk17d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> =
(concat_pV (merid North) @ (concat_pV (merid North))^) @
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk17e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(concat_pV (merid North) @ (concat_pV (merid North))^) @
<span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk17f">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concat_pV (merid North) @ (concat_pV (merid North))^ =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [susp_neg] is a natural equivalence on the suspension functor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk180"><span class="kn">Definition</span> <span class="nf">susp_neg_natural</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  : susp_neg B o functor_susp f == functor_susp f o susp_neg A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">susp_neg B o functor_susp f ==
functor_susp f o susp_neg A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk181"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">susp_neg B o functor_susp f ==
functor_susp f o susp_neg A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk182">snapply Susp_ind_FFlFFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">susp_neg B (functor_susp f North) =
functor_susp f (susp_neg A North)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="suspension-v-chk183" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk183"><hr></label><div class="goal-conclusion">susp_neg B (functor_susp f South) =
functor_susp f (susp_neg A South)</div></blockquote><input class="alectryon-extra-goal-toggle" id="suspension-v-chk184" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><label class="goal-separator" for="suspension-v-chk184"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
ap (susp_neg B) (ap (functor_susp f) (merid x)) @ <span class="nl">?HS</span> =
<span class="nl">?HN</span> @ ap (functor_susp f) (ap (susp_neg A) (merid x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk185"><span class="mi">1</span>, <span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
ap (susp_neg B) (ap (functor_susp f) (merid x)) @ <span class="mi">1</span> =
<span class="mi">1</span> @ ap (functor_susp f) (ap (susp_neg A) (merid x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk186"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg B) (ap (functor_susp f) (merid a)) @ <span class="mi">1</span> =
<span class="mi">1</span> @ ap (functor_susp f) (ap (susp_neg A) (merid a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk187"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg B) (ap (functor_susp f) (merid a)) =
ap (functor_susp f) (ap (susp_neg A) (merid a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk188">lhs napply (ap _ (Susp_rec_beta_merid _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg B) (merid (f a)) =
ap (functor_susp f) (ap (susp_neg A) (merid a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk189">rhs napply (ap _ (Susp_rec_beta_merid _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg B) (merid (f a)) =
ap (functor_susp f) (merid a)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk18a">rhs napply (ap_V _ (merid a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg B) (merid (f a)) =
(ap (functor_susp f) (merid a))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="suspension-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="suspension-v-chk18b">rhs napply (ap _ (Susp_rec_beta_merid _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (susp_neg B) (merid (f a)) = (merid (f a))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply Susp_rec_beta_merid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
