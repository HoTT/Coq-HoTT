<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Circle.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core Pointed.Loops Pointed.pEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HSet.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Int.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Coeq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core Truncations.Connectedness.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Theorems about the [Circle]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">X</span> A B f g n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* ** Definition of the [Circle]. *)</span>

<span class="sd">(** We define the circle as the coequalizer of two copies of the identity map of [Unit].  This is easily equivalent to the naive definition</span>

<span class="sd">&lt;&lt;</span>
<span class="sd">Private Inductive Circle : Type0 :=</span>
<span class="sd">| base : Circle</span>
<span class="sd">| loop : base = base.</span>
<span class="sd">&gt;&gt;</span>

<span class="sd">but it allows us to apply the flattening lemma directly rather than having to pass across that equivalence.  *)</span>

<span class="sd">(** The circle is defined to be the coequalizer of two copies of the identity map on [Unit]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Circle</span> := @Coeq Unit Unit idmap idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It has a basepoint. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">base</span> : Circle := coeq tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And a non-trivial path. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">loop</span> : base = base := cglue tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here is a notation for the circle that can be imported. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">CircleNotation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">S1</span> := Circle (<span class="kn">only parsing</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CircleNotation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Circle induction *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk1"><span class="kn">Definition</span> <span class="nf">Circle_ind</span> (<span class="nv">P</span> : Circle -&gt; <span class="kt">Type</span>)
  (<span class="nv">b</span> : P base) (<span class="nv">l</span> : loop # b = b)
  : <span class="kr">forall</span> (<span class="nv">x</span> : Circle), P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>Circle -&gt; <span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P base</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>transport P loop b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Circle, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>Circle -&gt; <span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P base</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>transport P loop b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Circle, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk3"><span class="nb">refine</span> (Coeq_ind P (<span class="kr">fun</span> <span class="nv">u</span> =&gt; transport P (ap coeq (path_unit tt u)) b) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>Circle -&gt; <span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P base</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>transport P loop b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b0</span> : Unit,
transport P (cglue b0)
  (transport P (ap coeq (path_unit tt b0)) b) =
transport P (ap coeq (path_unit tt b0)) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">exact</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Computation rule for circle induction. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Circle_ind_beta_loop</span> (<span class="nv">P</span> : Circle -&gt; <span class="kt">Type</span>)
  (<span class="nv">b</span> : P base) (<span class="nv">l</span> : loop # b = b)
  : apD (Circle_ind P b l) loop = l
  := Coeq_ind_beta_cglue P _ _ tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We mark [Circle], [base] and [loop] to never be simplified by [simpl] or [cbn] in order to hide how we defined it from the user. *)</span> 
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Circle : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> base : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> loop : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Circle_ind_beta_loop : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The recursion principle or non-dependent eliminator. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Circle_rec</span> (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : P) (<span class="nv">l</span> : b = b)
  : Circle -&gt; P
  := Circle_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) b (transport_const _ _ @ l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Computation rule for non-dependent eliminator. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk4"><span class="kn">Definition</span> <span class="nf">Circle_rec_beta_loop</span> (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">b</span> : P) (<span class="nv">l</span> : b = b)
  : ap (Circle_rec P b l) loop = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec P b l) loop = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec P b l) loop = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk6"><span class="nb">unfold</span> Circle_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Circle_ind (<span class="kr">fun</span> <span class="nv">_</span> : Circle =&gt; P) b
     (transport_const loop b @ l)) loop = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk7"><span class="nb">refine</span> (cancelL (transport_const loop b) _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_const loop b @
ap
  (Circle_ind (<span class="kr">fun</span> <span class="nv">_</span> : Circle =&gt; P) b
     (transport_const loop b @ l)) loop =
transport_const loop b @ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk8"><span class="nb">refine</span> ((apD_const (Circle_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) b _) loop)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD
  (Circle_ind (<span class="kr">fun</span> <span class="nv">_</span> : Circle =&gt; P) b
     (transport_const loop b @ l)) loop =
transport_const loop b @ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Circle_ind_beta_loop (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [Circle] is pointed by [base]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ispointed_Circle</span> : IsPointed Circle := base.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pCircle</span> : pType := [Circle, base].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The loop space of the [Circle] is the Integers [Int]</span>

<span class="sd">  This is the encode-decode style proof a la Licata-Shulman. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">EncodeDecode</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We assume univalence throughout this section. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** First we define the type of codes, this is a type family over the circle. This can be thought of as the covering space by the homotopical real numbers. It is defined by mapping loop to the path given by univalence applied to the automorphism of the integers. We will show that the section of this family at [base] is equivalent to the loop space of the circle. Giving us an equivalence [base = base &lt;~&gt; Int]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Circle_code</span> : Circle -&gt; <span class="kt">Type</span>
    := Circle_rec <span class="kt">Type</span> Int (path_universe int_succ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Transporting along [loop] gives us the successor automorphism on [Int]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk9"><span class="kn">Definition</span> <span class="nf">transport_Circle_code_loop</span> (<span class="nv">z</span> : Int)
    : transport Circle_code loop z = int_succ z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop z = z.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop z = z.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chkb"><span class="nb">refine</span> (transport_compose idmap Circle_code loop z @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (ap Circle_code loop) z = z.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chkc"><span class="nb">unfold</span> Circle_code; <span class="nb">rewrite</span> Circle_rec_beta_loop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe int_succ) z = z.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_path_universe.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Transporting along [loop^] gives us the predecessor on [Int]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chkd"><span class="kn">Definition</span> <span class="nf">transport_Circle_code_loopV</span> (<span class="nv">z</span> : Int)
    : transport Circle_code loop^ z = int_pred z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop^ z = z.-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop^ z = z.-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chkf"><span class="nb">refine</span> (transport_compose idmap Circle_code loop^ z @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (ap Circle_code loop^) z = z.-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk10"><span class="nb">rewrite</span> ap_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (ap Circle_code loop)^ z = z.-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk11"><span class="nb">unfold</span> Circle_code; <span class="nb">rewrite</span> Circle_rec_beta_loop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe int_succ)^ z = z.-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk12"><span class="nb">rewrite</span> &lt;- (path_universe_V int_succ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe int_succ^-<span class="mi">1</span>) z =
z.-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_path_universe.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** To turn a path in [Circle] based at [base] into a code we transport along it. We call this encoding. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Circle_encode</span> (<span class="nv">x</span>:Circle) : (base = x) -&gt; Circle_code x
    := <span class="kr">fun</span> <span class="nv">p</span> =&gt; p # zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** TODO: explain this proof in more detail. *)</span>
  <span class="sd">(** Turning a code into a path based at [base]. We call this decoding. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk13"><span class="kn">Definition</span> <span class="nf">Circle_decode</span> (<span class="nv">x</span> : Circle) : Circle_code x -&gt; (base = x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_code x -&gt; base = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_code x -&gt; base = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk15"><span class="nb">revert</span> x; <span class="nb">refine</span> (Circle_ind (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Circle_code x -&gt; base = x) (loopexp loop) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; Circle_code x -&gt; base = x) loop
  (loopexp loop) = loopexp loop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk16"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> z; <span class="nb">simpl</span> <span class="kr">in</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; Circle_code x -&gt; base = x) loop
  (loopexp loop) z = loopexp loop z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk17"><span class="nb">refine</span> (transport_arrow _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (paths base) loop
  (loopexp loop (transport Circle_code loop^ z)) =
loopexp loop z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk18"><span class="nb">refine</span> (transport_paths_r loop _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loopexp loop (transport Circle_code loop^ z) @ loop =
loopexp loop z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk19"><span class="nb">rewrite</span> transport_Circle_code_loopV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loopexp loop z.-<span class="mi">1</span>%int @ loop = loopexp loop z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk1a"><span class="nb">rewrite</span> loopexp_pred_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(loopexp loop z @ loop^) @ loop = loopexp loop z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_pV_p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The non-trivial part of the proof that decode and encode are equivalences is showing that decoding followed by encoding is the identity on the fibers over [base]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk1b"><span class="kn">Definition</span> <span class="nf">Circle_encode_loopexp</span> (<span class="nv">z</span> : Int)
    : Circle_encode base (loopexp loop z) = z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop z) = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop z) = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk1d"><span class="nb">induction</span> z <span class="kr">as</span> [|n | n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop <span class="mi">0</span>%int) = <span class="mi">0</span>%int</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>Circle_encode base (loopexp loop n) = n</span></span></span><br></div><label class="goal-separator" for="circle-v-chk1e"><hr></label><div class="goal-conclusion">Circle_encode base (loopexp loop n.+<span class="mi">1</span>%int) = n.+<span class="mi">1</span>%int</div></blockquote><input class="alectryon-extra-goal-toggle" id="circle-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>Circle_encode base (loopexp loop (- n)%int) = (- n)%int</span></span></span><br></div><label class="goal-separator" for="circle-v-chk1f"><hr></label><div class="goal-conclusion">Circle_encode base (loopexp loop (- n).-<span class="mi">1</span>%int) =
(- n).-<span class="mi">1</span>%int</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop <span class="mi">0</span>%int) = <span class="mi">0</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk21">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>Circle_encode base (loopexp loop n) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop n.+<span class="mi">1</span>%int) = n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk22"><span class="nb">rewrite</span> loopexp_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>Circle_encode base (loopexp loop n) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop n @ loop) = n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk23"><span class="nb">unfold</span> Circle_encode <span class="kr">in</span> IHz |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>transport Circle_code (loopexp loop n) <span class="mi">0</span>%int = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code (loopexp loop n @ loop) <span class="mi">0</span>%int =
n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk24"><span class="nb">rewrite</span> transport_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>transport Circle_code (loopexp loop n) <span class="mi">0</span>%int = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop
  (transport Circle_code (loopexp loop n) <span class="mi">0</span>%int) =
n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk25"><span class="nb">rewrite</span> IHz.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>transport Circle_code (loopexp loop n) <span class="mi">0</span>%int = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop n = n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_Circle_code_loop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>Circle_encode base (loopexp loop (- n)%int) = (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop (- n).-<span class="mi">1</span>%int) =
(- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk27"><span class="nb">rewrite</span> loopexp_pred_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>Circle_encode base (loopexp loop (- n)%int) = (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_encode base (loopexp loop (- n)%int @ loop^) =
(- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk28"><span class="nb">unfold</span> Circle_encode <span class="kr">in</span> IHz |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>transport Circle_code (loopexp loop (- n)%int) <span class="mi">0</span>%int = (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code (loopexp loop (- n)%int @ loop^)
  <span class="mi">0</span>%int = (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk29"><span class="nb">rewrite</span> transport_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>transport Circle_code (loopexp loop (- n)%int) <span class="mi">0</span>%int = (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop^
  (transport Circle_code (loopexp loop (- n)%int)
     <span class="mi">0</span>%int) = (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk2a"><span class="nb">rewrite</span> IHz.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHz</var><span class="hyp-type"><b>: </b><span>transport Circle_code (loopexp loop (- n)%int) <span class="mi">0</span>%int = (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport Circle_code loop^ (- n)%int = (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_Circle_code_loopV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we put it together. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk2b"><span class="kn">Definition</span> <span class="nf">Circle_encode_isequiv</span> (<span class="nv">x</span>:Circle) : IsEquiv (Circle_encode x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Circle_encode x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Circle_encode x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk2d"><span class="nb">refine</span> (isequiv_adjointify (Circle_encode x) (Circle_decode x) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Circle_code x =&gt;
 Circle_encode x (Circle_decode x x0)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><label class="goal-separator" for="circle-v-chk2e"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : base = x =&gt;
 Circle_decode x (Circle_encode x x0)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Here we induct on [x:Circle].  We just did the case when [x] is [base]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : Circle_code x =&gt;
 Circle_encode x (Circle_decode x x0)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk30"><span class="nb">refine</span> (Circle_ind (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (Circle_encode x) o (Circle_decode x) == idmap)
        Circle_encode_loopexp _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt;
   (<span class="kr">fun</span> <span class="nv">x0</span> : Circle_code x =&gt;
    Circle_encode x (Circle_decode x x0)) == idmap)
  loop Circle_encode_loopexp = Circle_encode_loopexp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      <span class="c">(* What remains is easy since [Int] is known to be a set. *)</span>
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> path_forall; <span class="nb">intros</span> z; <span class="nb">apply</span> hset_path2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* The other side is trivial by path induction. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x0</span> : base = x =&gt;
 Circle_decode x (Circle_encode x x0)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Finally giving us an equivalence between the loop space of the [Circle] and [Int]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_loopCircle_int</span> : (base = base) &lt;~&gt; Int
    := Build_Equiv _ _ (Circle_encode base) (Circle_encode_isequiv base).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">EncodeDecode</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Connectedness and truncatedness of the [Circle] *)</span>

<span class="sd">(** The circle is 0-connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk32"><span class="kn">Instance</span> <span class="nf">isconnected_Circle</span> `{Univalence} : IsConnected <span class="mi">0</span> Circle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) Circle</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) Circle</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk34"><span class="nb">apply</span> is0connected_merely_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely Circle</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="circle-v-chk35"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Circle, merely (x = y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk36"><span class="mi">1</span>: <span class="bp">exact</span> (tr base).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Circle, merely (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk37">srefine (Circle_ind _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Circle, merely (x = y))
  base</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="circle-v-chk38"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Circle, merely (x = y))
  loop <span class="nl">?b</span> = <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Circle, merely (x = y))
  base</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk3a"><span class="nb">simple refine</span> (Circle_ind _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; trunctype_type (merely (base = x)))
  base</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="circle-v-chk3b"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; merely (base = x)) loop
  <span class="nl">?b</span> = <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk3c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; trunctype_type (merely (base = x)))
  base</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tr <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk3d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; merely (base = x)) loop
  (tr <span class="mi">1</span>) = tr <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Circle, merely (x = y))
  loop
  (Circle_ind (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; merely (base = x))
     (tr <span class="mi">1</span>)
     (path_ishprop
        (transport
           (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; merely (base = x)) loop
           (tr <span class="mi">1</span>)) (tr <span class="mi">1</span>))) =
Circle_ind (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; merely (base = x))
  (tr <span class="mi">1</span>)
  (path_ishprop
     (transport (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt; merely (base = x))
        loop (tr <span class="mi">1</span>)) (tr <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that the circle is a 1-type. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk3f"><span class="kn">Instance</span> <span class="nf">istrunc_Circle</span> `{Univalence} : IsTrunc <span class="mi">1</span> Circle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> Circle</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> Circle</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk41"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Circle, IsHSet (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk42"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk43"><span class="nb">assert</span> (p := merely_path_is0connected Circle base x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>merely (base = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk44"><span class="nb">assert</span> (q := merely_path_is0connected Circle base y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>merely (base = x)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>merely (base = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk45">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Circle</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>base = y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>base = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk46"><span class="nb">destruct</span> p, q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (base = base)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_equiv_istrunc (n := <span class="mi">0</span>) Int equiv_loopCircle_int^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Iteration of equivalences *)</span>

<span class="sd">(** If [P : Circle -&gt; Type] is defined by a type [X] and an auto-equivalence [f], then the image of [n : Int] regarded as in [base = base] is [iter_int f n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk47"><span class="kn">Definition</span> <span class="nf">Circle_action_is_iter</span> `{Univalence} X (f : X &lt;~&gt; X) (n : Int) (x : X)
: transport (Circle_rec <span class="kt">Type</span> X (path_universe f)) (equiv_loopCircle_int^-<span class="mi">1</span> n) x
  = int_iter f n x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Circle_rec <span class="kt">Type</span> X (path_universe f))
  (equiv_loopCircle_int^-<span class="mi">1</span> n) x = int_iter f n x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Circle_rec <span class="kt">Type</span> X (path_universe f))
  (equiv_loopCircle_int^-<span class="mi">1</span> n) x = int_iter f n x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk49"><span class="nb">refine</span> (_ @ loopexp_path_universe _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Circle_rec <span class="kt">Type</span> X (path_universe f))
  (equiv_loopCircle_int^-<span class="mi">1</span> n) x =
transport idmap (loopexp (path_universe f) n) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk4a"><span class="nb">refine</span> (transport_compose idmap _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap
  (ap (Circle_rec <span class="kt">Type</span> X (path_universe f))
     (equiv_loopCircle_int^-<span class="mi">1</span> n)) x =
transport idmap (loopexp (path_universe f) n) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk4b"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; transport idmap p x) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec <span class="kt">Type</span> X (path_universe f))
  (equiv_loopCircle_int^-<span class="mi">1</span> n) =
loopexp (path_universe f) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk4c"><span class="nb">unfold</span> equiv_loopCircle_int; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec <span class="kt">Type</span> X (path_universe f))
  (Circle_decode base n) = loopexp (path_universe f) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk4d"><span class="nb">unfold</span> Circle_decode; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec <span class="kt">Type</span> X (path_universe f))
  (loopexp loop n) = loopexp (path_universe f) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk4e"><span class="nb">rewrite</span> ap_loopexp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">loopexp
  (ap (Circle_rec <span class="kt">Type</span> X (path_universe f)) loop) n =
loopexp (path_universe f) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk4f"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">p</span> =&gt; loopexp p n) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec <span class="kt">Type</span> X (path_universe f)) loop =
path_universe f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Circle_rec_beta_loop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The universal property of the circle (Lemma 6.2.9 in the Book).  We could deduce this from [isequiv_Coeq_rec], but it&#39;s nice to see a direct proof too. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Circle_rec_uncurried</span> (<span class="nv">P</span> : <span class="kt">Type</span>)
  : {b : P &amp; b = b} -&gt; (Circle -&gt; P)
  := <span class="kr">fun</span> <span class="nv">x</span> =&gt; Circle_rec P (pr1 x) (pr2 x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk50"><span class="kn">Instance</span> <span class="nf">isequiv_Circle_rec_uncurried</span> `{Funext} (P : <span class="kt">Type</span>) : IsEquiv (Circle_rec_uncurried P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Circle_rec_uncurried P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Circle_rec_uncurried P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk52">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Circle -&gt; P) -&gt; {b : P &amp; b = b}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="circle-v-chk53"><hr></label><div class="goal-conclusion">Circle_rec_uncurried P o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="circle-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="circle-v-chk54"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o Circle_rec_uncurried P == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk55">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Circle -&gt; P) -&gt; {b : P &amp; b = b}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">g</span> =&gt; (g base ; ap g loop)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_rec_uncurried P
o (<span class="kr">fun</span> <span class="nv">g</span> : Circle -&gt; P =&gt; (g base; ap g loop)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk57"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_rec_uncurried P (g base; ap g loop) = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk58"><span class="nb">apply</span> path_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Circle_rec_uncurried P (g base; ap g loop) == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk59">srapply Circle_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt;
 Circle_rec_uncurried P (g base; ap g loop) x = g x)
  base</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><label class="goal-separator" for="circle-v-chk5a"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt;
   Circle_rec_uncurried P (g base; ap g loop) x = g x)
  loop <span class="nl">?b</span> = <span class="nl">?b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk5b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt;
 Circle_rec_uncurried P (g base; ap g loop) x = g x)
  base</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk5c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : Circle =&gt;
   Circle_rec_uncurried P (g base; ap g loop) x = g x)
  loop <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk5d">transport_paths FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec_uncurried P (g base; ap g loop)) loop @
<span class="mi">1</span> = <span class="mi">1</span> @ ap g loop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk5e"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Circle -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec_uncurried P (g base; ap g loop)) loop =
ap g loop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Circle_rec_beta_loop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">g</span> : Circle -&gt; P =&gt; (g base; ap g loop))
o Circle_rec_uncurried P == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk60"><span class="nb">intros</span> [b p]; <span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>b = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Circle_rec_uncurried P (b; p)) loop = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Circle_rec_beta_loop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_Circle_rec</span> `{Funext} (P : <span class="kt">Type</span>)
  : {b : P &amp; b = b} &lt;~&gt; (Circle -&gt; P)
  := Build_Equiv _ _ _ (isequiv_Circle_rec_uncurried P).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A pointed version of the universal property of the circle. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk61"><span class="kn">Definition</span> <span class="nf">pmap_from_circle_loops</span> `{Funext} (X : pType)
  : (pCircle -&gt;** X) &lt;~&gt;* loops X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pCircle -&gt;** X) &lt;~&gt;* loops X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pCircle -&gt;** X) &lt;~&gt;* loops X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk63">snapply Build_pEquiv&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pCircle -&gt;** X) &lt;~&gt; loops X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="circle-v-chk64"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pCircle -&gt;** X) &lt;~&gt; loops X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk66"><span class="nb">refine</span> (_ oE (issig_pmap _ _)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pCircle -&gt; X &amp; f pt = pt} &lt;~&gt; loops X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk67">equiv_via { xp : { x : X &amp; x = x } &amp; xp.<span class="mi">1</span> = pt }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pCircle -&gt; X &amp; f pt = pt} &lt;~&gt;
{xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="circle-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="circle-v-chk68"><hr></label><div class="goal-conclusion">{xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt} &lt;~&gt; loops X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk69"><span class="mi">2</span>: make_equiv_contr_basedpaths.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : pCircle -&gt; X &amp; f pt = pt} &lt;~&gt;
{xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((equiv_functor_sigma_pb (equiv_Circle_rec X)^-<span class="mi">1</span>%equiv)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk6a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_composeR&#39;
   (equiv_functor_sigma_pb (equiv_Circle_rec X)^-<span class="mi">1</span>)
   (equiv_adjointify
      (<span class="kr">fun</span> <span class="nv">H0</span> : {xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt} =&gt;
       (<span class="kr">fun</span> <span class="nv">H1</span> : {x : X &amp; x = x} =&gt;
        (<span class="kr">fun</span> (<span class="nv">H2</span> : X) (<span class="nv">H3</span> : H2 = H2)
           (<span class="nv">H4</span> : (H2; H3).<span class="mi">1</span> = pt) =&gt;
         paths_ind_r pt
           (<span class="kr">fun</span> (<span class="nv">y</span> : X) (<span class="nv">_</span> : y = pt) =&gt;
            y = y -&gt; loops X)
           (<span class="kr">fun</span> <span class="nv">H5</span> : pt = pt =&gt; H5 : loops X) H2 H4 H3)
          H1.<span class="mi">1</span> H1.<span class="mi">2</span>) H0.<span class="mi">1</span> H0.<span class="mi">2</span>)
      (<span class="kr">fun</span> <span class="nv">H0</span> : loops X =&gt;
       ((<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1;
        H0
        :
        (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1) = (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1))
        :
        {x : X &amp; x = x};
       <span class="mi">1</span>%path
       :
       ((<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1;
        H0
        :
        (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1) = (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1))
        :
        {x : X &amp; x = x}).<span class="mi">1</span> = pt)
       :
       {xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt})
      ((<span class="kr">fun</span> <span class="nv">H0</span> : loops X =&gt; <span class="mi">1</span>%path)
       :
       (<span class="kr">fun</span> <span class="nv">H0</span> : {xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt} =&gt;
        (<span class="kr">fun</span> <span class="nv">H1</span> : {x : X &amp; x = x} =&gt;
         (<span class="kr">fun</span> (<span class="nv">H2</span> : X) (<span class="nv">H3</span> : H2 = H2)
            (<span class="nv">H4</span> : (H2; H3).<span class="mi">1</span> = pt) =&gt;
          paths_ind_r pt
            (<span class="kr">fun</span> (<span class="nv">y</span> : X) (<span class="nv">_</span> : y = pt) =&gt;
             y = y -&gt; loops X)
            (<span class="kr">fun</span> <span class="nv">H5</span> : pt = pt =&gt; H5 : loops X) H2 H4
            H3) H1.<span class="mi">1</span> H1.<span class="mi">2</span>) H0.<span class="mi">1</span> H0.<span class="mi">2</span>)
       o (<span class="kr">fun</span> <span class="nv">H0</span> : loops X =&gt;
          ((<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1;
           H0
           :
           (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1) = (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1))
           :
           {x : X &amp; x = x};
          <span class="mi">1</span>%path
          :
          ((<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1;
           H0
           :
           (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1) = (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1))
           :
           {x : X &amp; x = x}).<span class="mi">1</span> = pt)
          :
          {xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt}) == idmap)
      ((<span class="kr">fun</span> <span class="nv">H0</span> : {xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt} =&gt;
        (<span class="kr">fun</span> <span class="nv">H1</span> : {x : X &amp; x = x} =&gt;
         (<span class="kr">fun</span> (<span class="nv">H2</span> : X) (<span class="nv">H3</span> : H2 = H2)
            (<span class="nv">H4</span> : (H2; H3).<span class="mi">1</span> = pt) =&gt;
          paths_ind_r pt
            (<span class="kr">fun</span> (<span class="nv">y</span> : X) (<span class="nv">p</span> : y = pt) =&gt;
             <span class="kr">forall</span> <span class="nv">H5</span> : y = y,
             ((<span class="kr">let</span> <span class="nv">H6</span> := pt <span class="kr">in</span> H6;
              paths_ind_r pt (... =&gt; ...) idmap y p H5);
             <span class="mi">1</span>%path) = ((y; H5); p))
            (<span class="kr">fun</span> <span class="nv">H5</span> : pt = pt =&gt; <span class="mi">1</span>%path) H2 H4 H3)
           H1.<span class="mi">1</span> H1.<span class="mi">2</span>) H0.<span class="mi">1</span> H0.<span class="mi">2</span>)
       :
       (<span class="kr">fun</span> <span class="nv">H0</span> : loops X =&gt;
        ((<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1;
         H0
         :
         (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1) = (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1))
         :
         {x : X &amp; x = x};
        <span class="mi">1</span>%path
        :
        ((<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1;
         H0
         :
         (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1) = (<span class="kr">let</span> <span class="nv">H1</span> := pt <span class="kr">in</span> H1))
         :
         {x : X &amp; x = x}).<span class="mi">1</span> = pt)
        :
        {xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt})
       o (<span class="kr">fun</span> <span class="nv">H0</span> : {xp : {x : X &amp; x = x} &amp; xp.<span class="mi">1</span> = pt}
          =&gt;
          (<span class="kr">fun</span> <span class="nv">H1</span> : {x : X &amp; x = x} =&gt;
           (<span class="kr">fun</span> (<span class="nv">H2</span> : X) (<span class="nv">H3</span> : H2 = H2)
              (<span class="nv">H4</span> : (H2; H3).<span class="mi">1</span> = pt) =&gt;
            paths_ind_r pt
              (<span class="kr">fun</span> (<span class="nv">y</span> : X) (<span class="nv">_</span> : y = pt) =&gt;
               y = y -&gt; loops X)
              (<span class="kr">fun</span> <span class="nv">H5</span> : pt = pt =&gt; H5 : loops X) H2 H4
              H3) H1.<span class="mi">1</span> H1.<span class="mi">2</span>) H0.<span class="mi">1</span> H0.<span class="mi">2</span>) == idmap))
 oE (issig_pmap pCircle X)^-<span class="mi">1</span>) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="circle-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="circle-v-chk6b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">_</span> : Circle =&gt; pt) loop = pt</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
