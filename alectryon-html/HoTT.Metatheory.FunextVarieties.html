<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>FunextVarieties.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Varieties of function extensionality *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Metatheory.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In the Overture, we defined function extensionality to be the assertion that the map [apD10] is an equivalence.   We now prove that this follows from a couple of weaker-looking forms of function extensionality.  We do require eta conversion, which Coq 8.4+ has judgmentally.</span>

<span class="sd">   This proof is originally due to Voevodsky; it has since been simplified by Peter Lumsdaine and Michael Shulman. *)</span>

<span class="sd">(** Naive funext is the simple assertion that pointwise equal functions are equal.  The domain and codomain could live in different universes; the third universe argument is essentially the max of [i] and [j] (and similarly for all subsequent axioms). *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NaiveFunext</span> :=
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>@{j}) (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x),
    (<span class="kr">forall</span> <span class="nv">x</span>, f x = g x) -&gt; (f = g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Naive non-dependent funext is the same, but only for non-dependent functions.  *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NaiveNondepFunext</span> :=
  <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B),
    (<span class="kr">forall</span> <span class="nv">x</span>, f x = g x) -&gt; (f = g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Weak funext says that a product of contractible types is contractible. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">WeakFunext</span> :=
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
    (<span class="kr">forall</span> <span class="nv">x</span>, Contr (P x)) -&gt; Contr (<span class="kr">forall</span> <span class="nv">x</span>, P x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The obvious implications are</span>
<span class="sd">   [Funext -&gt; NaiveFunext -&gt; WeakFunext] and [NaiveFunext -&gt; NaiveNondepFunext].</span>
<span class="sd">   None of these do anything fiddly with the universes either. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk1"><span class="kn">Definition</span> <span class="nf">Funext_implies_NaiveFunext</span>@{i j max}
  : Funext_type@{i j max} -&gt; NaiveFunext@{i j max}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Funext_type -&gt; NaiveFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Funext_type -&gt; NaiveFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk3"><span class="nb">intros</span> fe A P f g h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fe</var><span class="hyp-type"><b>: </b><span>Funext_type</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk4"><span class="nb">unfold</span> Funext_type <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fe</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
(<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, P x), IsEquiv apD10</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, f x = g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((@apD10 A P f g)^-<span class="mi">1</span> h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk5"><span class="kn">Definition</span> <span class="nf">NaiveFunext_implies_WeakFunext</span>@{i j max}
  : NaiveFunext@{i j max} -&gt; WeakFunext@{i j max}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NaiveFunext -&gt; WeakFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NaiveFunext -&gt; WeakFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk7"><span class="nb">intros</span> nf A P Pc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>nf</var><span class="hyp-type"><b>: </b><span>NaiveFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (<span class="kr">forall</span> <span class="nv">x</span> : A, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk8"><span class="nb">apply</span> (Build_Contr _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; center (P x))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>nf</var><span class="hyp-type"><b>: </b><span>NaiveFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, P x,
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; center (P x)) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk9"><span class="nb">intros</span> f; <span class="nb">apply</span> nf; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>nf</var><span class="hyp-type"><b>: </b><span>NaiveFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Pc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center (P x) = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NaiveFunext_implies_NaiveNondepFunext</span>@{i j max}
  : NaiveFunext@{i j max} -&gt; NaiveNondepFunext@{i j max}
  := <span class="kr">fun</span> <span class="nv">nf</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; nf A (<span class="kr">fun</span> <span class="nv">_</span> =&gt; B) f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The non-obvious directions are that [WeakFunext] implies Funext and that [NaiveNondepFunext] implies [WeakFunext] (and hence all four are logically equivalent). *)</span>

<span class="sd">(** ** [WeakFunext] implies [Funext] *)</span>

<span class="sd">(** To show that [WeakFunext] implies Funext, the point is that under weak funext, the space of &quot;pointwise homotopies&quot; has the same universal property as the space of paths. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Homotopies</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">wf</span> : WeakFunext).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span>:<span class="kt">Type</span>} {<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Recall that [f == g] is the type of pointwise paths (or &quot;homotopies&quot;) from [f] to [g]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Let</span> <span class="nf">idhtpy</span> : f == f := <span class="kr">fun</span> <span class="nv">x</span> =&gt; idpath (f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Weak funext implies that the &quot;based homotopy space&quot; of the Pi-type is contractible, just like the based path space. *)</span>
  <span class="sd">(** Use priority 1, so we don&#39;t override [Contr Unit]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chka">#[export] <span class="kn">Instance</span> <span class="nf">contr_basedhtpy</span> : Contr {g : <span class="kr">forall</span> <span class="nv">x</span>, B x &amp; f == g } | <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chkc"><span class="nb">unfold</span> WeakFunext <span class="kr">in</span> <span class="kn">wf</span>.    <span class="c">(* Allow typeclass inference to find it *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)) -&gt;
Contr (<span class="kr">forall</span> <span class="nv">x</span> : A, P x)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chkd"><span class="nb">apply</span> (Build_Contr _ (f;idhtpy)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)) -&gt;
Contr (<span class="kr">forall</span> <span class="nv">x</span> : A, P x)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : {x : _ &amp; f == x}, (f; idhtpy) = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chke"><span class="nb">intros</span> [g h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)) -&gt;
Contr (<span class="kr">forall</span> <span class="nv">x</span> : A, P x)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f; idhtpy) = (g; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* The trick is to show that the type [{g : forall x, B x &amp; f == g }] is a retract of [forall x, {y : B x &amp; f x = y}], which is contractible due to J and weak funext.  Here are the retraction and its section. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chkf"><span class="nb">pose</span> (r := <span class="kr">fun</span> <span class="nv">k</span> =&gt; exist (<span class="kr">fun</span> <span class="nv">g</span> =&gt; f == g)
      (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (k x).<span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (k x).<span class="mi">2</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)) -&gt;
Contr (<span class="kr">forall</span> <span class="nv">x</span> : A, P x)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0} =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (k x).<span class="mi">1</span>; <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (k x).<span class="mi">2</span>)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0}) -&gt;
{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f; idhtpy) = (g; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk10"><span class="nb">pose</span> (s := <span class="kr">fun</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x) (<span class="nv">h</span> : f == g) <span class="nv">x</span> =&gt; (g x ; h x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)) -&gt;
Contr (<span class="kr">forall</span> <span class="nv">x</span> : A, P x)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0} =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (k x).<span class="mi">1</span>; <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (k x).<span class="mi">2</span>)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0}) -&gt;
{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">h</span> : f == g) (<span class="nv">x</span> : A) =&gt;
(g x; h x)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x,
f == g -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f; idhtpy) = (g; h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Because of judgemental eta-conversion, the retraction is actually definitional, so we can just replace the goal. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk11"><span class="nb">change</span> (r (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (f x ; idpath (f x))) = r (s g h)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)) -&gt;
Contr (<span class="kr">forall</span> <span class="nv">x</span> : A, P x)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>idhtpy</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>f == f</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0} =&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (k x).<span class="mi">1</span>; <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (k x).<span class="mi">2</span>)</span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0}) -&gt;
{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></span></span></span><br><span><var>s</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">h</span> : f == g) (<span class="nv">x</span> : A) =&gt;
(g x; h x)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x,
f == g -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, {x0 : _ &amp; f x = x0}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (f x; <span class="mi">1</span>)) = r (s g h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap; srapply path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This enables us to prove that pointwise homotopies have the same elimination rule as the identity type. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">Q</span> : <span class="kr">forall</span> <span class="nv">g</span> (<span class="nv">h</span> : f == g), <span class="kt">Type</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">d</span> : Q f idhtpy).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">htpy_ind</span> <span class="nv">g</span> <span class="nv">h</span> : Q g h
    := @transport _ (<span class="kr">fun</span> <span class="nv">gh</span> =&gt; Q gh.<span class="mi">1</span> gh.<span class="mi">2</span>) (f;idhtpy) (g;h)
         (@path_contr _ _ _ _) d.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The computation rule, of course, is only propositional. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">htpy_ind_beta</span> : htpy_ind f idhtpy = d
    := transport (<span class="kr">fun</span> <span class="nv">p</span> : (f;idhtpy) = (f;idhtpy) =&gt;
                    transport (<span class="kr">fun</span> <span class="nv">gh</span> =&gt; Q gh.<span class="mi">1</span> gh.<span class="mi">2</span>) p d = d)
         (@path2_contr _ _ _ _
           (path_contr (f;idhtpy) (f;idhtpy)) (idpath _))^
         (idpath _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Homotopies</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now the proof is fairly easy; we can just use the same induction principle on both sides.  This proof also preserves all the universes. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk12"><span class="kn">Theorem</span> <span class="nf">WeakFunext_implies_Funext</span>@{i j max}
  : WeakFunext@{i j max} -&gt; Funext_type@{i j max}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">WeakFunext -&gt; Funext_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">WeakFunext -&gt; Funext_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk14"><span class="nb">intros</span> <span class="kn">wf</span>; <span class="nb">hnf</span>; <span class="nb">intros</span> A B f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv apD10</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk15"><span class="nb">refine</span> (isequiv_adjointify (@apD10 A B f g)
    (htpy_ind <span class="kn">wf</span> f (<span class="kr">fun</span> <span class="nv">g&#39;</span> <span class="nv">_</span> =&gt; f = g&#39;) idpath g) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : f == g =&gt;
 apD10
   (htpy_ind <span class="kn">wf</span> f
      (<span class="kr">fun</span> (<span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) (<span class="nv">_</span> : f == g&#39;) =&gt;
       f = g&#39;) <span class="mi">1</span> g x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="funextvarieties-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><label class="goal-separator" for="funextvarieties-v-chk16"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : f = g =&gt;
 htpy_ind <span class="kn">wf</span> f
   (<span class="kr">fun</span> (<span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) (<span class="nv">_</span> : f == g&#39;) =&gt;
    f = g&#39;) <span class="mi">1</span> g (apD10 x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : f == g =&gt;
 apD10
   (htpy_ind <span class="kn">wf</span> f
      (<span class="kr">fun</span> (<span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) (<span class="nv">_</span> : f == g&#39;) =&gt;
       f = g&#39;) <span class="mi">1</span> g x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk18"><span class="nb">revert</span> g; <span class="nb">refine</span> (htpy_ind <span class="kn">wf</span> _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD10
  (htpy_ind <span class="kn">wf</span> f
     (<span class="kr">fun</span> (<span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">_</span> : f == g&#39;) =&gt;
      f = g&#39;) <span class="mi">1</span> f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span>)) = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (ap _ (htpy_ind_beta <span class="kn">wf</span> _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : f = g =&gt;
 htpy_ind <span class="kn">wf</span> f
   (<span class="kr">fun</span> (<span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, B x0) (<span class="nv">_</span> : f == g&#39;) =&gt;
    f = g&#39;) <span class="mi">1</span> g (apD10 x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk1a"><span class="nb">intros</span> h; <span class="nb">destruct</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>wf</var><span class="hyp-type"><b>: </b><span>WeakFunext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">htpy_ind <span class="kn">wf</span> f
  (<span class="kr">fun</span> (<span class="nv">g&#39;</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, B x) (<span class="nv">_</span> : f == g&#39;) =&gt;
   f = g&#39;) <span class="mi">1</span> f (apD10 <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (htpy_ind_beta <span class="kn">wf</span> _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NaiveFunext_implies_Funext</span> : NaiveFunext -&gt; Funext_type
  := WeakFunext_implies_Funext o NaiveFunext_implies_WeakFunext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Naive non-dependent funext implies weak funext  *)</span>

<span class="sd">(** First we show that naive non-dependent funext suffices to show that postcomposition with an equivalence is an equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_postcompose_from_NaiveNondepFunext</span>
           (<span class="nv">nf</span> : NaiveNondepFunext) {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B &lt;~&gt; C)
  : (A -&gt; B) &lt;~&gt; (A -&gt; C)
  := Build_Equiv
       _ _ (<span class="kr">fun</span> (<span class="nv">g</span>:A-&gt;B) =&gt; f o g)
       (isequiv_adjointify
          (<span class="kr">fun</span> (<span class="nv">g</span>:A-&gt;B) =&gt; f o g)
          (<span class="kr">fun</span> <span class="nv">h</span> =&gt; f^-<span class="mi">1</span> o h)
          (<span class="kr">fun</span> <span class="nv">h</span> =&gt; nf _ _ _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; eisretr f (h x)))
          (<span class="kr">fun</span> <span class="nv">g</span> =&gt; nf _ _ _ _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; eissect f (g y)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Now, if each [P x] is contractible, the projection [pr1 : {x:X &amp; P x} -&gt; X] is an equivalence (this requires no funext).  Thus, postcomposition with it is also an equivalence, and hence the fiber of postcomposition over [idmap X] is contractible.  But this fiber is &quot;the type of sections of [pr1]&quot; and hence equivalent to [forall x:X, P x].  The latter equivalence requires full funext to prove, but without any funext we can show that [forall x:X, P x] is a *retract* of the type of sections, hence also contractible. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk1b"><span class="kn">Theorem</span> <span class="nf">NaiveNondepFunext_implies_WeakFunext</span>
  : NaiveNondepFunext -&gt; WeakFunext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NaiveNondepFunext -&gt; WeakFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NaiveNondepFunext -&gt; WeakFunext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk1d"><span class="nb">intros</span> nf X P H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>nf</var><span class="hyp-type"><b>: </b><span>NaiveNondepFunext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Contr (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (<span class="kr">forall</span> <span class="nv">x</span> : X, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk1e"><span class="nb">pose</span> (T := (hfiber (equiv_postcompose_from_NaiveNondepFunext nf (equiv_pr1 P)) idmap)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>nf</var><span class="hyp-type"><b>: </b><span>NaiveNondepFunext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, Contr (P x)</span></span></span><br><span><var>T</var><span><span class="hyp-body"><b>:= </b><span>hfiber
  (equiv_postcompose_from_NaiveNondepFunext nf
     (equiv_pr1 P)) idmap</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (<span class="kr">forall</span> <span class="nv">x</span> : X, P x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@contr_retract T _ _
           (<span class="kr">fun</span> <span class="nv">fp</span> <span class="nv">x</span> =&gt; transport P (ap10 fp.<span class="mi">2</span> x) (fp.<span class="mi">1</span> x).<span class="mi">2</span>)
           (<span class="kr">fun</span> <span class="nv">f</span> =&gt; ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x ; f x)) ; <span class="mi">1</span>)) (<span class="kr">fun</span> <span class="nv">f</span> =&gt; <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Therefore, naive non-dependent funext also implies full funext.  Interestingly, this requires the universe of the assumption codomain to be not just that of the conclusion codomain, but the max of that universe with the domain universe (which is unchanged). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NaiveNondepFunext_implies_Funext</span>@{i j max}
  : NaiveNondepFunext@{i max max} -&gt; Funext_type@{i j max}
  := WeakFunext_implies_Funext o NaiveNondepFunext_implies_WeakFunext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functional extensionality is downward closed *)</span>

<span class="sd">(** If universe [U_i] is functionally extensional, then so are universes [U_i&#39;] for [i&#39; ‚â§ i]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk1f"><span class="kn">Lemma</span> <span class="nf">Funext_downward_closed</span>@{i j max i&#39; j&#39; max&#39; | i &lt;= max, j &lt;= max, i&#39; &lt;= max&#39;, j&#39; &lt;= max&#39;, i&#39; &lt;= i, j&#39; &lt;= j}
  `{H : Funext_type@{i j max}} : Funext_type@{i&#39; j&#39; max&#39;}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Funext_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext_type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Funext_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="funextvarieties-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="funextvarieties-v-chk21"><span class="nb">hnf</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
(<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, P x), IsEquiv apD10</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
(<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, P x), IsEquiv apD10</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Here we make use of cumulativity. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">A</span> <span class="nv">P</span> =&gt; H A P).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
