<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Cofiber.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Tactics Basics.PathGroupoids Basics.Trunc Basics.Equivalences.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Unit Types.Paths Types.<span class="kn">Universe</span> <span class="nf">Types</span>.Sigma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core Truncations.Connectedness.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Pushout Homotopy.Suspension.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.NullHomotopy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HFiber Limits.Pullback BlakersMassey.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Homotopy Cofibers *)</span>

<span class="sd">(** ** Definition *)</span>

<span class="sd">(** Homotopy cofibers or mapping cones are spaces constructed from a map [f : X -&gt; Y] by contracting the image of [f] inside [Y] to a point. They can be thought of as a kind of coimage or quotient. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Cofiber</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y)
  := Pushout f (const_tt X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Constructors *)</span>

<span class="sd">(** Any element of [Y] can be included in the cofiber. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cofib</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) : Y -&gt; Cofiber f
  := pushl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We have a distinguished point in the cofiber, where the image of [f] is contracted to. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cf_apex</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) : Cofiber f
  := pushr tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given an element [x : X], we have the path [cfglue f x] from the [f x] to the [cf_apex]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cfglue</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">x</span> : X) : cofib f (f x) = cf_apex f
  := pglue _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Induction and recursion principles *)</span>

<span class="sd">(** The recursion principle for the cofiber of [f : X -&gt; Y] requires a function [g : Y -&gt; Z] such that [g o f] is null homotopic, i.e. constant. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk1"><span class="kn">Definition</span> <span class="nf">cofiber_rec</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">g</span> : Y -&gt; Z)
  (<span class="nv">null</span> : NullHomotopy (g o f))
  : Cofiber f -&gt; Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cofiber f -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cofiber f -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk3">snapply Pushout_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; Z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="cofiber-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chk4"><hr></label><div class="goal-conclusion">Unit -&gt; Z</div></blockquote><input class="alectryon-extra-goal-toggle" id="cofiber-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chk5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X, <span class="nl">?pushb</span> (f a) = <span class="nl">?pushc</span> (const_tt X a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit -&gt; Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="bp">exact</span> null.<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
g (f a) = unit_name null.<span class="mi">1</span> (const_tt X a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk9"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>NullHomotopy (g o f)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f a) = unit_name null.<span class="mi">1</span> (const_tt X a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (null.<span class="mi">2</span> a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The induction principle is similar, although requires a dependent form of null homotopy. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chka"><span class="kn">Definition</span> <span class="nf">cofiber_ind</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">P</span> : Cofiber f -&gt; <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">y</span>, P (cofib f y))
  (<span class="nv">null</span> : <span class="kr">exists</span> <span class="nv">b</span>, <span class="kr">forall</span> <span class="nv">x</span>, transport P (cfglue f x) (g (f x)) = b)
  : <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Cofiber f, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Cofiber f, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chkc">snapply Pushout_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y, P (pushl b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="cofiber-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chkd"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : Unit, P (pushr c)</div></blockquote><input class="alectryon-extra-goal-toggle" id="cofiber-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chke"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
transport P (pglue a) (<span class="nl">?pushb</span> (f a)) =
<span class="nl">?pushc</span> (const_tt X a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chkf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y, P (pushl b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> y; <span class="nb">apply</span> g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : Unit, P (pushr c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">exact</span> null.<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, P (cofib f y)</span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span>{b : P (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport P (cfglue f x) (g (f x)) = b}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
transport P (pglue a) ((<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt; g y) (f a)) =
(<span class="kr">fun</span> <span class="nv">c</span> : Unit =&gt;
 <span class="kr">match</span> c <span class="kr">as</span> u <span class="kr">return</span> (P (pushr u)) <span class="kr">with</span>
 | tt =&gt; null.<span class="mi">1</span>
 <span class="kr">end</span>) (const_tt X a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> null.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Close Scope</span> trunc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The homotopy cofiber can be thought of as a functor from the category of arrows in [Type] to [Type]. *)</span>

<span class="sd">(** 1-functorial action. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_cofiber</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">X&#39;</span> <span class="nv">Y&#39;</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : X -&gt; Y} {<span class="nv">f&#39;</span> : X&#39; -&gt; Y&#39;}
  (<span class="nv">g</span> : X -&gt; X&#39;) (<span class="nv">h</span> : Y -&gt; Y&#39;) (<span class="nv">p</span> : h o f == f&#39; o g)
  : Cofiber f -&gt; Cofiber f&#39;
  := functor_pushout g h idmap p (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** 2-functorial action. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk12"><span class="kn">Definition</span> <span class="nf">functor_cofiber_homotopy</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">X&#39;</span> <span class="nv">Y&#39;</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : X -&gt; Y} {<span class="nv">f&#39;</span> : X&#39; -&gt; Y&#39;}
  {<span class="nv">g</span> <span class="nv">g&#39;</span> : X -&gt; X&#39;} {<span class="nv">h</span> <span class="nv">h&#39;</span> : Y -&gt; Y&#39;} {<span class="nv">p</span> : h o f == f&#39; o g} {<span class="nv">p&#39;</span> : h&#39; o f == f&#39; o g&#39;}
  (<span class="nv">u</span> : g == g&#39;) (<span class="nv">v</span> : h == h&#39;) 
  (<span class="nv">r</span> : <span class="kr">forall</span> <span class="nv">x</span>, p x @ ap f&#39; (u x) = v (f x) @ p&#39; x)
  : functor_cofiber g h p == functor_cofiber g&#39; h&#39; p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, X', Y'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X&#39; -&gt; Y&#39;</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>X -&gt; X&#39;</span></span></span><br><span><var>h, h'</var><span class="hyp-type"><b>: </b><span>Y -&gt; Y&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h o f == f&#39; o g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>h&#39; o f == f&#39; o g&#39;</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>g == g&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>h == h&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, p x @ ap f&#39; (u x) = v (f x) @ p&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_cofiber g h p == functor_cofiber g&#39; h&#39; p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, X', Y'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X&#39; -&gt; Y&#39;</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>X -&gt; X&#39;</span></span></span><br><span><var>h, h'</var><span class="hyp-type"><b>: </b><span>Y -&gt; Y&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h o f == f&#39; o g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>h&#39; o f == f&#39; o g&#39;</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>g == g&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>h == h&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, p x @ ap f&#39; (u x) = v (f x) @ p&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_cofiber g h p == functor_cofiber g&#39; h&#39; p&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk14">snapply (functor_pushout_homotopic u v (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>) r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, X', Y'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>X&#39; -&gt; Y&#39;</span></span></span><br><span><var>g, g'</var><span class="hyp-type"><b>: </b><span>X -&gt; X&#39;</span></span></span><br><span><var>h, h'</var><span class="hyp-type"><b>: </b><span>Y -&gt; Y&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h o f == f&#39; o g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>h&#39; o f == f&#39; o g&#39;</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>g == g&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>h == h&#39;</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, p x @ ap f&#39; (u x) = v (f x) @ p&#39; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>) a @ ap (const_tt X&#39;) (u a) =
(<span class="kr">fun</span> <span class="nv">x</span> : Unit =&gt; <span class="mi">1</span>) (const_tt X a) @
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="mi">1</span>) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; <span class="bp">exact</span> (concat_1p _ @ ap_const _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The cofiber functor preserves the identity map. *)</span> 
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_cofiber_idmap</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y)
  : functor_cofiber (f:=f) idmap idmap (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>) == idmap
  := functor_pushout_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The cofiber functor preserves composition of squares. (When mapping parallel edges). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_cofiber_compose</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">X&#39;</span> <span class="nv">Y&#39;</span> <span class="nv">X&#39;&#39;</span> <span class="nv">Y&#39;&#39;</span> : <span class="kt">Type</span>}
  {<span class="nv">f</span> : X -&gt; Y} {<span class="nv">f&#39;</span> : X&#39; -&gt; Y&#39;} {<span class="nv">f&#39;&#39;</span> : X&#39;&#39; -&gt; Y&#39;&#39;}
  {<span class="nv">g</span> : X -&gt; X&#39;} {<span class="nv">g&#39;</span> : X&#39; -&gt; X&#39;&#39;} {<span class="nv">h</span> : Y -&gt; Y&#39;} {<span class="nv">h&#39;</span> : Y&#39; -&gt; Y&#39;&#39;}
  (<span class="nv">p</span> : h o f == f&#39; o g) (<span class="nv">p&#39;</span> : h&#39; o f&#39; == f&#39;&#39; o g&#39;)
  : functor_cofiber (g&#39; o g) (h&#39; o h) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap h&#39; (p x) @ p&#39; (g x))
    == functor_cofiber g&#39; h&#39; p&#39; o functor_cofiber g h p
  := functor_pushout_compose g h idmap g&#39; h&#39; idmap p (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>) p&#39; (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> trunc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Connectivity of cofibers *)</span>

<span class="sd">(** The cofiber of an [n]-connected map is [n.+1]-connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk15"><span class="kn">Definition</span> <span class="nf">isconnected_cofiber</span> (<span class="nv">n</span> : trunc_index) {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y)
  {<span class="nv">fc</span> : IsConnMap n f}
  : IsConnected n.+<span class="mi">1</span> (Cofiber f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk17"><span class="nb">apply</span> isconnected_from_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>,
In (Tr n.+<span class="mi">1</span>) C -&gt;
<span class="kr">forall</span> <span class="nv">f0</span> : Cofiber f -&gt; C, NullHomotopy f0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk18"><span class="nb">intros</span> C H&#39; g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk19"><span class="kr">exists</span> (<span class="nv">g</span> (cf_apex _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Cofiber f, g x = g (cf_apex f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk1a">snapply cofiber_ind; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Y, g (cofib f y) = g (cf_apex f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="cofiber-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chk1b"><hr></label><div class="goal-conclusion">{b : g (cf_apex f) = g (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">x0</span> : Cofiber f =&gt; g x0 = g (cf_apex f))
  (cfglue f x) (<span class="nl">?Goal</span> (f x)) = b}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk1c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Y, g (cofib f y) = g (cf_apex f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk1d">rapply (conn_map_elim n f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X, g (cofib f (f a)) = g (cf_apex f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk1e"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (cofib f (f x)) = g (cf_apex f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap g (cfglue f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{b : g (cf_apex f) = g (cf_apex f) &amp;
<span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">x0</span> : Cofiber f =&gt; g x0 = g (cf_apex f))
  (cfglue f x)
  (conn_map_elim (Tr n) f
     (<span class="kr">fun</span> <span class="nv">b0</span> : Y =&gt; g (cofib f b0) = g (cf_apex f))
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; ap g (cfglue f x0)) (f x)) = b}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk20"><span class="kr">exists</span> <span class="nv">idpath</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
transport (<span class="kr">fun</span> <span class="nv">x0</span> : Cofiber f =&gt; g x0 = g (cf_apex f))
  (cfglue f x)
  (conn_map_elim (Tr n) f
     (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; g (cofib f b) = g (cf_apex f))
     (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; ap g (cfglue f x0)) (f x)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk21"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : Cofiber f =&gt; g x = g (cf_apex f))
  (cfglue f x)
  (conn_map_elim (Tr n) f
     (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; g (cofib f b) = g (cf_apex f))
     (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap g (cfglue f x)) (f x)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk22">transport_paths Fl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim (Tr n) f
  (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; g (cofib f b) = g (cf_apex f))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap g (cfglue f x)) (f x) =
ap g (cfglue f x) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk23">rhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>In (Tr n.+<span class="mi">1</span>) C</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Cofiber f -&gt; C</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_map_elim (Tr n) f
  (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt; g (cofib f b) = g (cf_apex f))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; ap g (cfglue f x)) (f x) =
ap g (cfglue f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply conn_map_comp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Comparison of fibers and cofibers *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk24"><span class="kn">Definition</span> <span class="nf">fiber_to_path_cofiber</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">y</span> : Y)
  : hfiber f y -&gt; cofib f y = cf_apex f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f y -&gt; cofib f y = cf_apex f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f y -&gt; cofib f y = cf_apex f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk26"><span class="nb">intros</span> [x p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cofib f y = cf_apex f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk27">lhs_V napply (ap (cofib f) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cofib f (f x) = cf_apex f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cfglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Blakers-Massey implies that the comparison map is highly connected.  Here we assume that [X] is merely inhabited.  There is a variant that instead assumes that [f] is surjective, with the same proof except that [blakers_massey_po] is used. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk28"><span class="kn">Definition</span> <span class="nf">isconnected_fiber_to_cofiber</span> `{Univalence}
  (n m : trunc_index) {X Y : <span class="kt">Type</span>} {ac : IsConnected m.+<span class="mi">1</span> X}
  (f : X -&gt; Y) {fc : IsConnMap n f} (y : Y)
  : IsConnMap (m +<span class="mi">2</span>+ n).-<span class="mi">1</span> (fiber_to_path_cofiber f y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>)
  (fiber_to_path_cofiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>)
  (fiber_to_path_cofiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* It&#39;s enough to check the connectivity of [functor_sigma idmap (fiber_to_path_cofiber f)]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk2a"><span class="nb">revert</span> y; snapply conn_map_fiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>)
  (functor_sigma idmap (fiber_to_path_cofiber f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We precompose with the equivalence [X &lt;~&gt; { y : Y &amp; hfiber f y }]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk2b">rapply (cancelR_conn_map _ (equiv_fibration_replacement _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>)
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   functor_sigma idmap (fiber_to_path_cofiber f)
     (equiv_fibration_replacement f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The Sigma-type [{ y : Y &amp; cofib f y = cf_apex f}] in the codomain is the fiber of the map [cofib f], and so it is equivalent to the pullback of the cospan in the pushout square defining [Cofiber f].  We postcompose with this equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk2c">snapply (cancelL_equiv_conn_map _ _ (equiv_pullback_unit_hfiber _ _)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>)
  ((equiv_pullback_unit_hfiber (cofib f) pushr)^-<span class="mi">1</span>%equiv
   o (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
      functor_sigma idmap (fiber_to_path_cofiber f)
        (equiv_fibration_replacement f x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The composite is homotopic to the map from [blakers_massey_po], with the only difference being an extra [1 @ _]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk2d">snapply conn_map_homotopic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; Pullback (cofib f) pushr</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="cofiber-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chk2e"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 (equiv_pullback_unit_hfiber (cofib f) pushr)^-<span class="mi">1</span>%equiv
   ((<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
     functor_sigma idmap (fiber_to_path_cofiber f)
       (equiv_fibration_replacement f x0)) x))</div></blockquote><input class="alectryon-extra-goal-toggle" id="cofiber-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chk2f"><hr></label><div class="goal-conclusion">IsConnMap (Tr (m +<span class="mi">2</span>+ n).-<span class="mi">1</span>) <span class="nl">?f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk30"><span class="mi">3</span>: rapply blakers_massey_po&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_corec pglue ==
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
 (equiv_pullback_unit_hfiber (cofib f) pushr)^-<span class="mi">1</span>%equiv
   ((<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt;
     functor_sigma idmap (fiber_to_path_cofiber f)
       (equiv_fibration_replacement f x0)) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Use [compute.] to see the details of the goal. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk31"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pullback_corec pglue x =
(equiv_pullback_unit_hfiber (cofib f) pushr)^-<span class="mi">1</span>%equiv
  (functor_sigma idmap (fiber_to_path_cofiber f)
     (equiv_fibration_replacement f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk32"><span class="nb">apply</span> (ap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; (f x; tt; z))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pglue x =
transport (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; cofib f x = pushr tt)
  (eisretr <span class="mi">1</span>%equiv
     (functor_sigma idmap (fiber_to_path_cofiber f)
        (equiv_fibration_replacement f x)).<span class="mi">1</span>)^
  (functor_sigma idmap (fiber_to_path_cofiber f)
     (equiv_fibration_replacement f x)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk33"><span class="nb">unfold</span> fiber_to_path_cofiber; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ac</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>fc</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pglue x = <span class="mi">1</span> @ cfglue f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This lets us prove a converse to [isconnected_cofiber] when [X] is 1-connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk34"><span class="kn">Definition</span> <span class="nf">isconnmap_isconnected_cofiber</span> `{Univalence}
  (n : trunc_index) {X Y : <span class="kt">Type</span>} `{IsConnected <span class="mi">1</span> X}
  (f : X -&gt; Y) `{IsConnected n.+<span class="mi">1</span> (Cofiber f)}
  : IsConnMap n f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk36">simple_induction n n IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) (Cofiber f) -&gt;
IsConnMap (Tr (-<span class="mi">2</span>)) f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="cofiber-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f) -&gt; IsConnMap (Tr n) f</span></span></span><br></div><label class="goal-separator" for="cofiber-v-chk37"><hr></label><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">2</span>) (Cofiber f) -&gt;
IsConnMap (Tr n.+<span class="mi">1</span>) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk38">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) (Cofiber f) -&gt;
IsConnMap (Tr (-<span class="mi">2</span>)) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f) -&gt; IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">2</span>) (Cofiber f) -&gt;
IsConnMap (Tr n.+<span class="mi">1</span>) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk3a"><span class="nb">intros</span> conn_cof y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f) -&gt; IsConnMap (Tr n) f</span></span></span><br><span><var>conn_cof</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">2</span>) (Cofiber f)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) (hfiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="cofiber-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="cofiber-v-chk3b">rapply (isconnected_conn_map_isconnected (n.+<span class="mi">1</span>) (fiber_to_path_cofiber f y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">1</span>) X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) (Cofiber f) -&gt;
IsConnMap (Tr n) f</span></span></span><br><span><var>conn_cof</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">2</span>) (Cofiber f)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n.+<span class="mi">1</span>) (fiber_to_path_cofiber f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (isconnected_fiber_to_cofiber n <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
