<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>CoreflectiveSubuniverse.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.Modality Modalities.Open.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Coreflective subuniverses. *)</span>

<span class="sd">(** In this file we study &quot;coreflective subuniverses&quot; that are defined dually to reflective subuniverses.  However, it turns out that there are many fewer examples of these.  The &quot;internal&quot; nature of such definitions, which in the reflective case makes the subuniverse automatically an exponential ideal, in the coreflective case has much stronger consequences: it forces the entire coreflection to be determined by the image of [Unit], which can be an arbitrary hprop.  Thus, this file is essentially just a no-go theorem: there are no coreflective subuniverses other than a certain class of fairly simple ones (which we call &quot;co-open&quot; since they are dual to open modalities).</span>

<span class="sd">In particular, since we do not foresee many applications of this file, we don&#39;t bother introducing modules to make the definitions more universe polymorphic the way we did for reflective subuniverses. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">CoreflectiveSubuniverse</span> :=
  { inF : <span class="kt">Type</span> -&gt; HProp ;
    F_coreflector : <span class="kt">Type</span> -&gt; <span class="kt">Type</span> ;
    F_inF : <span class="kr">forall</span> <span class="nv">X</span>, inF (F_coreflector X) ;
    fromF : <span class="kr">forall</span> <span class="nv">X</span>, F_coreflector X -&gt; X ;
    <span class="sd">(** We also don&#39;t bother defining [ooLiftableAlong] so as to state the universal property without [Funext]. *)</span>
    isequiv_fromF_postcompose
    : <span class="kr">forall</span> {<span class="nv">Y</span> <span class="nv">X</span>} {<span class="nv">Y_inF</span> : inF Y},
        IsEquiv (<span class="kr">fun</span> (<span class="nv">g</span> : Y -&gt; F_coreflector X) =&gt; fromF X o g)
    <span class="sd">(** Similarly, we don&#39;t bother asserting repleteness; we&#39;ll just use univalence. *)</span>
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">F_coreflector</span> : CoreflectiveSubuniverse &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">CoreflectiveSubuniverse</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">F</span> : CoreflectiveSubuniverse}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We begin by extracting the corecursor, its computation rule, and its eta principle. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk1"><span class="kn">Definition</span> <span class="nf">F_corec</span> {<span class="nv">Y</span> <span class="nv">X</span>} `(inF F Y) (f : Y -&gt; X) : Y -&gt; F X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; F X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; F X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk3"><span class="nb">refine</span> ((<span class="kr">fun</span> (<span class="nv">g</span> : Y -&gt; F X) =&gt; fromF F X o g)^-<span class="mi">1</span> f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> (<span class="nv">g</span> : Y -&gt; F X) (<span class="nv">x</span> : Y) =&gt; fromF F X (g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> isequiv_fromF_postcompose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk4"><span class="kn">Definition</span> <span class="nf">F_corec_beta</span> {<span class="nv">Y</span> <span class="nv">X</span>} (<span class="nv">YF</span> : inF F Y) (<span class="nv">f</span> : Y -&gt; X)
  : fromF F X o F_corec YF f == f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YF</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fromF F X o F_corec YF f == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YF</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fromF F X o F_corec YF f == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap10, (eisretr (<span class="kr">fun</span> <span class="nv">g</span> =&gt; fromF F X o g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk6"><span class="kn">Definition</span> <span class="nf">F_coindpaths</span> {<span class="nv">Y</span> <span class="nv">X</span>} `(inF F Y) (g h : Y -&gt; F X)
             (p : fromF F X o g == fromF F X o h)
  : g == h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Y -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o g == fromF F X o h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Y -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o g == fromF F X o h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk8"><span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Y -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o g == fromF F X o h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk9"><span class="nb">refine</span> (equiv_inj (<span class="kr">fun</span> <span class="nv">k</span> =&gt; fromF F X o k) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Y -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o g == fromF F X o h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> (<span class="nv">k</span> : Y -&gt; F X) (<span class="nv">x</span> : Y) =&gt; fromF F X (k x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Y -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o g == fromF F X o h</span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chka"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; fromF F X (g x)) =
(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; fromF F X (h x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Y -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o g == fromF F X o h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> (<span class="nv">k</span> : Y -&gt; F X) (<span class="nv">x</span> : Y) =&gt; fromF F X (k x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> isequiv_fromF_postcompose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chkc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inF0</var><span class="hyp-type"><b>: </b><span>inF F Y</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>Y -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o g == fromF F X o h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; fromF F X (g x)) =
(<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; fromF F X (h x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> path_arrow.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The functorial action of the coreflector. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">F_functor</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) : F X -&gt; F Y
    := F_corec (F_inF F X) (f o fromF F X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The coreflector preserves hprops (since it is a right adjoint and thus preserves limits). *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chkd"><span class="kn">Local Instance</span> <span class="nf">ishprop_coreflection</span> <span class="nv">A</span> `{IsHProp A} : IsHProp (F A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (F A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (F A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chkf"><span class="nb">apply</span> hprop_allpath; <span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>F A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (F_coindpaths (F_inF F A) (const x) (const y)
                        (<span class="kr">fun</span> <span class="nv">_</span> =&gt; path_ishprop _ _) x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A type lies in [F] as soon as [fromF] admits a section. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk10"><span class="kn">Definition</span> <span class="nf">inF_fromF_sect</span> <span class="nv">X</span> (<span class="nv">s</span> : X -&gt; F X) (<span class="nv">p</span> : fromF F X o s == idmap)
  : inF F X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>X -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inF F X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>X -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inF F X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk12"><span class="nb">refine</span> (transport (inF F) (path_universe (fromF F X)) (F_inF F X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>X -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (fromF F X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk13"><span class="nb">refine</span> (isequiv_adjointify _ s p _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>X -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : F X =&gt; s (fromF F X x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk14"><span class="nb">change</span> (s o fromF F X == idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>X -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s o fromF F X == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk15"><span class="nb">apply</span> F_coindpaths; <span class="kp">try</span> <span class="nb">apply</span> F_inF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>X -&gt; F X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fromF F X o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : F X =&gt; fromF F X (s (fromF F X x))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : F X =&gt; fromF F X x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** So far, nothing unexpected has happened.  Now, however, we claim that [F] is completely determined by the image of [Unit], which by [ishprop_coreflection] is an hprop.  Specifically, we claim that [X] lies in [F] exactly when [X -&gt; F Unit]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk16"><span class="kn">Definition</span> <span class="nf">inF_equiv_implies_funit</span> <span class="nv">X</span>
  : inF F X &lt;~&gt; (X -&gt; F Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inF F X &lt;~&gt; (X -&gt; F Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inF F X &lt;~&gt; (X -&gt; F Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk18"><span class="nb">apply</span> equiv_iff_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inF F X -&gt; X -&gt; F Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chk19"><hr></label><div class="goal-conclusion">(X -&gt; F Unit) -&gt; inF F X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inF F X -&gt; X -&gt; F Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk1b"><span class="nb">intros</span> ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>inF F X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; F Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk1c"><span class="nb">apply</span> F_corec; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>inF F X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X -&gt; F Unit) -&gt; inF F X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk1e"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; F Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inF F X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk1f"><span class="nb">simple refine</span> (inF_fromF_sect X _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; F Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; F X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; F Unit</span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chk20"><hr></label><div class="goal-conclusion">fromF F X o <span class="nl">?s</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk21">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; F Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt; F X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk22"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; F Unit</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">F X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (F_functor (unit_name x) (f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk23">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; F Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fromF F X
o (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; F_functor (unit_name x) (f x)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk24"><span class="nb">intros</span> x; <span class="nb">unfold</span> F_functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>CoreflectiveSubuniverse</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; F Unit</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fromF F X
  (F_corec (F_inF F Unit) (<span class="kr">fun</span> <span class="nv">_</span> : F Unit =&gt; x) (f x)) =
x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (F_corec_beta (F_inF F Unit) (const x) (f x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CoreflectiveSubuniverse</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Conversely, we will now show that for any hprop [U], the types [X] such that [X -&gt; U] are a coreflective subuniverse, which we call &quot;co-open&quot; since it is dual to the open modality. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">CoOpen</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext} (U : HProp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk25"><span class="kn">Definition</span> <span class="nf">coOp</span> : CoreflectiveSubuniverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">CoreflectiveSubuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">CoreflectiveSubuniverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk27"><span class="nb">simple refine</span> (Build_CoreflectiveSubuniverse
              (<span class="kr">fun</span> <span class="nv">X</span> =&gt; Build_HProp (X -&gt; U))
              (<span class="kr">fun</span> <span class="nv">X</span> =&gt; X * U)
              (<span class="kr">fun</span> <span class="nv">X</span> =&gt; @snd X U)
              (<span class="kr">fun</span> <span class="nv">X</span> =&gt; @fst X U) _); <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Y</span> <span class="nv">X</span> : <span class="kt">Type</span>,
(<span class="kr">fun</span> <span class="nv">X0</span> : <span class="kt">Type</span> =&gt; Build_HProp (X0 -&gt; U)) Y -&gt;
IsEquiv
  (<span class="kr">fun</span> <span class="nv">g</span> : Y -&gt; (<span class="kr">fun</span> <span class="nv">X0</span> : <span class="kt">Type</span> =&gt; X0 * U) X =&gt;
   (<span class="kr">fun</span> <span class="nv">X0</span> : <span class="kt">Type</span> =&gt; fst) X o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk28"><span class="nb">intros</span> Y X YU; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YU</var><span class="hyp-type"><b>: </b><span>Y -&gt; U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> (<span class="nv">g</span> : Y -&gt; X * U) (<span class="nv">x</span> : Y) =&gt; fst (g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk29"><span class="nb">refine</span> (isequiv_adjointify _ (<span class="kr">fun</span> <span class="nv">h</span> <span class="nv">y</span> =&gt; (h y , YU y)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YU</var><span class="hyp-type"><b>: </b><span>Y -&gt; U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : Y -&gt; X) (<span class="nv">x0</span> : Y) =&gt; x x0) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YU</var><span class="hyp-type"><b>: </b><span>Y -&gt; U</span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chk2a"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : Y -&gt; X * U) (<span class="nv">y</span> : Y) =&gt; (fst (x y), YU y)) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YU</var><span class="hyp-type"><b>: </b><span>Y -&gt; U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : Y -&gt; X) (<span class="nv">x0</span> : Y) =&gt; x x0) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> g; <span class="nb">apply</span> path_arrow; <span class="nb">intros</span> y; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YU</var><span class="hyp-type"><b>: </b><span>Y -&gt; U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : Y -&gt; X * U) (<span class="nv">y</span> : Y) =&gt; (fst (x y), YU y)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk2d"><span class="nb">intros</span> h; <span class="nb">apply</span> path_arrow; <span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Y, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>YU</var><span class="hyp-type"><b>: </b><span>Y -&gt; U</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Y -&gt; X * U</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst (h y), YU y) = h y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; [ <span class="bp">reflexivity</span> | <span class="bp">by</span> <span class="nb">apply</span> path_ishprop ].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Thus, each coreflective subuniverses are uniquely determined by an hprop.  Moreover, the coreflective subuniverse corresponding to an hprop [U] is closely related to the open modality [Op U].  Specifically, they form an _adjoint modality pair_ in the sense that the subuniverses are canonically equivalent, and the coreflection and reflection respect this equivalence.  In categorical language, this says that the inclusion of an open subtopos is the center of a local geometric morphism in the other direction.  We express this concisely as follows. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk2e"><span class="kn">Definition</span> <span class="nf">coopen_isequiv_open</span> <span class="nv">X</span>
  : IsEquiv (O_functor (Op U) (fromF coOp X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (Op U) (fromF coOp X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts (Op U) (fromF coOp X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk30"><span class="nb">refine</span> (isequiv_adjointify _ (<span class="kr">fun</span> <span class="nv">ux</span> =&gt; <span class="kr">fun</span> <span class="nv">u</span> =&gt; (ux u , u)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : U -&gt; X =&gt;
 O_functor (Op U) (fromF coOp X)
   (<span class="kr">fun</span> <span class="nv">u</span> : U =&gt; (x u, u))) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chk31"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : U -&gt; X * U) (<span class="nv">u</span> : U) =&gt;
 (O_functor (Op U) (fromF coOp X) x u, u)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : U -&gt; X =&gt;
 O_functor (Op U) (fromF coOp X)
   (<span class="kr">fun</span> <span class="nv">u</span> : U =&gt; (x u, u))) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk33"><span class="nb">intros</span> ux; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ux</var><span class="hyp-type"><b>: </b><span>U -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst (<span class="kr">fun</span> <span class="nv">u</span> : U =&gt; (ux u, u)) = ux</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk34"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ux</var><span class="hyp-type"><b>: </b><span>U -&gt; X</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst (<span class="kr">fun</span> <span class="nv">u</span> : U =&gt; (ux u, u)) u = ux u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk35"><span class="nb">transitivity</span> (O_functor (Op U) fst (to (Op U) (X * U) (ux u , u)) u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ux</var><span class="hyp-type"><b>: </b><span>U -&gt; X</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst (<span class="kr">fun</span> <span class="nv">u</span> : U =&gt; (ux u, u)) u =
O_functor (Op U) fst (to (Op U) (X * U) (ux u, u)) u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ux</var><span class="hyp-type"><b>: </b><span>U -&gt; X</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chk36"><hr></label><div class="goal-conclusion">O_functor (Op U) fst (to (Op U) (X * U) (ux u, u)) u =
ux u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk37">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ux</var><span class="hyp-type"><b>: </b><span>U -&gt; X</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst (<span class="kr">fun</span> <span class="nv">u</span> : U =&gt; (ux u, u)) u =
O_functor (Op U) fst (to (Op U) (X * U) (ux u, u)) u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk38"><span class="nb">apply</span> ap10, ap, path_arrow; <span class="nb">intros</span> u&#39;; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ux</var><span class="hyp-type"><b>: </b><span>U -&gt; X</span></span></span><br><span><var>u, u'</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ux u&#39;, u&#39;) = (ux u, u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">simpl</span>; [ <span class="nb">apply</span> ap | ]; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk39">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ux</var><span class="hyp-type"><b>: </b><span>U -&gt; X</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst (to (Op U) (X * U) (ux u, u)) u =
ux u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap10 (to_O_natural (Op U) (@fst X U) (ux u , u)) u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : U -&gt; X * U) (<span class="nv">u</span> : U) =&gt;
 (O_functor (Op U) (fromF coOp X) x u, u)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk3b"><span class="nb">intros</span> uux; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">u</span> : U =&gt; (O_functor (Op U) fst uux u, u)) = uux</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk3c"><span class="nb">apply</span> path_arrow; <span class="nb">intros</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(O_functor (Op U) fst uux u, u) = uux u</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk3d"><span class="nb">apply</span> path_prod; [ <span class="nb">simpl</span> | <span class="nb">apply</span> path_ishprop ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst uux u = fst (uux u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk3e"><span class="nb">transitivity</span> (O_functor (Op U) fst (to (Op U) _ (fst (uux u) , u)) u).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst uux u =
O_functor (Op U) fst
  (to (Op U) (X * U) (fst (uux u), u)) u</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chk3f"><hr></label><div class="goal-conclusion">O_functor (Op U) fst
  (to (Op U) (X * U) (fst (uux u), u)) u = fst (uux u)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk40">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst uux u =
O_functor (Op U) fst
  (to (Op U) (X * U) (fst (uux u), u)) u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk41"><span class="nb">apply</span> ap10, ap, path_arrow; <span class="nb">intros</span> u&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u, u'</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">uux u&#39; = to (Op U) (X * U) (fst (uux u), u) u&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk42"><span class="nb">apply</span> path_prod; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u, u'</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (uux u&#39;) = fst (uux u)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="coreflectivesubuniverse-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u, u'</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><label class="goal-separator" for="coreflectivesubuniverse-v-chk43"><hr></label><div class="goal-conclusion">snd (uux u&#39;) = u</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk44">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u, u'</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (uux u&#39;) = fst (uux u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap fst (ap uux (path_ishprop u&#39; u))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk45">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u, u'</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (uux u&#39;) = u</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreflectivesubuniverse-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="coreflectivesubuniverse-v-chk46">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>uux</var><span class="hyp-type"><b>: </b><span>U -&gt; X * U</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>U</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor (Op U) fst
  (to (Op U) (X * U) (fst (uux u), u)) u = fst (uux u)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap10 (to_O_natural (Op U) (@fst X U) (fst (uux u) , u)) u).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">coopen_equiv_open</span> <span class="nv">X</span>
  : Op U (coOp X) &lt;~&gt; Op U X
    := Build_Equiv _ _ (O_functor (Op U) (fromF coOp X))
                  (coopen_isequiv_open X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">CoOpen</span>.</span></span></pre>
</div>
</div></body>
</html>
