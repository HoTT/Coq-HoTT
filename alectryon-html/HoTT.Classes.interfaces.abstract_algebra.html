<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>abstract_algebra.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk0"><span class="kn">Require Export</span> Basics.Classes Basics.Overture.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> HoTT.Classes.interfaces.canonical_names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.ReflectiveSubuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B C f g x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">For various structures we omit declaration of substructures. For example, if we</span>
<span class="c">say:</span>

<span class="c">Class Setoid_Morphism :=</span>
<span class="c">  { setoidmor_a : Setoid A</span>
<span class="c">  ; setoidmor_b : Setoid B</span>
<span class="c">  ; sm_proper : Proper ((=) ==&gt; (=)) f }.</span>
<span class="c">#[export] Existing Instances setoidmor_a setoidmor_b sm_proper.</span>

<span class="c">then each time a Setoid instance is required, Coq will try to prove that a</span>
<span class="c">Setoid_Morphism exists. This obviously results in an enormous blow-up of the</span>
<span class="c">search space. Moreover, one should be careful to declare a Setoid_Morphisms</span>
<span class="c">as a substructure. Consider [f t1 t2], now if we want to perform setoid rewriting</span>
<span class="c">in [t2] Coq will first attempt to prove that [f t1] is Proper, for which it will</span>
<span class="c">attempt to prove [Setoid_Morphism (f t1)]. If many structures declare</span>
<span class="c">Setoid_Morphism as a substructure, setoid rewriting will become horribly slow.</span>
<span class="c">*)</span>

<span class="c">(* An unbundled variant of the former CoRN CSetoid. We do not</span>
<span class="c">  include a proof that A is a Setoid because it can be derived. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsApart</span> <span class="nv">A</span> {<span class="nv">Aap</span> : Apart A} : <span class="kt">Type</span> :=
  { apart_set :: IsHSet A
  ; apart_mere :: is_mere_relation _ apart
  ; apart_symmetric :: Symmetric (‚â∂)
  ; apart_cotrans :: CoTransitive (‚â∂)
  ; tight_apart : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, ~(x ‚â∂ y) &lt;-&gt; x = y }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1"><span class="kn">Instance</span> <span class="nf">apart_irrefl</span> `{IsApart A} : Irreflexive (‚â∂).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Irreflexive apart</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Irreflexive apart</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3"><span class="nb">intros</span> x ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4"><span class="nb">apply</span> (tight_apart x x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk5"><hr></label><div class="goal-conclusion">x ‚â∂ x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚â∂ x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> tight_apart {A Aap IsApart} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">setoid_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B} (<span class="nv">f</span> : A -&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">StrongExtensionality</span> := strong_extensionality : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x ‚â∂ f y -&gt; x ‚â∂ y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">setoid_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* HOTT TODO check if this is ok/useful *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (<span class="nl">?f</span> _ = <span class="nl">?f</span> _) =&gt; <span class="nb">eapply</span> (ap f) : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">setoid_binary_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} {<span class="nv">Aap</span>: Apart A}
    {<span class="nv">Bap</span> : Apart B} {<span class="nv">Cap</span> : Apart C} (<span class="nv">f</span> : A -&gt; B -&gt; C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">StrongBinaryExtensionality</span> := strong_binary_extensionality
    : <span class="kr">forall</span> <span class="nv">x‚ÇÅ</span> <span class="nv">y‚ÇÅ</span> <span class="nv">x‚ÇÇ</span> <span class="nv">y‚ÇÇ</span>, f x‚ÇÅ y‚ÇÅ ‚â∂ f x‚ÇÇ y‚ÇÇ -&gt; hor (x‚ÇÅ ‚â∂ x‚ÇÇ) (y‚ÇÅ ‚â∂ y‚ÇÇ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">setoid_binary_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">Since apartness usually only becomes relevant when considering fields (e.g. the</span>
<span class="c">real numbers), we do not include it in the lower part of the algebraic hierarchy</span>
<span class="c">(as opposed to CoRN).</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">upper_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Universe</span> <span class="nf">i</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiGroup</span> {<span class="nv">Aop</span>: SgOp A} :=
    { sg_set :: IsHSet A
    ; sg_ass :: Associative (.*.) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsCommutativeSemiGroup</span> {<span class="nv">Aop</span> : SgOp A} :=
    { comsg_sg :: @IsSemiGroup (.*.)
    ; comsg_comm :: Commutative (.*.) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiLattice</span> {<span class="nv">Aop</span> : SgOp A} :=
    { semilattice_sg :: @IsCommutativeSemiGroup (.*.)
    ; semilattice_idempotent :: BinaryIdempotent (.*.)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMonoid</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { monoid_semigroup :: IsSemiGroup
    ; monoid_left_id :: LeftIdentity (.*.) mon_unit
    ; monoid_right_id :: RightIdentity (.*.) mon_unit }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsCommutativeMonoid</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { commonoid_mon :: @IsMonoid (.*.) Aunit
    ; commonoid_commutative :: Commutative (.*.) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsGroup</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Ainv</span> : Inverse A} :=
    { group_monoid :: @IsMonoid (.*.) mon_unit
    ; inverse_l :: LeftInverse (.*.) (^) mon_unit
    ; inverse_r :: RightInverse (.*.) (^) mon_unit
    }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedSemiLattice</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { bounded_semilattice_mon :: @IsCommutativeMonoid (.*.) Aunit
    ; bounded_semilattice_idempotent :: BinaryIdempotent (.*.)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Close Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsAbGroup</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Ainv</span> : Inverse A} :=
    { abgroup_group :: @IsGroup Aop Aunit Ainv
    ; abgroup_commutative :: Commutative Aop }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Aplus</span> : Plus A} {<span class="nv">Amult</span> : Mult A} {<span class="nv">Azero</span> : Zero A} {<span class="nv">Aone</span> : One A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiCRing</span> :=
    { semiplus_monoid :: @IsCommutativeMonoid (+) <span class="mi">0</span>
    ; semimult_monoid :: @IsCommutativeMonoid (.*.) <span class="mi">1</span>
    ; semiring_distr :: LeftDistribute (.*.) (+)
    ; semiring_left_absorb :: LeftAbsorb (.*.) <span class="mi">0</span> }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Anegate</span> : Negate A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsRing</span> :=
    { ring_abgroup :: @IsAbGroup (+) <span class="mi">0</span> (-)
    ; ring_monoid :: @IsMonoid (.*.) <span class="mi">1</span>
    ; ring_dist_left :: LeftDistribute (.*.) (+)
    ; ring_dist_right :: RightDistribute (.*.) (+)
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsCRing</span> :=
    { cring_group :: @IsAbGroup (+) <span class="mi">0</span> (-)
    ; cring_monoid :: @IsCommutativeMonoid (.*.) <span class="mi">1</span>
    ; cring_dist :: LeftDistribute (.*.) (+) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8">#[export] <span class="kn">Instance</span> <span class="nf">isring_iscring</span> : IsCRing -&gt; IsRing.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCRing -&gt; IsRing</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCRing -&gt; IsRing</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chka"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsRing</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkb"><span class="nb">econstructor</span>; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightDistribute mult plus</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkc"><span class="nb">intros</span> a b c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a + b) * c = a * c + b * c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkd">lhs rapply commutativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op c (a + b) = a * c + b * c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chke">lhs rapply distribute_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c * a + c * b = a * c + b * c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">f_ap; <span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsIntegralDomain</span> :=
    { intdom_ring : IsCRing
    ; intdom_nontrivial : PropHolds (not (<span class="mi">1</span> = <span class="mi">0</span>))
    ; intdom_nozeroes :: NoZeroDivisors A }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* We do not include strong extensionality for (-) and (/)</span>
<span class="c">    because it can be derived *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsField</span> {<span class="nv">Aap</span>: Apart A} {<span class="nv">Arecip</span>: Recip A} :=
    { field_ring :: IsCRing
    ; field_apart :: IsApart A
    ; field_plus_ext :: StrongBinaryExtensionality (+)
    ; field_mult_ext :: StrongBinaryExtensionality (.*.)
    ; field_nontrivial : PropHolds (<span class="mi">1</span> ‚â∂ <span class="mi">0</span>)
    ; recip_inverse : <span class="kr">forall</span> <span class="nv">x</span>, x.<span class="mi">1</span> // x = <span class="mi">1</span> }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* We let /0 = 0 so properties as Injective (/),</span>
<span class="c">    f (/x) = / (f x), / /x = x, /x * /y = /(x * y)</span>
<span class="c">    hold without any additional assumptions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsDecField</span> {<span class="nv">Adec_recip</span> : DecRecip A} :=
    { decfield_ring :: IsCRing
    ; decfield_nontrivial : PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)
    ; dec_recip_0 : /<span class="mi">0</span> = <span class="mi">0</span>
    ; dec_recip_inverse : <span class="kr">forall</span> <span class="nv">x</span>, x &lt;&gt; <span class="mi">0</span> -&gt; x / x = <span class="mi">1</span> }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">FieldCharacteristic</span>@{j} {Aap : Apart@{i j} A} (k : nat) : <span class="kt">Type</span>@{j}
    := field_characteristic : <span class="kr">forall</span> <span class="nv">n</span> : nat,
        Nat.Core.lt <span class="mi">0</span> n -&gt;
        iff@{j j j} (<span class="kr">forall</span> <span class="nv">m</span> : nat, not@{j} (paths@{<span class="kt">Set</span>} n
                                                  (nat_mul k m)))
        (@apart A Aap (nat_iter n (<span class="mi">1</span> +) <span class="mi">0</span>) <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">upper_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Due to bug #2528 *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @intdom_nontrivial : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">5</span> (PropHolds (<span class="mi">1</span> ‚â∂ <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @field_nontrivial : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">5</span> (PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @decfield_nontrivial : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">For a strange reason IsCRing instances of Integers are sometimes obtained by</span>
<span class="c">Integers -&gt; IntegralDomain -&gt; Ring and sometimes directly. Making this an</span>
<span class="c">instance with a low priority instead of using intdom_ring:&gt; IsCRing forces Coq to</span>
<span class="c">take the right way</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">10</span> (IsCRing _) =&gt; <span class="nb">apply</span> @intdom_ring : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> recip_inverse {A Aplus Amult Azero Aone Anegate Aap Arecip IsField} _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> dec_recip_inverse
  {A Aplus Amult Azero Aone Anegate Adec_recip IsDecField} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> dec_recip_0 {A Aplus Amult Azero Aone Anegate Adec_recip IsDecField}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">lattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> <span class="nv">A</span> {<span class="nv">Ajoin</span>: Join A} {<span class="nv">Ameet</span>: Meet A} {<span class="nv">Abottom</span> : Bottom A} {<span class="nv">Atop</span> : Top A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsJoinSemiLattice</span> :=
    join_semilattice :: @IsSemiLattice A join_is_sg_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedJoinSemiLattice</span> :=
    bounded_join_semilattice :: @IsBoundedSemiLattice A
      join_is_sg_op bottom_is_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMeetSemiLattice</span> :=
    meet_semilattice :: @IsSemiLattice A meet_is_sg_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedMeetSemiLattice</span> :=
    bounded_meet_semilattice :: @IsBoundedSemiLattice A
      meet_is_sg_op top_is_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsLattice</span> :=
    { lattice_join :: IsJoinSemiLattice
    ; lattice_meet :: IsMeetSemiLattice
    ; join_meet_absorption :: Absorption (‚äî) (‚äì)
    ; meet_join_absorption :: Absorption (‚äì) (‚äî) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedLattice</span> :=
    { boundedlattice_join :: IsBoundedJoinSemiLattice
    ; boundedlattice_meet :: IsBoundedMeetSemiLattice
    ; boundedjoin_meet_absorption :: Absorption (‚äî) (‚äì)
    ; boundedmeet_join_absorption :: Absorption (‚äì) (‚äî)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsDistributiveLattice</span> :=
    { distr_lattice_lattice :: IsLattice
    ; join_meet_distr_l :: LeftDistribute (‚äî) (‚äì) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">lattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">morphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sgmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Bop</span> : SgOp B}
    {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Bunit</span> : MonUnit B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiGroupPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    preserves_sg_op : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f (x * y) = f x * f y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsUnitPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    preserves_mon_unit : f mon_unit = mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMonoidPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { monmor_sgmor :: IsSemiGroupPreserving f
    ; monmor_unitmor :: IsUnitPreserving f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sgmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ringmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Aplus</span> : Plus A} {<span class="nv">Bplus</span> : Plus B}
    {<span class="nv">Amult</span> : Mult A} {<span class="nv">Bmult</span> : Mult B} {<span class="nv">Azero</span> : Zero A} {<span class="nv">Bzero</span> : Zero B}
    {<span class="nv">Aone</span> : One A} {<span class="nv">Bone</span> : One B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiRingPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { semiringmor_plus_mor :: @IsMonoidPreserving A B
        (+) (+) <span class="mi">0</span> <span class="mi">0</span> f
    ; semiringmor_mult_mor :: @IsMonoidPreserving A B
        (.*.) (.*.) <span class="mi">1</span> <span class="mi">1</span> f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiRingStrongPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { strong_semiringmor_sr_mor :: IsSemiRingPreserving f
    ; strong_semiringmor_strong_mor :: StrongExtensionality f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ringmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">latticemorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Ajoin</span> : Join A} {<span class="nv">Bjoin</span> : Join B}
    {<span class="nv">Ameet</span> : Meet A} {<span class="nv">Bmeet</span> : Meet B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsJoinPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    join_slmor_sgmor :: @IsSemiGroupPreserving A B join_is_sg_op join_is_sg_op f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMeetPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    meet_slmor_sgmor :: @IsSemiGroupPreserving A B meet_is_sg_op meet_is_sg_op f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Abottom</span> : Bottom A} {<span class="nv">Bbottom</span> : Bottom B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedJoinPreserving</span> (<span class="nv">f</span> : A -&gt; B) := bounded_join_slmor_monmor
      :: @IsMonoidPreserving A B join_is_sg_op join_is_sg_op
         bottom_is_mon_unit bottom_is_mon_unit f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsLatticePreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { latticemor_join_mor :: IsJoinPreserving f
    ; latticemor_meet_mor :: IsMeetPreserving f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">latticemorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">morphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">id_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{SgOp A} `{MonUnit A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkf">#[export] <span class="kn">Instance</span> <span class="nf">id_sg_morphism</span> : IsSemiGroupPreserving (@id A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk11">#[export] <span class="kn">Instance</span> <span class="nf">id_monoid_morphism</span> : IsMonoidPreserving (@id A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">id_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">compose_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{SgOp A} `{MonUnit A}
    `{SgOp B} `{MonUnit B}
    `{SgOp C} `{MonUnit C}
    (f : A -&gt; B) (g : B -&gt; C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Making these global instances causes typeclass loops.  Instead they are declared below as [Hint Extern]s that apply only when the goal has the specified form. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk13"><span class="kn">Local Instance</span> <span class="nf">compose_sg_morphism</span> : IsSemiGroupPreserving f -&gt; IsSemiGroupPreserving g -&gt;
    IsSemiGroupPreserving (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f -&gt;
IsSemiGroupPreserving g -&gt;
IsSemiGroupPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f -&gt;
IsSemiGroupPreserving g -&gt;
IsSemiGroupPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk15"><span class="nb">red</span>; <span class="nb">intros</span> fp gp x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚àò f) (sg_op x y) = sg_op ((g ‚àò f) x) ((g ‚àò f) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk16"><span class="nb">unfold</span> Compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f (sg_op x y)) = sg_op (g (f x)) (g (f y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk17"><span class="nb">refine</span> ((ap g _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op x y) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk18"><hr></label><div class="goal-conclusion">g <span class="nl">?Goal</span> = sg_op (g (f x)) (g (f y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op x y) = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (sg_op (f x) (f y)) = sg_op (g (f x)) (g (f y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> gp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1b"><span class="kn">Local Instance</span> <span class="nf">compose_monoid_morphism</span> : IsMonoidPreserving f -&gt; IsMonoidPreserving g -&gt;
    IsMonoidPreserving (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving f -&gt;
IsMonoidPreserving g -&gt; IsMonoidPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving f -&gt;
IsMonoidPreserving g -&gt; IsMonoidPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1d"><span class="nb">intros</span>;<span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (g ‚àò f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk1e"><hr></label><div class="goal-conclusion">IsUnitPreserving (g ‚àò f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk21"><span class="nb">red</span>;<span class="nb">unfold</span> Compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f mon_unit) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk22"><span class="nb">etransitivity</span>;[|<span class="bp">exact</span> (preserves_mon_unit (f:=g))].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f mon_unit) = g mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap,preserves_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">compose_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">invert_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{SgOp A} `{MonUnit A}
    `{SgOp B} `{MonUnit B}
    (f : A -&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk23"><span class="kn">Local Instance</span> <span class="nf">invert_sg_morphism</span>
    : <span class="kr">forall</span> `{!IsEquiv f}, IsSemiGroupPreserving f -&gt;
      IsSemiGroupPreserving (f^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsSemiGroupPreserving f -&gt; IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsSemiGroupPreserving f -&gt; IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk25"><span class="nb">red</span>; <span class="nb">intros</span> E fp x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> (sg_op x y) = sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk26"><span class="nb">apply</span> (equiv_inj f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> (sg_op x y)) = f (sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk27">lhs napply eisretr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op x y = f (sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk28"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y)) = sg_op x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk29">lhs napply fp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (f (f^-<span class="mi">1</span> x)) (f (f^-<span class="mi">1</span> y)) = sg_op x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">f_ap; <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2a"><span class="kn">Local Instance</span> <span class="nf">invert_monoid_morphism</span> :
    <span class="kr">forall</span> `{!IsEquiv f}, IsMonoidPreserving f -&gt; IsMonoidPreserving (f^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsMonoidPreserving f -&gt; IsMonoidPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsMonoidPreserving f -&gt; IsMonoidPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2c"><span class="nb">intros</span>;<span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk2d"><hr></label><div class="goal-conclusion">IsUnitPreserving f^-<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk30"><span class="nb">apply</span> (equiv_inj f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> mon_unit) = f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk31"><span class="nb">refine</span> (_ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> mon_unit) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk32"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = f mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk33">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> mon_unit) = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk34">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit = f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> preserves_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">invert_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsSemiGroupPreserving (_ ‚àò _)) =&gt;
  class_apply @compose_sg_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsMonoidPreserving (_ ‚àò _)) =&gt;
  class_apply @compose_monoid_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsSemiGroupPreserving (_ o _)) =&gt;
  class_apply @compose_sg_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsMonoidPreserving (_ o _)) =&gt;
  class_apply @compose_monoid_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsSemiGroupPreserving (_^-<span class="mi">1</span>)) =&gt;
  class_apply @invert_sg_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsMonoidPreserving (_^-<span class="mi">1</span>)) =&gt;
  class_apply @invert_monoid_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Instance</span> <span class="nf">isinjective_mapinO_tr</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  {<span class="nv">p</span> : MapIn (Tr (-<span class="mi">1</span>)) f} : IsInjective f
  := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">pfeq</span> =&gt; ap pr1 (@center _ (p (f y) (x; pfeq) (y; idpath))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">strong_injective</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B} (<span class="nv">f</span> : A -&gt; B) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsStrongInjective</span> :=
    { strong_injective : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â∂ y -&gt; f x ‚â∂ f y
    ; strong_injective_mor : StrongExtensionality f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">strong_injective</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">extras</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">CutMinusSpec</span> <span class="nv">A</span> (<span class="nv">cm</span> : CutMinus A) `{Zero A} `{Plus A} `{Le A} := {
  cut_minus_le : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, y ‚â§ x -&gt; x ‚à∏ y + y = x ;
  cut_minus_0 : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â§ y -&gt; x ‚à∏ y = <span class="mi">0</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk35">#[export] <span class="kn">Instance</span> <span class="nf">istrunc_isunitpreserving</span> `{Funext} {n A B} unitA unitB f
  : IsTrunc n.+<span class="mi">1</span> B -&gt; IsTrunc n (@IsUnitPreserving A B unitA unitB f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unitA</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>unitB</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> B -&gt; IsTrunc n (IsUnitPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>unitA</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>unitB</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> B -&gt; IsTrunc n (IsUnitPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> IsUnitPreserving; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk37">#[export] <span class="kn">Instance</span> <span class="nf">istrunc_issemigrouppreserving</span> `{Funext} {n A B} opA opB f
  : IsTrunc n.+<span class="mi">1</span> B -&gt; IsTrunc n (@IsSemiGroupPreserving A B opA opB f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>opA</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>opB</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> B -&gt; IsTrunc n (IsSemiGroupPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>opA</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>opB</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> B -&gt; IsTrunc n (IsSemiGroupPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> IsSemiGroupPreserving; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_IsSemiRingPreserving</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B} {f : A -&gt; B}
  : _ &lt;~&gt; IsSemiRingPreserving f := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_IsMonoidPreserving</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{SgOp A} `{SgOp B}
  `{MonUnit A} `{MonUnit B} {f : A -&gt; B} : _ &lt;~&gt; IsMonoidPreserving f
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_ismonoidpreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{SgOp A}
  `{SgOp B} `{IsHSet B} `{MonUnit A} `{MonUnit B} (f : A -&gt; B)
  : IsHProp (IsMonoidPreserving f)
  := istrunc_equiv_istrunc _ issig_IsMonoidPreserving.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_issemiringpreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{IsHSet B}
  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B}
  (f : A -&gt; B)
  : IsHProp (IsSemiRingPreserving f)
  := istrunc_equiv_istrunc _ issig_IsSemiRingPreserving.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_issemigroup</span> <span class="nv">x</span> <span class="nv">y</span> : _ &lt;~&gt; @IsSemiGroup x y := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_issemigroup</span> `{Funext} x y
  : IsHProp (@IsSemiGroup x y)
  := istrunc_equiv_istrunc _ (issig_issemigroup _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_ismonoid</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : _ &lt;~&gt; @IsMonoid x y z := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_ismonoid</span> `{Funext} x y z : IsHProp (@IsMonoid x y z)
  := istrunc_equiv_istrunc _ (issig_ismonoid _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_isgroup</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : _ &lt;~&gt; @IsGroup w x y z := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ishprop_isgroup</span> `{Funext} w x y z : IsHProp (@IsGroup w x y z)
  := istrunc_equiv_istrunc _ (issig_isgroup _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">extras</span>.</span></span></pre>
</div>
</div></body>
</html>
