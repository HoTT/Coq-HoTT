<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>HFiber.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types Diagrams.CommutativeSquares HSet.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> equiv_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Basic facts about fibrations *)</span>

<span class="c">(* ** Homotopy fibers *)</span>

<span class="sd">(** Paths in homotopy fibers can be constructed using [path_sigma] and [transport_paths_Fl]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk1"><span class="kn">Definition</span> <span class="nf">equiv_path_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; B} {<span class="nv">y</span> : B}
  (<span class="nv">x1</span> <span class="nv">x2</span> : hfiber f y)
  : { q : x1.<span class="mi">1</span> = x2.<span class="mi">1</span> &amp; x1.<span class="mi">2</span> = ap f q @ x2.<span class="mi">2</span> } &lt;~&gt; (x1 = x2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>hfiber f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{q : x1.<span class="mi">1</span> = x2.<span class="mi">1</span> &amp; x1.<span class="mi">2</span> = ap f q @ x2.<span class="mi">2</span>} &lt;~&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>hfiber f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{q : x1.<span class="mi">1</span> = x2.<span class="mi">1</span> &amp; x1.<span class="mi">2</span> = ap f q @ x2.<span class="mi">2</span>} &lt;~&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk3"><span class="nb">refine</span> (equiv_path_sigma _ _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>hfiber f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{q : x1.<span class="mi">1</span> = x2.<span class="mi">1</span> &amp; x1.<span class="mi">2</span> = ap f q @ x2.<span class="mi">2</span>} &lt;~&gt;
{p : x1.<span class="mi">1</span> = x2.<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = y) p x1.<span class="mi">2</span> = x2.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk4"><span class="nb">apply</span> equiv_functor_sigma_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>hfiber f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : x1.<span class="mi">1</span> = x2.<span class="mi">1</span>,
x1.<span class="mi">2</span> = ap f a @ x2.<span class="mi">2</span> &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = y) a x1.<span class="mi">2</span> = x2.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk5"><span class="nb">intros</span> p; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>hfiber f y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1.<span class="mi">1</span> = x2.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x1.<span class="mi">2</span> = ap f p @ x2.<span class="mi">2</span> &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = y) p x1.<span class="mi">2</span> = x2.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk6"><span class="nb">refine</span> (_ oE equiv_moveR_Vp _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>hfiber f y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1.<span class="mi">1</span> = x2.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f p)^ @ x1.<span class="mi">2</span> = x2.<span class="mi">2</span> &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = y) p x1.<span class="mi">2</span> = x2.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_concat_l (transport_paths_Fl _ _) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_hfiber_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; B} {<span class="nv">y</span> : B}
  {<span class="nv">x1</span> <span class="nv">x2</span> : hfiber f y}
  : { q : x1.<span class="mi">1</span> = x2.<span class="mi">1</span> &amp; x1.<span class="mi">2</span> = ap f q @ x2.<span class="mi">2</span> } -&gt; (x1 = x2)
  := equiv_path_hfiber x1 x2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; B} {<span class="nv">y</span> : B}
  {<span class="nv">x1</span> <span class="nv">x2</span> : hfiber f y} (<span class="nv">q</span> : x1.<span class="mi">1</span> = x2.<span class="mi">1</span>) (<span class="nv">r</span> : x1.<span class="mi">2</span> = ap f q @ x2.<span class="mi">2</span>)
  : x1 = x2
  := path_hfiber_uncurried (q;r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If we rearrange this a bit, then it characterizes the fibers of [ap]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk7"><span class="kn">Definition</span> <span class="nf">hfiber_ap</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; B} {<span class="nv">x1</span> <span class="nv">x2</span> : A}
           (<span class="nv">p</span> : f x1 = f x2)
  : hfiber (ap f) p &lt;~&gt; ((x1 ; p) = (x2 ; <span class="mi">1</span>) :&gt; hfiber f (f x2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x1 = f x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (ap f) p &lt;~&gt; (x1; p) = (x2; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x1 = f x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (ap f) p &lt;~&gt; (x1; p) = (x2; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk9"><span class="nb">refine</span> (equiv_path_hfiber (x1;p) (x2;<span class="mi">1</span>%path) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x1 = f x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (ap f) p &lt;~&gt;
{q : (x1; p).<span class="mi">1</span> = (x2; <span class="mi">1</span>).<span class="mi">1</span> &amp;
(x1; p).<span class="mi">2</span> = ap f q @ (x2; <span class="mi">1</span>).<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chka"><span class="nb">unfold</span> hfiber; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x1 = f x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : x1 = x2 &amp; ap f x = p} &lt;~&gt;
{q : x1 = x2 &amp; p = ap f q @ <span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chkb"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x1 = f x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f q = p &lt;~&gt; p = ap f q @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chkc"><span class="nb">refine</span> (_ oE equiv_path_inverse _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x1 = f x2</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = ap f q &lt;~&gt; p = ap f q @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_concat_r (concat_p1 _)^ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Homotopic maps have equivalent fibers. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chkd"><span class="kn">Definition</span> <span class="nf">equiv_hfiber_homotopic</span>
  {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; B) (<span class="nv">h</span> : f == g) (<span class="nv">b</span> : B)
  : hfiber f b &lt;~&gt; hfiber g b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b &lt;~&gt; hfiber g b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b &lt;~&gt; hfiber g b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chkf"><span class="nb">refine</span> (Build_Equiv _ _ (<span class="kr">fun</span> <span class="nv">fx</span> =&gt; (fx.<span class="mi">1</span> ; (h fx.<span class="mi">1</span>)^ @ fx.<span class="mi">2</span>)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">fx</span> : {x : A &amp; f x = b} =&gt;
   (fx.<span class="mi">1</span>; (h fx.<span class="mi">1</span>)^ @ fx.<span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk10"><span class="nb">refine</span> (isequiv_adjointify _ (<span class="kr">fun</span> <span class="nv">gx</span> =&gt; (gx.<span class="mi">1</span> ; (h gx.<span class="mi">1</span>) @ gx.<span class="mi">2</span>)) _ _);
    <span class="nb">intros</span> [a p]; <span class="nb">simpl</span>; <span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(h a)^ @ (h a @ p) = p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="hfiber-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><label class="goal-separator" for="hfiber-v-chk11"><hr></label><div class="goal-conclusion">h a @ ((h a)^ @ p) = p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(h a)^ @ (h a @ p) = p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_V_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h a @ ((h a)^ @ p) = p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p_Vp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutative squares induce maps between fibers. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk14"><span class="kn">Definition</span> <span class="nf">functor_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
           (<span class="nv">p</span> : k o f == g o h) (<span class="nv">b</span> : B)
: hfiber f b -&gt; hfiber g (k b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber g (k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber g (k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk16">snapply @functor_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; C</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="hfiber-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="hfiber-v-chk17"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) a -&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) (<span class="nl">?f</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) a -&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) (h a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> a e; <span class="bp">exact</span> ((p a)^ @ ap k e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This doesn&#39;t need to be defined as an instance, since typeclass search can already find it, but we state it here for the reader&#39;s benefit. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_functor_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
           `{IsEquiv A C h} `{IsEquiv B D k}
           (p : k o f == g o h) (b : B)
: IsEquiv (functor_hfiber p b) := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A &lt;~&gt; C} {<span class="nv">k</span> : B &lt;~&gt; D}
           (<span class="nv">p</span> : k o f == g o h) (<span class="nv">b</span> : B)
  : hfiber f b &lt;~&gt; hfiber g (k b)
  := Build_Equiv _ _ (functor_hfiber p b) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version of [functor_hfiber] which is functorial in both the function and the point *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk1a"><span class="kn">Definition</span> <span class="nf">functor_hfiber2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
           (<span class="nv">p</span> : k o f == g o h) {<span class="nv">b</span> : B} {<span class="nv">b&#39;</span> : D} (<span class="nv">q</span> : k b = b&#39;)
  : hfiber f b -&gt; hfiber g b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber g b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber g b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk1c">srapply functor_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; C</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="hfiber-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><label class="goal-separator" for="hfiber-v-chk1d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) a -&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = b&#39;) (<span class="nl">?f</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) a -&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = b&#39;) (h a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk20"><span class="nb">intros</span> a e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = b) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = b&#39;) (h a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((p a)^ @ ap k e @ q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk21"><span class="kn">Instance</span> <span class="nf">isequiv_functor_hfiber2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
       {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
       `{IsEquiv A C h} `{IsEquiv B D k}
       (p : k o f == g o h) {b : B} {b&#39; : D} (q : k b = b&#39;)
  : IsEquiv (functor_hfiber2 p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv k</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_hfiber2 p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv k</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_hfiber2 p q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk23"><span class="nb">refine</span> (isequiv_functor_sigma (f := h)); <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv h</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv k</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>k b = b&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">e</span> : f a = b =&gt; ((p a)^ @ ap k e) @ q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isequiv_compose (<span class="kr">fun</span> <span class="nv">e</span> =&gt; (p a)^ @ ap k e) (<span class="kr">fun</span> <span class="nv">e&#39;</span> =&gt; e&#39; @ q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_hfiber2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A &lt;~&gt; C} {<span class="nv">k</span> : B &lt;~&gt; D}
           (<span class="nv">p</span> : k o f == g o h) {<span class="nv">b</span> : B} {<span class="nv">b&#39;</span> : D} (<span class="nv">q</span> : k b = b&#39;)
  : hfiber f b &lt;~&gt; hfiber g b&#39;
  := Build_Equiv _ _ (functor_hfiber2 p q) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk24"><span class="kn">Definition</span> <span class="nf">functor_hfiber_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span> : <span class="kt">Type</span>} {<span class="nv">k</span> : A -&gt; B} {<span class="nv">l</span> : B -&gt; C}
    {<span class="nv">f</span> : A -&gt; X} {<span class="nv">g</span> : B -&gt; Y} {<span class="nv">h</span> : C -&gt; Z} {<span class="nv">i</span> : X -&gt; Y} {<span class="nv">j</span> : Y -&gt; Z}
    (<span class="nv">H</span> : i o f == g o k) (<span class="nv">K</span> : j o g == h o l)
  : <span class="kr">forall</span> <span class="nv">x</span>, functor_hfiber (comm_square_comp&#39; H K) x
    == (functor_hfiber K (i x)) o (functor_hfiber H x : hfiber f x -&gt; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
functor_hfiber (comm_square_comp&#39; H K) x ==
functor_hfiber K (i x)
o (functor_hfiber H x : hfiber f x -&gt; hfiber g (i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : X,
functor_hfiber (comm_square_comp&#39; H K) x ==
functor_hfiber K (i x)
o (functor_hfiber H x : hfiber f x -&gt; hfiber g (i x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk26"><span class="nb">intros</span> x [y p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f y = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_hfiber (comm_square_comp&#39; H K) x (y; p) =
functor_hfiber K (i x) (functor_hfiber H x (y; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk27"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_hfiber (comm_square_comp&#39; H K) (f y) (y; <span class="mi">1</span>) =
functor_hfiber K (i (f y))
  (functor_hfiber H (f y) (y; <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk28"><span class="nb">apply</span> (path_sigma&#39; _ idpath).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; h x = j (i (f y))) <span class="mi">1</span>
  ((comm_square_comp&#39; H K (y; <span class="mi">1</span>).<span class="mi">1</span>)^ @
   ap (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; j (i x)) (y; <span class="mi">1</span>).<span class="mi">2</span>) =
(K (functor_hfiber H (f y) (y; <span class="mi">1</span>)).<span class="mi">1</span>)^ @
ap j (functor_hfiber H (f y) (y; <span class="mi">1</span>)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk29"><span class="nb">refine</span> (concat_p1 _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(comm_square_comp&#39; H K (y; <span class="mi">1</span>).<span class="mi">1</span>)^ =
(K (functor_hfiber H (f y) (y; <span class="mi">1</span>)).<span class="mi">1</span>)^ @
ap j (functor_hfiber H (f y) (y; <span class="mi">1</span>)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk2a"><span class="nb">refine</span> (inv_pp _ _ @ ap _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap j (H (y; <span class="mi">1</span>).<span class="mi">1</span>))^ =
ap j (functor_hfiber H (f y) (y; <span class="mi">1</span>)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk2b"><span class="nb">refine</span> ((ap_V _ _)^ @ ap _ _^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>C -&gt; Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i o f == g o k</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>j o g == h o l</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(functor_hfiber H (f y) (y; <span class="mi">1</span>)).<span class="mi">2</span> = (H (y; <span class="mi">1</span>).<span class="mi">1</span>)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The 3x3 lemma for fibrations *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk2c"><span class="kn">Definition</span> <span class="nf">hfiber_functor_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
  {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
  (<span class="nv">p</span> : k o f == g o h) (<span class="nv">b</span> : B) (<span class="nv">c</span> : C) (<span class="nv">q</span> : g c = k b)
  : hfiber (functor_hfiber p b) (c;q)
    &lt;~&gt; hfiber (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (p x)^) c) (b;q^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_hfiber p b) (c; q) &lt;~&gt;
hfiber (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) c)
  (b; q^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_hfiber p b) (c; q) &lt;~&gt;
hfiber (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) c)
  (b; q^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk2e">rapply (equiv_functor_sigma_id _ oE _ oE (equiv_functor_sigma_id _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : hfiber h c,
<span class="nl">?Goal</span> a &lt;~&gt;
functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) c a = (b; q^)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="hfiber-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br></div><label class="goal-separator" for="hfiber-v-chk2f"><hr></label><div class="goal-conclusion">{x : _ &amp; <span class="nl">?Goal2</span> x} &lt;~&gt; {x : _ &amp; <span class="nl">?Goal</span> x}</div></blockquote><input class="alectryon-extra-goal-toggle" id="hfiber-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br></div><label class="goal-separator" for="hfiber-v-chk30"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : hfiber f b,
<span class="nl">?Goal2</span> a &lt;~&gt; functor_hfiber p b a = (c; q)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk31"><span class="mi">1</span>,<span class="mi">3</span>:<span class="nb">intros</span>; rapply equiv_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : hfiber f b &amp;
{p0 : (functor_hfiber p b a).<span class="mi">1</span> = (c; q).<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) p0
  (functor_hfiber p b a).<span class="mi">2</span> = (c; q).<span class="mi">2</span>}} &lt;~&gt;
{a : hfiber h c &amp;
{p0
: (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) c a).<span class="mi">1</span> =
  (b; q^).<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) p0
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) c a).<span class="mi">2</span> =
(b; q^).<span class="mi">2</span>}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk32"><span class="nb">refine</span> (equiv_sigma_assoc _ _ oE _ oE (equiv_sigma_assoc _ _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp;
{p0 : f a = b &amp;
{p1 : (functor_hfiber p b (a; p0)).<span class="mi">1</span> = (c; q).<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) p1
  (functor_hfiber p b (a; p0)).<span class="mi">2</span> = (c; q).<span class="mi">2</span>}}} &lt;~&gt;
{a : A &amp;
{p0 : h a = c &amp;
{p1
: (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) c (a; p0)).<span class="mi">1</span> =
  (b; q^).<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) p1
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (p x)^) c (a; p0)).<span class="mi">2</span> =
(b; q^).<span class="mi">2</span>}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk33"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p0 : f a = b &amp;
{p1 : h a = c &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) p1
  ((p a)^ @ ap k p0) = q}} &lt;~&gt;
{p0 : h a = c &amp;
{p1 : f a = b &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) p1
  (((p a)^)^ @ ap g p0) = q^}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk34"><span class="nb">refine</span> (equiv_sigma_symm _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p0 : f a = b &amp;
{p1 : h a = c &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) p1
  ((p a)^ @ ap k p0) = q}} &lt;~&gt;
{a0 : f a = b &amp;
{b0 : h a = c &amp;
transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) a0
  (((p a)^)^ @ ap g b0) = q^}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk35"><span class="kp">do</span> <span class="mi">2</span> (<span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intro</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>h a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) a1
  ((p a)^ @ ap k a0) = q &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) a0
  (((p a)^)^ @ ap g a1) = q^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk36"><span class="nb">refine</span> ((equiv_ap inverse _ _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>h a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) a1
  ((p a)^ @ ap k a0) = q &lt;~&gt;
(transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) a0
   (((p a)^)^ @ ap g a1))^ = (q^)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk37"><span class="nb">refine</span> (equiv_concat_r (inv_V q)^ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>h a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) a1
  ((p a)^ @ ap k a0) = q &lt;~&gt;
(transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) a0
   (((p a)^)^ @ ap g a1))^ = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk38"><span class="nb">apply</span> equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C -&gt; D</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>k o f == g o h</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g c = k b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>f a = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>h a = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k x = g c) a0
   (((p a)^)^ @ ap g a1))^ =
transport (<span class="kr">fun</span> <span class="nv">x</span> : C =&gt; g x = k b) a1
  ((p a)^ @ ap k a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="nb">rewrite</span> !transport_paths_Fl, !inv_pp, !inv_V, concat_pp_p; <span class="bp">reflexivity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Replacing a map with a fibration *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk39"><span class="kn">Definition</span> <span class="nf">equiv_fibration_replacement</span>  {<span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span>:C -&gt;B)
  : C &lt;~&gt; {y:B &amp; hfiber f y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C &lt;~&gt; {y : B &amp; hfiber f y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C &lt;~&gt; {y : B &amp; hfiber f y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This is a useful variant for taking a &quot;double fiber&quot; of two maps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk3b"><span class="kn">Definition</span> <span class="nf">equiv_double_fibration_replacement</span>
  {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">g</span> : X -&gt; Z)
  : X &lt;~&gt; {y : Y &amp; {z : Z &amp; {x : X &amp; f x = y /\ g x = z}}}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X &lt;~&gt;
{y : Y &amp; {z : Z &amp; {x : X &amp; (f x = y) * (g x = z)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X -&gt; Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X &lt;~&gt;
{y : Y &amp; {z : Z &amp; {x : X &amp; (f x = y) * (g x = z)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk3d"><span class="kn">Definition</span> <span class="nf">hfiber_fibration</span> {<span class="nv">X</span>} (<span class="nv">x</span> : X) (<span class="nv">P</span>:X-&gt;<span class="kt">Type</span>)
  : P x &lt;~&gt; @hfiber (sig P) X pr1 x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x &lt;~&gt; hfiber pr1 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x &lt;~&gt; hfiber pr1 x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Exercise 4.4: The unstable octahedral axiom. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UnstableOctahedral</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">n</span> : trunc_index) {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hfiber_compose_map</span> (<span class="nv">c</span> : C)
    : hfiber (g o f) c -&gt; hfiber g c
    := <span class="kr">fun</span> <span class="nv">x</span> =&gt; (f x.<span class="mi">1</span> ; x.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk3f"><span class="kn">Definition</span> <span class="nf">hfiber_hfiber_compose_map</span> (<span class="nv">b</span> : B)
    : hfiber (hfiber_compose_map (g b)) (b;<span class="mi">1</span>) &lt;~&gt; hfiber f b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (hfiber_compose_map (g b)) (b; <span class="mi">1</span>) &lt;~&gt;
hfiber f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (hfiber_compose_map (g b)) (b; <span class="mi">1</span>) &lt;~&gt;
hfiber f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk41"><span class="nb">unfold</span> hfiber, hfiber_compose_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : {x : A &amp; g (f x) = g b} &amp; (f x.<span class="mi">1</span>; x.<span class="mi">2</span>) = (b; <span class="mi">1</span>)} &lt;~&gt;
{x : A &amp; f x = b}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Once we &quot;destruct&quot; the equality in a sigma type, the rest is just shuffling of data and path induction. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk42"><span class="nb">refine</span> (_ oE equiv_functor_sigma_id (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (equiv_path_sigma _ _ _)^-<span class="mi">1</span>)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : {x : A &amp; g (f x) = g b} &amp;
{p : f x.<span class="mi">1</span> = b &amp;
transport (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt; g x0 = g b) p x.<span class="mi">2</span> = <span class="mi">1</span>}} &lt;~&gt;
{x : A &amp; f x = b}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk43"><span class="kn">Definition</span> <span class="nf">hfiber_compose</span> (<span class="nv">c</span> : C)
    : hfiber (g o f) c &lt;~&gt; { w : hfiber g c &amp; hfiber f w.<span class="mi">1</span> }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (g o f) c &lt;~&gt; {w : hfiber g c &amp; hfiber f w.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (g o f) c &lt;~&gt; {w : hfiber g c &amp; hfiber f w.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">make_equiv_contr_basedpaths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk45">#[export] <span class="kn">Instance</span> <span class="nf">istruncmap_compose</span> `{!IsTruncMap n g} `{!IsTruncMap n f}
    : IsTruncMap n (g o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>IsTruncMap0</var><span class="hyp-type"><b>: </b><span>IsTruncMap n g</span></span></span><br><span><var>IsTruncMap1</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>IsTruncMap0</var><span class="hyp-type"><b>: </b><span>IsTruncMap n g</span></span></span><br><span><var>IsTruncMap1</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n (g o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk47"><span class="nb">intros</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>IsTruncMap0</var><span class="hyp-type"><b>: </b><span>IsTruncMap n g</span></span></span><br><span><var>IsTruncMap1</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_isequiv_istrunc _ (hfiber_compose c)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UnstableOctahedral</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We characterize the fibers of [functor_forall], but only in the special case where the base map is [idmap]. This doesn&#39;t depend on anything else in this file, but can&#39;t be put in Types/Forall.v, because it requires results from Types/Sigma.v. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk48"><span class="kn">Definition</span> <span class="nf">hfiber_functor_forall_id</span> `{Funext} {A : <span class="kt">Type</span>} {P Q : A -&gt; <span class="kt">Type</span>}
  (h : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a) (g : <span class="kr">forall</span> <span class="nv">a</span>, Q a)
  : hfiber (functor_forall_id h) g &lt;~&gt; (<span class="kr">forall</span> <span class="nv">a</span>, hfiber (h a) (g a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_forall_id h) g &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, hfiber (h a) (g a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (functor_forall_id h) g &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, hfiber (h a) (g a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk4a"><span class="nb">unfold</span> hfiber, functor_forall_id, functor_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : <span class="kr">forall</span> <span class="nv">a</span> : A, P a &amp; (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; h b (x b)) = g} &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, {x : P a &amp; h a x = g a})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk4b">nrefine (equiv_sig_coind _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : <span class="kr">forall</span> <span class="nv">a</span> : A, P a &amp; (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; h b (x b)) = g} &lt;~&gt;
{f : <span class="kr">forall</span> <span class="nv">x</span> : A, P x &amp;
<span class="kr">forall</span> <span class="nv">x</span> : A, h x (f x) = g x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk4c"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, Q a</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; h b (f b)) = g &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, h x (f x) = g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_apD10.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Fibers of constant functions *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hfiber_const</span> <span class="nv">A</span> {<span class="nv">B</span>} (<span class="nv">y</span> <span class="nv">y&#39;</span> : B)
  : hfiber (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; y) y&#39; &lt;~&gt; A * (y = y&#39;)
  := equiv_sigma_prod0 A (y = y&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">istruncmap_const</span> <span class="nv">n</span> {<span class="nv">A</span> <span class="nv">B</span>} `{!IsTrunc n A}
       (y : B) `{!<span class="kr">forall</span> <span class="nv">y&#39;</span>, IsTrunc n (y = y&#39;)}
  : IsTruncMap n (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; y)
  := <span class="kr">fun</span> <span class="nv">y&#39;</span> =&gt; _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** [IsTruncMap n.+1 f &lt;-&gt; IsTruncMap n (ap f)] *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">istruncmap_ap</span> {<span class="nv">A</span> <span class="nv">B</span>} <span class="nv">n</span> (<span class="nv">f</span>:A -&gt; B) `{!IsTruncMap n.+<span class="mi">1</span> f}
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsTruncMap n (@ap _ _ f x y)
  := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">x&#39;</span> <span class="nv">y</span> =&gt;
       istrunc_equiv_istrunc _ (hfiber_ap y)^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk4d"><span class="kn">Definition</span> <span class="nf">istruncmap_from_ap</span> {<span class="nv">A</span> <span class="nv">B</span>} <span class="nv">n</span> (<span class="nv">f</span>:A -&gt; B) `{!<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsTruncMap n (@ap _ _ f x y)}
  : IsTruncMap n.+<span class="mi">1</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTruncMap n (ap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n.+<span class="mi">1</span> f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTruncMap n (ap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n.+<span class="mi">1</span> f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk4f"><span class="nb">intro</span> y; <span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTruncMap n (ap f)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y0</span> : hfiber f y, IsTrunc n (x = y0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [a p] [b q];
    <span class="nb">destruct</span> q;
    <span class="bp">exact</span> (istrunc_equiv_istrunc _ (hfiber_ap p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_istruncmap_ap</span> `{Funext} {A B} n (f:A -&gt; B)
  : IsTruncMap n.+<span class="mi">1</span> f &lt;~&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsTruncMap n (@ap _ _ f x y))
  := equiv_iff_hprop (@istruncmap_ap _ _ n f) (@istruncmap_from_ap _ _ n f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk50"><span class="kn">Instance</span> <span class="nf">isequiv_ap_isembedding</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{!IsEmbedding f}
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsEquiv (@ap _ _ f x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsEquiv (ap f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsEquiv (ap f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk52"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (ap f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isequiv_contr_map,_.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_ap_isembedding</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{!IsEmbedding f} (x y : A)
  : (x = y) &lt;~&gt; (f x = f y)
  := Build_Equiv _ _ (ap f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk53"><span class="kn">Definition</span> <span class="nf">isembedding_isequiv_ap</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{!<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsEquiv (@ap _ _ f x y)}
  : IsEmbedding f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsEquiv (ap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsEquiv (ap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply istruncmap_from_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk55"><span class="kn">Definition</span> <span class="nf">equiv_isequiv_ap_isembedding</span> `{Funext} {A B} (f : A -&gt; B)
  : IsEmbedding f &lt;~&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsEquiv (@ap _ _ f x y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding f &lt;~&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsEquiv (ap f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding f &lt;~&gt; (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsEquiv (ap f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_iff_hprop (@isequiv_ap_isembedding _ _ f) (@isembedding_isequiv_ap _ _ f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows from [isembedding_isequiv_ap] and [isequiv_ap_equiv_fun] that [equiv_fun] is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk57"><span class="kn">Instance</span> <span class="nf">isembedding_equiv_fun</span> `{Funext} {A B : <span class="kt">Type</span>}
  : IsEmbedding (@equiv_fun A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding equiv_fun</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding equiv_fun</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isembedding_isequiv_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk59"><span class="kn">Lemma</span> <span class="nf">ap_isinj_embedding_beta</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; Y) {<span class="nv">I</span> : IsEmbedding f} {<span class="nv">x0</span> <span class="nv">x1</span> : X}
  : <span class="kr">forall</span> (<span class="nv">p</span> : f x0 = f x1), ap f (isinj_embedding f I x0 x1 p) = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : f x0 = f x1,
ap f (isinj_embedding f I x0 x1 p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : f x0 = f x1,
ap f (isinj_embedding f I x0 x1 p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk5b">equiv_intro (equiv_ap_isembedding f x0 x1) q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x0 = x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (isinj_embedding f I x0 x1
     (equiv_ap_isembedding f x0 x1 q)) =
equiv_ap_isembedding f x0 x1 q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk5c"><span class="nb">induction</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (isinj_embedding f I x0 x0
     (equiv_ap_isembedding f x0 x0 <span class="mi">1</span>)) =
equiv_ap_isembedding f x0 x0 <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="hfiber-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="hfiber-v-chk5d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>I</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (isinj_embedding f I x0 x0 <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap _ (isinj_embedding_beta f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
