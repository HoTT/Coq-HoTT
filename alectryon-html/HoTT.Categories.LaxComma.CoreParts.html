<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>CoreParts.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk0"><span class="kn">Require Import</span> Category.Core Functor.Core NaturalTransformation.Core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Functor.Composition.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> NaturalTransformation.Paths NaturalTransformation.Composition.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Category.Morphisms FunctorCategory.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pseudofunctor.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> NaturalTransformation.Composition.Laws.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Trunc Types.Sigma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Basics.Tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> Functor.Identity.FunctorIdentityNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Universe Polymorphism</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Asymmetric Patterns</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> morphism_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> category_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> type_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Quoting David Spivak:</span>

<span class="sd">    David: ok</span>
<span class="sd">       so an object of [FC ‚áì D] is a pair [(X, G)], where [X] is a</span>
<span class="sd">       finite category (or a small category or whatever you wanted)</span>
<span class="sd">       and [G : X --&gt; D] is a functor.</span>
<span class="sd">       a morphism in [FC ‚áì D] is a ``natural transformation diagram&#39;&#39;</span>
<span class="sd">       (as opposed to a commutative diagram, in which the natural</span>
<span class="sd">       transformation would be ``identity&#39;&#39;)</span>
<span class="sd">       so a map in [FC ‚áì D] from [(X, G)] to [(X&#39;, G&#39;)] is a pair</span>
<span class="sd">       [(F, Œ±)] where [F : X --&gt; X&#39;] is a functor and</span>
<span class="sd">       [Œ± : G --&gt; G&#39; ‚àò F] is a natural transformation</span>
<span class="sd">       and the punchline is that there is a functor</span>
<span class="sd">       [colim : FC ‚áì D --&gt; D]</span>

<span class="sd">     David: consider for yourself the case where [F : X --&gt; X&#39;] is</span>
<span class="sd">       identity ([X = X&#39;]) and (separately) the case where</span>
<span class="sd">       [Œ± : G --&gt; G ‚àò F] is identity.</span>
<span class="sd">       the point is, you&#39;ve already done the work to get this colim</span>
<span class="sd">       functor.</span>
<span class="sd">       because every map in [FC ‚áì D] can be written as a composition</span>
<span class="sd">       of two maps, one where the [F]-part is identity and one where</span>
<span class="sd">       the [Œ±]-part is identity.</span>
<span class="sd">       and you&#39;ve worked both of those cases out already.</span>
<span class="sd">       *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Import</span> LaxCommaCategoryParts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">lax_comma_category_parts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variables</span> <span class="nv">A</span> <span class="nv">B</span> : PreCategory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">S</span> : Pseudofunctor A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">T</span> : Pseudofunctor B.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, IsHSet (Functor (S a) (T b))}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">object</span> :=
      {
        a : A;
        b : B;
        f : Functor (S a) (T b)
      }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">object_sig_T</span> :=
      ({ a : A
       | { b : B
         | Functor (S a) (T b) }}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk1"><span class="kn">Lemma</span> <span class="nf">issig_object</span>
    : object_sig_T &lt;~&gt; object.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; Functor (S a) (T b)}} &lt;~&gt; object</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; {b : B &amp; Functor (S a) (T b)}} &lt;~&gt; object</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">issig.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk3">#[export] <span class="kn">Instance</span> <span class="nf">trunc_object</span> `{IsTrunc n A, IsTrunc n B}
           `{<span class="kr">forall</span> <span class="nv">s</span> <span class="nv">d</span>, IsTrunc n (Functor (S s) (T d))}
    : IsTrunc n object.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s</span> : A) (<span class="nv">d</span> : B),
IsTrunc n (Functor (S s) (T d))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n object</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s</span> : A) (<span class="nv">d</span> : B),
IsTrunc n (Functor (S s) (T d))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n object</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk5"><span class="nb">eapply</span> istrunc_equiv_istrunc;
      [ <span class="bp">exact</span> issig_object | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">s</span> : A) (<span class="nv">d</span> : B),
IsTrunc n (Functor (S s) (T d))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n {a : A &amp; {b : B &amp; Functor (S a) (T b)}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk6"><span class="kn">Lemma</span> <span class="nf">path_object</span> (<span class="nv">x</span> <span class="nv">y</span> : object)
    : <span class="kr">forall</span> (<span class="nv">Ha</span> : x.(a) = y.(a))
             (<span class="nv">Hb</span> : x.(b) = y.(b)),
        <span class="kr">match</span> Ha <span class="kr">in</span> _ = X, Hb <span class="kr">in</span> _ = Y <span class="kr">return</span> Functor (S X) (T Y) <span class="kr">with</span>
          | idpath, idpath =&gt; x.(f)
        <span class="kr">end</span> = y.(f)
        -&gt; x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Ha</span> : a x = a y) (<span class="nv">Hb</span> : b x = b y),
<span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T (b y)))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y) <span class="kr">return</span> (Functor (S (a x)) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f x
    <span class="kr">end</span>
<span class="kr">end</span> = f y -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Ha</span> : a x = a y) (<span class="nv">Hb</span> : b x = b y),
<span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T (b y)))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y) <span class="kr">return</span> (Functor (S (a x)) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f x
    <span class="kr">end</span>
<span class="kr">end</span> = f y -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk8"><span class="nb">destruct</span> x, y; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>Functor (S a0) (T b0)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Functor (S a1) (T b1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Ha</span> : a0 = a1) (<span class="nv">Hb</span> : b0 = b1),
<span class="kr">match</span> Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T b1)) <span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y) <span class="kr">return</span> (Functor (S a0) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f0
    <span class="kr">end</span>
<span class="kr">end</span> = f1 -&gt;
{| a := a0; b := b0; f := f0 |} =
{| a := a1; b := b1; f := f1 |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; path_induction; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_object_uncurried</span> <span class="nv">x</span> <span class="nv">y</span>
               (<span class="nv">H</span> : { HaHb : (x.(a) = y.(a)) * (x.(b) = y.(b))
                    | <span class="kr">match</span> fst HaHb <span class="kr">in</span> _ = X, snd HaHb <span class="kr">in</span> _ = Y <span class="kr">return</span> Functor (S X) (T Y) <span class="kr">with</span>
                        | idpath, idpath =&gt; x.(f)
                      <span class="kr">end</span> = y.(f) })
    : x = y
      := @path_object x y (fst H.<span class="mi">1</span>) (snd H.<span class="mi">1</span>) H.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk9"><span class="kn">Lemma</span> <span class="nf">ap_a_path_object</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">Ha</span> <span class="nv">Hb</span> <span class="nv">Hf</span>
    : ap (@a) (@path_object x y Ha Hb Hf) = Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a x = a y</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>b x = b y</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T (b y)))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y)
      <span class="kr">return</span> (Functor (S (a x)) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f x
    <span class="kr">end</span>
<span class="kr">end</span> = f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap a (path_object x y Ha Hb Hf) = Ha</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a x = a y</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>b x = b y</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T (b y)))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y)
      <span class="kr">return</span> (Functor (S (a x)) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f x
    <span class="kr">end</span>
<span class="kr">end</span> = f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap a (path_object x y Ha Hb Hf) = Ha</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chkb"><span class="nb">destruct</span> x, y; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>Functor (S a0) (T b0)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Functor (S a1) (T b1)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 = a1</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>b0 = b1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T b1))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y) <span class="kr">return</span> (Functor (S a0) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f0
    <span class="kr">end</span>
<span class="kr">end</span> = f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap a
  (path_object {| a := a0; b := b0; f := f0 |}
     {| a := a1; b := b1; f := f1 |} Ha Hb Hf) = Ha</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chkc"><span class="nb">destruct</span> Ha, Hb, Hf; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>Functor (S a0) (T b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%path = <span class="mi">1</span>%path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chkd"><span class="kn">Lemma</span> <span class="nf">ap_b_path_object</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">Ha</span> <span class="nv">Hb</span> <span class="nv">Hf</span>
    : ap (@b) (@path_object x y Ha Hb Hf) = Hb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a x = a y</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>b x = b y</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T (b y)))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y)
      <span class="kr">return</span> (Functor (S (a x)) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f x
    <span class="kr">end</span>
<span class="kr">end</span> = f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap b (path_object x y Ha Hb Hf) = Hb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a x = a y</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>b x = b y</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T (b y)))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y)
      <span class="kr">return</span> (Functor (S (a x)) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f x
    <span class="kr">end</span>
<span class="kr">end</span> = f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap b (path_object x y Ha Hb Hf) = Hb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chkf"><span class="nb">destruct</span> x, y; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>Functor (S a0) (T b0)</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Functor (S a1) (T b1)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 = a1</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>b0 = b1</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Ha <span class="kr">in</span> (_ = X) <span class="kr">return</span> (Functor (S X) (T b1))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hb <span class="kr">in</span> (_ = Y) <span class="kr">return</span> (Functor (S a0) (T Y))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; f0
    <span class="kr">end</span>
<span class="kr">end</span> = f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap b
  (path_object {| a := a0; b := b0; f := f0 |}
     {| a := a1; b := b1; f := f1 |} Ha Hb Hf) = Hb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk10"><span class="nb">destruct</span> Ha, Hb, Hf; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>Functor (S a0) (T b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%path = <span class="mi">1</span>%path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Opaque</span> path_object.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">morphism</span> (<span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span> : object) :=
      {
        g : Category.Core.morphism A (abf.(a)) (a&#39;b&#39;f&#39;.(a));
        h : Category.Core.morphism B (abf.(b)) (a&#39;b&#39;f&#39;.(b));
        p : NaturalTransformation (p_morphism_of T h o abf.(f))
                                  (a&#39;b&#39;f&#39;.(f) o p_morphism_of S g)
      }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">morphism_sig_T</span> abf a&#39;b&#39;f&#39; :=
      ({ g : Category.Core.morphism A (abf.(a)) (a&#39;b&#39;f&#39;.(a))
       | { h : Category.Core.morphism B (abf.(b)) (a&#39;b&#39;f&#39;.(b))
         | NaturalTransformation (p_morphism_of T h o abf.(f))
                                 (a&#39;b&#39;f&#39;.(f) o p_morphism_of S g) }}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk11"><span class="kn">Lemma</span> <span class="nf">issig_morphism</span> <span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span>
    : (morphism_sig_T abf a&#39;b&#39;f&#39;)
        &lt;~&gt; morphism abf a&#39;b&#39;f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism_sig_T abf a&#39;b&#39;f&#39; &lt;~&gt; morphism abf a&#39;b&#39;f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism_sig_T abf a&#39;b&#39;f&#39; &lt;~&gt; morphism abf a&#39;b&#39;f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">issig.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk13">#[export] <span class="kn">Instance</span> <span class="nf">trunc_morphism</span> <span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span>
           `{IsTrunc n (Category.Core.morphism A (abf.(a)) (a&#39;b&#39;f&#39;.(a)))}
           `{IsTrunc n (Category.Core.morphism B (abf.(b)) (a&#39;b&#39;f&#39;.(b)))}
           `{<span class="kr">forall</span> <span class="nv">m1</span> <span class="nv">m2</span>,
               IsTrunc n (NaturalTransformation
                            (p_morphism_of T m2 o abf.(f))
                            (a&#39;b&#39;f&#39;.(f) o p_morphism_of S m1))}
    : IsTrunc n (morphism abf a&#39;b&#39;f&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n
  (Core.morphism A (a abf) (a a&#39;b&#39;f&#39;))</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n
  (Core.morphism B (b abf) (b a&#39;b&#39;f&#39;))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m1</span> : Core.morphism A (a abf) (a a&#39;b&#39;f&#39;))
(<span class="nv">m2</span> : Core.morphism B (b abf) (b a&#39;b&#39;f&#39;)),
IsTrunc n
  (NaturalTransformation
     (p_morphism_of T m2 o f abf)
     (f a&#39;b&#39;f&#39; o p_morphism_of S m1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (morphism abf a&#39;b&#39;f&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n
  (Core.morphism A (a abf) (a a&#39;b&#39;f&#39;))</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n
  (Core.morphism B (b abf) (b a&#39;b&#39;f&#39;))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m1</span> : Core.morphism A (a abf) (a a&#39;b&#39;f&#39;))
(<span class="nv">m2</span> : Core.morphism B (b abf) (b a&#39;b&#39;f&#39;)),
IsTrunc n
  (NaturalTransformation
     (p_morphism_of T m2 o f abf)
     (f a&#39;b&#39;f&#39; o p_morphism_of S m1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (morphism abf a&#39;b&#39;f&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk15"><span class="nb">eapply</span> istrunc_equiv_istrunc;
      [ <span class="bp">exact</span> (issig_morphism _ _) | ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n
  (Core.morphism A (a abf) (a a&#39;b&#39;f&#39;))</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc n
  (Core.morphism B (b abf) (b a&#39;b&#39;f&#39;))</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m1</span> : Core.morphism A (a abf) (a a&#39;b&#39;f&#39;))
(<span class="nv">m2</span> : Core.morphism B (b abf) (b a&#39;b&#39;f&#39;)),
IsTrunc n
  (NaturalTransformation
     (p_morphism_of T m2 o f abf)
     (f a&#39;b&#39;f&#39; o p_morphism_of S m1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (morphism_sig_T abf a&#39;b&#39;f&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk16"><span class="kn">Lemma</span> <span class="nf">path_morphism</span> <span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span>
          (<span class="nv">gh</span> <span class="nv">g&#39;h&#39;</span> : morphism abf a&#39;b&#39;f&#39;)
    : <span class="kr">forall</span>
        (<span class="nv">Hg</span> : gh.(g) = g&#39;h&#39;.(g))
        (<span class="nv">Hh</span> : gh.(h) = g&#39;h&#39;.(h)),
        <span class="kr">match</span> Hg <span class="kr">in</span> _ = g, Hh <span class="kr">in</span> _ = h
              <span class="kr">return</span> NaturalTransformation
                       (p_morphism_of T h o abf.(f))
                       (a&#39;b&#39;f&#39;.(f) o p_morphism_of S g)
        <span class="kr">with</span>
          | idpath, idpath =&gt; gh.(p)
        <span class="kr">end</span> = g&#39;h&#39;.(p)
         -&gt; gh = g&#39;h&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh, g'h'</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hg</span> : g gh = g g&#39;h&#39;) (<span class="nv">Hh</span> : h gh = h g&#39;h&#39;),
<span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T (h g&#39;h&#39;) o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S (g gh)))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p gh
    <span class="kr">end</span>
<span class="kr">end</span> = p g&#39;h&#39; -&gt; gh = g&#39;h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh, g'h'</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hg</span> : g gh = g g&#39;h&#39;) (<span class="nv">Hh</span> : h gh = h g&#39;h&#39;),
<span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T (h g&#39;h&#39;) o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S (g gh)))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p gh
    <span class="kr">end</span>
<span class="kr">end</span> = p g&#39;h&#39; -&gt; gh = g&#39;h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk18"><span class="nb">intros</span> Hg Hh Hp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh, g'h'</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g gh = g g&#39;h&#39;</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h gh = h g&#39;h&#39;</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T (h g&#39;h&#39;) o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S (g gh)))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p gh
    <span class="kr">end</span>
<span class="kr">end</span> = p g&#39;h&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">gh = g&#39;h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk19"><span class="nb">destruct</span> gh, g&#39;h&#39;; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>Core.morphism A (a abf) (a a&#39;b&#39;f&#39;)</span></span></span><br><span><var>h0</var><span class="hyp-type"><b>: </b><span>Core.morphism B (b abf) (b a&#39;b&#39;f&#39;)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>NaturalTransformation
  (p_morphism_of T h0 o f abf)
  (f a&#39;b&#39;f&#39; o p_morphism_of S g0)</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>Core.morphism A (a abf) (a a&#39;b&#39;f&#39;)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>Core.morphism B (b abf) (b a&#39;b&#39;f&#39;)</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>NaturalTransformation
  (p_morphism_of T h1 o f abf)
  (f a&#39;b&#39;f&#39; o p_morphism_of S g1)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g0 = g1</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h0 = h1</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T h1 o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S g0))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p0
    <span class="kr">end</span>
<span class="kr">end</span> = p1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{| g := g0; h := h0; p := p0 |} =
{| g := g1; h := h1; p := p1 |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk1a"><span class="nb">destruct</span> Hg, Hh, Hp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>Core.morphism A (a abf) (a a&#39;b&#39;f&#39;)</span></span></span><br><span><var>h0</var><span class="hyp-type"><b>: </b><span>Core.morphism B (b abf) (b a&#39;b&#39;f&#39;)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>NaturalTransformation
  (p_morphism_of T h0 o f abf)
  (f a&#39;b&#39;f&#39; o p_morphism_of S g0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{| g := g0; h := h0; p := p0 |} =
{| g := g0; h := h0; p := p0 |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_morphism_uncurried</span> <span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span> <span class="nv">gh</span> <span class="nv">g&#39;h&#39;</span>
               (<span class="nv">H</span> : { HgHh : (gh.(g) = g&#39;h&#39;.(g)) * (gh.(h) = g&#39;h&#39;.(h))
                    | <span class="kr">match</span> fst HgHh <span class="kr">in</span> _ = g, snd HgHh <span class="kr">in</span> _ = h
                            <span class="kr">return</span> NaturalTransformation
                                     (p_morphism_of T h o abf.(f))
                                     (a&#39;b&#39;f&#39;.(f) o p_morphism_of S g)
                      <span class="kr">with</span>
                        | idpath, idpath =&gt; gh.(p)
                      <span class="kr">end</span> = g&#39;h&#39;.(p) })
    : gh = g&#39;h&#39;
      := @path_morphism abf a&#39;b&#39;f&#39; gh g&#39;h&#39; (fst H.<span class="mi">1</span>) (snd H.<span class="mi">1</span>) H.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk1b"><span class="kn">Lemma</span> <span class="nf">path_morphism&#39;_helper</span> <span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span>
          (<span class="nv">gh</span> <span class="nv">g&#39;h&#39;</span> : morphism abf a&#39;b&#39;f&#39;)
    : <span class="kr">forall</span>
        (<span class="nv">Hg</span> : gh.(g) = g&#39;h&#39;.(g))
        (<span class="nv">Hh</span> : gh.(h) = g&#39;h&#39;.(h)),
        ((_ oL (Category.Morphisms.idtoiso (_ -&gt; _) (ap (@p_morphism_of _ _ S _ _) Hg) : Category.Core.morphism _ _ _))
           o (gh.(p))
           o ((Category.Morphisms.idtoiso (_ -&gt; _) (ap (@p_morphism_of _ _ T _ _) Hh) : Category.Core.morphism _ _ _)^-<span class="mi">1</span> oR _)
         = g&#39;h&#39;.(p))%natural_transformation
        -&gt; <span class="kr">match</span> Hg <span class="kr">in</span> _ = g, Hh <span class="kr">in</span> _ = h
                 <span class="kr">return</span> NaturalTransformation
                          (p_morphism_of T h o abf.(f))
                          (a&#39;b&#39;f&#39;.(f) o p_morphism_of S g)
           <span class="kr">with</span>
             | idpath, idpath =&gt; gh.(p)
           <span class="kr">end</span> = g&#39;h&#39;.(p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh, g'h'</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hg</span> : g gh = g g&#39;h&#39;) (<span class="nv">Hh</span> : h gh = h g&#39;h&#39;),
(f a&#39;b&#39;f&#39;
 oL (idtoiso (S (a abf) -&gt; S (a a&#39;b&#39;f&#39;))
       (ap (p_morphism_of S) Hg)
     :
     Core.morphism (S (a abf) -&gt; S (a a&#39;b&#39;f&#39;))
       (p_morphism_of S (g gh))
       (p_morphism_of S (g g&#39;h&#39;))) o p gh
 o ((idtoiso (T (b abf) -&gt; T (b a&#39;b&#39;f&#39;))
       (ap (p_morphism_of T) Hh))^-<span class="mi">1</span> oR f abf))%natural_transformation =
p g&#39;h&#39; -&gt;
<span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T (h g&#39;h&#39;) o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S (g gh)))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p gh
    <span class="kr">end</span>
<span class="kr">end</span> = p g&#39;h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh, g'h'</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hg</span> : g gh = g g&#39;h&#39;) (<span class="nv">Hh</span> : h gh = h g&#39;h&#39;),
(f a&#39;b&#39;f&#39;
 oL (idtoiso (S (a abf) -&gt; S (a a&#39;b&#39;f&#39;))
       (ap (p_morphism_of S) Hg)
     :
     Core.morphism (S (a abf) -&gt; S (a a&#39;b&#39;f&#39;))
       (p_morphism_of S (g gh))
       (p_morphism_of S (g g&#39;h&#39;))) o p gh
 o ((idtoiso (T (b abf) -&gt; T (b a&#39;b&#39;f&#39;))
       (ap (p_morphism_of T) Hh))^-<span class="mi">1</span> oR f abf))%natural_transformation =
p g&#39;h&#39; -&gt;
<span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T (h g&#39;h&#39;) o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S (g gh)))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p gh
    <span class="kr">end</span>
<span class="kr">end</span> = p g&#39;h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk1d"><span class="nb">simpl</span>; <span class="nb">intros</span> Hg Hh Hp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh, g'h'</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g gh = g g&#39;h&#39;</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h gh = h g&#39;h&#39;</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>(f a&#39;b&#39;f&#39;
 oL idtoiso (S (a abf) -&gt; S (a a&#39;b&#39;f&#39;))
      (ap (p_morphism_of S) Hg) o 
 p gh
 o ((idtoiso (T (b abf) -&gt; T (b a&#39;b&#39;f&#39;))
       (ap (p_morphism_of T) Hh))^-<span class="mi">1</span> oR 
    f abf))%natural_transformation = 
p g&#39;h&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T (h g&#39;h&#39;) o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S (g gh)))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p gh
    <span class="kr">end</span>
<span class="kr">end</span> = p g&#39;h&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk1e"><span class="nb">destruct</span> g&#39;h&#39;; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br><span><var>g0</var><span class="hyp-type"><b>: </b><span>Core.morphism A (a abf) (a a&#39;b&#39;f&#39;)</span></span></span><br><span><var>h0</var><span class="hyp-type"><b>: </b><span>Core.morphism B (b abf) (b a&#39;b&#39;f&#39;)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>NaturalTransformation
  (p_morphism_of T h0 o f abf)
  (f a&#39;b&#39;f&#39; o p_morphism_of S g0)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g gh = g0</span></span></span><br><span><var>Hh</var><span class="hyp-type"><b>: </b><span>h gh = h0</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>(f a&#39;b&#39;f&#39;
 oL idtoiso (S (a abf) -&gt; S (a a&#39;b&#39;f&#39;))
      (ap (p_morphism_of S) Hg) o 
 p gh
 o ((idtoiso (T (b abf) -&gt; T (b a&#39;b&#39;f&#39;))
       (ap (p_morphism_of T) Hh))^-<span class="mi">1</span> oR 
    f abf))%natural_transformation = p0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  Hg <span class="kr">in</span> (_ = g)
  <span class="kr">return</span>
    (NaturalTransformation
       (p_morphism_of T h0 o f abf)
       (f a&#39;b&#39;f&#39; o p_morphism_of S g))
<span class="kr">with</span>
| <span class="mi">1</span>%path =&gt;
    <span class="kr">match</span>
      Hh <span class="kr">in</span> (_ = h)
      <span class="kr">return</span>
        (NaturalTransformation
           (p_morphism_of T h o f abf)
           (f a&#39;b&#39;f&#39; o p_morphism_of S (g gh)))
    <span class="kr">with</span>
    | <span class="mi">1</span>%path =&gt; p gh
    <span class="kr">end</span>
<span class="kr">end</span> = p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk1f"><span class="nb">destruct</span> Hg, Hh, Hp; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p gh =
(f a&#39;b&#39;f&#39;
 oL NaturalTransformation.Identity.identity
      (p_morphism_of S (g gh)) o p gh
 o (NaturalTransformation.Identity.identity
      (p_morphism_of T (h gh)) oR f abf))%natural_transformation</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk20">path_natural_transformation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>S (a abf)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p gh x = (f a&#39;b&#39;f&#39;) _1 <span class="mi">1</span> o p gh x o <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk21"><span class="nb">autorewrite with</span> functor morphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>abf, a'b'f'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh</var><span class="hyp-type"><b>: </b><span>morphism abf a&#39;b&#39;f&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>S (a abf)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p gh x = p gh x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_morphism&#39;</span> <span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span>
               (<span class="nv">gh</span> <span class="nv">g&#39;h&#39;</span> : morphism abf a&#39;b&#39;f&#39;)
               (<span class="nv">Hg</span> : gh.(g) = g&#39;h&#39;.(g))
               (<span class="nv">Hh</span> : gh.(h) = g&#39;h&#39;.(h))
               (<span class="nv">Hp</span> : ((_ oL (Category.Morphisms.idtoiso (_ -&gt; _) (ap (@p_morphism_of _ _ S _ _) Hg) : Category.Core.morphism _ _ _))
                        o (gh.(p))
                        o ((Category.Morphisms.idtoiso (_ -&gt; _) (ap (@p_morphism_of _ _ T _ _) Hh) : Category.Core.morphism _ _ _)^-<span class="mi">1</span> oR _)
                      = g&#39;h&#39;.(p))%natural_transformation)
    : gh = g&#39;h&#39;
      := @path_morphism abf a&#39;b&#39;f&#39; gh g&#39;h&#39; Hg Hh
                        (@path_morphism&#39;_helper abf a&#39;b&#39;f&#39; gh g&#39;h&#39; Hg Hh Hp).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_morphism&#39;_uncurried</span> <span class="nv">abf</span> <span class="nv">a&#39;b&#39;f&#39;</span> <span class="nv">gh</span> <span class="nv">g&#39;h&#39;</span>
               (<span class="nv">H</span> : { HgHh : (gh.(g) = g&#39;h&#39;.(g)) * (gh.(h) = g&#39;h&#39;.(h))
                    | ((_ oL (Category.Morphisms.idtoiso (_ -&gt; _) (ap (@p_morphism_of _ _ S _ _) (fst HgHh)) : Category.Core.morphism _ _ _))
                         o (gh.(p))
                         o ((Category.Morphisms.idtoiso (_ -&gt; _) (ap (@p_morphism_of _ _ T _ _) (snd HgHh)) : Category.Core.morphism _ _ _)^-<span class="mi">1</span> oR _)
                       = g&#39;h&#39;.(p))%natural_transformation })
    : gh = g&#39;h&#39;
      := @path_morphism&#39; abf a&#39;b&#39;f&#39; gh g&#39;h&#39; (fst H.<span class="mi">1</span>) (snd H.<span class="mi">1</span>) H.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk22"><span class="kn">Definition</span> <span class="nf">compose</span> <span class="nv">s</span> <span class="nv">d</span> <span class="nv">d&#39;</span>
               (<span class="nv">gh</span> : morphism d d&#39;) (<span class="nv">g&#39;h&#39;</span> : morphism s d)
    : morphism s d&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>s, d, d'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh</var><span class="hyp-type"><b>: </b><span>morphism d d&#39;</span></span></span><br><span><var>g'h'</var><span class="hyp-type"><b>: </b><span>morphism s d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism s d&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>s, d, d'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh</var><span class="hyp-type"><b>: </b><span>morphism d d&#39;</span></span></span><br><span><var>g'h'</var><span class="hyp-type"><b>: </b><span>morphism s d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism s d&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk24"><span class="kr">exists</span> (<span class="nv">gh</span>.(g) o g&#39;h&#39;.(g)) (<span class="nv">gh</span>.(h) o g&#39;h&#39;.(h)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>s, d, d'</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br><span><var>gh</var><span class="hyp-type"><b>: </b><span>morphism d d&#39;</span></span></span><br><span><var>g'h'</var><span class="hyp-type"><b>: </b><span>morphism s d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation
  (p_morphism_of T (h gh o h g&#39;h&#39;) o f s)
  (f d&#39; o p_morphism_of S (g gh o g g&#39;h&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((_ oL (p_composition_of S _ _ _ _ _)^-<span class="mi">1</span>)
               o (associator_1 _ _ _)
               o (gh.(p) oR _)
               o (associator_2 _ _ _)
               o (_ oL g&#39;h&#39;.(p))
               o (associator_1 _ _ _)
               o ((p_composition_of T _ _ _ _ _ : Category.Core.morphism _ _ _)
                    oR _))%natural_transformation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> compose _ _ _ _ _ / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk25"><span class="kn">Definition</span> <span class="nf">identity</span> <span class="nv">x</span> : morphism x x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism x x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">morphism x x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="coreparts-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="coreparts-v-chk27"><span class="kr">exists</span> (<span class="nv">identity</span> (x.(a))) (<span class="nv">identity</span> (x.(b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>PreCategory</span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Pseudofunctor A</span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Pseudofunctor B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B),
IsHSet (Functor (S a) (T b))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>object</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NaturalTransformation (p_morphism_of T <span class="mi">1</span> o f x)
  (f x o p_morphism_of S <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((_ oL (p_identity_of S _ : Category.Core.morphism _ _ _)^-<span class="mi">1</span>)
               o (right_identity_natural_transformation_2 _)
               o (left_identity_natural_transformation_1 _)
               o ((p_identity_of T _ : Category.Core.morphism _ _ _)
                    oR _))%natural_transformation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> identity _ / .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">lax_comma_category_parts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">LaxCommaCategoryParts</span>.</span></span></pre>
</div>
</div></body>
</html>
