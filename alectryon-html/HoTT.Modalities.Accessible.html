<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Accessible.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Accessible subuniverses and modalities *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk0"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Extensions NullHomotopy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Accessible reflective subuniverses *)</span>

<span class="sd">(** An accessible reflective subuniverse is one that is the localization at a small family of maps.  Accessibility is necessary for some constructions, and in practice it&#39;s a reasonable hypothesis that includes most examples (though a few examples, such as double negation, may only be accessible if we assume propositional resizing).</span>

<span class="sd">We now give the basic definitions related to accessibility, using [ooExtendableAlong] as our notion of equivalence as we did with reflective subuniverses.  The actual construction of a reflective subuniverse by localization will be in [Localization]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">LocalGenerators</span>@{a} :=
  { lgen_indices : <span class="kt">Type</span>@{a} ;
    lgen_domain : lgen_indices -&gt; <span class="kt">Type</span>@{a} ;
    lgen_codomain : lgen_indices -&gt; <span class="kt">Type</span>@{a} ;
    lgenerator : <span class="kr">forall</span> <span class="nv">i</span>, lgen_domain i -&gt; lgen_codomain i
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">lgenerator</span> : LocalGenerators &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We put this definition in a module so that no one outside of this file will use it accidentally.  It will be redefined in [Localization] to refer to the localization reflective subuniverse, which is judgmentally the same but will also pick up typeclass inference for [In]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Import</span> IsLocal_Internal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsLocal</span> <span class="nv">f</span> <span class="nv">X</span> :=
    (<span class="kr">forall</span> (<span class="nv">i</span> : lgen_indices f), ooExtendableAlong (f i) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">IsLocal_Internal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsAccRSU</span>@{a i} (O : Subuniverse@{i}) :=
{
  acc_lgen : LocalGenerators@{a} ;
  inO_iff_islocal : <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{i}),
      <span class="sd">(** We call [iff] explicitly to control the number of universe parameters. *)</span>
      iff@{i i i} (In O X) (IsLocal acc_lgen X) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> acc_lgen O {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> inO_iff_islocal O {_} X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk1"><span class="kn">Instance</span> <span class="nf">O_inverts_generators</span> {<span class="nv">O</span> : ReflectiveSubuniverse} `{IsAccRSU O}
             (i : lgen_indices (acc_lgen O))
  : O_inverts O (acc_lgen O i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O (acc_lgen O i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O (acc_lgen O i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk3"><span class="nb">pose</span> (ext_dom := fst (inO_iff_islocal O (O (lgen_domain (acc_lgen O) i))) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O (acc_lgen O i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk4"><span class="nb">pose</span> (ext_cod := fst (inO_iff_islocal O (O (lgen_codomain (acc_lgen O) i))) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_inverts O (acc_lgen O i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk5"><span class="nb">simple refine</span> (isequiv_adjointify _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (lgen_codomain (acc_lgen O) i) -&gt;
O (lgen_domain (acc_lgen O) i)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><label class="goal-separator" for="accessible-v-chk6"><hr></label><div class="goal-conclusion">O_functor O (acc_lgen O i) o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="accessible-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><label class="goal-separator" for="accessible-v-chk7"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o O_functor O (acc_lgen O i) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O (lgen_codomain (acc_lgen O) i) -&gt;
O (lgen_domain (acc_lgen O) i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk9"><span class="nb">apply</span> O_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lgen_codomain (acc_lgen O) i -&gt;
O (lgen_domain (acc_lgen O) i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((fst (ext_dom i <span class="mi">1</span>%nat) (to O _)).<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O (acc_lgen O i)
o O_rec
    (fst (ext_dom i <span class="mi">1</span>)
       (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span> == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chkb"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_codomain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O (acc_lgen O i)
  (O_rec
     (fst (ext_dom i <span class="mi">1</span>)
        (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span>
     (to O (lgen_codomain (acc_lgen O) i) x)) =
to O (lgen_codomain (acc_lgen O) i) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chkc"><span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_codomain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O (acc_lgen O i)
  ((fst (ext_dom i <span class="mi">1</span>)
      (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span> x) =
to O (lgen_codomain (acc_lgen O) i) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chkd"><span class="nb">refine</span> ((fst (snd (ext_cod i <span class="mi">2</span>)
                        (<span class="kr">fun</span> <span class="nv">x</span> =&gt; O_functor O (acc_lgen O i)
                                            ((fst (ext_dom i <span class="mi">1</span>%nat) (to O _)).<span class="mi">1</span> x))
                        _) _).<span class="mi">1</span> x); <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_codomain (acc_lgen O) i</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O (acc_lgen O i)
  ((fst (ext_dom i <span class="mi">1</span>)
      (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span>
     (acc_lgen O i a)) =
to O (lgen_codomain (acc_lgen O) i) (acc_lgen O i a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chke"><span class="nb">rewrite</span> ((fst (ext_dom i <span class="mi">1</span>%nat) (to O _)).<span class="mi">2</span> a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_codomain (acc_lgen O) i</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_functor O (acc_lgen O i)
  (to O (lgen_domain (acc_lgen O) i) a) =
to O (lgen_codomain (acc_lgen O) i) (acc_lgen O i a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> to_O_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chkf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (fst (ext_dom i <span class="mi">1</span>)
     (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span>
o O_functor O (acc_lgen O i) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk10"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (fst (ext_dom i <span class="mi">1</span>)
     (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span>
  (O_functor O (acc_lgen O i)
     (to O (lgen_domain (acc_lgen O) i) x)) =
to O (lgen_domain (acc_lgen O) i) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk11"><span class="nb">rewrite</span> (to_O_natural O (acc_lgen O i) x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_rec
  (fst (ext_dom i <span class="mi">1</span>)
     (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span>
  (to O (lgen_codomain (acc_lgen O) i)
     (acc_lgen O i x)) =
to O (lgen_domain (acc_lgen O) i) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk12"><span class="nb">rewrite</span> O_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>ReflectiveSubuniverse</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>ext_dom</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_domain (acc_lgen O) i)))
  (O_inO (lgen_domain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_domain (acc_lgen O) i))</span></span></span></span><br><span><var>ext_cod</var><span><span class="hyp-body"><b>:= </b><span>fst
  (inO_iff_islocal O
     (O (lgen_codomain (acc_lgen O) i)))
  (O_inO (lgen_codomain (acc_lgen O) i))</span></span><span class="hyp-type"><b>: </b><span>IsLocal (acc_lgen O)
  (O (lgen_codomain (acc_lgen O) i))</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain (acc_lgen O) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst (ext_dom i <span class="mi">1</span>) (to O (lgen_domain (acc_lgen O) i))).<span class="mi">1</span>
  (acc_lgen O i x) =
to O (lgen_domain (acc_lgen O) i) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((fst (ext_dom i <span class="mi">1</span>%nat) (to O _)).<span class="mi">2</span> x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The construction of the localization reflective subuniverse for any family of maps will be in [Localization]. *)</span>


<span class="sd">(** ** Accessible modalities *)</span>

<span class="sd">(** A modality is accessible just when its underlying reflective subuniverse is accessible.  However, for modalities we have a simpler characterization in terms of families of generating connected objects rather than families of generating inverted maps.  We call an object [S]-null if it is local with respect to the maps [S i -&gt; Unit]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">NullGenerators</span> :=
  { ngen_indices : <span class="kt">Type</span>@{a} ;
    ngen_type : ngen_indices -&gt; <span class="kt">Type</span>@{a}
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">ngen_type</span> : NullGenerators &gt;-&gt; <span class="kt">Funclass</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">null_to_local_generators</span> : NullGenerators@{a1} -&gt; LocalGenerators@{a2}
  := <span class="kr">fun</span> <span class="nv">S</span> =&gt; Build_LocalGenerators (ngen_indices S) (ngen_type S) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Unit) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As with [IsLocal], the real version of this notation will be defined in [Nullification]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Import</span> IsNull_Internal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsNull</span> (<span class="nv">S</span> : NullGenerators@{a}) (<span class="nv">X</span> : <span class="kt">Type</span>@{i})
    := IsLocal@{i i a} (null_to_local_generators@{a a} S) X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">IsNull_Internal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A central fact: if a type [X] is null for all the fibers of a map [f], then it is [f]-local.  (NB: the converse is *not* generally true.)  TODO: Should this go in [Extensions]? *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk13"><span class="kn">Definition</span> <span class="nf">extendable_isnull_fibers</span> (<span class="nv">n</span> : nat)
           {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">C</span> : B -&gt; <span class="kt">Type</span>)
: (<span class="kr">forall</span> <span class="nv">b</span>, ooExtendableAlong (const_tt (hfiber f b))
                               (<span class="kr">fun</span> <span class="nv">_</span> =&gt; C b))
  -&gt; ExtendableAlong n f C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B,
 ooExtendableAlong (const_tt (hfiber f b))
   (unit_name (C b))) -&gt; ExtendableAlong n f C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B,
 ooExtendableAlong (const_tt (hfiber f b))
   (unit_name (C b))) -&gt; ExtendableAlong n f C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk15"><span class="nb">revert</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B,
 ooExtendableAlong (const_tt (hfiber f b))
   (unit_name (C b))) -&gt; ExtendableAlong n f C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk16">simple_induction n n IHn; <span class="nb">intros</span> C null; [<span class="bp">exact</span> tt | <span class="nb">split</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, C (f a), ExtensionAlong f C g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B,
 ooExtendableAlong (const_tt (hfiber f b))
   (unit_name (C b))) -&gt; 
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br></div><label class="goal-separator" for="accessible-v-chk17"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, C b,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, C (f a), ExtensionAlong f C g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk19"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, C (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong f C g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk1a"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">b</span> =&gt; (fst (null b <span class="mi">1</span>%nat) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x.<span class="mi">2</span> # g x.<span class="mi">1</span>)).<span class="mi">1</span> tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, C (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(fst (null (f x) <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber f (f x) =&gt;
    transport C x0.<span class="mi">2</span> (g x0.<span class="mi">1</span>))).<span class="mi">1</span> tt = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk1b"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, C (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst (null (f a) <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f (f a) =&gt; transport C x.<span class="mi">2</span> (g x.<span class="mi">1</span>))).<span class="mi">1</span>
  tt = g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk1c"><span class="nb">rewrite</span> (path_unit tt (const_tt _ a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, C (f a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fst (null (f a) <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x</span> : hfiber f (f a) =&gt; transport C x.<span class="mi">2</span> (g x.<span class="mi">1</span>))).<span class="mi">1</span>
  (const_tt A a) = g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((fst (null (f a) <span class="mi">1</span>%nat) _).<span class="mi">2</span> (a ; <span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">h</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">b</span> : B, C b,
ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk1e"><span class="nb">intros</span> h k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, C b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtendableAlong n f (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; h b = k b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk1f"><span class="nb">apply</span> IHn; <span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">C</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, ooExtendableAlong (const_tt (hfiber f b)) (unit_name (C b))) -&gt;
ExtendableAlong n f C</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>null</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (C b))</span></span></span><br><span><var>h, k</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, C b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (const_tt (hfiber f b))
  (unit_name (h b = k b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ooextendable_homotopy, null.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ooextendable_isnull_fibers</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">C</span> : B -&gt; <span class="kt">Type</span>)
: (<span class="kr">forall</span> <span class="nv">b</span>, ooExtendableAlong (const_tt (hfiber f b))
                               (<span class="kr">fun</span> <span class="nv">_</span> =&gt; C b))
  -&gt; ooExtendableAlong f C
:= <span class="kr">fun</span> <span class="nv">null</span> <span class="nv">n</span> =&gt; extendable_isnull_fibers n f C null.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We define a modality to be accessible if it consists of the null types for some family of generators as above. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsAccModality</span>@{a i} (O : Subuniverse@{i}) :=
{
  acc_ngen : NullGenerators@{a} ;
  inO_iff_isnull : <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{i}),
      iff@{i i i} (In O X) (IsNull acc_ngen X) ;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> acc_ngen O {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> inO_iff_isnull O {_} X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AccessibleModalities</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">O</span> : Modality) {<span class="nv">acco</span> : IsAccModality O}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Unsurprisingly, the generators are connected. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk20">#[export] <span class="kn">Instance</span> <span class="nf">isconnected_acc_ngen</span> <span class="nv">i</span> : IsConnected O (acc_ngen O i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ngen_indices (acc_ngen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (acc_ngen O i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ngen_indices (acc_ngen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected O (acc_ngen O i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk22"><span class="nb">apply</span> isconnected_from_elim_to_O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ngen_indices (acc_ngen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to O (acc_ngen O i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk23"><span class="nb">pose</span> (H := fst (fst (inO_iff_isnull O (O (acc_ngen O i))) _ i <span class="mi">1</span>%nat)
                   (to O ((acc_ngen O) i))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ngen_indices (acc_ngen O)</span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>fst
  (fst (inO_iff_isnull O (O (acc_ngen O i)))
     (O_inO (acc_ngen O i)) i <span class="mi">1</span>)
  (to O (acc_ngen O i))</span></span><span class="hyp-type"><b>: </b><span>ExtensionAlong
  (null_to_local_generators (acc_ngen O) i)
  (<span class="kr">fun</span>
     <span class="nv">_</span> : lgen_codomain
           (null_to_local_generators (acc_ngen O))
           i =&gt; O (acc_ngen O i))
  (to O (acc_ngen O i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy (to O (acc_ngen O i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk24"><span class="kr">exists</span> (<span class="nv">H</span>.<span class="mi">1</span> tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ngen_indices (acc_ngen O)</span></span></span><br><span><var>H</var><span><span class="hyp-body"><b>:= </b><span>fst
  (fst (inO_iff_isnull O (O (acc_ngen O i)))
     (O_inO (acc_ngen O i)) i <span class="mi">1</span>)
  (to O (acc_ngen O i))</span></span><span class="hyp-type"><b>: </b><span>ExtensionAlong
  (null_to_local_generators (acc_ngen O) i)
  (<span class="kr">fun</span>
     <span class="nv">_</span> : lgen_codomain
           (null_to_local_generators (acc_ngen O))
           i =&gt; O (acc_ngen O i))
  (to O (acc_ngen O i))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : acc_ngen O i,
to O (acc_ngen O i) x = H.<span class="mi">1</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (H.<span class="mi">2</span> x)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** If all the generators are inhabited, some things become a bit simpler. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">InhabitedGenerators</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">inhab</span> : <span class="kr">forall</span> <span class="nv">i</span>, acc_ngen O i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** For testing modal-ness of types, it suffices for all maps out of a generator to be constant.  Probably one could do without [Funext].  *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk25"><span class="kn">Definition</span> <span class="nf">inO_const_fromgen</span> `{Funext} A
               (c : <span class="kr">forall</span> <span class="nv">i</span> (<span class="nv">f</span> : acc_ngen O i -&gt; A), NullHomotopy f)
    : In O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk27"><span class="nb">apply</span> (snd (inO_iff_isnull O A)); <span class="nb">intros</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (null_to_local_generators (acc_ngen O) i)
  (<span class="kr">fun</span>
     <span class="nv">_</span> : lgen_codomain
           (null_to_local_generators (acc_ngen O)) i
   =&gt; A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk28"><span class="nb">apply</span> ((equiv_ooextendable_isequiv _ _)^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span>
     <span class="nv">g</span> : lgen_codomain
           (null_to_local_generators (acc_ngen O)) i -&gt;
         A =&gt;
   g oD null_to_local_generators (acc_ngen O) i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk29">snapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(lgen_domain (null_to_local_generators (acc_ngen O)) i -&gt;
 A) -&gt;
lgen_codomain (null_to_local_generators (acc_ngen O))
  i -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><label class="goal-separator" for="accessible-v-chk2a"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">g</span> : lgen_codomain
         (null_to_local_generators (acc_ngen O)) i -&gt;
       A =&gt;
 g oD null_to_local_generators (acc_ngen O) i) o 
<span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="accessible-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><label class="goal-separator" for="accessible-v-chk2b"><hr></label><div class="goal-conclusion"><span class="nl">?g</span>
o (<span class="kr">fun</span>
     <span class="nv">g</span> : lgen_codomain
           (null_to_local_generators (acc_ngen O)) i -&gt;
         A =&gt;
   g oD null_to_local_generators (acc_ngen O) i) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(lgen_domain (null_to_local_generators (acc_ngen O)) i -&gt;
 A) -&gt;
lgen_codomain (null_to_local_generators (acc_ngen O))
  i -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> f []; <span class="bp">exact</span> (c i f).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk2d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">g</span> : lgen_codomain
         (null_to_local_generators (acc_ngen O)) i -&gt;
       A =&gt;
 g oD null_to_local_generators (acc_ngen O) i)
o (<span class="kr">fun</span>
     (<span class="nv">f</span> : lgen_domain
            (null_to_local_generators (acc_ngen O)) i -&gt;
          A)
     (<span class="nv">b</span> : lgen_codomain
            (null_to_local_generators (acc_ngen O)) i)
   =&gt; <span class="kr">match</span> b <span class="kr">with</span>
      | tt =&gt; (c i f).<span class="mi">1</span>
      <span class="kr">end</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk2e"><span class="nb">intros</span> f; <span class="nb">apply</span> path_arrow; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>lgen_domain
  (null_to_local_generators (acc_ngen O)) i -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain
  (null_to_local_generators (acc_ngen O)) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">fun</span>
    <span class="nv">b</span> : lgen_codomain
          (null_to_local_generators (acc_ngen O)) i =&gt;
  <span class="kr">match</span> b <span class="kr">with</span>
  | tt =&gt; (c i f).<span class="mi">1</span>
  <span class="kr">end</span>) oD null_to_local_generators (acc_ngen O) i) x =
f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk2f"><span class="nb">simpl</span>; <span class="nb">unfold</span> composeD.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>lgen_domain
  (null_to_local_generators (acc_ngen O)) i -&gt; A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>lgen_domain
  (null_to_local_generators (acc_ngen O)) i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(c i f).<span class="mi">1</span> = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> ((c i f).<span class="mi">2</span> x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   (<span class="nv">f</span> : lgen_domain
          (null_to_local_generators (acc_ngen O)) i -&gt;
        A)
   (<span class="nv">b</span> : lgen_codomain
          (null_to_local_generators (acc_ngen O)) i)
 =&gt; <span class="kr">match</span> b <span class="kr">with</span>
    | tt =&gt; (c i f).<span class="mi">1</span>
    <span class="kr">end</span>)
o (<span class="kr">fun</span>
     <span class="nv">g</span> : lgen_codomain
           (null_to_local_generators (acc_ngen O)) i -&gt;
         A =&gt;
   g oD null_to_local_generators (acc_ngen O) i) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk31"><span class="nb">intros</span> g; <span class="nb">apply</span> path_arrow; <span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>lgen_codomain
  (null_to_local_generators (acc_ngen O)) i -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(c i (g oD null_to_local_generators (acc_ngen O) i)).<span class="mi">1</span> =
g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk32"><span class="nb">pose</span> ((c i (g oD (null_to_local_generators (acc_ngen O)) i)).<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>lgen_codomain
  (null_to_local_generators (acc_ngen O)) i -&gt; A</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>(c i (g oD null_to_local_generators (acc_ngen O) i)).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">y</span> : A =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : acc_ngen O i,
 (g oD null_to_local_generators (acc_ngen O) i) x =
 y)
  (c i
     (g oD null_to_local_generators (acc_ngen O) i)).<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(c i (g oD null_to_local_generators (acc_ngen O) i)).<span class="mi">1</span> =
g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk33"><span class="nb">simpl</span> <span class="kr">in</span> p; <span class="nb">unfold</span> composeD <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">f</span> : acc_ngen O i -&gt; A), 
NullHomotopy f</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices
  (null_to_local_generators (acc_ngen O))</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>lgen_codomain
  (null_to_local_generators (acc_ngen O)) i -&gt; A</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>(c i (<span class="kr">fun</span> <span class="nv">_</span> : acc_ngen O i =&gt; g tt)).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>acc_ngen O i -&gt;
g tt = (c i (<span class="kr">fun</span> <span class="nv">_</span> : acc_ngen O i =&gt; g tt)).<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(c i (g oD null_to_local_generators (acc_ngen O) i)).<span class="mi">1</span> =
g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> p, inhab.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** In particular, all hprops are modal. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk34"><span class="kn">Definition</span> <span class="nf">inO_hprop_inhab_gen</span> `{Funext} (A : <span class="kt">Type</span>) `{IsHProp A}
    : In O A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk36"><span class="nb">apply</span> inO_const_fromgen; <span class="nb">intros</span> i f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ngen_indices (acc_ngen O)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>acc_ngen O i -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk37"><span class="kr">exists</span> (<span class="nv">f</span> (inhab i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>acco</var><span class="hyp-type"><b>: </b><span>IsAccModality O</span></span></span><br><span><var>inhab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : ngen_indices (acc_ngen O),
acc_ngen O i</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ngen_indices (acc_ngen O)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>acc_ngen O i -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : acc_ngen O i, f x = f (inhab i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">InhabitedGenerators</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AccessibleModalities</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We will now show that a modality is accessible in this sense if and only if its underlying reflective subuniverse is accessible in the sense previously defined.  We (almost?) never need to actually use this, though; in practice accessible modalities usually seem to be given to us with the appropriate sort of generators. *)</span>

<span class="sd">(** One direction of this implication is trivial. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">acc_rsu_modality</span> (<span class="nv">O</span> : Modality) `{IsAccModality O}
  : IsAccRSU O
  := Build_IsAccRSU O (null_to_local_generators (acc_ngen O)) (<span class="kr">fun</span> <span class="nv">X</span> =&gt; inO_iff_isnull O X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For the less trivial converse, the idea is as follows.  By [ooextendable_isnull_fibers], we can detect locality with respect to a map by nullity with respect to its fibers.  Therefore, our first thought might be to just consider all the fibers of all the maps that we are localizing at.  However, this doesn&#39;t quite work because [ooextendable_isnull_fibers] is not an if-and-only-if, so not every modal type would necessarily be null for that type family.</span>

<span class="sd">     We do know, however, that if [f] is an [O]-connected map, then any [O]-modal type is null for its fibers (since they are [O]-connected types).  There is no *a priori* why all the maps we localize at should end up being connected for the modality; they will always be inverted, but not every inverted map is connected (unless the modality is lex).  But if [f : A -&gt; B] is [O]-inverted, then the [O]-connected map [to O A] is (up to equivalence) the composite of [f] with the [O]-connected map [to O B].  Thus, if [X] is null for the fibers of [to O A] and [to O B], it will be [f]-local and hence [O]-modal, while all [O]-modal types will be null for these fibers since they are connected. *)</span>

<span class="sd">(** We don&#39;t make this an [Instance] since it is rarely used, and would cause loops when combined with the previous one. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk38"><span class="kn">Definition</span> <span class="nf">acc_modality_rsu</span> (<span class="nv">O</span> : Modality) `{IsAccRSU O}
  : IsAccModality O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAccModality O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAccModality O</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk3a"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullGenerators</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><label class="goal-separator" for="accessible-v-chk3b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, In O X &lt;-&gt; IsNull <span class="nl">?acc_ngen</span> X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk3c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullGenerators</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk3d"><span class="nb">refine</span> (Build_NullGenerators
              (  { i : lgen_indices@{a} (acc_lgen O)
                   &amp; O (lgen_domain@{a} (acc_lgen O) i) }
               + { i : lgen_indices@{a} (acc_lgen O)
                   &amp; O (lgen_codomain@{a} (acc_lgen O) i) })
              _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{i : lgen_indices (acc_lgen O) &amp;
O (lgen_domain (acc_lgen O) i)} +
{i : lgen_indices (acc_lgen O) &amp;
O (lgen_codomain (acc_lgen O) i)} -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [ [i x] | [i x] ]; <span class="bp">exact</span> (hfiber (to O _) x).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk3e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In O X &lt;-&gt;
IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X0</span> : {i : lgen_indices (acc_lgen O) &amp;
             O (lgen_domain (acc_lgen O) i)} +
             {i : lgen_indices (acc_lgen O) &amp;
             O (lgen_codomain (acc_lgen O) i)} =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl s =&gt;
          (<span class="kr">fun</span>
             <span class="nv">s0</span> : {i : lgen_indices (acc_lgen O) &amp;
                  O (lgen_domain (acc_lgen O) i)} =&gt;
           (<span class="kr">fun</span> (<span class="nv">i</span> : lgen_indices (acc_lgen O))
              (<span class="nv">x</span> : O (lgen_domain (acc_lgen O) i)) =&gt;
            hfiber (to O (lgen_domain (acc_lgen O) i))
              x) s0.<span class="mi">1</span> s0.<span class="mi">2</span>) s
      | inr s =&gt;
          (<span class="kr">fun</span>
             <span class="nv">s0</span> : {i : lgen_indices (acc_lgen O) &amp;
                  O (lgen_codomain (acc_lgen O) i)} =&gt;
           (<span class="kr">fun</span> (<span class="nv">i</span> : lgen_indices (acc_lgen O))
              (<span class="nv">x</span> : O (lgen_codomain (acc_lgen O) i))
            =&gt;
            hfiber
              (to O (lgen_codomain (acc_lgen O) i)) x)
             s0.<span class="mi">1</span> s0.<span class="mi">2</span>) s
      <span class="kr">end</span>
  |} X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk3f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In O X &lt;-&gt;
IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X0</span> : {i : lgen_indices (acc_lgen O) &amp;
             O (lgen_domain (acc_lgen O) i)} +
             {i : lgen_indices (acc_lgen O) &amp;
             O (lgen_codomain (acc_lgen O) i)} =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl s =&gt;
          (<span class="kr">fun</span>
             <span class="nv">s0</span> : {i : lgen_indices (acc_lgen O) &amp;
                  O (lgen_domain (acc_lgen O) i)} =&gt;
           (<span class="kr">fun</span> (<span class="nv">i</span> : lgen_indices (acc_lgen O))
              (<span class="nv">x</span> : O (lgen_domain (acc_lgen O) i)) =&gt;
            hfiber (to O (lgen_domain (acc_lgen O) i))
              x) s0.<span class="mi">1</span> s0.<span class="mi">2</span>) s
      | inr s =&gt;
          (<span class="kr">fun</span>
             <span class="nv">s0</span> : {i : lgen_indices (acc_lgen O) &amp;
                  O (lgen_codomain (acc_lgen O) i)} =&gt;
           (<span class="kr">fun</span> (<span class="nv">i</span> : lgen_indices (acc_lgen O))
              (<span class="nv">x</span> : O (lgen_codomain (acc_lgen O) i))
            =&gt;
            hfiber
              (to O (lgen_codomain (acc_lgen O) i)) x)
             s0.<span class="mi">1</span> s0.<span class="mi">2</span>) s
      <span class="kr">end</span>
  |} X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk40"><span class="nb">assert</span> (cm := @conn_map_to_O O).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
In O X &lt;-&gt;
IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X0</span> : {i : lgen_indices (acc_lgen O) &amp;
             O (lgen_domain (acc_lgen O) i)} +
             {i : lgen_indices (acc_lgen O) &amp;
             O (lgen_codomain (acc_lgen O) i)} =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl s =&gt;
          (<span class="kr">fun</span>
             <span class="nv">s0</span> : {i : lgen_indices (acc_lgen O) &amp;
                  O (lgen_domain (acc_lgen O) i)} =&gt;
           (<span class="kr">fun</span> (<span class="nv">i</span> : lgen_indices (acc_lgen O))
              (<span class="nv">x</span> : O (lgen_domain (acc_lgen O) i)) =&gt;
            hfiber (to O (lgen_domain (acc_lgen O) i))
              x) s0.<span class="mi">1</span> s0.<span class="mi">2</span>) s
      | inr s =&gt;
          (<span class="kr">fun</span>
             <span class="nv">s0</span> : {i : lgen_indices (acc_lgen O) &amp;
                  O (lgen_codomain (acc_lgen O) i)} =&gt;
           (<span class="kr">fun</span> (<span class="nv">i</span> : lgen_indices (acc_lgen O))
              (<span class="nv">x</span> : O (lgen_codomain (acc_lgen O) i))
            =&gt;
            hfiber
              (to O (lgen_codomain (acc_lgen O) i)) x)
             s0.<span class="mi">1</span> s0.<span class="mi">2</span>) s
      <span class="kr">end</span>
  |} X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk41"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O X -&gt;
IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)} =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber (to O (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="accessible-v-chk42"><hr></label><div class="goal-conclusion">IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)} =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber (to O (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X -&gt; In O X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O X -&gt;
IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)} =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber (to O (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> X_inO [ [i x] | [i x] ];
        <span class="bp">exact</span> (ooextendable_const_isconnected_inO O _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk44">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)} =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber (to O (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X -&gt; In O X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk45"><span class="nb">intros</span> Xnull.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In O X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk46"><span class="nb">apply</span> (snd (inO_iff_islocal O X)); <span class="nb">intros</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (acc_lgen O i)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk47"><span class="nb">refine</span> (cancelL_ooextendable (<span class="kr">fun</span> <span class="nv">_</span> =&gt; X) (acc_lgen O i)
                                   (to O (lgen_codomain (acc_lgen O) i)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (to O (lgen_codomain (acc_lgen O) i))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><label class="goal-separator" for="accessible-v-chk48"><hr></label><div class="goal-conclusion">ooExtendableAlong
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
   to O (lgen_codomain (acc_lgen O) i)
     (acc_lgen O i x))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk49">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (to O (lgen_codomain (acc_lgen O) i))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk4a"><span class="nb">apply</span> ooextendable_isnull_fibers; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O_reflector O (lgen_codomain (acc_lgen O) i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (const_tt
     (hfiber (to O (lgen_codomain (acc_lgen O) i)) x))
  (unit_name X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Xnull (inr (i;x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk4b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
   to O (lgen_codomain (acc_lgen O) i)
     (acc_lgen O i x))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk4c"><span class="nb">refine</span> (ooextendable_homotopic _
                                       (O_functor O (acc_lgen O i)
                                                  o to O (lgen_domain (acc_lgen O) i)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
 O_functor O (acc_lgen O i)
   (to O (lgen_domain (acc_lgen O) i) x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
 to O (lgen_codomain (acc_lgen O) i) (acc_lgen O i x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><label class="goal-separator" for="accessible-v-chk4d"><hr></label><div class="goal-conclusion">ooExtendableAlong
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
   O_functor O (acc_lgen O i)
     (to O (lgen_domain (acc_lgen O) i) x))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk4e"><span class="mi">1</span>:<span class="nb">apply</span> to_O_natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
   O_functor O (acc_lgen O i)
     (to O (lgen_domain (acc_lgen O) i) x))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk4f"><span class="nb">apply</span> ooextendable_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (O_functor O (acc_lgen O i))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="accessible-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><label class="goal-separator" for="accessible-v-chk50"><hr></label><div class="goal-conclusion">ooExtendableAlong (to O (lgen_domain (acc_lgen O) i))
  (<span class="kr">fun</span> <span class="nv">_</span> : O (lgen_domain (acc_lgen O) i) =&gt; X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk51">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (O_functor O (acc_lgen O i))
  (<span class="kr">fun</span>
     <span class="nv">_</span> : O_reflector O (lgen_codomain (acc_lgen O) i)
   =&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ooextendable_equiv, O_inverts_generators.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk52">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong (to O (lgen_domain (acc_lgen O) i))
  (<span class="kr">fun</span> <span class="nv">_</span> : O (lgen_domain (acc_lgen O) i) =&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="accessible-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="accessible-v-chk53"><span class="nb">apply</span> ooextendable_isnull_fibers; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>O</var><span class="hyp-type"><b>: </b><span>Modality</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsAccRSU O</span></span></span><br><span><var>cm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsConnMap O (to O A)</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Xnull</var><span class="hyp-type"><b>: </b><span>IsNull
  {|
    ngen_indices :=
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_domain (acc_lgen O) i)} +
      {i : lgen_indices (acc_lgen O) &amp;
      O (lgen_codomain (acc_lgen O) i)};
    ngen_type :=
      <span class="kr">fun</span>
        <span class="nv">X</span> : {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_domain (acc_lgen O) i)} +
            {i : lgen_indices (acc_lgen O) &amp;
            O (lgen_codomain (acc_lgen O) i)}
      =&gt;
      <span class="kr">match</span> X <span class="kr">with</span>
      | inl s =&gt;
          hfiber
            (to O
               (lgen_domain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      | inr s =&gt;
          hfiber
            (to O
               (lgen_codomain (acc_lgen O) s.<span class="mi">1</span>))
            s.<span class="mi">2</span>
      <span class="kr">end</span>
  |} X</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>lgen_indices (acc_lgen O)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>O (lgen_domain (acc_lgen O) i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ooExtendableAlong
  (const_tt
     (hfiber (to O (lgen_domain (acc_lgen O) i)) x))
  (unit_name X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Xnull (inl (i;x))).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The construction of the nullification modality for any family of types will be in [Nullification]. *)</span></span></pre>
</div>
</div></body>
</html>
