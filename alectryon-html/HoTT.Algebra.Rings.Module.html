<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Module.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk0"><span class="kn">From</span> HoTT.WildCat <span class="kn">Require Import</span> Core Equiv Induced Products.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Some of the material in abstract_algebra and canonical names could be selectively exported to the user, as is done in Groups/Group.v. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Classes.interfaces.canonical_names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.Groups.QuotientGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.AbGroups.AbelianGroup Algebra.AbGroups.Biproduct.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Rings.Ring.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> module_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> module_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Modules over a ring. *)</span>

<span class="sd">(** ** Left Modules *)</span>

<span class="sd">(** An abelian group [M] is a left [R]-module when equipped with the following data: *)</span> 
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsLeftModule</span> (<span class="nv">R</span> : Ring) (<span class="nv">M</span> : AbGroup) := {
  <span class="sd">(** A function [lact] (left-action) that takes an element [r : R] and an element [m : M] and returns an element [lact r m : M], which we also denote [r *L m]. *)</span>
  lact : R -&gt; M -&gt; M;
  <span class="sd">(** Actions distribute on the left over addition in the abelian group. That is [r *L (m + n) = r *L m + r *L n]. *)</span>
  lact_left_dist :: LeftHeteroDistribute lact (+) (+);
  <span class="sd">(** Actions distribute on the right over addition in the ring. That is [(r + s) *L m = r *L m + s *L m]. *)</span>
  lact_right_dist :: RightHeteroDistribute lact (+) (+);
  <span class="sd">(** Actions are associative. That is [(r * s) *L m = r *L (s *L m)]. *)</span>
  lact_assoc :: HeteroAssociative lact lact lact (.*.);
  <span class="sd">(** Actions preserve the multiplicative identity. That is [1 *L m = m]. *)</span>
  lact_unit :: LeftIdentity lact <span class="mi">1</span>;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;*L&quot;</span> := lact : module_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A left R-module is an abelian group equipped with a left R-module structure. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">LeftModule</span> (<span class="nv">R</span> : Ring) := {
  lm_carrier :&gt; AbGroup;
  lm_lact :: IsLeftModule R lm_carrier;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">LeftModuleAxioms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : LeftModule R} (<span class="nv">r</span> <span class="nv">s</span> : R) (<span class="nv">m</span> <span class="nv">n</span> : M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Here we state the module axioms in a readable form for direct use. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lm_dist_l</span> : r *L (m + n) = r *L m + r *L n := lact_left_dist r m n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lm_dist_r</span> : (r + s) *L m = r *L m + s *L m := lact_right_dist r s m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lm_assoc</span> : r *L (s *L m) = (r * s) *L m := lact_assoc r s m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lm_unit</span> : <span class="mi">1</span> *L m = m := lact_unit m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">LeftModuleAxioms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Facts about left modules *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">LeftModuleFacts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : LeftModule R} (<span class="nv">r</span> : R) (<span class="nv">m</span> : M).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here are some quick facts that hold in modules. *)</span> 

  <span class="sd">(** The left action of zero is zero. *)</span> 
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk1"><span class="kn">Definition</span> <span class="nf">lm_zero_l</span> : <span class="mi">0</span> *L m = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> *L m = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> *L m = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk3"><span class="nb">apply</span> (grp_cancelL1 (z := lact <span class="mi">0</span> m)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (<span class="mi">0</span> *L m) (<span class="mi">0</span> *L m) = <span class="mi">0</span> *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk4">lhs_V napply lm_dist_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">0</span> + <span class="mi">0</span>) *L m = <span class="mi">0</span> *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk5">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> + <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rng_plus_zero_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The left action on zero is zero. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk6"><span class="kn">Definition</span> <span class="nf">lm_zero_r</span> : r *L (<span class="mi">0</span> : M) = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L (<span class="mi">0</span> : M) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L (<span class="mi">0</span> : M) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk8"><span class="nb">apply</span> (grp_cancelL1 (z := lact r <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (r *L <span class="mi">0</span>) (r *L <span class="mi">0</span>) = r *L <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk9">lhs_V napply lm_dist_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L (<span class="mi">0</span> + <span class="mi">0</span>) = r *L <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chka">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> + <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The left action of [-1] is the additive inverse. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb"><span class="kn">Definition</span> <span class="nf">lm_minus_one</span> : -<span class="mi">1</span> *L m = -m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">1</span> *L m = - m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">1</span> *L m = - m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd"><span class="nb">apply</span> grp_moveL_1V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (-<span class="mi">1</span> *L m) m = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke">lhs napply (ap (_ +) (lm_unit m)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">1</span> *L m + <span class="mi">1</span> *L m = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf">lhs_V napply lm_dist_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(-<span class="mi">1</span> + <span class="mi">1</span>) *L m = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk10">rhs_V napply lm_zero_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(-<span class="mi">1</span> + <span class="mi">1</span>) *L m = <span class="mi">0</span> *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk11">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">1</span> + <span class="mi">1</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The left action of [r] on the additive inverse of [m] is the additive inverse of the left action of [r] on [m]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk12"><span class="kn">Definition</span> <span class="nf">lm_neg</span> : r *L -m = - (r *L m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L - m = - (r *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L - m = - (r *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk14"><span class="nb">apply</span> grp_moveL_1V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (r *L - m) (r *L m) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk15">lhs_V napply lm_dist_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L (- m + m) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk16">rhs_V napply lm_zero_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L (- m + m) = r *L <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk17">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- m + m = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">LeftModuleFacts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Every ring [R] is a left [R]-module over itself. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk18"><span class="kn">Instance</span> <span class="nf">isleftmodule_ring</span> (<span class="nv">R</span> : Ring) : IsLeftModule R R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftModule R R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftModule R R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply Build_IsLeftModule.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Right Modules *)</span>

<span class="sd">(** An abelian group [M] is a right [R]-module when it is a left [R^op]-module. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsRightModule</span> (<span class="nv">R</span> : Ring) (<span class="nv">M</span> : AbGroup)
  := isleftmodule_op_isrightmodule :: IsLeftModule (rng_op R) M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ract] (right-action) that takes an element [m : M] and an element [r : R] and returns an element [ract m r : M] which we also denote [m *R r]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ract</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : AbGroup} `{!IsRightModule R M}
  : M -&gt; R -&gt; M
  := <span class="kr">fun</span> <span class="nv">m</span> <span class="nv">r</span> =&gt; lact (R:=rng_op R) r m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;*R&quot;</span> := ract.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A right module is a left module over the opposite ring. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RightModule</span> (<span class="nv">R</span> : Ring) := LeftModule (rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Right modules are right modules. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">rm_ract</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : RightModule R} : IsRightModule R M
  := lm_lact (rng_op R) M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">RightModuleAxioms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : RightModule R} (<span class="nv">m</span> <span class="nv">n</span> : M) (<span class="nv">r</span> <span class="nv">s</span> : R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Here we state the module axioms in a readable form for direct use. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_dist_r</span> : (m + n) *R r = m *R r + n *R r
    := lm_dist_l (R:=rng_op R) r m n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_dist_l</span> : m *R (r + s) = m *R r + m *R s
    := lm_dist_r (R:=rng_op R) r s m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_assoc</span> : (m *R r) *R s = m *R (r * s)
    := lm_assoc (R:=rng_op R) s r m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_unit</span> : m *R <span class="mi">1</span> = m
    := lm_unit (R:=rng_op R) m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">RightModuleAxioms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Facts about right modules *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">RightModuleFacts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : RightModule R} (<span class="nv">m</span> : M) (<span class="nv">r</span> : R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The right action on zero is zero. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_zero_l</span> : (<span class="mi">0</span> : M) *R r = <span class="mi">0</span>
    := lm_zero_r (R:=rng_op R) r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The right action of zero is zero. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_zero_r</span> : m *R <span class="mi">0</span> = <span class="mi">0</span>
    := lm_zero_l (R:=rng_op R) m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The right action of [-1] is the additive inverse. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_minus_one</span> : m *R -<span class="mi">1</span> = -m
    := lm_minus_one (R:=rng_op R) m.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The right action of [r] on the additive inverse of [m] is the additive inverse of the right action of [r] on [m]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_neg</span> : -m *R r = - (m *R r)
    := lm_neg (R:=rng_op R) r m.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">RightModuleFacts</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Every ring [R] is a right [R]-module over itself. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isrightmodule_ring</span> (<span class="nv">R</span> : Ring) : IsRightModule R R
  := isleftmodule_ring (rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Submodules *)</span>

<span class="sd">(** A subgroup of a left R-module is a left submodule if it is closed under the action of R. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsLeftSubmodule</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : LeftModule R} (<span class="nv">N</span> : M -&gt; <span class="kt">Type</span>) := {
  ils_issubgroup :: IsSubgroup N;
  is_left_submodule : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">m</span>, N m -&gt; N (r *L m);
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A subgroup of a right R-module is a right submodule if it is a left submodule over the opposite ring. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsRightSubmodule</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : RightModule R} (<span class="nv">N</span> : M -&gt; <span class="kt">Type</span>)
  := isleftsubmodule_op_isrightsubmodule :: IsLeftSubmodule (R:=rng_op R) N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A left submodule is a subgroup of the abelian group closed under the left action of R. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">LeftSubmodule</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : LeftModule R) := {
  lsm_carrier :&gt; M -&gt; <span class="kt">Type</span>;
  lsm_submodule :: IsLeftSubmodule lsm_carrier;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A right submodule is a subgroup of the abelian group closed under the right action of R. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RightSubmodule</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : RightModule R)
  := LeftSubmodule (R:=rng_op R) M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subgroup_leftsubmodule</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : LeftModule R}
  : LeftSubmodule M -&gt; Subgroup M
  := <span class="kr">fun</span> <span class="nv">N</span> =&gt; Build_Subgroup M N _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">subgroup_leftsubmodule</span> : LeftSubmodule &gt;-&gt; Subgroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">subgroup_rightsubmodule</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : RightModule R}
  : RightSubmodule M -&gt; Subgroup M
  := idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">subgroup_rightsubmodule</span> : RightSubmodule &gt;-&gt; Subgroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Left submodules inherit the left R-module structure of their parent. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk1a"><span class="kn">Instance</span> <span class="nf">isleftmodule_leftsubmodule</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> : LeftModule R} (<span class="nv">N</span> : LeftSubmodule M)
  : IsLeftModule R N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftModule R N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftModule R N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk1c">snapply Build_IsLeftModule.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R -&gt; N -&gt; N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chk1d"><hr></label><div class="goal-conclusion">LeftHeteroDistribute <span class="nl">?lact</span> plus plus</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chk1e"><hr></label><div class="goal-conclusion">RightHeteroDistribute <span class="nl">?lact</span> plus plus</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chk1f"><hr></label><div class="goal-conclusion">HeteroAssociative <span class="nl">?lact</span> <span class="nl">?lact</span> <span class="nl">?lact</span> mult</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chk20"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?lact</span> <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk21">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R -&gt; N -&gt; N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk22"><span class="nb">intros</span> r [n n_in_N].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>n_in_N</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk23"><span class="kr">exists</span> (<span class="nv">r</span> *L n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>n_in_N</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (r *L n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> lsm_submodule.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk24">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftHeteroDistribute
  (<span class="kr">fun</span> (<span class="nv">r</span> : R) (<span class="nv">X</span> : N) =&gt;
   (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">n_in_N</span> : N n) =&gt;
    (r *L n;
    <span class="kr">let</span> <span class="nv">X0</span> :=
      <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
      is_left_submodule <span class="kr">in</span>
    X0 M N r n n_in_N)) X.<span class="mi">1</span> X.<span class="mi">2</span>) plus plus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk25"><span class="nb">intros</span> r [n] [m]; <span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>N m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r *L ((n; proj2) + (m; proj0)).<span class="mi">1</span>;
<span class="kr">let</span> <span class="nv">X</span> :=
  <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
  is_left_submodule <span class="kr">in</span>
X M N r ((n; proj2) + (m; proj0)).<span class="mi">1</span>
  ((n; proj2) + (m; proj0)).<span class="mi">2</span>).<span class="mi">1</span> =
((r *L n;
 <span class="kr">let</span> <span class="nv">X</span> :=
   <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
   is_left_submodule <span class="kr">in</span>
 X M N r n proj2) +
 (r *L m;
 <span class="kr">let</span> <span class="nv">X</span> :=
   <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
   is_left_submodule <span class="kr">in</span>
 X M N r m proj0)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lact_left_dist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightHeteroDistribute
  (<span class="kr">fun</span> (<span class="nv">r</span> : R) (<span class="nv">X</span> : N) =&gt;
   (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">n_in_N</span> : N n) =&gt;
    (r *L n;
    <span class="kr">let</span> <span class="nv">X0</span> :=
      <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
      is_left_submodule <span class="kr">in</span>
    X0 M N r n n_in_N)) X.<span class="mi">1</span> X.<span class="mi">2</span>) plus plus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk27"><span class="nb">intros</span> r s [n]; <span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((r + s) *L n;
<span class="kr">let</span> <span class="nv">X</span> :=
  <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
  is_left_submodule <span class="kr">in</span>
X M N (r + s) n proj2).<span class="mi">1</span> =
((r *L n;
 <span class="kr">let</span> <span class="nv">X</span> :=
   <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
   is_left_submodule <span class="kr">in</span>
 X M N r n proj2) +
 (s *L n;
 <span class="kr">let</span> <span class="nv">X</span> :=
   <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
   is_left_submodule <span class="kr">in</span>
 X M N s n proj2)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lact_right_dist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HeteroAssociative
  (<span class="kr">fun</span> (<span class="nv">r</span> : R) (<span class="nv">X</span> : N) =&gt;
   (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">n_in_N</span> : N n) =&gt;
    (r *L n;
    <span class="kr">let</span> <span class="nv">X0</span> :=
      <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
      is_left_submodule <span class="kr">in</span>
    X0 M N r n n_in_N)) X.<span class="mi">1</span> X.<span class="mi">2</span>)
  (<span class="kr">fun</span> (<span class="nv">r</span> : R) (<span class="nv">X</span> : N) =&gt;
   (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">n_in_N</span> : N n) =&gt;
    (r *L n;
    <span class="kr">let</span> <span class="nv">X0</span> :=
      <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
      is_left_submodule <span class="kr">in</span>
    X0 M N r n n_in_N)) X.<span class="mi">1</span> X.<span class="mi">2</span>)
  (<span class="kr">fun</span> (<span class="nv">r</span> : R) (<span class="nv">X</span> : N) =&gt;
   (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">n_in_N</span> : N n) =&gt;
    (r *L n;
    <span class="kr">let</span> <span class="nv">X0</span> :=
      <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
      is_left_submodule <span class="kr">in</span>
    X0 M N r n n_in_N)) X.<span class="mi">1</span> X.<span class="mi">2</span>) mult</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk29"><span class="nb">intros</span> r s [n]; <span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r *L (s *L n);
<span class="kr">let</span> <span class="nv">X</span> :=
  <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
  is_left_submodule <span class="kr">in</span>
X M N r (s *L n)
  (<span class="kr">let</span> <span class="nv">X0</span> :=
     <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
     is_left_submodule <span class="kr">in</span>
   X0 M N s n proj2)).<span class="mi">1</span> =
((r * s) *L n;
<span class="kr">let</span> <span class="nv">X</span> :=
  <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
  is_left_submodule <span class="kr">in</span>
X M N (r * s) n proj2).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lact_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity
  (<span class="kr">fun</span> (<span class="nv">r</span> : R) (<span class="nv">X</span> : N) =&gt;
   (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">n_in_N</span> : N n) =&gt;
    (r *L n;
    <span class="kr">let</span> <span class="nv">X0</span> :=
      <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
      is_left_submodule <span class="kr">in</span>
    X0 M N r n n_in_N)) X.<span class="mi">1</span> X.<span class="mi">2</span>) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk2b"><span class="nb">intros</span> [n]; <span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> *L n;
<span class="kr">let</span> <span class="nv">X</span> :=
  <span class="kr">fun</span> (<span class="nv">M</span> : LeftModule R) (<span class="nv">l</span> : LeftSubmodule M) =&gt;
  is_left_submodule <span class="kr">in</span>
X M N <span class="mi">1</span> n proj2).<span class="mi">1</span> = (n; proj2).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lact_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Right submodules inherit the right R-module structure of their parent. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isrightmodule_rightsubmodule</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> : RightModule R} (<span class="nv">N</span> : RightSubmodule M)
  : IsRightModule R N
  := isleftmodule_leftsubmodule (R:=rng_op R) N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any left submodule of a left R-module is a left R-module. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">leftmodule_leftsubmodule</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> : LeftModule R} (<span class="nv">N</span> : LeftSubmodule M)
  : LeftModule R
  := Build_LeftModule R N _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">leftmodule_leftsubmodule</span> : LeftSubmodule &gt;-&gt; LeftModule.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any right submodule of a right R-module is a right R-module. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rightmodule_rightsubmodule</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> : RightModule R} (<span class="nv">N</span> : RightSubmodule M)
  : RightModule R
  := N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">rightmodule_rightsubmodule</span> : RightSubmodule &gt;-&gt; RightModule.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The submodule criterion. This is a convenient way to build submodules. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk2c"><span class="kn">Definition</span> <span class="nf">Build_IsLeftSubmodule&#39;</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : LeftModule R} 
  (<span class="nv">H</span> : M -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (H x)}
  (z : H zero)
  (c : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">n</span> <span class="nv">m</span>, H n -&gt; H m -&gt; H (n + r *L m))
  : IsLeftSubmodule H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftSubmodule H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftSubmodule H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk2e">snapply Build_IsLeftSubmodule.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSubgroup H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><label class="goal-separator" for="module-v-chk2f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M), H m -&gt; H (r *L m)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSubgroup H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk31">snapply Build_IsSubgroup&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><label class="goal-separator" for="module-v-chk32"><hr></label><div class="goal-conclusion">H mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><label class="goal-separator" for="module-v-chk33"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : M, H x -&gt; H y -&gt; H (sg_op x (inv y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk34">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk35">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk36">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : M, H x -&gt; H y -&gt; H (sg_op x (inv y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk37"><span class="nb">intros</span> x y hx hy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>H y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (sg_op x (inv y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk38"><span class="nb">change</span> (sg_op <span class="nl">?x</span> <span class="nl">?y</span>) <span class="kr">with</span> (x + y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>H y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (x + inv y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk39"><span class="nb">pose proof</span> (p := c (-<span class="mi">1</span>) x y hx hy).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>H y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>H (x + -<span class="mi">1</span> *L y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (x + inv y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk3a"><span class="nb">rewrite</span> lm_minus_one <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>hx</var><span class="hyp-type"><b>: </b><span>H x</span></span></span><br><span><var>hy</var><span class="hyp-type"><b>: </b><span>H y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>H (x - y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (x + inv y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M), H m -&gt; H (r *L m)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk3c"><span class="nb">intros</span> r m hm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>hm</var><span class="hyp-type"><b>: </b><span>H m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (r *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk3d"><span class="nb">rewrite</span> &lt;- (grp_unit_l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>hm</var><span class="hyp-type"><b>: </b><span>H m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (sg_op mon_unit (r *L m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_IsRightSubmodule&#39;</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : RightModule R} 
  (<span class="nv">H</span> : M -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (H x)}
  (z : H zero)
  (c : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">n</span> <span class="nv">m</span>, H n -&gt; H m -&gt; H (n + ract m r))
  : IsRightSubmodule H
  := Build_IsLeftSubmodule&#39; (R:=rng_op R) H z c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk3e"><span class="kn">Definition</span> <span class="nf">Build_LeftSubmodule&#39;</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : LeftModule R}
  (<span class="nv">H</span> : M -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (H x)}
  (z : H zero)
  (c : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">n</span> <span class="nv">m</span>, H n -&gt; H m -&gt; H (n + r *L m))
  : LeftSubmodule M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftSubmodule M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftSubmodule M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk40"><span class="nb">pose</span> (p := Build_IsLeftSubmodule&#39; H z c).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>Build_IsLeftSubmodule&#39; H z c</span></span><span class="hyp-type"><b>: </b><span>IsLeftSubmodule H</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftSubmodule M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk41">snapply Build_LeftSubmodule.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>Build_IsLeftSubmodule&#39; H z c</span></span><span class="hyp-type"><b>: </b><span>IsLeftSubmodule H</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>Build_IsLeftSubmodule&#39; H z c</span></span><span class="hyp-type"><b>: </b><span>IsLeftSubmodule H</span></span></span></span><br></div><label class="goal-separator" for="module-v-chk42"><hr></label><div class="goal-conclusion">IsLeftSubmodule <span class="nl">?lsm_carrier</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk43"><span class="mi">1</span>: snapply (Build_Subgroup _ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>Build_IsLeftSubmodule&#39; H z c</span></span><span class="hyp-type"><b>: </b><span>IsLeftSubmodule H</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSubgroup H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>Build_IsLeftSubmodule&#39; H z c</span></span><span class="hyp-type"><b>: </b><span>IsLeftSubmodule H</span></span></span></span><br></div><label class="goal-separator" for="module-v-chk44"><hr></label><div class="goal-conclusion">IsLeftSubmodule
  {|
    subgroup_pred := H;
    subgroup_issubgroup := <span class="nl">?subgroup_issubgroup</span>
  |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk45"><span class="mi">2</span>: <span class="bp">exact</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>M -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : M, IsHProp (H x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>H <span class="mi">0</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">n</span> <span class="nv">m</span> : M),
H n -&gt; H m -&gt; H (n + r *L m)</span></span></span><br><span><var>p</var><span><span class="hyp-body"><b>:= </b><span>Build_IsLeftSubmodule&#39; H z c</span></span><span class="hyp-type"><b>: </b><span>IsLeftSubmodule H</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSubgroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply ils_issubgroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_RightSubmodule</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> : RightModule R}
  (<span class="nv">H</span> : M -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (H x)}
  (z : H zero)
  (c : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">n</span> <span class="nv">m</span>, H n -&gt; H m -&gt; H (n + m *R r))
  : RightSubmodule M
  := Build_LeftSubmodule&#39; (R:=rng_op R) H z c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** R-module homomorphisms *)</span>

<span class="sd">(** A left module homomorphism is a group homomorphism that commutes with the left action of R. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">LeftModuleHomomorphism</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R) := {
  lm_homo_map :&gt; GroupHomomorphism M N;
  lm_homo_lact : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">m</span>, lm_homo_map (r *L m) = r *L lm_homo_map m;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RightModuleHomomorphism</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> <span class="nv">N</span> : RightModule R)
  := LeftModuleHomomorphism (R:=rng_op R) M N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_homo_map</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R}
  : RightModuleHomomorphism M N -&gt; GroupHomomorphism M N
  := lm_homo_map (R:=rng_op R) M N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">rm_homo_map</span> : RightModuleHomomorphism &gt;-&gt; GroupHomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_homo_ract</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R}
  (<span class="nv">f</span> : RightModuleHomomorphism M N)
  : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">r</span>, f (ract m r) = ract (f m) r
  := <span class="kr">fun</span> <span class="nv">m</span> <span class="nv">r</span> =&gt; lm_homo_lact (R:=rng_op R) M N f r m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk46"><span class="kn">Definition</span> <span class="nf">lm_homo_id</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : LeftModule R) : LeftModuleHomomorphism M M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism M M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism M M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk48">snapply Build_LeftModuleHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M M</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk49"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
<span class="nl">?lm_homo_map</span> (r *L m) = r *L <span class="nl">?lm_homo_map</span> m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk4a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_homo_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
grp_homo_id (r *L m) = r *L grp_homo_id m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_homo_id</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : RightModule R) : RightModuleHomomorphism M M
  := lm_homo_id (R:=rng_op R) M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk4c"><span class="kn">Definition</span> <span class="nf">lm_homo_compose</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> <span class="nv">L</span> : LeftModule R}
  : LeftModuleHomomorphism N L -&gt; LeftModuleHomomorphism M N
  -&gt; LeftModuleHomomorphism M L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism N L -&gt;
LeftModuleHomomorphism M N -&gt;
LeftModuleHomomorphism M L</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism N L -&gt;
LeftModuleHomomorphism M N -&gt;
LeftModuleHomomorphism M L</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk4e"><span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism M L</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk4f">snapply Build_LeftModuleHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M L</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br></div><label class="goal-separator" for="module-v-chk50"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
<span class="nl">?lm_homo_map</span> (r *L m) = r *L <span class="nl">?lm_homo_map</span> m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M L</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_compose f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk52">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
grp_homo_compose f g (r *L m) =
r *L grp_homo_compose f g m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk53"><span class="nb">intros</span> r m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose f g (r *L m) =
r *L grp_homo_compose f g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk54">rhs_V napply lm_homo_lact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose f g (r *L m) = f (r *L g m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk55"><span class="nb">apply</span> (ap f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism N L</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>LeftModuleHomomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (r *L m) = r *L g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lm_homo_lact.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_homo_compose</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> <span class="nv">L</span> : RightModule R}
  : RightModuleHomomorphism N L -&gt; RightModuleHomomorphism M N
  -&gt; RightModuleHomomorphism M L
  := lm_homo_compose (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Smart constructor for building left module homomorphisms from a map. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk56"><span class="kn">Definition</span> <span class="nf">Build_LeftModuleHomomorphism&#39;</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R}
  (<span class="nv">f</span> : M -&gt; N) (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">x</span> <span class="nv">y</span>, f (r *L x + y) = r *L f x + f y)
  : LeftModuleHomomorphism M N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk58">snapply Build_LeftModuleHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><label class="goal-separator" for="module-v-chk59"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
<span class="nl">?lm_homo_map</span> (r *L m) = r *L <span class="nl">?lm_homo_map</span> m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk5b">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M -&gt; N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><label class="goal-separator" for="module-v-chk5c"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk5d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M -&gt; N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk5e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk5f"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op x y) = sg_op (f x) (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk60"><span class="nb">rewrite</span> &lt;- (lm_unit (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op x y) = sg_op (<span class="mi">1</span> *L f x) (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk61"><span class="nb">set</span> (lact <span class="mi">1</span> (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="mi">1</span> *L f x</span></span><span class="hyp-type"><b>: </b><span>N</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op x y) = sg_op g (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk62"><span class="nb">rewrite</span> &lt;- (lm_unit x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span><span class="mi">1</span> *L f x</span></span><span class="hyp-type"><b>: </b><span>N</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op (<span class="mi">1</span> *L x) y) = sg_op g (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
{|
  grp_homo_map := f;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt;
     internal_paths_rew
       (<span class="kr">fun</span> <span class="nv">g</span> : N =&gt; f (sg_op x y) = sg_op g (f y))
       (<span class="kr">let</span> <span class="nv">g</span> := <span class="mi">1</span> *L f x <span class="kr">in</span>
        internal_paths_rew
          (<span class="kr">fun</span> <span class="nv">x0</span> : M =&gt;
           f (sg_op x0 y) = sg_op g (f y)) (p <span class="mi">1</span> x y)
          (lm_unit x)) (lm_unit (f x)))
    :
    IsSemiGroupPreserving f
|} (r *L m) =
r *L
{|
  grp_homo_map := f;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt;
     internal_paths_rew
       (<span class="kr">fun</span> <span class="nv">g</span> : N =&gt; f (sg_op x y) = sg_op g (f y))
       (<span class="kr">let</span> <span class="nv">g</span> := <span class="mi">1</span> *L f x <span class="kr">in</span>
        internal_paths_rew
          (<span class="kr">fun</span> <span class="nv">x0</span> : M =&gt;
           f (sg_op x0 y) = sg_op g (f y)) (p <span class="mi">1</span> x y)
          (lm_unit x)) (lm_unit (f x)))
    :
    IsSemiGroupPreserving f
|} m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk64"><span class="nb">intros</span> r m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := f;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt;
     internal_paths_rew
       (<span class="kr">fun</span> <span class="nv">g</span> : N =&gt; f (sg_op x y) = sg_op g (f y))
       (<span class="kr">let</span> <span class="nv">g</span> := <span class="mi">1</span> *L f x <span class="kr">in</span>
        internal_paths_rew
          (<span class="kr">fun</span> <span class="nv">x0</span> : M =&gt;
           f (sg_op x0 y) = sg_op g (f y)) (p <span class="mi">1</span> x y)
          (lm_unit x)) (lm_unit (f x)))
    :
    IsSemiGroupPreserving f
|} (r *L m) =
r *L
{|
  grp_homo_map := f;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt;
     internal_paths_rew
       (<span class="kr">fun</span> <span class="nv">g</span> : N =&gt; f (sg_op x y) = sg_op g (f y))
       (<span class="kr">let</span> <span class="nv">g</span> := <span class="mi">1</span> *L f x <span class="kr">in</span>
        internal_paths_rew
          (<span class="kr">fun</span> <span class="nv">x0</span> : M =&gt;
           f (sg_op x0 y) = sg_op g (f y)) (p <span class="mi">1</span> x y)
          (lm_unit x)) (lm_unit (f x)))
    :
    IsSemiGroupPreserving f
|} m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk65"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (r *L m) = r *L f m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk66"><span class="nb">rewrite</span> &lt;- (grp_unit_r (lact r m)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op (r *L m) mon_unit) = r *L f m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk67"><span class="nb">rewrite</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L f m + f mon_unit = r *L f m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk68">rhs_V napply grp_unit_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L f m + f mon_unit = sg_op (r *L f m) mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk69"><span class="nb">apply</span> grp_cancelL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : M),
f (r *L x + y) = r *L f x + f y</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk6a"><span class="nb">specialize</span> (p <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f (<span class="mi">1</span> *L <span class="mi">0</span> + <span class="mi">0</span>) = <span class="mi">1</span> *L f <span class="mi">0</span> + f <span class="mi">0</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk6b"><span class="nb">rewrite</span> <span class="mi">2</span> lm_unit <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f (<span class="mi">0</span> + <span class="mi">0</span>) = f <span class="mi">0</span> + f <span class="mi">0</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk6c"><span class="nb">apply</span> (grp_cancelL1 (z := f <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f (<span class="mi">0</span> + <span class="mi">0</span>) = f <span class="mi">0</span> + f <span class="mi">0</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (f <span class="mi">0</span>) (f mon_unit) = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk6d">lhs_V napply p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f (<span class="mi">0</span> + <span class="mi">0</span>) = f <span class="mi">0</span> + f <span class="mi">0</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (<span class="mi">0</span> + <span class="mi">0</span>) = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk6e"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M -&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f (<span class="mi">0</span> + <span class="mi">0</span>) = f <span class="mi">0</span> + f <span class="mi">0</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> + <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_RightModuleHomomorphism&#39;</span> {<span class="nv">R</span>  :Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R}
  (<span class="nv">f</span> : M -&gt; N) (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">x</span> <span class="nv">y</span>, f (x *R r + y) = f x *R r + f y)
  : RightModuleHomomorphism M N
  := Build_LeftModuleHomomorphism&#39; (R:=rng_op R) f p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">LeftModuleIsomorphism</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R) := {
  lm_iso_map :&gt; LeftModuleHomomorphism M N;
  isequiv_lm_iso_map :: IsEquiv lm_iso_map;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">RightModuleIsomorphism</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> <span class="nv">N</span> : RightModule R)
  := LeftModuleIsomorphism (R:=rng_op R) M N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk6f"><span class="kn">Definition</span> <span class="nf">Build_LeftModuleIsomorphism&#39;</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R)
  (<span class="nv">f</span> : GroupIsomorphism M N) (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">x</span>, f (r *L x) = r *L f x)
  : LeftModuleIsomorphism M N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleIsomorphism M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleIsomorphism M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk71">snapply Build_LeftModuleIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism M N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><label class="goal-separator" for="module-v-chk72"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?lm_iso_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk73">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism M N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk74">snapply Build_LeftModuleHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><label class="goal-separator" for="module-v-chk75"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
<span class="nl">?lm_homo_map</span> (r *L m) = r *L <span class="nl">?lm_homo_map</span> m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk76">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk77">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M), f (r *L m) = r *L f m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk78">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M), f (r *L x) = r *L f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv {| lm_homo_map := f; lm_homo_lact := p |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_RightModuleIsomorphism&#39;</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> <span class="nv">N</span> : RightModule R)
  (<span class="nv">f</span> : GroupIsomorphism M N) (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">r</span> <span class="nv">x</span>, f (ract x r) = ract (f x) r)
  : RightModuleIsomorphism M N
  := Build_LeftModuleIsomorphism&#39; (R:=rng_op R) M N f p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk79"><span class="kn">Definition</span> <span class="nf">lm_iso_inverse</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R}
  : LeftModuleIsomorphism M N -&gt; LeftModuleIsomorphism N M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleIsomorphism M N -&gt; LeftModuleIsomorphism N M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleIsomorphism M N -&gt; LeftModuleIsomorphism N M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk7b"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleIsomorphism N M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk7c">snapply Build_LeftModuleIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism N M</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><label class="goal-separator" for="module-v-chk7d"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?lm_iso_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk7e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModuleHomomorphism N M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk7f">snapply Build_LeftModuleHomomorphism&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N -&gt; M</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk80" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><label class="goal-separator" for="module-v-chk80"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : N),
<span class="nl">?f</span> (r *L x + y) = r *L <span class="nl">?f</span> x + <span class="nl">?f</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk81">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N -&gt; M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> f^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk82">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> <span class="nv">y</span> : N),
f^-<span class="mi">1</span> (r *L x + y) = r *L f^-<span class="mi">1</span> x + f^-<span class="mi">1</span> y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk83"><span class="nb">intros</span> r m n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> (r *L m + n) = r *L f^-<span class="mi">1</span> m + f^-<span class="mi">1</span> n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk84"><span class="nb">apply</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L m + n = f (r *L f^-<span class="mi">1</span> m + f^-<span class="mi">1</span> n)</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk85">rhs napply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L m + n = sg_op (f (r *L f^-<span class="mi">1</span> m)) (f (f^-<span class="mi">1</span> n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk86"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (f (r *L f^-<span class="mi">1</span> m)) (f (f^-<span class="mi">1</span> n)) = r *L m + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk87">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (r *L f^-<span class="mi">1</span> m) = r *L m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="module-v-chk88"><hr></label><div class="goal-conclusion">f (f^-<span class="mi">1</span> n) = n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk89"><span class="mi">2</span>: <span class="nb">apply</span> eisretr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (r *L f^-<span class="mi">1</span> m) = r *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk8a">lhs napply lm_homo_lact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L f (f^-<span class="mi">1</span> m) = r *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk8b"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> m) = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk8c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>LeftModuleIsomorphism M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (Build_LeftModuleHomomorphism&#39; f^-<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> <span class="nv">n</span> : N) =&gt;
      moveR_equiv_V (r *L m + n)
        (r *L f^-<span class="mi">1</span> m + f^-<span class="mi">1</span> n)
        ((ap11
            (ap11 <span class="mi">1</span>
               (lm_homo_lact M N f r (f^-<span class="mi">1</span> m) @
                ap (lact r) (eisretr f m)))
            (eisretr f n))^ @
         (grp_homo_op f (r *L f^-<span class="mi">1</span> m) (f^-<span class="mi">1</span> n))^)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_iso_inverse</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R}
  : RightModuleIsomorphism M N -&gt; RightModuleIsomorphism N M
  := lm_iso_inverse (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Category of left and right R-modules *)</span>

<span class="sd">(** TODO: define as a displayed category over Ring *)</span>

<span class="sd">(** *** Category of left R-modules *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_leftmodule</span> {<span class="nv">R</span> : Ring} : IsGraph (LeftModule R)
  := Build_IsGraph _ LeftModuleHomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_leftmodule</span> {<span class="nv">R</span> : Ring} : Is01Cat (LeftModule R)
  := Build_Is01Cat _ _ lm_homo_id (@lm_homo_compose R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is2graph_leftmodule</span> {<span class="nv">R</span> : Ring} : Is2Graph (LeftModule R)
  := <span class="kr">fun</span> <span class="nv">M</span> <span class="nv">N</span> =&gt; isgraph_induced (@lm_homo_map R M N).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk8d"><span class="kn">Instance</span> <span class="nf">is1cat_leftmodule</span> {<span class="nv">R</span> : Ring} : Is1Cat (LeftModule R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat (LeftModule R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk8e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat (LeftModule R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk8f">snapply Build_Is1Cat&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, Is01Cat (a $-&gt; b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chk90"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, Is0Gpd (a $-&gt; b)</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chk91"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : LeftModule R) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chk92"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chk93"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chk94"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk95" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chk95"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk96">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, Is01Cat (a $-&gt; b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> M N; rapply is01cat_induced.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk97">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, Is0Gpd (a $-&gt; b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> M N; rapply is0gpd_induced.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk98">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : LeftModule R) (<span class="nv">g</span> : b $-&gt; c),
Is0Functor (cat_postcomp a g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk99"><span class="nb">intros</span> M N L h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>N $-&gt; L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_postcomp M h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk9a">snapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>N $-&gt; L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : M $-&gt; N,
(a $-&gt; b) -&gt; cat_postcomp M h a $-&gt; cat_postcomp M h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk9b"><span class="nb">intros</span> f g p m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>N $-&gt; L</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $-&gt; g</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_postcomp M h f m = cat_postcomp M h g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap h (p m)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk9c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
Is0Functor (cat_precomp c f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk9d"><span class="nb">intros</span> M N L f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_precomp L f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk9e">snapply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : N $-&gt; L,
(a $-&gt; b) -&gt; cat_precomp L f a $-&gt; cat_precomp L f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk9f"><span class="nb">intros</span> g h p m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>N $-&gt; L</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g $-&gt; h</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cat_precomp L f g m = cat_precomp L f h m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p (f m)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chka0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c) (<span class="nv">h</span> : c $-&gt; d),
h $o g $o f $== h $o (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chka1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
Id b $o f $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chka2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
f $o Id a $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chka3"><span class="kn">Instance</span> <span class="nf">hasequivs_leftmodule</span> {<span class="nv">R</span> : Ring} : HasEquivs (LeftModule R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs (LeftModule R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs (LeftModule R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chka5">snapply Build_HasEquivs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModule R -&gt; LeftModule R -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chka6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, (a $-&gt; b) -&gt; <span class="kt">Type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chka7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, <span class="nl">?CatEquiv&#39;</span> a b -&gt; a $-&gt; b</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chka8"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?CatIsEquiv&#39;</span> a b (<span class="nl">?cate_fun&#39;</span> a b f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chka9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
<span class="nl">?CatIsEquiv&#39;</span> a b f -&gt; <span class="nl">?CatEquiv&#39;</span> a b</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkaa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chkaa"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">fe</span> : <span class="nl">?CatIsEquiv&#39;</span> a b f),
<span class="nl">?cate_fun&#39;</span> a b (<span class="nl">?cate_buildequiv&#39;</span> a b f fe) $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chkab"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, <span class="nl">?CatEquiv&#39;</span> a b -&gt; b $-&gt; a</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chkac"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?cate_inv&#39;</span> a b f $o <span class="nl">?cate_fun&#39;</span> a b f $== Id a</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chkad"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?cate_fun&#39;</span> a b f $o <span class="nl">?cate_inv&#39;</span> a b f $== Id b</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><label class="goal-separator" for="module-v-chkae"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; a),
f $o g $== Id b -&gt;
g $o f $== Id a -&gt; <span class="nl">?CatIsEquiv&#39;</span> a b f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkaf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModule R -&gt; LeftModule R -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> LeftModuleIsomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R, (a $-&gt; b) -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> M N; <span class="bp">exact</span> IsEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R,
LeftModuleIsomorphism a b -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> M N f; <span class="bp">exact</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R)
(<span class="nv">f</span> : LeftModuleIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R) (<span class="nv">f0</span> : M $-&gt; N) =&gt; IsEquiv f0)
  a b
  ((<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R)
      (<span class="nv">f0</span> : LeftModuleIsomorphism M N) =&gt;
    lm_iso_map M N f0) a b f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">simpl</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b),
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R) (<span class="nv">f0</span> : M $-&gt; N) =&gt; IsEquiv f0)
  a b f -&gt; LeftModuleIsomorphism a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Build_LeftModuleIsomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">fe</span> : (<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R) (<span class="nv">f0</span> : M $-&gt; N) =&gt;
       IsEquiv f0) a b f),
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R)
   (<span class="nv">f0</span> : LeftModuleIsomorphism M N) =&gt;
 lm_iso_map M N f0) a b
  {| lm_iso_map := f; isequiv_lm_iso_map := fe |} $==
f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : LeftModule R,
LeftModuleIsomorphism a b -&gt; b $-&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> M N; <span class="bp">exact</span> lm_iso_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R)
(<span class="nv">f</span> : LeftModuleIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R)
   (<span class="nv">x</span> : LeftModuleIsomorphism M N) =&gt;
 lm_iso_map N M (lm_iso_inverse x)) a b f $o
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R)
   (<span class="nv">f0</span> : LeftModuleIsomorphism M N) =&gt;
 lm_iso_map M N f0) a b f $== Id a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> M N f; <span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R)
(<span class="nv">f</span> : LeftModuleIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R)
   (<span class="nv">f0</span> : LeftModuleIsomorphism M N) =&gt;
 lm_iso_map M N f0) a b f $o
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R)
   (<span class="nv">x</span> : LeftModuleIsomorphism M N) =&gt;
 lm_iso_map N M (lm_iso_inverse x)) a b f $== Id b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> M N f; <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : LeftModule R) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; a),
f $o g $== Id b -&gt;
g $o f $== Id a -&gt;
(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R) (<span class="nv">f0</span> : M $-&gt; N) =&gt; IsEquiv f0)
  a b f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkb9"><span class="nb">intros</span> M N f g fg gf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>N $-&gt; M</span></span></span><br><span><var>fg</var><span class="hyp-type"><b>: </b><span>f $o g $== Id N</span></span></span><br><span><var>gf</var><span class="hyp-type"><b>: </b><span>g $o f $== Id M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">M</span> <span class="nv">N</span> : LeftModule R) (<span class="nv">f</span> : M $-&gt; N) =&gt; IsEquiv f)
  M N f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isequiv_adjointify f g fg gf).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Category of right R-modules *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isgraph_rightmodule</span> {<span class="nv">R</span> : Ring} : IsGraph (RightModule R)
  := isgraph_leftmodule (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is01cat_rightmodule</span> {<span class="nv">R</span> : Ring} : Is01Cat (RightModule R)
  := is01cat_leftmodule (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is2graph_rightmodule</span> {<span class="nv">R</span> : Ring} : Is2Graph (RightModule R)
  := is2graph_leftmodule (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">is1cat_rightmodule</span> {<span class="nv">R</span> : Ring} : Is1Cat (RightModule R)
  := is1cat_leftmodule (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">hasequivs_rightmodule</span> {<span class="nv">R</span> : Ring} : HasEquivs (RightModule R)
  := hasequivs_leftmodule (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Kernel of module homomorphism *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkba"><span class="kn">Instance</span> <span class="nf">isleftsubmodule_grp_kernel</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R} (<span class="nv">f</span> : M $-&gt; N)
  : IsLeftSubmodule (grp_kernel f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftSubmodule (grp_kernel f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftSubmodule (grp_kernel f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkbc">srapply Build_IsLeftSubmodule.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : M),
grp_kernel f m -&gt; grp_kernel f (r *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkbd"><span class="nb">intros</span> r m n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>grp_kernel f m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_kernel f (r *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkbe">lhs napply lm_homo_lact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>grp_kernel f m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L f m = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkbf">rhs_V napply (lm_zero_r r).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>grp_kernel f m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L f m = r *L <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc0"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>grp_kernel f m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f m = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isrightsubmodule_grp_kernel</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> <span class="nv">N</span> : RightModule R} (<span class="nv">f</span> : M $-&gt; N)
  : IsRightSubmodule (grp_kernel f)
  := isleftsubmodule_grp_kernel (R:=rng_op R) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lm_kernel</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R} (<span class="nv">f</span> : M $-&gt; N)
  : LeftSubmodule M
  := Build_LeftSubmodule _ _ (grp_kernel f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_kernel</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R} (<span class="nv">f</span> : M $-&gt; N)
  : RightSubmodule M
  := lm_kernel (R:=rng_op R) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Image of module homomorphism *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc1"><span class="kn">Instance</span> <span class="nf">isleftsubmodule_grp_image</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R} (<span class="nv">f</span> : M $-&gt; N)
  : IsLeftSubmodule (grp_image f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftSubmodule (grp_image f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftSubmodule (grp_image f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc3">srapply Build_IsLeftSubmodule.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : N),
grp_image f m -&gt; grp_image f (r *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc4"><span class="nb">intros</span> r m; <span class="nb">apply</span> Trunc_functor; <span class="nb">intros</span> [n p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : M &amp; f x = r *L m}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc5"><span class="kr">exists</span> (<span class="nv">r</span> *L n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (r *L n) = r *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc6">lhs napply lm_homo_lact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L f n = r *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc7"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isrightsubmodule_grp_image</span> {<span class="nv">R</span> : Ring}
  {<span class="nv">M</span> <span class="nv">N</span> : RightModule R} (<span class="nv">f</span> : M $-&gt; N)
  : IsRightSubmodule (grp_image f)
  := isleftsubmodule_grp_image (R:=rng_op R) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lm_image</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R} (<span class="nv">f</span> : M $-&gt; N)
  : LeftSubmodule N
  := Build_LeftSubmodule _ _ (grp_image f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_image</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R} (<span class="nv">f</span> : M $-&gt; N)
  : RightSubmodule N
  := lm_image (R:=rng_op R) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Quotient Modules *)</span>

<span class="sd">(** The quotient abelian group of a module and a submodule has a natural ring action. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc8"><span class="kn">Instance</span> <span class="nf">isleftmodule_quotientabgroup</span> {<span class="nv">R</span> : Ring}
  (<span class="nv">M</span> : LeftModule R) (<span class="nv">N</span> : LeftSubmodule M)
  : IsLeftModule R (QuotientAbGroup M N).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftModule R (QuotientAbGroup M N)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkc9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftModule R (QuotientAbGroup M N)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkca">snapply Build_IsLeftModule.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R -&gt; QuotientAbGroup M N -&gt; QuotientAbGroup M N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chkcb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chkcb"><hr></label><div class="goal-conclusion">LeftHeteroDistribute <span class="nl">?lact</span> plus plus</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chkcc"><hr></label><div class="goal-conclusion">RightHeteroDistribute <span class="nl">?lact</span> plus plus</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkcd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chkcd"><hr></label><div class="goal-conclusion">HeteroAssociative <span class="nl">?lact</span> <span class="nl">?lact</span> <span class="nl">?lact</span> mult</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><label class="goal-separator" for="module-v-chkce"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?lact</span> <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkcf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R -&gt; QuotientAbGroup M N -&gt; QuotientAbGroup M N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd0"><span class="nb">intros</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">QuotientAbGroup M N -&gt; QuotientAbGroup M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd1">snapply quotient_abgroup_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M (QuotientAbGroup M N)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chkd2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><label class="goal-separator" for="module-v-chkd2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : M, N n -&gt; <span class="nl">?f</span> n = mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism M (QuotientAbGroup M N)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd4"><span class="nb">refine</span> (grp_quotient_map $o _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M $-&gt; M</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd5">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M -&gt; M</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><label class="goal-separator" for="module-v-chkd6"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd7">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M -&gt; M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (lact r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd8">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (lact r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkd9"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L sg_op x y = sg_op (r *L x) (r *L y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lm_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkda">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : M,
N n -&gt;
(grp_quotient_map $o
 {|
   grp_homo_map := lact r;
   issemigrouppreserving_grp_homo :=
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
     :
     IsSemiGroupPreserving (lact r)
 |}) n = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkdb"><span class="nb">intros</span> n Nn; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>Nn</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y)) (r *L n) =
mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkdc"><span class="nb">apply</span> qglue.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>Nn</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_cosetL N (r *L n) mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkdd"><span class="nb">apply</span> issubgroup_in_inv_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>Nn</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (r *L n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chkde" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>Nn</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><label class="goal-separator" for="module-v-chkde"><hr></label><div class="goal-conclusion">N mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkdf"><span class="mi">2</span>: <span class="bp">exact</span> issubgroup_in_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>Nn</var><span class="hyp-type"><b>: </b><span>N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N (r *L n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> is_left_submodule.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftHeteroDistribute
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt;
   quotient_abgroup_rec N (QuotientAbGroup M N)
     (grp_quotient_map $o
      {|
        grp_homo_map := lact r;
        issemigrouppreserving_grp_homo :=
          (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
          :
          IsSemiGroupPreserving (lact r)
      |})
     (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
      qglue
        (issubgroup_in_inv_op (r *L n) mon_unit
           (is_left_submodule r n Nn)
           issubgroup_in_unit)
      :
      (grp_quotient_map $o
       {|
         grp_homo_map := lact r;
         issemigrouppreserving_grp_homo :=
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
           :
           IsSemiGroupPreserving (lact r)
       |}) n = mon_unit)) plus plus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke1"><span class="nb">intros</span> r m n; <span class="nb">revert</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>QuotientAbGroup M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> : QuotientAbGroup M N,
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact r;
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op (r *L n) mon_unit
        (is_left_submodule r n Nn) issubgroup_in_unit))
  (m + n) =
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact r;
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op (r *L n) mon_unit
        (is_left_submodule r n Nn) issubgroup_in_unit))
  m +
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact r;
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op (r *L n) mon_unit
        (is_left_submodule r n Nn) issubgroup_in_unit))
  n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke2">snapply Quotient_ind_hprop; [<span class="bp">exact</span> _ | <span class="nb">intros</span> m; <span class="nb">revert</span> n].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : QuotientAbGroup M N,
(<span class="kr">fun</span>
   <span class="nv">x</span> : M /
       in_cosetL
         {|
           normalsubgroup_subgroup := N;
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup M N
         |} =&gt;
 quotient_abgroup_rec N (QuotientAbGroup M N)
   (grp_quotient_map $o
    {|
      grp_homo_map := lact r;
      issemigrouppreserving_grp_homo :=
        <span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x0 y
    |})
   (<span class="kr">fun</span> (<span class="nv">n0</span> : M) (<span class="nv">Nn</span> : N n0) =&gt;
    qglue
      (issubgroup_in_inv_op (r *L n0) mon_unit
         (is_left_submodule r n0 Nn)
         issubgroup_in_unit)) (x + n) =
 quotient_abgroup_rec N (QuotientAbGroup M N)
   (grp_quotient_map $o
    {|
      grp_homo_map := lact r;
      issemigrouppreserving_grp_homo :=
        <span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x0 y
    |})
   (<span class="kr">fun</span> (<span class="nv">n0</span> : M) (<span class="nv">Nn</span> : N n0) =&gt;
    qglue
      (issubgroup_in_inv_op (r *L n0) mon_unit
         (is_left_submodule r n0 Nn)
         issubgroup_in_unit)) x +
 quotient_abgroup_rec N (QuotientAbGroup M N)
   (grp_quotient_map $o
    {|
      grp_homo_map := lact r;
      issemigrouppreserving_grp_homo :=
        <span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x0 y
    |})
   (<span class="kr">fun</span> (<span class="nv">n0</span> : M) (<span class="nv">Nn</span> : N n0) =&gt;
    qglue
      (issubgroup_in_inv_op (r *L n0) mon_unit
         (is_left_submodule r n0 Nn)
         issubgroup_in_unit)) n)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := N;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup M N
        |}) m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke3">snapply Quotient_ind_hprop; [<span class="bp">exact</span> _ | <span class="nb">intros</span> n; <span class="nb">simpl</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y))
  (r *L sg_op m n) =
class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y)) (r *L m) +
class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y)) (r *L n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke4">rapply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L sg_op m n = sg_op (r *L m) (r *L n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lm_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightHeteroDistribute
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt;
   quotient_abgroup_rec N (QuotientAbGroup M N)
     (grp_quotient_map $o
      {|
        grp_homo_map := lact r;
        issemigrouppreserving_grp_homo :=
          (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
          :
          IsSemiGroupPreserving (lact r)
      |})
     (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
      qglue
        (issubgroup_in_inv_op (r *L n) mon_unit
           (is_left_submodule r n Nn)
           issubgroup_in_unit)
      :
      (grp_quotient_map $o
       {|
         grp_homo_map := lact r;
         issemigrouppreserving_grp_homo :=
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
           :
           IsSemiGroupPreserving (lact r)
       |}) n = mon_unit)) plus plus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke6"><span class="nb">intros</span> r s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : QuotientAbGroup M N,
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact (r + s);
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l (r + s) x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op ((r + s) *L n) mon_unit
        (is_left_submodule (r + s) n Nn)
        issubgroup_in_unit)) c =
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact r;
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op (r *L n) mon_unit
        (is_left_submodule r n Nn) issubgroup_in_unit))
  c +
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact s;
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l s x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op (s *L n) mon_unit
        (is_left_submodule s n Nn) issubgroup_in_unit))
  c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke7">snapply Quotient_ind_hprop; [<span class="bp">exact</span> _| <span class="nb">intros</span> m; <span class="nb">simpl</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y))
  ((r + s) *L m) =
class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y)) (r *L m) +
class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y)) (s *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke8">rapply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(r + s) *L m = sg_op (r *L m) (s *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lm_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chke9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HeteroAssociative
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt;
   quotient_abgroup_rec N (QuotientAbGroup M N)
     (grp_quotient_map $o
      {|
        grp_homo_map := lact r;
        issemigrouppreserving_grp_homo :=
          (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
          :
          IsSemiGroupPreserving (lact r)
      |})
     (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
      qglue
        (issubgroup_in_inv_op (r *L n) mon_unit
           (is_left_submodule r n Nn)
           issubgroup_in_unit)
      :
      (grp_quotient_map $o
       {|
         grp_homo_map := lact r;
         issemigrouppreserving_grp_homo :=
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
           :
           IsSemiGroupPreserving (lact r)
       |}) n = mon_unit))
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt;
   quotient_abgroup_rec N (QuotientAbGroup M N)
     (grp_quotient_map $o
      {|
        grp_homo_map := lact r;
        issemigrouppreserving_grp_homo :=
          (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
          :
          IsSemiGroupPreserving (lact r)
      |})
     (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
      qglue
        (issubgroup_in_inv_op (r *L n) mon_unit
           (is_left_submodule r n Nn)
           issubgroup_in_unit)
      :
      (grp_quotient_map $o
       {|
         grp_homo_map := lact r;
         issemigrouppreserving_grp_homo :=
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
           :
           IsSemiGroupPreserving (lact r)
       |}) n = mon_unit))
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt;
   quotient_abgroup_rec N (QuotientAbGroup M N)
     (grp_quotient_map $o
      {|
        grp_homo_map := lact r;
        issemigrouppreserving_grp_homo :=
          (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
          :
          IsSemiGroupPreserving (lact r)
      |})
     (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
      qglue
        (issubgroup_in_inv_op (r *L n) mon_unit
           (is_left_submodule r n Nn)
           issubgroup_in_unit)
      :
      (grp_quotient_map $o
       {|
         grp_homo_map := lact r;
         issemigrouppreserving_grp_homo :=
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
           :
           IsSemiGroupPreserving (lact r)
       |}) n = mon_unit)) mult</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkea"><span class="nb">intros</span> r s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : QuotientAbGroup M N,
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact r;
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op (r *L n) mon_unit
        (is_left_submodule r n Nn) issubgroup_in_unit))
  (quotient_abgroup_rec N (QuotientAbGroup M N)
     (grp_quotient_map $o
      {|
        grp_homo_map := lact s;
        issemigrouppreserving_grp_homo :=
          <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l s x y
      |})
     (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
      qglue
        (issubgroup_in_inv_op (s *L n) mon_unit
           (is_left_submodule s n Nn)
           issubgroup_in_unit)) z) =
quotient_abgroup_rec N (QuotientAbGroup M N)
  (grp_quotient_map $o
   {|
     grp_homo_map := lact (r * s);
     issemigrouppreserving_grp_homo :=
       <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l (r * s) x y
   |})
  (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
   qglue
     (issubgroup_in_inv_op ((r * s) *L n) mon_unit
        (is_left_submodule (r * s) n Nn)
        issubgroup_in_unit)) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkeb">snapply Quotient_ind_hprop; [<span class="bp">exact</span> _| <span class="nb">intros</span> m; <span class="nb">simpl</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y))
  (r *L (s *L m)) =
class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y))
  ((r * s) *L m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkec">rapply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L (s *L m) = (r * s) *L m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lm_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt;
   quotient_abgroup_rec N (QuotientAbGroup M N)
     (grp_quotient_map $o
      {|
        grp_homo_map := lact r;
        issemigrouppreserving_grp_homo :=
          (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
          :
          IsSemiGroupPreserving (lact r)
      |})
     (<span class="kr">fun</span> (<span class="nv">n</span> : M) (<span class="nv">Nn</span> : N n) =&gt;
      qglue
        (issubgroup_in_inv_op (r *L n) mon_unit
           (is_left_submodule r n Nn)
           issubgroup_in_unit)
      :
      (grp_quotient_map $o
       {|
         grp_homo_map := lact r;
         issemigrouppreserving_grp_homo :=
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; lm_dist_l r x y)
           :
           IsSemiGroupPreserving (lact r)
       |}) n = mon_unit)) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkee">snapply Quotient_ind_hprop; [<span class="bp">exact</span> _| <span class="nb">intros</span> m; <span class="nb">simpl</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y)) (<span class="mi">1</span> *L m) =
class_of (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : M =&gt; N (sg_op (inv x) y)) m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkef">rapply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>LeftSubmodule M</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> *L m = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lm_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isrightmodule_quotientabgroup</span> {<span class="nv">R</span> : Ring}
  (<span class="nv">M</span> : RightModule R) (<span class="nv">N</span> : RightSubmodule M)
  : IsRightModule R (QuotientAbGroup M N)
  := isleftmodule_quotientabgroup (R:=rng_op R) M N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can therefore form the quotient module of a module by its submodule. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">QuotientLeftModule</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : LeftModule R) (<span class="nv">N</span> : LeftSubmodule M)
  : LeftModule R
  := Build_LeftModule R (QuotientAbGroup M N) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">QuotientRightModule</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : RightModule R) (<span class="nv">N</span> : RightSubmodule M)
  : RightModule R
  := QuotientLeftModule (R:=rng_op R) M N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;/&quot;</span> := QuotientLeftModule : module_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: Notation for right module quotient? *)</span>

<span class="sd">(** ** First Isomorphism Theorem *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> module_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> wc_iso_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf0"><span class="kn">Definition</span> <span class="nf">lm_first_iso</span> `{Funext} {R : Ring} {M N : LeftModule R} (f : M $-&gt; N)
  : M / lm_kernel f ‚âÖ lm_image f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M / lm_kernel f ‚âÖ lm_image f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">M / lm_kernel f ‚âÖ lm_image f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf2">snapply Build_LeftModuleIsomorphism&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (M / lm_kernel f) (lm_image f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><label class="goal-separator" for="module-v-chkf3"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M / lm_kernel f),
<span class="nl">?f</span> (r *L x) = r *L <span class="nl">?f</span> x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf4"><span class="mi">1</span>: rapply abgroup_first_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">x</span> : M / lm_kernel f),
abgroup_first_iso f (r *L x) =
r *L abgroup_first_iso f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf5"><span class="nb">intros</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : M / lm_kernel f,
abgroup_first_iso f (r *L x) =
r *L abgroup_first_iso f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf6">srapply Quotient_ind_hprop; <span class="nb">intros</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">x</span> : Quotient
         (in_cosetL
            {|
              normalsubgroup_subgroup := lm_kernel f;
              normalsubgroup_isnormal :=
                isnormal_ab_subgroup M (lm_kernel f)
            |}) =&gt;
 abgroup_first_iso f (r *L x) =
 r *L abgroup_first_iso f x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := lm_kernel f;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup M (lm_kernel f)
        |}) m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf7"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>M $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (r *L m) = r *L f m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lm_homo_lact.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_first_iso</span> `{Funext} {R : Ring} {M N : RightModule R} (f : M $-&gt; N)
  : QuotientRightModule M (rm_kernel f) ‚âÖ rm_image f
  := lm_first_iso (R:=rng_op R) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Direct products *)</span>

<span class="sd">(** TODO: generalise to biproducts *)</span>
<span class="sd">(** The direct product of modules *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf8"><span class="kn">Definition</span> <span class="nf">lm_prod</span> {<span class="nv">R</span> : Ring} : LeftModule R -&gt; LeftModule R -&gt; LeftModule R.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModule R -&gt; LeftModule R -&gt; LeftModule R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkf9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModule R -&gt; LeftModule R -&gt; LeftModule R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkfa"><span class="nb">intros</span> M N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModule R</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkfb">snapply (Build_LeftModule R (ab_biprod M N)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLeftModule R (ab_biprod M N)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chkfc">snapply Build_IsLeftModule.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R -&gt; ab_biprod M N -&gt; ab_biprod M N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chkfd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chkfd"><hr></label><div class="goal-conclusion">LeftHeteroDistribute <span class="nl">?lact</span> plus plus</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkfe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chkfe"><hr></label><div class="goal-conclusion">RightHeteroDistribute <span class="nl">?lact</span> plus plus</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chkff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chkff"><hr></label><div class="goal-conclusion">HeteroAssociative <span class="nl">?lact</span> <span class="nl">?lact</span> <span class="nl">?lact</span> mult</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk100" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk100"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?lact</span> <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk101">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R -&gt; ab_biprod M N -&gt; ab_biprod M N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk102"><span class="nb">intros</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod M N -&gt; ab_biprod M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> functor_prod; <span class="bp">exact</span> (lact r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk103">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftHeteroDistribute
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt; functor_prod (lact r) (lact r)) plus
  plus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk104"><span class="nb">intros</span> r m n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>ab_biprod M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod (lact r) (lact r) (m + n) =
functor_prod (lact r) (lact r) m +
functor_prod (lact r) (lact r) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> lm_dist_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk105">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightHeteroDistribute
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt; functor_prod (lact r) (lact r)) plus
  plus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk106"><span class="nb">intros</span> r m n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r, m</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>ab_biprod M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod (lact (r + m)) (lact (r + m)) n =
functor_prod (lact r) (lact r) n +
functor_prod (lact m) (lact m) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> lm_dist_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk107">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HeteroAssociative
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt; functor_prod (lact r) (lact r))
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt; functor_prod (lact r) (lact r))
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt; functor_prod (lact r) (lact r)) mult</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk108"><span class="nb">intros</span> r s m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r, s</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>ab_biprod M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod (lact r) (lact r)
  (functor_prod (lact s) (lact s) m) =
functor_prod (lact (r * s)) (lact (r * s)) m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> lm_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk109">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity
  (<span class="kr">fun</span> <span class="nv">r</span> : R =&gt; functor_prod (lact r) (lact r)) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk10a"><span class="nb">intros</span> r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>ab_biprod M N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_prod (lact <span class="mi">1</span>) (lact <span class="mi">1</span>) r = r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> lm_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_prod</span> {<span class="nv">R</span> : Ring} : RightModule R -&gt; RightModule R -&gt; RightModule R
  := lm_prod (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk10b"><span class="kn">Definition</span> <span class="nf">lm_prod_fst</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R} : lm_prod M N $-&gt; M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lm_prod M N $-&gt; M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk10c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lm_prod M N $-&gt; M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk10d">snapply Build_LeftModuleHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (lm_prod M N) M</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk10e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk10e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : lm_prod M N),
<span class="nl">?lm_homo_map</span> (r *L m) = r *L <span class="nl">?lm_homo_map</span> m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk10f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (lm_prod M N) M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk110">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : lm_prod M N),
grp_prod_pr1 (r *L m) = r *L grp_prod_pr1 m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_prod_fst</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R} : rm_prod M N $-&gt; M
  := lm_prod_fst (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk111"><span class="kn">Definition</span> <span class="nf">lm_prod_snd</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R} : lm_prod M N $-&gt; N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lm_prod M N $-&gt; N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lm_prod M N $-&gt; N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk113">snapply Build_LeftModuleHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (lm_prod M N) N</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk114" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk114"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : lm_prod M N),
<span class="nl">?lm_homo_map</span> (r *L m) = r *L <span class="nl">?lm_homo_map</span> m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk115">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (lm_prod M N) N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_pr2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk116">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : lm_prod M N),
grp_prod_pr2 (r *L m) = r *L grp_prod_pr2 m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_prod_snd</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R} : rm_prod M N $-&gt; N
  := lm_prod_snd (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk117"><span class="kn">Definition</span> <span class="nf">lm_prod_corec</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : LeftModule R} (<span class="nv">L</span> : LeftModule R)
  (<span class="nv">f</span> : L $-&gt; M) (<span class="nv">g</span> : L $-&gt; N)
  : L $-&gt; lm_prod M N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>L $-&gt; M</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>L $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">L $-&gt; lm_prod M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk118"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>L $-&gt; M</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>L $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">L $-&gt; lm_prod M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk119">snapply Build_LeftModuleHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>L $-&gt; M</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>L $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism L (lm_prod M N)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>L $-&gt; M</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>L $-&gt; N</span></span></span><br></div><label class="goal-separator" for="module-v-chk11a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : L),
<span class="nl">?lm_homo_map</span> (r *L m) = r *L <span class="nl">?lm_homo_map</span> m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>L $-&gt; M</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>L $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism L (lm_prod M N)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_prod_corec f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>L $-&gt; M</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>L $-&gt; N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">r</span> : R) (<span class="nv">m</span> : L),
grp_prod_corec f g (r *L m) =
r *L grp_prod_corec f g m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk11d"><span class="nb">intros</span> r l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>L $-&gt; M</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>L $-&gt; N</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod_corec f g (r *L l) =
r *L grp_prod_corec f g l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod; <span class="nb">apply</span> lm_homo_lact.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_prod_corec</span> {<span class="nv">R</span> : Ring} {<span class="nv">M</span> <span class="nv">N</span> : RightModule R} (<span class="nv">R&#39;</span> : RightModule R)
  (<span class="nv">f</span> : R&#39; $-&gt; M) (<span class="nv">g</span> : R&#39; $-&gt; N)
  : R&#39; $-&gt; rm_prod M N
  := lm_prod_corec (R:=rng_op R) R&#39; f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk11e"><span class="kn">Instance</span> <span class="nf">hasbinaryproducts_leftmodule</span> {<span class="nv">R</span> : Ring}
  : HasBinaryProducts (LeftModule R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts (LeftModule R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk11f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts (LeftModule R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk120"><span class="nb">intros</span> M N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BinaryProduct M N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk121">snapply Build_BinaryProduct.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModule R</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk122" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk122"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod&#39;</span> $-&gt; M</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk123" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk123"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod&#39;</span> $-&gt; N</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk124" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk124"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : LeftModule R,
(z $-&gt; M) -&gt; (z $-&gt; N) -&gt; z $-&gt; <span class="nl">?cat_binprod&#39;</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk125" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk125"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : LeftModule R) (<span class="nv">f</span> : z $-&gt; M) (<span class="nv">g</span> : z $-&gt; N),
<span class="nl">?cat_pr1</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk126" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk126"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : LeftModule R) (<span class="nv">f</span> : z $-&gt; M) (<span class="nv">g</span> : z $-&gt; N),
<span class="nl">?cat_pr2</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== g</div></blockquote><input class="alectryon-extra-goal-toggle" id="module-v-chk127" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><label class="goal-separator" for="module-v-chk127"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : LeftModule R) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; <span class="nl">?cat_binprod&#39;</span>),
<span class="nl">?cat_pr1</span> $o f $== <span class="nl">?cat_pr1</span> $o g -&gt;
<span class="nl">?cat_pr2</span> $o f $== <span class="nl">?cat_pr2</span> $o g -&gt; f $== g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk128">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftModule R</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (lm_prod M N).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk129">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lm_prod M N $-&gt; M</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> lm_prod_fst.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk12a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lm_prod M N $-&gt; N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> lm_prod_snd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk12b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : LeftModule R,
(z $-&gt; M) -&gt; (z $-&gt; N) -&gt; z $-&gt; lm_prod M N</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> lm_prod_corec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk12c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : LeftModule R) (<span class="nv">f</span> : z $-&gt; M) (<span class="nv">g</span> : z $-&gt; N),
lm_prod_fst $o lm_prod_corec z f g $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk12d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : LeftModule R) (<span class="nv">f</span> : z $-&gt; M) (<span class="nv">g</span> : z $-&gt; N),
lm_prod_snd $o lm_prod_corec z f g $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk12e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : LeftModule R) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; lm_prod M N),
lm_prod_fst $o f $== lm_prod_fst $o g -&gt;
lm_prod_snd $o f $== lm_prod_snd $o g -&gt; f $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk12f"><span class="nb">intros</span> L f g p q a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M, N, L</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>L $-&gt; lm_prod M N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>lm_prod_fst $o f $== lm_prod_fst $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>lm_prod_snd $o f $== lm_prod_snd $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>L</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; (p a) (q a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">hasbinaryproducts_rightmodule</span> {<span class="nv">R</span> : Ring}
  : HasBinaryProducts (RightModule R)
  := hasbinaryproducts_leftmodule (R:=rng_op R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Finite Sums *)</span>

<span class="sd">(** Left scalar multiplication distributes over finite sums of left module elements. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk130"><span class="kn">Definition</span> <span class="nf">lm_sum_dist_l</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : LeftModule R) (<span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; M) (<span class="nv">r</span> : R)
  : r *L ab_sum n f = ab_sum n (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">Hk</span> =&gt; r *L f k Hk).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L ab_sum n f =
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; r *L f k Hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk131"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L ab_sum n f =
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; r *L f k Hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk132"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L ab_sum <span class="mi">0</span> f =
ab_sum <span class="mi">0</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat) =&gt; r *L f k Hk)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk133" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; M,
r *L ab_sum n f = ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; r *L f k Hk)</span></span></span><br></div><label class="goal-separator" for="module-v-chk133"><hr></label><div class="goal-conclusion">r *L ab_sum n.+<span class="mi">1</span> f =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; r *L f k Hk)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk134"><span class="mi">1</span>: <span class="nb">apply</span> lm_zero_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; M</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; M,
r *L ab_sum n f = ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; r *L f k Hk)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r *L ab_sum n.+<span class="mi">1</span> f =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; r *L f k Hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">lhs napply lm_dist_l; <span class="nb">simpl</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Right scalar multiplication distributes over finite sums of right module elements. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_sum_dist_r</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : RightModule R) (<span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; M) (<span class="nv">r</span> : R)
  : ab_sum n f *R r = ab_sum n (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">Hk</span> =&gt; f k Hk *R r)
  := lm_sum_dist_l (R:=rng_op R) M n f r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Left module elements distribute over finite sums of scalars. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk135"><span class="kn">Definition</span> <span class="nf">lm_sum_dist_r</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : LeftModule R) (<span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; R) (<span class="nv">x</span> : M)
  : ab_sum n f *L x = ab_sum n (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">Hk</span> =&gt; f k Hk *L x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f *L x =
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk *L x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk136"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f *L x =
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk *L x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk137"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum <span class="mi">0</span> f *L x =
ab_sum <span class="mi">0</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat) =&gt; f k Hk *L x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="module-v-chk138" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; R,
ab_sum n f *L x = ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk *L x)</span></span></span><br></div><label class="goal-separator" for="module-v-chk138"><hr></label><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f *L x =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; f k Hk *L x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="module-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="module-v-chk139"><span class="mi">1</span>: <span class="nb">apply</span> lm_zero_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>R</var><span class="hyp-type"><b>: </b><span>Ring</span></span></span><br><span><var>M</var><span class="hyp-type"><b>: </b><span>LeftModule R</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>M</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; R,
ab_sum n f *L x = ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk *L x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f *L x =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; f k Hk *L x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">lhs napply lm_dist_r; <span class="nb">simpl</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Right module elements distribute over finite sums of scalar. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">rm_sum_dist_l</span> {<span class="nv">R</span> : Ring} (<span class="nv">M</span> : RightModule R) (<span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; R) (<span class="nv">x</span> : M)
  : x *R ab_sum n f = ab_sum n (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">Hk</span> =&gt; x *R f k Hk)
  := lm_sum_dist_r (R:=rng_op R) M n f x.</span></span></pre>
</div>
</div></body>
</html>
