<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Nat.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Defining the natural numbers from univalence and propositional resizing. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HProp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Universes.Smallness.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Be careful about [Import]ing this file!  Usually you want to use the standard [Nat] instead. *)</span>

<span class="sd">(** Using propositional resizing and univalence, we can construct the natural numbers rather than defining them as an inductive type.  In concrete practice there is no reason we would want to do this, but semantically it means that an elementary (oo,1)-topos (unlike an elementary 1-topos) automatically has a natural numbers object. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AssumeStuff</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">UA</span>:Univalence} {<span class="nv">PR</span>:PropResizing}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The basic idea is that since the universe is closed under coproducts, it is already &quot;infinite&quot;, so we can find the &quot;smallest infinite set&quot; N inside it.  To get rid of the automorphisms in the universe coming from univalence and make N a set, instead of the universe of types we consider graphs (we could use posets or many other things too; in fact the graphs we are interested in will be posets). *)</span>

  <span class="sd">(** Here is the readable definition of [Graph]:</span>

<span class="sd">  &gt; Definition Graph := { V : Type &amp; { E : V -&gt; V -&gt; Type &amp; forall x y, IsHProp@{hp} (E x y) }}.</span>

<span class="sd">  However, to enable performance speedups by controlling universes, we write out its universe parameters explicitly, making it less readable.  Moreover, since here we will eventually only be interested in those graphs that represent natural numbers, it does no harm to fix these universes at the outset throughout the entire development. *)</span>

  <span class="sd">(** [s] : universe of the vertex and edge types</span>
<span class="sd">      [u] : universe of the graph type, morally [s+1] *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">Universes s u.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Graph</span>@{} := @sig@{u u} <span class="kt">Type</span>@{s} (<span class="kr">fun</span> <span class="nv">V</span> =&gt; @sig@{u u} (V -&gt; V -&gt; <span class="kt">Type</span>@{s}) (<span class="kr">fun</span> <span class="nv">E</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHProp (E x y))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We also write out its constructors and fields explicitly to control their universes. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Build_Graph</span>@{} (vert : <span class="kt">Type</span>@{s}) (edge : vert -&gt; vert -&gt; <span class="kt">Type</span>@{s})
             (ishprop_edge : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHProp (edge x y))
    : Graph
    := @exist@{u u} <span class="kt">Type</span>@{s} (<span class="kr">fun</span> <span class="nv">V</span> =&gt; @sig@{u u} (V -&gt; V -&gt; <span class="kt">Type</span>@{s}) (<span class="kr">fun</span> <span class="nv">E</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHProp (E x y)))
             vert
             (@exist@{u u} (vert -&gt; vert -&gt; <span class="kt">Type</span>@{s}) (<span class="kr">fun</span> <span class="nv">E</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHProp (E x y))
                    edge ishprop_edge).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">vert</span>@{} : Graph -&gt; <span class="kt">Type</span>@{s} := pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">edge</span>@{} (A : Graph) : vert A -&gt; vert A -&gt; <span class="kt">Type</span>@{s} := pr1 (pr2 A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ishprop_edge</span>@{} (A : Graph) (x y : vert A) : IsHProp (edge A x y)
    := pr2 (pr2 A) x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** We will need universe annotations in a few more places, but not many. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2"><span class="kn">Definition</span> <span class="nf">equiv_path_graph</span>@{} (A B : Graph)
    : { f : vert A &lt;~&gt; vert B &amp;
            <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, edge A x y &lt;-&gt; edge B (f x) (f y) }
        &lt;~&gt; (A = B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)} &lt;~&gt;
A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)} &lt;~&gt;
A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk4">srefine (equiv_path_sigma _ A B oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)} &lt;~&gt;
{p : A.<span class="mi">1</span> = B.<span class="mi">1</span> &amp;
transport
  (<span class="kr">fun</span> <span class="nv">V</span> : <span class="kt">Type</span> =&gt;
   {E : V -&gt; V -&gt; <span class="kt">Type</span> &amp; is_mere_relation V E}) p A.<span class="mi">2</span> =
B.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk5">srefine (equiv_functor_sigma&#39; (equiv_path_universe (vert A) (vert B)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : vert A &lt;~&gt; vert B,
(<span class="kr">fun</span> <span class="nv">f</span> : vert A &lt;~&gt; vert B =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
 edge A x y &lt;-&gt; edge B (f x) (f y)) a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">p</span> : A.<span class="mi">1</span> = B.<span class="mi">1</span> =&gt;
 transport
   (<span class="kr">fun</span> <span class="nv">V</span> : <span class="kt">Type</span> =&gt;
    {E : V -&gt; V -&gt; <span class="kt">Type</span> &amp; is_mere_relation V E}) p A.<span class="mi">2</span> =
 B.<span class="mi">2</span>) (equiv_path_universe (vert A) (vert B) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk6"><span class="nb">intros</span> f; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
 edge A x y &lt;-&gt; edge B (f x) (f y)) &lt;~&gt;
transport
  (<span class="kr">fun</span> <span class="nv">V</span> : <span class="kt">Type</span> =&gt;
   {E : V -&gt; V -&gt; <span class="kt">Type</span> &amp; is_mere_relation V E})
  (path_universe_uncurried f) A.<span class="mi">2</span> = B.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk7"><span class="nb">rewrite</span> transport_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
 edge A x y &lt;-&gt; edge B (f x) (f y)) &lt;~&gt;
(transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
   (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span>;
transportD (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">y</span> : x -&gt; x -&gt; <span class="kt">Type</span>) =&gt;
   is_mere_relation x y) (path_universe_uncurried f)
  (A.<span class="mi">2</span>).<span class="mi">1</span> (A.<span class="mi">2</span>).<span class="mi">2</span>) = B.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk8">srefine (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
 edge A x y &lt;-&gt; edge B (f x) (f y)) &lt;~&gt;
(transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
   (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span>;
transportD (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">y</span> : x -&gt; x -&gt; <span class="kt">Type</span>) =&gt;
   is_mere_relation x y) (path_universe_uncurried f)
  (A.<span class="mi">2</span>).<span class="mi">1</span> (A.<span class="mi">2</span>).<span class="mi">2</span>).<span class="mi">1</span> = (B.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk9"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
 edge A x y &lt;-&gt; edge B (f x) (f y)) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
  (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> = (B.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka">srefine (equiv_path_forall _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
 edge A x y &lt;-&gt; edge B (f x) (f y)) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
  (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> == (B.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb">srefine (equiv_functor_forall&#39; (f^-<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : vert B,
(<span class="kr">fun</span> <span class="nv">a</span> : vert A =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : vert A, edge A a y &lt;-&gt; edge B (f a) (f y))
  (f^-<span class="mi">1</span>%equiv b) &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">b0</span> : vert B =&gt;
 transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
   (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> b0 = (B.<span class="mi">2</span>).<span class="mi">1</span> b0)
  b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : vert A =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : vert A, edge A a y &lt;-&gt; edge B (f a) (f y))
  (f^-<span class="mi">1</span>%equiv x) &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">b</span> : vert B =&gt;
 transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
   (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> b = (B.<span class="mi">2</span>).<span class="mi">1</span> b)
  x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd">srefine (equiv_path_forall _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">y</span> : vert A,
 edge A (f^-<span class="mi">1</span>%equiv x) y &lt;-&gt;
 edge B (f (f^-<span class="mi">1</span>%equiv x)) (f y)) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
  (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> x == (B.<span class="mi">2</span>).<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke">srefine (equiv_functor_forall&#39; (f^-<span class="mi">1</span>) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : vert B,
(<span class="kr">fun</span> <span class="nv">a</span> : vert A =&gt;
 edge A (f^-<span class="mi">1</span>%equiv x) a &lt;-&gt;
 edge B (f (f^-<span class="mi">1</span>%equiv x)) (f a)) (f^-<span class="mi">1</span>%equiv b) &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">b0</span> : vert B =&gt;
 transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
   (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> x b0 =
 (B.<span class="mi">2</span>).<span class="mi">1</span> x b0) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : vert A =&gt;
 edge A (f^-<span class="mi">1</span>%equiv x) a &lt;-&gt;
 edge B (f (f^-<span class="mi">1</span>%equiv x)) (f a)) (f^-<span class="mi">1</span>%equiv y) &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">b</span> : vert B =&gt;
 transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
   (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> x b =
 (B.<span class="mi">2</span>).<span class="mi">1</span> x b) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk10"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(edge A (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) &lt;-&gt;
 edge B (f (f^-<span class="mi">1</span> x)) (f (f^-<span class="mi">1</span> y))) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; x -&gt; <span class="kt">Type</span>)
  (path_universe_uncurried f) (A.<span class="mi">2</span>).<span class="mi">1</span> x y =
(B.<span class="mi">2</span>).<span class="mi">1</span> x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk11"><span class="nb">rewrite</span> transport_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(edge A (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) &lt;-&gt;
 edge B (f (f^-<span class="mi">1</span> x)) (f (f^-<span class="mi">1</span> y))) &lt;~&gt;
transport (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kt">Type</span> =&gt; x -&gt; <span class="kt">Type</span>)
  (path_universe_uncurried f)
  ((A.<span class="mi">2</span>).<span class="mi">1</span>
     (transport idmap (path_universe_uncurried f)^ x))
  y = (B.<span class="mi">2</span>).<span class="mi">1</span> x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk12"><span class="nb">rewrite</span> transport_arrow_toconst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(edge A (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) &lt;-&gt;
 edge B (f (f^-<span class="mi">1</span> x)) (f (f^-<span class="mi">1</span> y))) &lt;~&gt;
(A.<span class="mi">2</span>).<span class="mi">1</span>
  (transport idmap (path_universe_uncurried f)^ x)
  (transport idmap (path_universe_uncurried f)^ y) =
(B.<span class="mi">2</span>).<span class="mi">1</span> x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk13"><span class="nb">rewrite</span> !transport_path_universe_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(edge A (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) &lt;-&gt;
 edge B (f (f^-<span class="mi">1</span> x)) (f (f^-<span class="mi">1</span> y))) &lt;~&gt;
(A.<span class="mi">2</span>).<span class="mi">1</span> (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) = (B.<span class="mi">2</span>).<span class="mi">1</span> x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk14"><span class="nb">rewrite</span> !eisretr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(edge A (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) &lt;-&gt; edge B x y) &lt;~&gt;
(A.<span class="mi">2</span>).<span class="mi">1</span> (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) = (B.<span class="mi">2</span>).<span class="mi">1</span> x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk15">srefine (equiv_path_universe _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(edge A (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) &lt;-&gt; edge B x y) &lt;~&gt;
((A.<span class="mi">2</span>).<span class="mi">1</span> (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y) &lt;~&gt; (B.<span class="mi">2</span>).<span class="mi">1</span> x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">srefine (equiv_equiv_iff_hprop _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** N will be the set of graphs generated by the empty graph as</span>
<span class="sd">  &quot;zero&quot;, and &quot;adding a new top element&quot; as &quot;successor&quot;. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">graph_zero</span>@{} : Graph
    := Build_Graph Empty
                   (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; @Empty_rec@{u} <span class="kt">Type</span>@{s} x)
                   (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; Empty_rec x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk16"><span class="kn">Definition</span> <span class="nf">graph_succ</span>@{} (A : Graph) : Graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Graph</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Graph</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk18">srefine (Build_Graph (sum@{s s} (vert A) Unit) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vert A + Unit -&gt; vert A + Unit -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><label class="goal-separator" for="nat-v-chk19"><hr></label><div class="goal-conclusion">is_mere_relation (vert A + Unit) <span class="nl">?edge</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vert A + Unit -&gt; vert A + Unit -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1b"><span class="nb">intros</span> [x|x] [y|y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1c"><hr></label><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1d"><hr></label><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1e"><hr></label><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (edge A x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk21">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Empty.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk22">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_mere_relation (vert A + Unit)
  (<span class="kr">fun</span> <span class="nv">X</span> : vert A + Unit =&gt;
   <span class="kr">match</span> X <span class="kr">with</span>
   | inl v =&gt;
       (<span class="kr">fun</span> (<span class="nv">x0</span> : vert A) (<span class="nv">X0</span> : vert A + Unit) =&gt;
        <span class="kr">match</span> X0 <span class="kr">with</span>
        | inl v0 =&gt;
            (<span class="kr">fun</span> <span class="nv">y0</span> : vert A =&gt; edge A x0 y0) v0
        | inr u =&gt; unit_name Unit u
        <span class="kr">end</span>) v
   | inr u =&gt;
       unit_name
         (<span class="kr">fun</span> <span class="nv">X0</span> : vert A + Unit =&gt;
          <span class="kr">match</span> X0 <span class="kr">with</span>
          | inl v =&gt; (<span class="kr">fun</span> <span class="nv">_</span> : vert A =&gt; Empty) v
          | inr u0 =&gt; unit_name Unit u0
          <span class="kr">end</span>) u
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="nb">intros</span> [x|x] [y|y]; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The following lemmas about graphs will be used later on to prove</span>
<span class="sd">  the Peano axioms about N. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk24"><span class="kn">Definition</span> <span class="nf">graph_succ_top</span>@{} {A : Graph} (x : vert (graph_succ A))
    : edge (graph_succ A) x (inr tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_succ A) x (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_succ A) x (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> x <span class="kr">as</span> [x|x]; <span class="bp">exact</span> tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk26"><span class="kn">Definition</span> <span class="nf">graph_succ_top_unique</span>@{}
             {A : Graph} (y : vert (graph_succ A))
             (yt : <span class="kr">forall</span> <span class="nv">x</span>, edge (graph_succ A) x y)
    : y = inr tt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A)</span></span></span><br><span><var>yt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : vert (graph_succ A),
edge (graph_succ A) x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A)</span></span></span><br><span><var>yt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : vert (graph_succ A),
edge (graph_succ A) x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk28"><span class="nb">destruct</span> y <span class="kr">as</span> [y|[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>yt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : vert (graph_succ A),
edge (graph_succ A) x (inl y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl y = inr tt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>yt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : vert (graph_succ A),
edge (graph_succ A) x (inr tt)</span></span></span><br></div><label class="goal-separator" for="nat-v-chk29"><hr></label><div class="goal-conclusion">inr tt = inr tt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>yt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : vert (graph_succ A),
edge (graph_succ A) x (inl y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl y = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (yt (inr tt)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>yt</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : vert (graph_succ A),
edge (graph_succ A) x (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inr tt = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">graph_succ_not_top</span>@{} {A : Graph} (x : vert A)
    : ~(edge (graph_succ A) (inr tt) (inl x))
    := idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2c"><span class="kn">Definition</span> <span class="nf">graph_succ_not_top_unique</span>@{} {A : Graph} (x : vert (graph_succ A))
             (xt : ~(edge (graph_succ A) (inr tt) x))
    : is_inl x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A)</span></span></span><br><span><var>xt</var><span class="hyp-type"><b>: </b><span>~ edge (graph_succ A) (inr tt) x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A)</span></span></span><br><span><var>xt</var><span class="hyp-type"><b>: </b><span>~ edge (graph_succ A) (inr tt) x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2e"><span class="nb">destruct</span> x <span class="kr">as</span> [x|x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>xt</var><span class="hyp-type"><b>: </b><span>~ edge (graph_succ A) (inr tt) (inl x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (inl x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>xt</var><span class="hyp-type"><b>: </b><span>~ edge (graph_succ A) (inr tt) (inr x)</span></span></span><br></div><label class="goal-separator" for="nat-v-chk2f"><hr></label><div class="goal-conclusion">is_inl (inr x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>xt</var><span class="hyp-type"><b>: </b><span>~ edge (graph_succ A) (inr tt) (inl x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (inl x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> tt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>xt</var><span class="hyp-type"><b>: </b><span>~ edge (graph_succ A) (inr tt) (inr x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (inr x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (xt tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Graph_Succ_Equiv</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : Graph} (<span class="nv">f</span> : vert (graph_succ A) &lt;~&gt; vert (graph_succ B))
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, edge (graph_succ A) x y &lt;-&gt; edge (graph_succ B) (f x) (f y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk32"><span class="kn">Definition</span> <span class="nf">graph_succ_equiv_inr</span>@{} : f (inr tt) = inr tt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (inr tt) = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (inr tt) = inr tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk34"><span class="nb">apply</span> (graph_succ_top_unique (f (inr tt))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : vert (graph_succ B),
edge (graph_succ B) x (f (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk35"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert (graph_succ B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_succ B) x (f (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk36"><span class="nb">rewrite</span> &lt;- (eisretr f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert (graph_succ B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_succ B) (f (f^-<span class="mi">1</span> x)) (f (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk37"><span class="nb">apply</span> (fst (e (f^-<span class="mi">1</span> x) (inr tt))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert (graph_succ B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_succ A) (f^-<span class="mi">1</span> x) (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> graph_succ_top.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk38"><span class="kn">Local Definition</span> <span class="nf">Ha</span>@{} : <span class="kr">forall</span> <span class="nv">x</span>, is_inl (f (inl x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : vert A, is_inl (f (inl x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : vert A, is_inl (f (inl x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk3a"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (f (inl x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk3b"><span class="nb">apply</span> graph_succ_not_top_unique.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ edge (graph_succ B) (inr tt) (f (inl x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk3c"><span class="nb">rewrite</span> &lt;- (eisretr f (inr tt)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ edge (graph_succ B) (f (f^-<span class="mi">1</span> (inr tt))) (f (inl x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk3d"><span class="nb">intros</span> ed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>ed</var><span class="hyp-type"><b>: </b><span>edge (graph_succ B) (f (f^-<span class="mi">1</span> (inr tt)))
  (f (inl x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk3e"><span class="nb">apply</span> (snd (e (f^-<span class="mi">1</span> (inr tt)) (inl x))) <span class="kr">in</span> ed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>ed</var><span class="hyp-type"><b>: </b><span>edge (graph_succ A) (f^-<span class="mi">1</span> (inr tt)) (inl x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk3f"><span class="nb">pose</span> (finr := graph_succ_equiv_inr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>ed</var><span class="hyp-type"><b>: </b><span>edge (graph_succ A) (f^-<span class="mi">1</span> (inr tt)) (inl x)</span></span></span><br><span><var>finr</var><span><span class="hyp-body"><b>:= </b><span>graph_succ_equiv_inr</span></span><span class="hyp-type"><b>: </b><span>f (inr tt) = inr tt</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk40"><span class="nb">apply</span> moveL_equiv_V <span class="kr">in</span> finr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>ed</var><span class="hyp-type"><b>: </b><span>edge (graph_succ A) (f^-<span class="mi">1</span> (inr tt)) (inl x)</span></span></span><br><span><var>finr</var><span class="hyp-type"><b>: </b><span>inr tt = f^-<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk41"><span class="nb">rewrite</span> &lt;- finr <span class="kr">in</span> ed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>ed</var><span class="hyp-type"><b>: </b><span>edge (graph_succ A) (inr tt) (inl x)</span></span></span><br><span><var>finr</var><span class="hyp-type"><b>: </b><span>inr tt = f^-<span class="mi">1</span> (inr tt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (graph_succ_not_top x ed).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* Coq bug: without the [:Unit] annotation some floating universe appears. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk42"><span class="kn">Local Definition</span> <span class="nf">Hb</span>@{} : <span class="kr">forall</span> <span class="nv">x</span>:Unit, is_inr (f (inr x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Unit, is_inr (f (inr x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Unit, is_inr (f (inr x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk44"><span class="nb">destruct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inr (f (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">srefine (transport@{s <span class="kt">Set</span>} is_inr graph_succ_equiv_inr^ tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">graph_unsucc_equiv_vert</span>@{} : vert A &lt;~&gt; vert B
      := equiv_unfunctor_sum_l@{s s s s s s} f Ha Hb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk45"><span class="kn">Definition</span> <span class="nf">graph_unsucc_equiv_edge</span>@{} (x y : vert A)
      : iff@{s s s} (edge A x y) (edge B (graph_unsucc_equiv_vert x) (graph_unsucc_equiv_vert y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge A x y &lt;-&gt;
edge B (graph_unsucc_equiv_vert x)
  (graph_unsucc_equiv_vert y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge A x y &lt;-&gt;
edge B (graph_unsucc_equiv_vert x)
  (graph_unsucc_equiv_vert y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk47"><span class="nb">pose</span> (h := e (inl x) (inl y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>h</var><span><span class="hyp-body"><b>:= </b><span>e (inl x) (inl y)</span></span><span class="hyp-type"><b>: </b><span>edge (graph_succ A) (inl x) (inl y) &lt;-&gt;
edge (graph_succ B) (f (inl x)) (f (inl y))</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge A x y &lt;-&gt;
edge B (graph_unsucc_equiv_vert x)
  (graph_unsucc_equiv_vert y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk48"><span class="nb">rewrite</span> &lt;- (unfunctor_sum_l_beta f Ha x) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>edge (graph_succ A) (inl x) (inl y) &lt;-&gt;
edge (graph_succ B) (inl (unfunctor_sum_l f Ha x))
  (f (inl y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge A x y &lt;-&gt;
edge B (graph_unsucc_equiv_vert x)
  (graph_unsucc_equiv_vert y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk49"><span class="nb">rewrite</span> &lt;- (unfunctor_sum_l_beta f Ha y) <span class="kr">in</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>edge (graph_succ A) (inl x) (inl y) &lt;-&gt;
edge (graph_succ B) (inl (unfunctor_sum_l f Ha x))
  (inl (unfunctor_sum_l f Ha y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge A x y &lt;-&gt;
edge B (graph_unsucc_equiv_vert x)
  (graph_unsucc_equiv_vert y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Graph_Succ_Equiv</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk4a"><span class="kn">Definition</span> <span class="nf">graph_succ_path_equiv</span>@{} (A B : Graph)
    : (A = B) &lt;~&gt; (graph_succ A = graph_succ B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = B &lt;~&gt; graph_succ A = graph_succ B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = B &lt;~&gt; graph_succ A = graph_succ B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk4c"><span class="nb">refine</span> ((equiv_path_graph _ _) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A = B &lt;~&gt;
{f : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk4d"><span class="nb">refine</span> (_ oE (equiv_path_graph _ _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)} &lt;~&gt;
{f : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk4e">srefine (equiv_adjointify _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)} -&gt;
{f : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><label class="goal-separator" for="nat-v-chk4f"><hr></label><div class="goal-conclusion">{f : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)} -&gt;
{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)}</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><label class="goal-separator" for="nat-v-chk50"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><label class="goal-separator" for="nat-v-chk51"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk52">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)} -&gt;
{f : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk53"><span class="nb">intros</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk54"><span class="kr">exists</span> (<span class="nv">f</span> +E <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) ((f +E <span class="mi">1</span>) x) ((f +E <span class="mi">1</span>) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk55"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) ((f +E <span class="mi">1</span>) x) ((f +E <span class="mi">1</span>) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk56"><span class="nb">destruct</span> x <span class="kr">as</span> [x|x]; <span class="nb">destruct</span> y <span class="kr">as</span> [y|y]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge A x y &lt;-&gt; edge B (f x) (f y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><label class="goal-separator" for="nat-v-chk57"><hr></label><div class="goal-conclusion">Unit &lt;-&gt; Unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><label class="goal-separator" for="nat-v-chk58"><hr></label><div class="goal-conclusion">Empty &lt;-&gt; Empty</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><label class="goal-separator" for="nat-v-chk59"><hr></label><div class="goal-conclusion">Unit &lt;-&gt; Unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk5a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge A x y &lt;-&gt; edge B (f x) (f y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk5b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit &lt;-&gt; Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">apply</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk5c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty &lt;-&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">apply</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk5d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Unit &lt;-&gt; Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">apply</span> idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk5e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)} -&gt;
{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk5f"><span class="nb">intros</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert A &lt;~&gt; vert B &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A, edge A x y &lt;-&gt; edge B (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk60"><span class="kr">exists</span> (<span class="nv">graph_unsucc_equiv_vert</span> <span class="nv">f</span> <span class="nv">e</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt;
edge B (graph_unsucc_equiv_vert f e x)
  (graph_unsucc_equiv_vert f e y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (graph_unsucc_equiv_edge f e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">X</span> : {f : vert A &lt;~&gt; vert B &amp;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
       edge A x y &lt;-&gt; edge B (f x) (f y)} =&gt;
 (<span class="kr">fun</span> (<span class="nv">f</span> : vert A &lt;~&gt; vert B)
    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
         edge A x y &lt;-&gt; edge B (f x) (f y)) =&gt;
  (f +E <span class="mi">1</span>;
  <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A) =&gt;
  <span class="kr">match</span>
    x <span class="kr">as</span> s
    <span class="kr">return</span>
      (edge (graph_succ A) s y &lt;-&gt;
       edge (graph_succ B) ((f +E <span class="mi">1</span>) s) ((f +E <span class="mi">1</span>) y))
  <span class="kr">with</span>
  | inl v =&gt;
      (<span class="kr">fun</span> <span class="nv">x0</span> : vert A =&gt;
       <span class="kr">match</span>
         y <span class="kr">as</span> s
         <span class="kr">return</span>
           (edge (graph_succ A) (inl x0) s &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl x0))
              ((f +E <span class="mi">1</span>) s))
       <span class="kr">with</span>
       | inl v0 =&gt;
           (<span class="kr">fun</span> <span class="nv">y0</span> : vert A =&gt;
            e x0 y0
            :
            edge (graph_succ A) (inl x0) (inl y0) &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl x0))
              ((f +E <span class="mi">1</span>) (inl y0))) v0
       | inr u =&gt;
           (<span class="kr">fun</span> <span class="nv">y0</span> : Unit =&gt;
            (idmap, idmap)
            :
            edge (graph_succ A) (inl x0) (inr y0) &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl x0))
              ((f +E <span class="mi">1</span>) (inr y0))) u
       <span class="kr">end</span>) v
  | inr u =&gt;
      (<span class="kr">fun</span> <span class="nv">x0</span> : Unit =&gt;
       <span class="kr">match</span>
         y <span class="kr">as</span> s
         <span class="kr">return</span>
           (edge (graph_succ A) (inr x0) s &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr x0))
              ((f +E <span class="mi">1</span>) s))
       <span class="kr">with</span>
       | inl v =&gt;
           (<span class="kr">fun</span> <span class="nv">y0</span> : vert A =&gt;
            (idmap, idmap)
            :
            edge (graph_succ A) (inr x0) (inl y0) &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr x0))
              ((f +E <span class="mi">1</span>) (inl y0))) v
       | inr u0 =&gt;
           (<span class="kr">fun</span> <span class="nv">y0</span> : Unit =&gt;
            (idmap, idmap)
            :
            edge (graph_succ A) (inr x0) (inr y0) &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr x0))
              ((f +E <span class="mi">1</span>) (inr y0))) u0
       <span class="kr">end</span>) u
  <span class="kr">end</span>)) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o (<span class="kr">fun</span>
     <span class="nv">X</span> : {f
         : vert (graph_succ A) &lt;~&gt; vert (graph_succ B)
         &amp;
         <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
         edge (graph_succ A) x y &lt;-&gt;
         edge (graph_succ B) (f x) (f y)} =&gt;
   (<span class="kr">fun</span>
      (<span class="nv">f</span> : vert (graph_succ A) &lt;~&gt; vert (graph_succ B))
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
           edge (graph_succ A) x y &lt;-&gt;
           edge (graph_succ B) (f x) (f y)) =&gt;
    (graph_unsucc_equiv_vert f e;
    graph_unsucc_equiv_edge f e)) X.<span class="mi">1</span> X.<span class="mi">2</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk62"><span class="nb">intros</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(graph_unsucc_equiv_vert f e +E <span class="mi">1</span>;
<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A) =&gt;
<span class="kr">match</span>
  x <span class="kr">as</span> s
  <span class="kr">return</span>
    (edge (graph_succ A) s y &lt;-&gt;
     edge (graph_succ B)
       ((graph_unsucc_equiv_vert f e +E <span class="mi">1</span>) s)
       ((graph_unsucc_equiv_vert f e +E <span class="mi">1</span>) y))
<span class="kr">with</span>
| inl v =&gt;
    <span class="kr">match</span>
      y <span class="kr">as</span> s
      <span class="kr">return</span>
        (edge (graph_succ A) (inl v) s &lt;-&gt;
         edge (graph_succ B)
           ((graph_unsucc_equiv_vert f e +E <span class="mi">1</span>) (inl v))
           ((graph_unsucc_equiv_vert f e +E <span class="mi">1</span>) s))
    <span class="kr">with</span>
    | inl v0 =&gt; graph_unsucc_equiv_edge f e v v0
    | inr _ =&gt; (idmap, idmap)
    <span class="kr">end</span>
| inr u =&gt;
    <span class="kr">match</span>
      y <span class="kr">as</span> s
      <span class="kr">return</span>
        (edge (graph_succ A) (inr u) s &lt;-&gt;
         edge (graph_succ B)
           ((graph_unsucc_equiv_vert f e +E <span class="mi">1</span>) (inr u))
           ((graph_unsucc_equiv_vert f e +E <span class="mi">1</span>) s))
    <span class="kr">with</span>
    | inl _ =&gt; (idmap, idmap)
    | inr _ =&gt; (idmap, idmap)
    <span class="kr">end</span>
<span class="kr">end</span>) = (f; e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk63"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_unsucc_equiv_vert f e +E <span class="mi">1</span> = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk64"><span class="nb">apply</span> path_equiv, path_arrow; <span class="nb">intros</span> [x|[]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl (unfunctor_sum_l f (Ha f e) x) = f (inl x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><label class="goal-separator" for="nat-v-chk65"><hr></label><div class="goal-conclusion">inr tt = f (inr tt)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk66">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inl (unfunctor_sum_l f (Ha f e) x) = f (inl x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> unfunctor_sum_l_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk67">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert (graph_succ A) &lt;~&gt; vert (graph_succ B)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
edge (graph_succ A) x y &lt;-&gt;
edge (graph_succ B) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inr tt = f (inr tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> graph_succ_equiv_inr, e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk68">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">X</span> : {f
       : vert (graph_succ A) &lt;~&gt; vert (graph_succ B) &amp;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
       edge (graph_succ A) x y &lt;-&gt;
       edge (graph_succ B) (f x) (f y)} =&gt;
 (<span class="kr">fun</span>
    (<span class="nv">f</span> : vert (graph_succ A) &lt;~&gt; vert (graph_succ B))
    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A),
         edge (graph_succ A) x y &lt;-&gt;
         edge (graph_succ B) (f x) (f y)) =&gt;
  (graph_unsucc_equiv_vert f e;
  graph_unsucc_equiv_edge f e)) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o (<span class="kr">fun</span>
     <span class="nv">X</span> : {f : vert A &lt;~&gt; vert B &amp;
         <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
         edge A x y &lt;-&gt; edge B (f x) (f y)} =&gt;
   (<span class="kr">fun</span> (<span class="nv">f</span> : vert A &lt;~&gt; vert B)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
           edge A x y &lt;-&gt; edge B (f x) (f y)) =&gt;
    (f +E <span class="mi">1</span>;
    <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A) =&gt;
    <span class="kr">match</span>
      x <span class="kr">as</span> s
      <span class="kr">return</span>
        (edge (graph_succ A) s y &lt;-&gt;
         edge (graph_succ B) ((f +E <span class="mi">1</span>) s) ((f +E <span class="mi">1</span>) y))
    <span class="kr">with</span>
    | inl v =&gt;
        (<span class="kr">fun</span> <span class="nv">x0</span> : vert A =&gt;
         <span class="kr">match</span>
           y <span class="kr">as</span> s
           <span class="kr">return</span>
             (edge (graph_succ A) (inl x0) s &lt;-&gt;
              edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl x0))
                ((f +E <span class="mi">1</span>) s))
         <span class="kr">with</span>
         | inl v0 =&gt;
             (<span class="kr">fun</span> <span class="nv">y0</span> : vert A =&gt;
              e x0 y0
              :
              edge (graph_succ A) (inl x0) (inl y0) &lt;-&gt;
              edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl x0))
                ((f +E <span class="mi">1</span>) (inl y0))) v0
         | inr u =&gt;
             (<span class="kr">fun</span> <span class="nv">y0</span> : Unit =&gt;
              (idmap, idmap)
              :
              edge (graph_succ A) (inl x0) (inr y0) &lt;-&gt;
              edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl x0))
                ((f +E <span class="mi">1</span>) (inr y0))) u
         <span class="kr">end</span>) v
    | inr u =&gt;
        (<span class="kr">fun</span> <span class="nv">x0</span> : Unit =&gt;
         <span class="kr">match</span>
           y <span class="kr">as</span> s
           <span class="kr">return</span>
             (edge (graph_succ A) (inr x0) s &lt;-&gt;
              edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr x0))
                ((f +E <span class="mi">1</span>) s))
         <span class="kr">with</span>
         | inl v =&gt;
             (<span class="kr">fun</span> <span class="nv">y0</span> : vert A =&gt;
              (idmap, idmap)
              :
              edge (graph_succ A) (inr x0) (inl y0) &lt;-&gt;
              edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr x0))
                ((f +E <span class="mi">1</span>) (inl y0))) v
         | inr u0 =&gt;
             (<span class="kr">fun</span> <span class="nv">y0</span> : Unit =&gt;
              (idmap, idmap)
              :
              edge (graph_succ A) (inr x0) (inr y0) &lt;-&gt;
              edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr x0))
                ((f +E <span class="mi">1</span>) (inr y0))) u0
         <span class="kr">end</span>) u
    <span class="kr">end</span>)) X.<span class="mi">1</span> X.<span class="mi">2</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk69"><span class="nb">intros</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(graph_unsucc_equiv_vert (f +E <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A) =&gt;
    <span class="kr">match</span>
      x <span class="kr">as</span> s
      <span class="kr">return</span>
        (edge (graph_succ A) s y &lt;-&gt;
         edge (graph_succ B) ((f +E <span class="mi">1</span>) s) ((f +E <span class="mi">1</span>) y))
    <span class="kr">with</span>
    | inl v =&gt;
        <span class="kr">match</span>
          y <span class="kr">as</span> s
          <span class="kr">return</span>
            (edge (graph_succ A) (inl v) s &lt;-&gt;
             edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl v))
               ((f +E <span class="mi">1</span>) s))
        <span class="kr">with</span>
        | inl v0 =&gt; e v v0
        | inr _ =&gt; (idmap, idmap)
        <span class="kr">end</span>
    | inr u =&gt;
        <span class="kr">match</span>
          y <span class="kr">as</span> s
          <span class="kr">return</span>
            (edge (graph_succ A) (inr u) s &lt;-&gt;
             edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr u))
               ((f +E <span class="mi">1</span>) s))
        <span class="kr">with</span>
        | inl _ =&gt; (idmap, idmap)
        | inr _ =&gt; (idmap, idmap)
        <span class="kr">end</span>
    <span class="kr">end</span>);
graph_unsucc_equiv_edge (f +E <span class="mi">1</span>)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_succ A) =&gt;
   <span class="kr">match</span>
     x <span class="kr">as</span> s
     <span class="kr">return</span>
       (edge (graph_succ A) s y &lt;-&gt;
        edge (graph_succ B) ((f +E <span class="mi">1</span>) s) ((f +E <span class="mi">1</span>) y))
   <span class="kr">with</span>
   | inl v =&gt;
       <span class="kr">match</span>
         y <span class="kr">as</span> s
         <span class="kr">return</span>
           (edge (graph_succ A) (inl v) s &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inl v))
              ((f +E <span class="mi">1</span>) s))
       <span class="kr">with</span>
       | inl v0 =&gt; e v v0
       | inr _ =&gt; (idmap, idmap)
       <span class="kr">end</span>
   | inr u =&gt;
       <span class="kr">match</span>
         y <span class="kr">as</span> s
         <span class="kr">return</span>
           (edge (graph_succ A) (inr u) s &lt;-&gt;
            edge (graph_succ B) ((f +E <span class="mi">1</span>) (inr u))
              ((f +E <span class="mi">1</span>) s))
       <span class="kr">with</span>
       | inl _ =&gt; (idmap, idmap)
       | inr _ =&gt; (idmap, idmap)
       <span class="kr">end</span>
   <span class="kr">end</span>)) = (f; e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk6a"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert A &lt;~&gt; vert B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A,
edge A x y &lt;-&gt; edge B (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_unsucc_equiv_vert (f +E <span class="mi">1</span>)
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : vert A + Unit =&gt;
   <span class="kr">match</span>
     x <span class="kr">as</span> s
     <span class="kr">return</span>
       (<span class="kr">match</span> s <span class="kr">with</span>
        | inl v =&gt;
            <span class="kr">fun</span> <span class="nv">X</span> : vert A + Unit =&gt;
            <span class="kr">match</span> X <span class="kr">with</span>
            | inl v0 =&gt; edge A v v0
            | inr _ =&gt; Unit
            <span class="kr">end</span>
        | inr _ =&gt;
            <span class="kr">fun</span> <span class="nv">X</span> : vert A + Unit =&gt;
            <span class="kr">match</span> X <span class="kr">with</span>
            | inl _ =&gt; Empty
            | inr _ =&gt; Unit
            <span class="kr">end</span>
        <span class="kr">end</span> y &lt;-&gt;
        <span class="kr">match</span> functor_sum f idmap s <span class="kr">with</span>
        | inl v =&gt;
            <span class="kr">fun</span> <span class="nv">X</span> : vert B + Unit =&gt;
            <span class="kr">match</span> X <span class="kr">with</span>
            | inl v0 =&gt; edge B v v0
            | inr _ =&gt; Unit
            <span class="kr">end</span>
        | inr _ =&gt;
            <span class="kr">fun</span> <span class="nv">X</span> : vert B + Unit =&gt;
            <span class="kr">match</span> X <span class="kr">with</span>
            | inl _ =&gt; Empty
            | inr _ =&gt; Unit
            <span class="kr">end</span>
        <span class="kr">end</span> (functor_sum f idmap y))
   <span class="kr">with</span>
   | inl v =&gt;
       <span class="kr">match</span>
         y <span class="kr">as</span> s
         <span class="kr">return</span>
           (<span class="kr">match</span> s <span class="kr">with</span>
            | inl v0 =&gt; edge A v v0
            | inr _ =&gt; Unit
            <span class="kr">end</span> &lt;-&gt;
            <span class="kr">match</span> functor_sum f idmap s <span class="kr">with</span>
            | inl v0 =&gt; edge B (f v) v0
            | inr _ =&gt; Unit
            <span class="kr">end</span>)
       <span class="kr">with</span>
       | inl v0 =&gt; e v v0
       | inr _ =&gt; (idmap, idmap)
       <span class="kr">end</span>
   | inr _ =&gt;
       <span class="kr">match</span>
         y <span class="kr">as</span> s
         <span class="kr">return</span>
           (<span class="kr">match</span> s <span class="kr">with</span>
            | inl _ =&gt; Empty
            | inr _ =&gt; Unit
            <span class="kr">end</span> &lt;-&gt;
            <span class="kr">match</span> functor_sum f idmap s <span class="kr">with</span>
            | inl _ =&gt; Empty
            | inr _ =&gt; Unit
            <span class="kr">end</span>)
       <span class="kr">with</span>
       | inl _ =&gt; (idmap, idmap)
       | inr _ =&gt; (idmap, idmap)
       <span class="kr">end</span>
   <span class="kr">end</span>) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_equiv, path_arrow; <span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">graph_unsucc_path</span>@{} (A B : Graph)
    : (graph_succ A = graph_succ B) -&gt; A = B
    := (graph_succ_path_equiv A B)^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Here is the impredicative definition of N, as the smallest</span>
<span class="sd">  subtype of [Graph] containing [graph_zero] and closed under</span>
<span class="sd">  [graph_succ]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">in_N</span>@{p} (n : Graph)
    := <span class="kr">forall</span> (<span class="nv">P</span> : Graph -&gt; <span class="kt">Type</span>@{p}),
           (<span class="kr">forall</span> <span class="nv">A</span>, IsHProp (P A))
           -&gt; P graph_zero
           -&gt; (<span class="kr">forall</span> <span class="nv">A</span>, P A -&gt; P (graph_succ A))
           -&gt; P n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk6b"><span class="kn">Instance</span> <span class="nf">ishprop_in_N</span>@{p sp} (n : Graph) : IsHProp@{sp} (in_N@{p} n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (in_N n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (in_N n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> istrunc_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** [p] : universe of [N], morally [u+1] i.e. [s+2]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Universe</span> <span class="nf">p</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">N</span>@{} : <span class="kt">Type</span>@{p}
    := @sig@{u p} Graph in_N@{u}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_N</span>@{} (n m : N) : n.<span class="mi">1</span> = m.<span class="mi">1</span> -&gt; n = m
    := path_sigma_hprop@{u p p} n m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk6d"><span class="kn">Definition</span> <span class="nf">zero</span>@{} : N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk6f"><span class="kr">exists</span> <span class="nv">graph_zero</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N graph_zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> P PH P0 Ps; <span class="bp">exact</span> P0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk70"><span class="kn">Definition</span> <span class="nf">succ</span>@{} : N -&gt; N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N -&gt; N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk71"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N -&gt; N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk72"><span class="nb">intros</span> [n nrec].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk73"><span class="kr">exists</span> (<span class="nv">graph_succ</span> <span class="nv">n</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N (graph_succ n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk74"><span class="nb">intros</span> P PH P0 Ps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_succ n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk75"><span class="nb">apply</span> Ps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (nrec P PH P0 Ps).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** First Peano axiom: successor is injective *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk76"><span class="kn">Definition</span> <span class="nf">succ_inj</span>@{} (n m : N) (p : succ n = succ m) : n = m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>succ n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>succ n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk78"><span class="nb">apply</span> path_N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>succ n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n.<span class="mi">1</span> = m.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk79"><span class="nb">apply</span> ((graph_succ_path_equiv n.<span class="mi">1</span> m.<span class="mi">1</span>)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>succ n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_succ n.<span class="mi">1</span> = graph_succ m.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p..<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A slightly more general version of the theorem that N is a set,</span>
<span class="sd">  which will be useful later. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk7a"><span class="kn">Lemma</span> <span class="nf">ishprop_path_graph_in_N</span>@{} (A B : Graph) (Arec : in_N@{u} A) : IsHProp (A = B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (A = B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk7b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (A = B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk7c"><span class="nb">apply</span> hprop_inhabited_contr; <span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A = A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk7d"><span class="nb">apply</span> Arec; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (graph_zero = graph_zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><label class="goal-separator" for="nat-v-chk7e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
Contr (A = A) -&gt; Contr (graph_succ A = graph_succ A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (graph_zero = graph_zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk80"><span class="nb">apply</span> contr_inhabited_hprop; <span class="kp">try</span> <span class="bp">exact</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (graph_zero = graph_zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk81"><span class="nb">apply</span> hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : graph_zero = graph_zero, x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk82">equiv_intro (equiv_path_graph graph_zero graph_zero) fe.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br><span><var>fe</var><span class="hyp-type"><b>: </b><span>{f : vert graph_zero &lt;~&gt; vert graph_zero &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f x) (f y)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : graph_zero = graph_zero,
equiv_path_graph graph_zero graph_zero fe = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk83"><span class="nb">destruct</span> fe <span class="kr">as</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : graph_zero = graph_zero,
equiv_path_graph graph_zero graph_zero (f; e) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk84">equiv_intro (equiv_path_graph graph_zero graph_zero) fe&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f x) (f y)</span></span></span><br><span><var>fe'</var><span class="hyp-type"><b>: </b><span>{f : vert graph_zero &lt;~&gt; vert graph_zero &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f x) (f y)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_graph graph_zero graph_zero (f; e) =
equiv_path_graph graph_zero graph_zero fe&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk85"><span class="nb">destruct</span> fe&#39; <span class="kr">as</span> [f&#39; e&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f x) (f y)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f&#39; x) (f&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_graph graph_zero graph_zero (f; e) =
equiv_path_graph graph_zero graph_zero (f&#39;; e&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk86"><span class="nb">apply</span> equiv_ap; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f x) (f y)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f&#39; x) (f&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f; e) = (f&#39;; e&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk87"><span class="nb">apply</span> path_sigma_hprop, path_equiv@{s s s}, path_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f x) (f y)</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert graph_zero</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge graph_zero (f&#39; x) (f&#39; y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f; e).<span class="mi">1</span> == (f&#39;; e&#39;).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk88">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
Contr (A = A) -&gt; Contr (graph_succ A = graph_succ A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk89"><span class="kp">try</span> <span class="nb">clear</span> B;<span class="nb">intros</span> B BC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>Arec</var><span class="hyp-type"><b>: </b><span>in_N A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>BC</var><span class="hyp-type"><b>: </b><span>Contr (B = B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (graph_succ B = graph_succ B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (contr_equiv (B = B) (graph_succ_path_equiv B B)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk8a"><span class="kn">Instance</span> <span class="nf">ishprop_path_N</span>@{} (n : N) (A : Graph) : IsHProp (n.<span class="mi">1</span> = A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n.<span class="mi">1</span> = A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk8b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n.<span class="mi">1</span> = A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ishprop_path_graph_in_N, pr2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk8c"><span class="kn">Instance</span> <span class="nf">ishset_N</span>@{} : IsHSet N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk8e"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_mere_relation N paths</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk8f"><span class="nb">intros</span> n m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n = m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk90"><span class="nb">change</span> (IsHProp (n = m)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n = m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (istrunc_equiv_istrunc (n.<span class="mi">1</span> = m.<span class="mi">1</span>) (equiv_path_sigma_hprop n m)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk91"><span class="kn">Definition</span> <span class="nf">graph_zero_neq_succ</span>@{} {A : Graph}
    : graph_zero &lt;&gt; graph_succ A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_zero &lt;&gt; graph_succ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk92"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_zero &lt;&gt; graph_succ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk93"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>graph_zero = graph_succ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk94"><span class="nb">destruct</span> ((equiv_path_graph graph_zero (graph_succ A))^-<span class="mi">1</span> p) <span class="kr">as</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>graph_zero = graph_succ A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert graph_zero &lt;~&gt; vert (graph_succ A)</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert graph_zero,
edge graph_zero x y &lt;-&gt;
edge (graph_succ A) (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f^-<span class="mi">1</span> (inr tt)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Second Peano axiom: zero is not a successor *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk95"><span class="kn">Definition</span> <span class="nf">zero_neq_succ</span>@{} (n : N) : zero &lt;&gt; succ n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero &lt;&gt; succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero &lt;&gt; succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> p; <span class="nb">apply</span> pr1_path <span class="kr">in</span> p; <span class="nb">refine</span> (graph_zero_neq_succ p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This tweak is sometimes necessary to avoid universe inconsistency.</span>
<span class="sd">  It&#39;s how the impredicativity of propositional resizing enters. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk97"><span class="kn">Definition</span> <span class="nf">resize_nrec</span>@{p0 p1} (n : Graph) (nrec : in_N@{p0} n)
    : in_N@{p1} n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk98"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk99"><span class="nb">intros</span> P&#39; PH&#39; P0&#39; Ps&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P'</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P&#39; A)</span></span></span><br><span><var>P0'</var><span class="hyp-type"><b>: </b><span>P&#39; graph_zero</span></span></span><br><span><var>Ps'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P&#39; A -&gt; P&#39; (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P&#39; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk9a">srefine ((equiv_smalltype (P&#39; n))
             (nrec (<span class="kr">fun</span> <span class="nv">A</span> =&gt; smalltype (P&#39; A)) _ _ _));
      <span class="kp">try</span> <span class="bp">exact</span> _; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P'</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P&#39; A)</span></span></span><br><span><var>P0'</var><span class="hyp-type"><b>: </b><span>P&#39; graph_zero</span></span></span><br><span><var>Ps'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P&#39; A -&gt; P&#39; (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">smalltype (P&#39; graph_zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P'</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P&#39; A)</span></span></span><br><span><var>P0'</var><span class="hyp-type"><b>: </b><span>P&#39; graph_zero</span></span></span><br><span><var>Ps'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P&#39; A -&gt; P&#39; (graph_succ A)</span></span></span><br></div><label class="goal-separator" for="nat-v-chk9b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
smalltype (P&#39; A) -&gt; smalltype (P&#39; (graph_succ A))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk9c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P'</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P&#39; A)</span></span></span><br><span><var>P0'</var><span class="hyp-type"><b>: </b><span>P&#39; graph_zero</span></span></span><br><span><var>Ps'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P&#39; A -&gt; P&#39; (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">smalltype (P&#39; graph_zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((equiv_smalltype (P&#39; graph_zero))^-<span class="mi">1</span> P0&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk9d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P'</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P&#39; A)</span></span></span><br><span><var>P0'</var><span class="hyp-type"><b>: </b><span>P&#39; graph_zero</span></span></span><br><span><var>Ps'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P&#39; A -&gt; P&#39; (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
smalltype (P&#39; A) -&gt; smalltype (P&#39; (graph_succ A))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk9e"><span class="nb">intros</span> A P&#39;A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>P'</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P&#39; A)</span></span></span><br><span><var>P0'</var><span class="hyp-type"><b>: </b><span>P&#39; graph_zero</span></span></span><br><span><var>Ps'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P&#39; A -&gt; P&#39; (graph_succ A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>P'A</var><span class="hyp-type"><b>: </b><span>smalltype (P&#39; A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">smalltype (P&#39; (graph_succ A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((equiv_smalltype (P&#39; (graph_succ A)))^-<span class="mi">1</span>
                                (Ps&#39; A ((equiv_smalltype (P&#39; A)) P&#39;A))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk9f"><span class="kn">Local Instance</span> <span class="nf">ishprop_graph_zero_or_succ</span>@{} : <span class="kr">forall</span> <span class="nv">n</span> : Graph,
      IsHProp ((n = graph_zero) + { m : N &amp; n = graph_succ m.<span class="mi">1</span> }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph,
IsHProp
  ((n = graph_zero) + {m : N &amp; n = graph_succ m.<span class="mi">1</span>})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : Graph,
IsHProp
  ((n = graph_zero) + {m : N &amp; n = graph_succ m.<span class="mi">1</span>})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka1"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  ((n = graph_zero) + {m : N &amp; n = graph_succ m.<span class="mi">1</span>})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka2"><span class="nb">apply</span> ishprop_sum@{u p p}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n = graph_zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><label class="goal-separator" for="nat-v-chka3"><hr></label><div class="goal-conclusion">IsHProp {m : N &amp; n = graph_succ m.<span class="mi">1</span>}</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chka4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><label class="goal-separator" for="nat-v-chka4"><hr></label><div class="goal-conclusion">n = graph_zero -&gt;
{m : N &amp; n = graph_succ m.<span class="mi">1</span>} -&gt; Empty</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n = graph_zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka6"><span class="nb">apply</span> (@istrunc_equiv_istrunc _ _ (equiv_path_inverse _ _)),ishprop_path_graph_in_N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N graph_zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> zero.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp {m : N &amp; n = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chka8"><span class="nb">apply</span> @ishprop_sigma_disjoint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : N, IsHProp (n = graph_succ a.<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><label class="goal-separator" for="nat-v-chka9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : N,
n = graph_succ x.<span class="mi">1</span> -&gt; n = graph_succ y.<span class="mi">1</span> -&gt; x = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkaa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : N, IsHProp (n = graph_succ a.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkab"><span class="nb">intros</span> m;<span class="nb">apply</span> (@istrunc_equiv_istrunc _ _ (equiv_path_inverse _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (graph_succ m.<span class="mi">1</span> = n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkac"><span class="nb">apply</span> ishprop_path_graph_in_N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N (graph_succ m.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((succ m).<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkad">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : N,
n = graph_succ x.<span class="mi">1</span> -&gt; n = graph_succ y.<span class="mi">1</span> -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkae"><span class="nb">intros</span> x y ex ey.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>ex</var><span class="hyp-type"><b>: </b><span>n = graph_succ x.<span class="mi">1</span></span></span></span><br><span><var>ey</var><span class="hyp-type"><b>: </b><span>n = graph_succ y.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkaf"><span class="nb">apply</span> succ_inj, path_N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>ex</var><span class="hyp-type"><b>: </b><span>n = graph_succ x.<span class="mi">1</span></span></span></span><br><span><var>ey</var><span class="hyp-type"><b>: </b><span>n = graph_succ y.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(succ x).<span class="mi">1</span> = (succ y).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">path_via n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = graph_zero -&gt;
{m : N &amp; n = graph_succ m.<span class="mi">1</span>} -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb1"><span class="nb">intros</span> e0 [m es].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>n = graph_zero</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>es</var><span class="hyp-type"><b>: </b><span>n = graph_succ m.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb2"><span class="nb">apply</span> zero_neq_succ <span class="kr">with</span> m, path_N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>n = graph_zero</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>es</var><span class="hyp-type"><b>: </b><span>n = graph_succ m.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero.<span class="mi">1</span> = (succ m).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">path_via n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb3"><span class="kn">Local Instance</span> <span class="nf">ishprop_N_zero_or_succ</span>@{} : <span class="kr">forall</span> <span class="nv">n</span> : N,
      IsHProp ((n = zero) + { m : N &amp; n = succ m }).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N,
IsHProp ((n = zero) + {m : N &amp; n = succ m})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N,
IsHProp ((n = zero) + {m : N &amp; n = succ m})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb5"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp ((n = zero) + {m : N &amp; n = succ m})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb6"><span class="nb">apply</span> ishprop_sum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n = zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chkb7"><hr></label><div class="goal-conclusion">IsHProp {m : N &amp; n = succ m}</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chkb8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chkb8"><hr></label><div class="goal-conclusion">n = zero -&gt; {m : N &amp; n = succ m} -&gt; Empty</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n = zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp {m : N &amp; n = succ m}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkbb"><span class="nb">apply</span> ishprop_sigma_disjoint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : N, n = succ x -&gt; n = succ y -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkbc"><span class="nb">intros</span> x y ex ey.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>ex</var><span class="hyp-type"><b>: </b><span>n = succ x</span></span></span><br><span><var>ey</var><span class="hyp-type"><b>: </b><span>n = succ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> succ_inj;path_via n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkbd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = zero -&gt; {m : N &amp; n = succ m} -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkbe"><span class="nb">intros</span> e0 [m es].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>n = zero</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>es</var><span class="hyp-type"><b>: </b><span>n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkbf"><span class="nb">apply</span> zero_neq_succ <span class="kr">with</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>n = zero</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>es</var><span class="hyp-type"><b>: </b><span>n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = succ m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">path_via n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc0"><span class="kn">Definition</span> <span class="nf">N_zero_or_succ</span>@{} (n : N)
    : (n = zero) + { m : N &amp; n = succ m }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n = zero) + {m : N &amp; n = succ m}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n = zero) + {m : N &amp; n = succ m}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc2"><span class="nb">apply</span> (functor_sum (path_N _ _)
                       (functor_sigma (Q := <span class="kr">fun</span> <span class="nv">m</span>:N =&gt; n = succ m) idmap (<span class="kr">fun</span> <span class="nv">m</span> =&gt; path_N _ (succ m)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n.<span class="mi">1</span> = zero.<span class="mi">1</span>) + {m : N &amp; n.<span class="mi">1</span> = (succ m).<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc3"><span class="nb">destruct</span> n <span class="kr">as</span> [n nrec]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n = graph_zero) + {m : N &amp; n = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc4">srefine (resize_nrec n nrec
             (<span class="kr">fun</span> <span class="nv">n</span> =&gt; (n = graph_zero) +
                    {m : N &amp; n = graph_succ m.<span class="mi">1</span>}) _ _ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(graph_zero = graph_zero) +
{m : N &amp; graph_zero = graph_succ m.<span class="mi">1</span>}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chkc5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><label class="goal-separator" for="nat-v-chkc5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
(A = graph_zero) + {m : N &amp; A = graph_succ m.<span class="mi">1</span>} -&gt;
(graph_succ A = graph_zero) +
{m : N &amp; graph_succ A = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(graph_zero = graph_zero) +
{m : N &amp; graph_zero = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> inl; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
(A = graph_zero) + {m : N &amp; A = graph_succ m.<span class="mi">1</span>} -&gt;
(graph_succ A = graph_zero) +
{m : N &amp; graph_succ A = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkc8"><span class="nb">intros</span> A [A0|[m <span class="kn">As</span>]]; <span class="nb">apply</span> inr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A0</var><span class="hyp-type"><b>: </b><span>A = graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; graph_succ A = graph_succ m.<span class="mi">1</span>}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>As</var><span class="hyp-type"><b>: </b><span>A = graph_succ m.<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="nat-v-chkc9"><hr></label><div class="goal-conclusion">{m : N &amp; graph_succ A = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkca">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A0</var><span class="hyp-type"><b>: </b><span>A = graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; graph_succ A = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkcb"><span class="kr">exists</span> <span class="nv">zero</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A0</var><span class="hyp-type"><b>: </b><span>A = graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_succ A = graph_succ zero.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkcc"><span class="nb">rewrite</span> A0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>A0</var><span class="hyp-type"><b>: </b><span>A = graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_succ graph_zero = graph_succ zero.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkcd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>As</var><span class="hyp-type"><b>: </b><span>A = graph_succ m.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; graph_succ A = graph_succ m.<span class="mi">1</span>}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkce"><span class="kr">exists</span> (<span class="nv">succ</span> <span class="nv">m</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>As</var><span class="hyp-type"><b>: </b><span>A = graph_succ m.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_succ A = graph_succ (succ m).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkcf"><span class="nb">rewrite</span> <span class="kn">As</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>As</var><span class="hyp-type"><b>: </b><span>A = graph_succ m.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_succ (graph_succ m.<span class="mi">1</span>) = graph_succ (succ m).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd0"><span class="kn">Definition</span> <span class="nf">pred_in_N</span>@{} (n : Graph) (snrec : in_N@{u} (graph_succ n))
    : in_N@{u} n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd2"><span class="nb">destruct</span> (N_zero_or_succ (graph_succ n ; snrec)) <span class="kr">as</span> [H0|[m Hs]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(graph_succ n; snrec) = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>(graph_succ n; snrec) = succ m</span></span></span><br></div><label class="goal-separator" for="nat-v-chkd3"><hr></label><div class="goal-conclusion">in_N n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(graph_succ n; snrec) = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd5"><span class="nb">apply</span> pr1_path <span class="kr">in</span> H0; <span class="nb">cbn</span> <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>graph_succ n = graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (graph_zero_neq_succ H0^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>(graph_succ n; snrec) = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd7"><span class="nb">apply</span> pr1_path <span class="kr">in</span> Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>(graph_succ n; snrec).<span class="mi">1</span> = (succ m).<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd8"><span class="nb">apply</span> graph_unsucc_path <span class="kr">in</span> Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>n = m.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkd9"><span class="nb">apply</span> (transport@{u p} in_N Hs^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>snrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ n)</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>n = m.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N m.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> m.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Final Peano axiom: induction.  Importantly, the universe of the motive [P] is not constrained but can be arbitrary. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkda"><span class="kn">Definition</span> <span class="nf">N_propind</span>@{P} (P : N -&gt; <span class="kt">Type</span>@{P}) `{<span class="kr">forall</span> <span class="nv">n</span>, IsHProp (P n)}
             (P0 : P zero) (Ps : <span class="kr">forall</span> <span class="nv">n</span>, P n -&gt; P (succ n))
    : <span class="kr">forall</span> <span class="nv">n</span>, P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkdb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkdc"><span class="nb">intros</span> [n nrec].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (n; nrec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkdd"><span class="nb">pose</span> (Q := <span class="kr">fun</span> <span class="nv">m</span>:Graph =&gt; <span class="kr">forall</span> (<span class="nv">mrec</span> : in_N m), P (m;mrec)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>nrec</var><span class="hyp-type"><b>: </b><span>in_N n</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (n; nrec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkde"><span class="nb">refine</span> (resize_nrec n nrec Q _ _ _ nrec); <span class="nb">clear</span> n nrec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q graph_zero</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br></div><label class="goal-separator" for="nat-v-chkdf"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph, Q A -&gt; Q (graph_succ A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q graph_zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke1"><span class="nb">intros</span> zrec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>zrec</var><span class="hyp-type"><b>: </b><span>in_N graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_zero; zrec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke2"><span class="nb">refine</span> (transport P _ P0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>zrec</var><span class="hyp-type"><b>: </b><span>in_N graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero = (graph_zero; zrec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke3"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>zrec</var><span class="hyp-type"><b>: </b><span>in_N graph_zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">P</span> : Graph -&gt; <span class="kt">Type</span>)
   (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A))
   (<span class="nv">P0</span> : P graph_zero)
   (<span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)) =&gt;
 P0) = zrec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph, Q A -&gt; Q (graph_succ A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke5"><span class="nb">intros</span> A QA Asrec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>QA</var><span class="hyp-type"><b>: </b><span>Q A</span></span></span><br><span><var>Asrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_succ A; Asrec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke6"><span class="nb">pose</span> (m := (A ; pred_in_N A Asrec) : N).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>QA</var><span class="hyp-type"><b>: </b><span>Q A</span></span></span><br><span><var>Asrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ A)</span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>(A; pred_in_N A Asrec) : N</span></span><span class="hyp-type"><b>: </b><span>N</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_succ A; Asrec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke7"><span class="nb">refine</span> (transport P _ (Ps m (QA (pred_in_N A Asrec)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>N -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (P n)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : N, P n -&gt; P (succ n)</span></span></span><br><span><var>Q</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">m</span> : Graph =&gt; <span class="kr">forall</span> <span class="nv">mrec</span> : in_N m, P (m; mrec)</span></span><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>QA</var><span class="hyp-type"><b>: </b><span>Q A</span></span></span><br><span><var>Asrec</var><span class="hyp-type"><b>: </b><span>in_N (graph_succ A)</span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>(A; pred_in_N A Asrec) : N</span></span><span class="hyp-type"><b>: </b><span>N</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ m = (graph_succ A; Asrec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_N; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A first application *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke8"><span class="kn">Definition</span> <span class="nf">N_neq_succ</span>@{} (n : N) : n &lt;&gt; succ n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;&gt; succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chke9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;&gt; succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkea"><span class="nb">revert</span> n; <span class="nb">apply</span> N_propind@{p}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (n &lt;&gt; succ n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chkeb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><label class="goal-separator" for="nat-v-chkeb"><hr></label><div class="goal-conclusion">zero &lt;&gt; succ zero</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chkec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><label class="goal-separator" for="nat-v-chkec"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, n &lt;&gt; succ n -&gt; succ n &lt;&gt; succ (succ n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (n &lt;&gt; succ n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n;<span class="bp">exact</span> istrunc_arrow@{p p p}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkee">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero &lt;&gt; succ zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> zero_neq_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, n &lt;&gt; succ n -&gt; succ n &lt;&gt; succ (succ n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf0"><span class="nb">intros</span> n H e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;&gt; succ n</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>succ n = succ (succ n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf1"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;&gt; succ n</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>succ n = succ (succ n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (succ_inj n (succ n) e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we want to use induction to define recursion.  The basic</span>
<span class="sd">  idea is the same as always: define partial attempts and show by</span>
<span class="sd">  induction that they are uniquely defined.  But we have to be careful</span>
<span class="sd">  to phrase it in a way that works without assuming any truncation</span>
<span class="sd">  restrictions on the codomain.</span>

<span class="sd">  First we need inequality on N, which we define in terms of addition.</span>
<span class="sd">  Normally addition is defined *using* recursion, but here we can</span>
<span class="sd">  &quot;cheat&quot; because we know how to add graphs, and then prove that it</span>
<span class="sd">  satisfies the recursive equations for addition. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf2"><span class="kn">Definition</span> <span class="nf">graph_add</span>@{} (A B : Graph) : Graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Graph</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Graph</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf4"><span class="kr">exists</span> (<span class="nv">vert</span> <span class="nv">A</span> + vert B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{E : vert A + vert B -&gt; vert A + vert B -&gt; <span class="kt">Type</span> &amp;
is_mere_relation (vert A + vert B) E}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf5"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">ab</span> <span class="nv">ab&#39;</span> =&gt;
              <span class="kr">match</span> ab, ab&#39; <span class="kr">return</span> <span class="kt">Type</span>@{s} <span class="kr">with</span>
              | inl a, inl a&#39; =&gt; edge A a a&#39;
              | inl a, inr b =&gt; Unit
              | inr b, inl a =&gt; Empty
              | inr b, inr b&#39; =&gt; edge B b b&#39;
              <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert A + vert B,
IsHProp
  <span class="kr">match</span> x <span class="kr">with</span>
  | inl a =&gt;
      <span class="kr">match</span> y <span class="kr">with</span>
      | inl a&#39; =&gt; edge A a a&#39;
      | inr _ =&gt; Unit
      <span class="kr">end</span>
  | inr b =&gt;
      <span class="kr">match</span> y <span class="kr">with</span>
      | inl _ =&gt; Empty
      | inr b&#39; =&gt; edge B b b&#39;
      <span class="kr">end</span>
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [a|b] [a&#39;|b&#39;]; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf6"><span class="kn">Definition</span> <span class="nf">graph_add_zero_r</span>@{} (A : Graph) : graph_add A graph_zero = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add A graph_zero = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add A graph_zero = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf8"><span class="nb">apply</span> equiv_path_graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert (graph_add A graph_zero) &lt;~&gt; vert A &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add A graph_zero),
edge (graph_add A graph_zero) x y &lt;-&gt;
edge A (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkf9"><span class="kr">exists</span> (<span class="nv">sum_empty_r</span> (vert A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add A graph_zero),
edge (graph_add A graph_zero) x y &lt;-&gt;
edge A (sum_empty_r (vert A) x)
  (sum_empty_r (vert A) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkfa"><span class="nb">intros</span> [x|[]] [y|[]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_add A graph_zero) (inl x) (inl y) &lt;-&gt;
edge A (sum_empty_r (vert A) (inl x))
  (sum_empty_r (vert A) (inl y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> iff_reflexive@{u s}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkfb"><span class="kn">Definition</span> <span class="nf">graph_add_zero_l</span>@{} (A : Graph) : graph_add graph_zero A = A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add graph_zero A = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkfc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add graph_zero A = A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkfd"><span class="nb">apply</span> equiv_path_graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert (graph_add graph_zero A) &lt;~&gt; vert A &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add graph_zero A),
edge (graph_add graph_zero A) x y &lt;-&gt;
edge A (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkfe"><span class="kr">exists</span> (<span class="nv">sum_empty_l</span> (vert A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add graph_zero A),
edge (graph_add graph_zero A) x y &lt;-&gt;
edge A (sum_empty_l (vert A) x)
  (sum_empty_l (vert A) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chkff"><span class="nb">intros</span> [[]|x] [[]|y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>vert A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">edge (graph_add graph_zero A) (inr x) (inr y) &lt;-&gt;
edge A (sum_empty_l (vert A) (inr x))
  (sum_empty_l (vert A) (inr y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> iff_reflexive@{u s}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk100"><span class="kn">Definition</span> <span class="nf">graph_add_succ</span>@{} (A B : Graph)
    : graph_add A (graph_succ B) = graph_succ (graph_add A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add A (graph_succ B) =
graph_succ (graph_add A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add A (graph_succ B) =
graph_succ (graph_add A B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk102"><span class="nb">apply</span> equiv_path_graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f
: vert (graph_add A (graph_succ B)) &lt;~&gt;
  vert (graph_succ (graph_add A B)) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add A (graph_succ B)),
edge (graph_add A (graph_succ B)) x y &lt;-&gt;
edge (graph_succ (graph_add A B)) (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk103"><span class="kr">exists</span> (<span class="nv">equiv_inverse</span> (equiv_sum_assoc (vert A) (vert B) Unit)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add A (graph_succ B)),
edge (graph_add A (graph_succ B)) x y &lt;-&gt;
edge (graph_succ (graph_add A B))
  ((equiv_sum_assoc (vert A) (vert B) Unit)^-<span class="mi">1</span>%equiv x)
  ((equiv_sum_assoc (vert A) (vert B) Unit)^-<span class="mi">1</span>%equiv y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [x|[x|[]]] [y|[y|[]]];<span class="nb">apply</span> iff_reflexive@{u s}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk104"><span class="kn">Definition</span> <span class="nf">graph_add_assoc</span>@{} (A B C : Graph)
    : graph_add (graph_add A B) C = graph_add A (graph_add B C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add (graph_add A B) C =
graph_add A (graph_add B C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk105"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add (graph_add A B) C =
graph_add A (graph_add B C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk106"><span class="nb">apply</span> equiv_path_graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f
: vert (graph_add (graph_add A B) C) &lt;~&gt;
  vert (graph_add A (graph_add B C)) &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add (graph_add A B) C),
edge (graph_add (graph_add A B) C) x y &lt;-&gt;
edge (graph_add A (graph_add B C)) (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk107"><span class="kr">exists</span> (<span class="nv">equiv_sum_assoc</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add (graph_add A B) C),
edge (graph_add (graph_add A B) C) x y &lt;-&gt;
edge (graph_add A (graph_add B C))
  (equiv_sum_assoc (vert A) (vert B) (vert C) x)
  (equiv_sum_assoc (vert A) (vert B) (vert C) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [[x|x]|x] [[y|y]|y]; <span class="nb">apply</span> iff_reflexive@{u s}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">graph_one</span>@{} : Graph
    := Build_Graph Unit (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> : Unit =&gt; Unit) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk108"><span class="kn">Definition</span> <span class="nf">graph_add_one_succ</span>@{} (A : Graph)
    : graph_add A graph_one = graph_succ A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add A graph_one = graph_succ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk109"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add A graph_one = graph_succ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk10a"><span class="nb">apply</span> equiv_path_graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f
: vert (graph_add A graph_one) &lt;~&gt; vert (graph_succ A)
&amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add A graph_one),
edge (graph_add A graph_one) x y &lt;-&gt;
edge (graph_succ A) (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk10b"><span class="kr">exists</span> <span class="nv">equiv_idmap</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert (graph_add A graph_one),
edge (graph_add A graph_one) x y &lt;-&gt;
edge (graph_succ A) (<span class="mi">1</span>%equiv x) (<span class="mi">1</span>%equiv y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [x|[]] [y|[]]; <span class="nb">apply</span> iff_reflexive@{u s}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk10c"><span class="kn">Definition</span> <span class="nf">graph_succ_zero</span>@{} : graph_succ graph_zero = graph_one.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_succ graph_zero = graph_one</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk10d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_succ graph_zero = graph_one</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk10e"><span class="nb">rewrite</span> &lt;- graph_add_one_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add graph_zero graph_one = graph_one</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> graph_add_zero_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk10f"><span class="kn">Definition</span> <span class="nf">one</span>@{} : N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk110"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk111"><span class="kr">exists</span> <span class="nv">graph_one</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N graph_one</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk112"><span class="nb">intros</span> P PH P0 Ps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P graph_one</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk113"><span class="nb">rewrite</span> &lt;- graph_succ_zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_succ graph_zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Ps, P0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk114"><span class="kn">Definition</span> <span class="nf">N_add</span>@{} (n m : N) : N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk115"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk116"><span class="kr">exists</span> (<span class="nv">graph_add</span> <span class="nv">n</span>.<span class="mi">1</span> m.<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_N (graph_add n.<span class="mi">1</span> m.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk117"><span class="nb">intros</span> P PH P0 Ps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_add n.<span class="mi">1</span> m.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk118"><span class="nb">apply</span> m.<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P (graph_add n.<span class="mi">1</span> A))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><label class="goal-separator" for="nat-v-chk119"><hr></label><div class="goal-conclusion">P (graph_add n.<span class="mi">1</span> graph_zero)</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><label class="goal-separator" for="nat-v-chk11a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
P (graph_add n.<span class="mi">1</span> A) -&gt;
P (graph_add n.<span class="mi">1</span> (graph_succ A))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P (graph_add n.<span class="mi">1</span> A))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> PH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_add n.<span class="mi">1</span> graph_zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk11d"><span class="nb">apply</span> (transport P (graph_add_zero_r n.<span class="mi">1</span>)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (n.<span class="mi">2</span> P PH P0 Ps).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : Graph,
P (graph_add n.<span class="mi">1</span> A) -&gt;
P (graph_add n.<span class="mi">1</span> (graph_succ A))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk11f"><span class="nb">intros</span> A PA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>PA</var><span class="hyp-type"><b>: </b><span>P (graph_add n.<span class="mi">1</span> A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_add n.<span class="mi">1</span> (graph_succ A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk120"><span class="nb">apply</span> (transport P (graph_add_succ n.<span class="mi">1</span> A)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Graph -&gt; <span class="kt">Type</span></span></span></span><br><span><var>PH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, IsHProp (P A)</span></span></span><br><span><var>P0</var><span class="hyp-type"><b>: </b><span>P graph_zero</span></span></span><br><span><var>Ps</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> : Graph, P A -&gt; P (graph_succ A)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>PA</var><span class="hyp-type"><b>: </b><span>P (graph_add n.<span class="mi">1</span> A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (graph_succ (graph_add n.<span class="mi">1</span> A))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Ps, PA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;n + m&quot;</span> := (N_add n m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk121"><span class="kn">Definition</span> <span class="nf">N_add_zero_l</span>@{} (n : N) : zero + n = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero + n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk122"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero + n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_N, graph_add_zero_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk123"><span class="kn">Definition</span> <span class="nf">N_add_zero_r</span>@{} (n : N) : n + zero = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + zero = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk124"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + zero = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_N, graph_add_zero_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk125"><span class="kn">Definition</span> <span class="nf">N_add_succ</span>@{} (n m : N) : n + succ m = succ (n + m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + succ m = succ (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk126"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + succ m = succ (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_N, graph_add_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk127"><span class="kn">Definition</span> <span class="nf">N_add_assoc</span>@{} (n m k : N) : (n + m) + k = n + (m + k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + m + k = n + (m + k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk128"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + m + k = n + (m + k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_N, graph_add_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk129"><span class="kn">Definition</span> <span class="nf">N_add_cancel_r</span>@{} (n m k : N) (H : n + k = m + k)
    : n = m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n + k = m + k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk12a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n + k = m + k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk12b"><span class="nb">revert</span> k H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : N, n + k = m + k -&gt; n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk12c"><span class="nb">refine</span> (N_propind _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + zero = m + zero -&gt; n = m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk12d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk12d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n0</span> : N,
(n + n0 = m + n0 -&gt; n = m) -&gt;
n + succ n0 = m + succ n0 -&gt; n = m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk12e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + zero = m + zero -&gt; n = m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> H; <span class="nb">rewrite</span> !N_add_zero_r <span class="kr">in</span> H; <span class="bp">exact</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk12f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n0</span> : N,
(n + n0 = m + n0 -&gt; n = m) -&gt;
n + succ n0 = m + succ n0 -&gt; n = m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk130"><span class="nb">intros</span> k H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>n + k = m + k -&gt; n = m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>n + succ k = m + succ k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk131"><span class="nb">rewrite</span> !N_add_succ <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>n + k = m + k -&gt; n = m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>succ (n + k) = succ (m + k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk132"><span class="nb">apply</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>n + k = m + k -&gt; n = m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>succ (n + k) = succ (m + k)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + k = m + k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (succ_inj _ _ H2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk133"><span class="kn">Definition</span> <span class="nf">N_add_cancel_zero_r</span>@{} (n k : N) (H : k + n = n)
    : k = zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + n = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk134"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + n = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk135"><span class="nb">refine</span> (N_add_cancel_r k zero n _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + n = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k + n = zero + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk136"><span class="nb">rewrite</span> H; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + n = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero + n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_N, graph_add_zero_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk137"><span class="kn">Definition</span> <span class="nf">N_add_one_r</span>@{} (n : N) : n + one = succ n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + one = succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk138"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + one = succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk139"><span class="nb">apply</span> path_N; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">graph_add n.<span class="mi">1</span> graph_one = graph_succ n.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> graph_add_one_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk13a"><span class="kn">Definition</span> <span class="nf">N_add_one_l</span>@{} (n : N) : one + n = succ n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one + n = succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one + n = succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk13c"><span class="nb">revert</span> n; <span class="nb">refine</span> (N_propind (<span class="kr">fun</span> <span class="nv">m</span> =&gt; one + m = succ m) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one + zero = succ zero</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><label class="goal-separator" for="nat-v-chk13d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N,
one + n = succ n -&gt; one + succ n = succ (succ n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk13e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one + zero = succ zero</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk13f"><span class="nb">rewrite</span> N_add_zero_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one = succ zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk140"><span class="nb">apply</span> path_N.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one.<span class="mi">1</span> = (succ zero).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> graph_succ_zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk141">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N,
one + n = succ n -&gt; one + succ n = succ (succ n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk142"><span class="nb">intros</span> n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>one + n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">one + succ n = succ (succ n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk143"><span class="nb">rewrite</span> N_add_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>one + n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ (one + n) = succ (succ n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk144"><span class="kn">Definition</span> <span class="nf">N_add_succ_l</span>@{} (n m : N) : succ n + m = succ (n + m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ n + m = succ (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk145"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ n + m = succ (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk146"><span class="nb">rewrite</span> &lt;- (N_add_one_r n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + one + m = succ (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk147"><span class="nb">rewrite</span> N_add_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + (one + m) = succ (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk148"><span class="nb">rewrite</span> N_add_one_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + succ m = succ (n + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> N_add_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we define inequality in terms of addition. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">N_le</span>@{} (n m : N) : <span class="kt">Type</span>@{p}
    := { k : N &amp; k + n = m }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;n &lt;= m&quot;</span> := (N_le n m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk149"><span class="kn">Local Instance</span> <span class="nf">ishprop_N_le</span>@{} n m : IsHProp (n &lt;= m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n &lt;= m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk14a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n &lt;= m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk14b"><span class="nb">apply</span> ishprop_sigma_disjoint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : N, x + n = m -&gt; y + n = m -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk14c"><span class="nb">intros</span> x y e1 e2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>x + n = m</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>y + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk14d"><span class="nb">apply</span> N_add_cancel_r <span class="kr">with</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>x + n = m</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>y + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + n = y + n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">path_via m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk14e"><span class="kn">Definition</span> <span class="nf">N_zero_le</span>@{} (n : N) : zero &lt;= n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk14f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk150"><span class="kr">exists</span> <span class="nv">n</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + zero = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> N_add_zero_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk151"><span class="kn">Definition</span> <span class="nf">N_le_zero</span>@{} (n : N) (H : n &lt;= zero) : n = zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk152"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk153"><span class="nb">destruct</span> H <span class="kr">as</span> [k H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + n = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk154"><span class="nb">apply</span> pr1_path <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(k + n).<span class="mi">1</span> = zero.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk155"><span class="nb">apply</span> ((equiv_path_graph _ _)^-<span class="mi">1</span>), pr1 <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>vert (k + n).<span class="mi">1</span> &lt;~&gt; vert zero.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk156"><span class="nb">pose proof</span> ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; H (inr x)) : (vert n.<span class="mi">1</span>) -&gt; Empty) <span class="kr">as</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>vert (k + n).<span class="mi">1</span> &lt;~&gt; vert zero.<span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert n.<span class="mi">1</span> -&gt; Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk157"><span class="nb">apply</span> path_N, equiv_path_graph.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>vert (k + n).<span class="mi">1</span> &lt;~&gt; vert zero.<span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert n.<span class="mi">1</span> -&gt; Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : vert n.<span class="mi">1</span> &lt;~&gt; vert zero.<span class="mi">1</span> &amp;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert n.<span class="mi">1</span>,
edge n.<span class="mi">1</span> x y &lt;-&gt; edge zero.<span class="mi">1</span> (f x) (f y)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk158">srefine ((Build_Equiv _ _ f _);_); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>vert (k + n).<span class="mi">1</span> &lt;~&gt; vert zero.<span class="mi">1</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>vert n.<span class="mi">1</span> -&gt; Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : vert n.<span class="mi">1</span>,
edge n.<span class="mi">1</span> x y &lt;-&gt; Empty_rec (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y; <span class="nb">destruct</span> (f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk159"><span class="kn">Instance</span> <span class="nf">contr_le_zero</span>@{} : Contr {n:N &amp; n &lt;= zero}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {n : N &amp; n &lt;= zero}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk15a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {n : N &amp; n &lt;= zero}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk15b"><span class="nb">apply</span> (Build_Contr _ (exist (<span class="kr">fun</span> <span class="nv">n</span> =&gt; n &lt;= zero) zero (N_zero_le zero))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : {n : N &amp; n &lt;= zero},
(zero; N_zero_le zero) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk15c"><span class="nb">intros</span> [n H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(zero; N_zero_le zero) = (n; H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk15d"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(zero; N_zero_le zero).<span class="mi">1</span> = (n; H).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (N_le_zero n H)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk15e"><span class="kn">Instance</span> <span class="nf">reflexive_N_le</span>@{} : Reflexive N_le.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive N_le</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk15f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Reflexive N_le</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk160"><span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk161"><span class="kr">exists</span> <span class="nv">zero</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero + n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> N_add_zero_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">N_lt</span>@{} (n m : N) : <span class="kt">Type</span>@{p}
    := { k : N &amp; (succ k) + n = m }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;n &lt; m&quot;</span> := (N_lt n m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk162"><span class="kn">Lemma</span> <span class="nf">ishprop_N_lt</span>@{} n m : IsHProp (n &lt; m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n &lt; m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk163"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (n &lt; m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk164"><span class="nb">apply</span> ishprop_sigma_disjoint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : N,
succ x + n = m -&gt; succ y + n = m -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk165"><span class="nb">intros</span> x y e1 e2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>succ x + n = m</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>succ y + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk166"><span class="nb">apply</span> N_add_cancel_r <span class="kr">with</span> (succ n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>succ x + n = m</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>succ y + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + succ n = y + succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk167"><span class="nb">rewrite</span> !N_add_succ, &lt;-!N_add_succ_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, x, y</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>succ x + n = m</span></span></span><br><span><var>e2</var><span class="hyp-type"><b>: </b><span>succ y + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ x + n = succ y + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">path_via m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Existing Instance</span> <span class="nf">ishprop_N_lt</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk168"><span class="kn">Definition</span> <span class="nf">N_lt_zero</span>@{} (n : N) : ~(n &lt; zero).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (n &lt; zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk169"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (n &lt; zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk16a"><span class="nb">unfold</span> N_lt; <span class="nb">intros</span> [k H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk16b"><span class="nb">apply</span> pr1_path, (equiv_path_graph _ _)^-<span class="mi">1</span>, pr1 <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>vert (succ k + n).<span class="mi">1</span> &lt;~&gt; vert zero.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H (inl (inr tt))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk16c"><span class="kn">Definition</span> <span class="nf">N_lt_irref</span>@{} (n : N) : ~(n &lt; n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (n &lt; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk16d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (n &lt; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk16e"><span class="nb">revert</span> n; <span class="nb">apply</span> N_propind@{p}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (~ (n &lt; n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk16f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><label class="goal-separator" for="nat-v-chk16f"><hr></label><div class="goal-conclusion">~ (zero &lt; zero)</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk170" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><label class="goal-separator" for="nat-v-chk170"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, ~ (n &lt; n) -&gt; ~ (succ n &lt; succ n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk171">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (~ (n &lt; n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n;<span class="bp">exact</span> istrunc_arrow@{p p p}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk172">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (zero &lt; zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> N_lt_zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk173">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, ~ (n &lt; n) -&gt; ~ (succ n &lt; succ n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk174"><span class="nb">intros</span> n H [k K].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (n &lt; n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>succ k + succ n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk175"><span class="nb">apply</span> H; <span class="kr">exists</span> <span class="nv">k</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (n &lt; n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>succ k + succ n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk176"><span class="nb">rewrite</span> N_add_succ <span class="kr">in</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (n &lt; n)</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>succ (succ k + n) = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> succ_inj; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk177"><span class="kn">Definition</span> <span class="nf">N_le_eq_or_lt</span>@{} (n m : N) (H : n &lt;= m)
    : (n = m) + (n &lt; m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk178"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk179"><span class="nb">assert</span> (HP : IsHProp ((n = m) + (n &lt; m))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp ((n = m) + (n &lt; m))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk17a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br></div><label class="goal-separator" for="nat-v-chk17a"><hr></label><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk17b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp ((n = m) + (n &lt; m))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk17c"><span class="nb">apply</span> ishprop_sum; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = m -&gt; n &lt; m -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk17d"><span class="nb">intros</span> [] [l K].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>succ l + n = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk17e"><span class="nb">apply</span> N_add_cancel_zero_r <span class="kr">in</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>succ l = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry in</span> K; <span class="nb">apply</span> zero_neq_succ <span class="kr">in</span> K; <span class="bp">assumption</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk17f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk180"><span class="nb">destruct</span> H <span class="kr">as</span> [k K].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>k + n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk181"><span class="nb">destruct</span> (N_zero_or_succ k) <span class="kr">as</span> [k0|[l L]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>k + n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br><span><var>k0</var><span class="hyp-type"><b>: </b><span>k = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk182" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>k + n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>k = succ l</span></span></span><br></div><label class="goal-separator" for="nat-v-chk182"><hr></label><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk183">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>k + n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br><span><var>k0</var><span class="hyp-type"><b>: </b><span>k = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk184"><span class="nb">rewrite</span> k0 <span class="kr">in</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>zero + n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br><span><var>k0</var><span class="hyp-type"><b>: </b><span>k = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk185"><span class="nb">rewrite</span> (N_add_zero_l n) <span class="kr">in</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br><span><var>k0</var><span class="hyp-type"><b>: </b><span>k = zero</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inl K).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk186">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>k + n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>k = succ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk187"><span class="nb">rewrite</span> L <span class="kr">in</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k, l</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>succ l + n = m</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>IsHProp ((n = m) + (n &lt; m))</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>k = succ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((n = m) + (n &lt; m))%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inr (l;K)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk188"><span class="kn">Definition</span> <span class="nf">N_succ_nlt</span>@{} (n : N) : ~(succ n &lt; n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (succ n &lt; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk189"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (succ n &lt; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk18a"><span class="nb">revert</span> n; <span class="nb">apply</span> N_propind@{p}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (~ (succ n &lt; n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk18b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><label class="goal-separator" for="nat-v-chk18b"><hr></label><div class="goal-conclusion">~ (succ zero &lt; zero)</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk18c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><label class="goal-separator" for="nat-v-chk18c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N,
~ (succ n &lt; n) -&gt; ~ (succ (succ n) &lt; succ n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk18d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N, IsHProp (~ (succ n &lt; n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> n;<span class="bp">exact</span> istrunc_arrow@{p p p}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk18e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (succ zero &lt; zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> N_lt_zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk18f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N,
~ (succ n &lt; n) -&gt; ~ (succ (succ n) &lt; succ n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk190"><span class="nb">intros</span> n H L.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>~ (succ n &lt; n)</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>succ (succ n) &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk191"><span class="nb">apply</span> H; <span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>succ (succ n) &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ n &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk192"><span class="nb">destruct</span> L <span class="kr">as</span> [k H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + succ (succ n) = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ n &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk193"><span class="kr">exists</span> <span class="nv">k</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + succ (succ n) = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + succ n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk194"><span class="nb">rewrite</span> N_add_succ <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ (succ k + succ n) = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + succ n = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (succ_inj _ _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk195"><span class="kn">Definition</span> <span class="nf">N_lt_succ</span>@{} (n : N) : n &lt; succ n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk196"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk197"><span class="kr">exists</span> <span class="nv">zero</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ zero + n = succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk198"><span class="nb">rewrite</span> N_add_succ_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ (zero + n) = succ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, N_add_zero_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk199"><span class="kn">Definition</span> <span class="nf">N_succ_lt</span>@{} (n m : N) (H : n &lt; m) : succ n &lt; succ m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ n &lt; succ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk19a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ n &lt; succ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk19b"><span class="nb">destruct</span> H <span class="kr">as</span> [k H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ n &lt; succ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk19c"><span class="kr">exists</span> <span class="nv">k</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + succ n = succ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk19d"><span class="nb">rewrite</span> N_add_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ (succ k + n) = succ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk19e"><span class="kn">Definition</span> <span class="nf">N_lt_le</span>@{} (n m : N) (H : n &lt; m) : n &lt;= m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk19f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a0"><span class="nb">destruct</span> H <span class="kr">as</span> [k K].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>succ k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (succ k; K).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a1"><span class="kn">Definition</span> <span class="nf">N_lt_iff_succ_le</span>@{} (n m : N) :
    (n &lt; m) &lt;-&gt; (succ n &lt;= m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; m &lt;-&gt; succ n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; m &lt;-&gt; succ n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a3"><span class="nb">split</span>; <span class="nb">intros</span> [k H]; <span class="kr">exists</span> <span class="nv">k</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k + succ n = m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1a4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + succ n = m</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1a4"><hr></label><div class="goal-conclusion">succ k + n = m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k + succ n = m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a6"><span class="nb">rewrite</span> N_add_succ, &lt;- N_add_succ_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + succ n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + n = m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a8"><span class="nb">rewrite</span> N_add_succ_l, &lt;- N_add_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + succ n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k + succ n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1a9"><span class="kn">Definition</span> <span class="nf">N_lt_succ_iff_le</span>@{} (n m : N) : (n &lt; succ m) &lt;-&gt; (n &lt;= m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; succ m &lt;-&gt; n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1aa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; succ m &lt;-&gt; n &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ab"><span class="nb">split</span>; <span class="nb">intros</span> [k H]; <span class="kr">exists</span> <span class="nv">k</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k + n = m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1ac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + n = m</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1ac"><hr></label><div class="goal-conclusion">succ k + n = succ m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ k + n = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k + n = m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ae"><span class="nb">rewrite</span> N_add_succ_l <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ (k + n) = succ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k + n = m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (succ_inj _ _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1af">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n, m, k</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>k + n = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ k + n = succ m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> N_add_succ_l; <span class="nb">apply</span> ap, H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1b0"><span class="kn">Definition</span> <span class="nf">equiv_N_segment</span>@{} (n : N)
    : { m : N &amp; m &lt;= n } &lt;~&gt; (sum@{p p} {m : N &amp; m &lt; n} Unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n} &lt;~&gt; {m : N &amp; m &lt; n} + Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1b1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n} &lt;~&gt; {m : N &amp; m &lt; n} + Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1b2">srefine (equiv_adjointify _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n} -&gt; {m : N &amp; m &lt; n} + Unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1b3"><hr></label><div class="goal-conclusion">{m : N &amp; m &lt; n} + Unit -&gt; {m : N &amp; m &lt;= n}</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk1b4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1b4"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1b5"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1b6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n} -&gt; {m : N &amp; m &lt; n} + Unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1b7"><span class="nb">intros</span> mH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mH</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt; n} + Unit)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1b8"><span class="nb">destruct</span> (N_le_eq_or_lt mH.<span class="mi">1</span> n mH.<span class="mi">2</span>) <span class="kr">as</span> [H0|Hs].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mH</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>mH.<span class="mi">1</span> = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt; n} + Unit)%type</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1b9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mH</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>mH.<span class="mi">1</span> &lt; n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1b9"><hr></label><div class="goal-conclusion">({m : N &amp; m &lt; n} + Unit)%type</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ba">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mH</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>mH.<span class="mi">1</span> = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt; n} + Unit)%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inr tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1bb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mH</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>mH.<span class="mi">1</span> &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt; n} + Unit)%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inl (mH.<span class="mi">1</span>;Hs)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1bc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt; n} + Unit -&gt; {m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1bd"><span class="nb">intros</span> [mH|?].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mH</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1be"><hr></label><div class="goal-conclusion">{m : N &amp; m &lt;= n}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1bf">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mH</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (mH.<span class="mi">1</span>; N_lt_le mH.<span class="mi">1</span> n mH.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c0">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> <span class="nv">n</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">mH</span> : {m : N &amp; m &lt;= n} =&gt;
 <span class="kr">let</span> <span class="nv">s</span> := N_le_eq_or_lt mH.<span class="mi">1</span> n mH.<span class="mi">2</span> <span class="kr">in</span>
 <span class="kr">match</span> s <span class="kr">with</span>
 | inl p =&gt; (<span class="kr">fun</span> <span class="nv">_</span> : mH.<span class="mi">1</span> = n =&gt; inr tt) p
 | inr n0 =&gt; (<span class="kr">fun</span> <span class="nv">Hs</span> : mH.<span class="mi">1</span> &lt; n =&gt; inl (mH.<span class="mi">1</span>; Hs)) n0
 <span class="kr">end</span>)
o (<span class="kr">fun</span> <span class="nv">X</span> : {m : N &amp; m &lt; n} + Unit =&gt;
   <span class="kr">match</span> X <span class="kr">with</span>
   | inl s =&gt;
       (<span class="kr">fun</span> <span class="nv">mH</span> : {m : N &amp; m &lt; n} =&gt;
        (mH.<span class="mi">1</span>; N_lt_le mH.<span class="mi">1</span> n mH.<span class="mi">2</span>)) s
   | inr u =&gt; unit_name (n; reflexive_N_le n) u
   <span class="kr">end</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="nb">intros</span> [[m H]|[]]; <span class="nb">cbn</span>;
      [ <span class="nb">generalize</span> (N_le_eq_or_lt m n (N_lt_le m n H));
        <span class="nb">intros</span> [H0|Hs]; <span class="nb">cbn</span>;
        [ <span class="nb">apply</span> Empty_rec;
          <span class="nb">rewrite</span> H0 <span class="kr">in</span> H; <span class="bp">exact</span> (N_lt_irref n H)
        | <span class="nb">apply</span> ap, ap, path_ishprop ]
      | <span class="nb">generalize</span> (N_le_eq_or_lt n n (reflexive_N_le n));
        <span class="nb">intros</span> [H0|Hs];
        [ <span class="bp">reflexivity</span>
        | <span class="nb">apply</span> Empty_rec;
          <span class="bp">exact</span> (N_lt_irref n Hs) ]]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">X</span> : {m : N &amp; m &lt; n} + Unit =&gt;
 <span class="kr">match</span> X <span class="kr">with</span>
 | inl s =&gt;
     (<span class="kr">fun</span> <span class="nv">mH</span> : {m : N &amp; m &lt; n} =&gt;
      (mH.<span class="mi">1</span>; N_lt_le mH.<span class="mi">1</span> n mH.<span class="mi">2</span>)) s
 | inr u =&gt; unit_name (n; reflexive_N_le n) u
 <span class="kr">end</span>)
o (<span class="kr">fun</span> <span class="nv">mH</span> : {m : N &amp; m &lt;= n} =&gt;
   <span class="kr">let</span> <span class="nv">s</span> := N_le_eq_or_lt mH.<span class="mi">1</span> n mH.<span class="mi">2</span> <span class="kr">in</span>
   <span class="kr">match</span> s <span class="kr">with</span>
   | inl p =&gt; (<span class="kr">fun</span> <span class="nv">_</span> : mH.<span class="mi">1</span> = n =&gt; inr tt) p
   | inr n0 =&gt;
       (<span class="kr">fun</span> <span class="nv">Hs</span> : mH.<span class="mi">1</span> &lt; n =&gt; inl (mH.<span class="mi">1</span>; Hs)) n0
   <span class="kr">end</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="nb">intros</span> [m H]; <span class="nb">cbn</span>;
      <span class="nb">generalize</span> (N_le_eq_or_lt m n H);
      <span class="nb">intros</span> [H0|Hs]; <span class="nb">cbn</span>;
      [ <span class="nb">apply</span> path_sigma_hprop;
        <span class="nb">symmetry</span>; <span class="bp">assumption</span>
      | <span class="nb">apply</span> ap, path_ishprop ]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c3"><span class="kn">Definition</span> <span class="nf">equiv_N_segment_succ</span>@{} (n : N)
    : { m : N &amp; m &lt;= succ n } &lt;~&gt; @sum@{p p} {m : N &amp; m &lt;= n} Unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= succ n} &lt;~&gt; {m : N &amp; m &lt;= n} + Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= succ n} &lt;~&gt; {m : N &amp; m &lt;= n} + Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c5"><span class="nb">refine</span> (_ oE equiv_N_segment (succ n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt; succ n} + Unit &lt;~&gt;
{m : N &amp; m &lt;= n} + Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c6"><span class="nb">apply</span> equiv_functor_sum_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt; succ n} &lt;~&gt; {m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c7"><span class="nb">apply</span> equiv_functor_sigma_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : N, a &lt; succ n &lt;~&gt; a &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> m; <span class="nb">apply</span> equiv_iff_hprop_uncurried, N_lt_succ_iff_le.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A fancy name for [1] so that we can [rewrite] with it later. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c8"><span class="kn">Definition</span> <span class="nf">equiv_N_segment_succ_inv_inl</span>@{} (n : N) (mh : {m:N &amp; m &lt;= n})
    : ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl mh)).<span class="mi">1</span> = mh.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl mh)).<span class="mi">1</span> = mh.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1c9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl mh)).<span class="mi">1</span> = mh.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ca"><span class="kn">Definition</span> <span class="nf">equiv_N_segment_lt_succ</span>@{} (n : N)
    : { m : N &amp; m &lt; succ n } &lt;~&gt; {m : N &amp; m &lt;= n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt; succ n} &lt;~&gt; {m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1cb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt; succ n} &lt;~&gt; {m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1cc"><span class="nb">apply</span> equiv_functor_sigma_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : N, a &lt; succ n &lt;~&gt; a &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> equiv_iff_hprop; <span class="nb">apply</span> N_lt_succ_iff_le.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">zero_seg</span>@{} (n : N) : { m : N &amp; m &lt;= n }
    := (zero ; N_zero_le n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">succ_seg</span>@{} (n : N)
    : { m : N &amp; m &lt; n } -&gt; { m : N &amp; m &lt;= n }
    := <span class="kr">fun</span> <span class="nv">mh</span> =&gt;
         <span class="kr">let</span> (<span class="nv">m</span>,H) := mh <span class="kr">in</span>
         (succ m; fst (N_lt_iff_succ_le m n) H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1cd"><span class="kn">Definition</span> <span class="nf">refl_seg</span>@{} (n : N) : {m : N &amp; m &lt;= n}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= n}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1cf"><span class="kr">exists</span> <span class="nv">n</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we&#39;re finally ready to prove recursion. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">NRec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Here is the type we will recurse into.  Importantly, it doesn&#39;t have to be a set! *)</span>
    <span class="sd">(** [nr] is the universe of [partial_Nrec], morally [max(p,x)]. Note that it shouldn&#39;t be [large], see constraints on [contr_partial_Nrec_zero]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">Universes x nr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{x}) (<span class="nv">x0</span> : X) (<span class="nv">xs</span> : X -&gt; X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The type of partially defined recursive functions &quot;up to [n]&quot;. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">partial_Nrec</span>@{} (n : N) : <span class="kt">Type</span>@{nr}
      := sig@{nr nr}
            (<span class="kr">fun</span> <span class="nv">f</span> : ({ m : N &amp; m &lt;= n} -&gt; X) =&gt;
               prod@{x nr} (f (zero_seg n) = x0)
                   (<span class="kr">forall</span> (<span class="nv">mh</span> : {m:N &amp; m &lt; n}),
                       f (succ_seg n mh) = xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The crucial point that makes it work for arbitrary [X] is to</span>
<span class="sd">    prove in one big induction that these types are always</span>
<span class="sd">    contractible.  Here is the base case. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d0"><span class="kn">Lemma</span> <span class="nf">contr_partial_Nrec_zero</span>@{} : Contr (partial_Nrec zero).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (partial_Nrec zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (partial_Nrec zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d2"><span class="nb">unfold</span> partial_Nrec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
  (f (zero_seg zero) = x0) *
  (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
   f (succ_seg zero mh) =
   xs (f ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d3">srefine (istrunc_equiv_istrunc {f0 : {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
    (f (zero_seg zero) = x0)} &amp;
    (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
     f0.<span class="mi">1</span> (succ_seg zero mh) =
     xs (f0.<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))} _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>{f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
f (zero_seg zero) = x0}</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; zero}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (equiv_N_segment zero)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1d4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1d4"><hr></label><div class="goal-conclusion">{f0
: {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
  f (zero_seg zero) = x0} &amp;
<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
f0.<span class="mi">1</span> (succ_seg zero mh) =
xs (f0.<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))} &lt;~&gt;
{f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
(f (zero_seg zero) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
 f (succ_seg zero mh) =
 xs (f ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))}</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk1d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1d5"><hr></label><div class="goal-conclusion">Contr
  {f0
  : {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
    f (zero_seg zero) = x0} &amp;
  <span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
  f0.<span class="mi">1</span> (succ_seg zero mh) =
  xs (f0.<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>{f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
f (zero_seg zero) = x0}</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; zero}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (equiv_N_segment zero)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f0
: {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
  f (zero_seg zero) = x0} &amp;
<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
f0.<span class="mi">1</span> (succ_seg zero mh) =
xs (f0.<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))} &lt;~&gt;
{f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
(f (zero_seg zero) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
 f (succ_seg zero mh) =
 xs (f ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d8"><span class="nb">refine</span> (_ oE equiv_inverse (equiv_sigma_assoc _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : {m : N &amp; m &lt;= zero} -&gt; X &amp;
{p : a (zero_seg zero) = x0 &amp;
<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
(a; p).<span class="mi">1</span> (succ_seg zero mh) =
xs ((a; p).<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))}} &lt;~&gt;
{f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
(f (zero_seg zero) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
 f (succ_seg zero mh) =
 xs (f ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1d9"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f (zero_seg zero) = x0 &amp;
<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
(f; p).<span class="mi">1</span> (succ_seg zero mh) =
xs ((f; p).<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))} &lt;~&gt;
(f (zero_seg zero) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
 f (succ_seg zero mh) =
 xs (f ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="nb">apply</span> equiv_sigma_prod0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {f0
  : {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
    f (zero_seg zero) = x0} &amp;
  <span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
  f0.<span class="mi">1</span> (succ_seg zero mh) =
  xs (f0.<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1db"><span class="nb">refine</span> (@istrunc_sigma@{nr nr nr} _ _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
  f (zero_seg zero) = x0}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1dc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1dc"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
    f (zero_seg zero) = x0},
Contr
  (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
   a.<span class="mi">1</span> (succ_seg zero mh) =
   xs (a.<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1dd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
  f (zero_seg zero) = x0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1de">srefine (Build_Contr _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
f (zero_seg zero) = x0}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1df" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1df"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
    f (zero_seg zero) = x0}, <span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e0">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
f (zero_seg zero) = x0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">_</span> =&gt; x0); <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e1">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
    f (zero_seg zero) = x0},
(<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0; <span class="mi">1</span>) = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e2"><span class="nb">intros</span> [g H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0; <span class="mi">1</span>) = (g; H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e3">srefine (path_sigma _ _ _ _ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) = g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1e4"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= zero} -&gt; X =&gt;
   f (zero_seg zero) = x0) <span class="nl">?Goal0</span> <span class="mi">1</span> = H</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) = g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e6"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x0 = g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H^ @ ap g (path_ishprop _ _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= zero} -&gt; X =&gt;
   f (zero_seg zero) = x0)
  (path_forall (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) g
     ((<span class="kr">fun</span> <span class="nv">m</span> : {m : N &amp; m &lt;= zero} =&gt;
       H^ @ ap g (path_ishprop (zero_seg zero) m))
      :
      (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) == g)) <span class="mi">1</span> = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e8">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= zero} -&gt; X =&gt;
   f (zero_seg zero) = x0)
  (path_forall (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) g
     ((<span class="kr">fun</span> <span class="nv">m</span> : {m : N &amp; m &lt;= zero} =&gt;
       H^ @ ap g (path_ishprop (zero_seg zero) m))
      :
      (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) == g)) <span class="mi">1</span> = H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1e9"><span class="nb">rewrite</span> transport_paths_Fl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (<span class="kr">fun</span> <span class="nv">x</span> : {m : N &amp; m &lt;= zero} -&gt; X =&gt;
    x (zero_seg zero))
   (path_forall (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) g
      (<span class="kr">fun</span> <span class="nv">m</span> : {m : N &amp; m &lt;= zero} =&gt;
       H^ @ ap g (path_ishprop (zero_seg zero) m))))^ @
<span class="mi">1</span> = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ea"><span class="nb">rewrite</span> ap_apply_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap10
   (path_forall (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= zero} =&gt; x0) g
      (<span class="kr">fun</span> <span class="nv">m</span> : {m : N &amp; m &lt;= zero} =&gt;
       H^ @ ap g (path_ishprop (zero_seg zero) m)))
   (zero_seg zero))^ @ <span class="mi">1</span> = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1eb"><span class="nb">rewrite</span> ap10_path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(H^ @
 ap g (path_ishprop (zero_seg zero) (zero_seg zero)))^ @
<span class="mi">1</span> = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ec"><span class="nb">rewrite</span> inv_pp, inv_V, concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap g (path_ishprop (zero_seg zero) (zero_seg zero)))^ @
H = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ed"><span class="nb">transitivity</span> ((ap g <span class="mi">1</span>)^ @ H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap g (path_ishprop (zero_seg zero) (zero_seg zero)))^ @
H = (ap g <span class="mi">1</span>)^ @ H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1ee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1ee"><hr></label><div class="goal-conclusion">(ap g <span class="mi">1</span>)^ @ H = H</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap g (path_ishprop (zero_seg zero) (zero_seg zero)))^ @
H = (ap g <span class="mi">1</span>)^ @ H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f0"><span class="nb">apply</span> whiskerR, ap, ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_ishprop (zero_seg zero) (zero_seg zero) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>g (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap g <span class="mi">1</span>)^ @ H = H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : {f : {m : N &amp; m &lt;= zero} -&gt; X &amp;
    f (zero_seg zero) = x0},
Contr
  (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
   a.<span class="mi">1</span> (succ_seg zero mh) =
   xs (a.<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f3"><span class="nb">intros</span> [f H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
   (f; H).<span class="mi">1</span> (succ_seg zero mh) =
   xs ((f; H).<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f4"><span class="nb">apply</span> (Build_Contr _ (<span class="kr">fun</span> <span class="nv">mh</span> =&gt; Empty_rec (N_lt_zero mh.<span class="mi">1</span> mh.<span class="mi">2</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f (zero_seg zero) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : <span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
    (f; H).<span class="mi">1</span> (succ_seg zero mh) =
    xs ((f; H).<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh))),
(<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero} =&gt;
 Empty_rec (N_lt_zero mh.<span class="mi">1</span> mh.<span class="mi">2</span>)) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f5"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f (zero_seg zero) = x0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
(f; H).<span class="mi">1</span> (succ_seg zero mh) =
xs ((f; H).<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero} =&gt;
 Empty_rec (N_lt_zero mh.<span class="mi">1</span> mh.<span class="mi">2</span>)) = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f6"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= zero} -&gt; X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f (zero_seg zero) = x0</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; zero},
(f; H).<span class="mi">1</span> (succ_seg zero mh) =
xs ((f; H).<span class="mi">1</span> ((equiv_N_segment zero)^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; zero}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty_rec (N_lt_zero m.<span class="mi">1</span> m.<span class="mi">2</span>) = g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (N_lt_zero m.<span class="mi">1</span> m.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Existing Instance</span> <span class="nf">contr_partial_Nrec_zero</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f7"><span class="kn">Local Definition</span> <span class="nf">equiv_N_segment_succ_maps</span>@{} (n : N)
      : Equiv@{nr nr} (prod@{nr x} ({ m : N &amp; m &lt;= n} -&gt; X) X) ({ m : N &amp; m &lt;= succ n} -&gt; X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt;= n} -&gt; X) * X &lt;~&gt;
({m : N &amp; m &lt;= succ n} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt;= n} -&gt; X) * X &lt;~&gt;
({m : N &amp; m &lt;= succ n} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1f9"><span class="nb">refine</span> (_ oE @equiv_sum_ind@{x nr nr nr nr p p p}
                _ {m:N&amp;m&lt;=n} Unit (<span class="kr">fun</span> <span class="nv">_</span> =&gt; X) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt;= n} + Unit -&gt; X) &lt;~&gt;
({m : N &amp; m &lt;= succ n} -&gt; X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk1fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk1fa"><hr></label><div class="goal-conclusion">({m : N &amp; m &lt;= n} -&gt; X) * X &lt;~&gt;
({m : N &amp; m &lt;= n} -&gt; X) * (Unit -&gt; X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1fb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt;= n} + Unit -&gt; X) &lt;~&gt;
({m : N &amp; m &lt;= succ n} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1fc"><span class="nb">apply</span> equiv_precompose&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : N &amp; m &lt;= succ n} &lt;~&gt; {m : N &amp; m &lt;= n} + Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_N_segment_succ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1fd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt;= n} -&gt; X) * X &lt;~&gt;
({m : N &amp; m &lt;= n} -&gt; X) * (Unit -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1fe"><span class="nb">apply</span> equiv_functor_prod_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X &lt;~&gt; (Unit -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_unit_rec@{x nr}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk1ff"><span class="kn">Local Definition</span> <span class="nf">equiv_seg_succ</span>@{} (n m : N) (H : m &lt; succ n)
               (f : { m : N &amp; m &lt;= n} -&gt; X) (xsn : X)
      : equiv_N_segment_succ_maps n (f,xsn) (m ; N_lt_le m _ H) = f (exist (<span class="kr">fun</span> <span class="nv">m</span>=&gt;m&lt;=n) m (fst (N_lt_succ_iff_le m _) H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (m; N_lt_le m (succ n) H) =
f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk200"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (m; N_lt_le m (succ n) H) =
f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk201"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span>
       N_le_eq_or_lt m (succ n) (N_lt_le m (succ n) H)
     <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (m; n0)
     <span class="kr">end</span>) = f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk202"><span class="nb">generalize</span> (N_le_eq_or_lt m (succ n) (N_lt_le m (succ n) H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : (m = succ n) + (m &lt; succ n),
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span> s <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (m; n0)
     <span class="kr">end</span>) = f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk203"><span class="nb">intros</span> [E|L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>m = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt)) =
f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk204" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk204"><hr></label><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (m; L))) =
f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk205">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>m = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt)) =
f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk206"><span class="nb">apply</span> Empty_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>m = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk207"><span class="nb">rewrite</span> E <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ n &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>m = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (N_lt_irref _ H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk208">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (m; L))) =
f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk209"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (functor_sigma idmap
     (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)) (m; L)) =
f (m; fst (N_lt_succ_iff_le m n) H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** And here, essentially, is the inductive step. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk20a"><span class="kn">Local Definition</span> <span class="nf">partial_Nrec_succ0</span> (<span class="nv">n</span> : N)
      : partial_Nrec n &lt;~&gt; partial_Nrec (succ n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec n &lt;~&gt; partial_Nrec (succ n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk20b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec n &lt;~&gt; partial_Nrec (succ n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk20c"><span class="nb">unfold</span> partial_Nrec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : {m : N &amp; m &lt;= n} -&gt; X &amp;
(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))} &lt;~&gt;
{f : {m : N &amp; m &lt;= succ n} -&gt; X &amp;
(f (zero_seg (succ n)) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
 f (succ_seg (succ n) mh) =
 xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk20d">srefine (equiv_functor_sigma&#39; (equiv_N_segment_succ_maps n) _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt;= n} -&gt; X) * X -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk20e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk20e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ({m : N &amp; m &lt;= n} -&gt; X) * X,
<span class="nl">?P</span> a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= succ n} -&gt; X =&gt;
 (f (zero_seg (succ n)) = x0) *
 (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
  f (succ_seg (succ n) mh) =
  xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))))
  (equiv_N_segment_succ_maps n a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="nat-v-chk20f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk20f"><hr></label><div class="goal-conclusion">{f : {m : N &amp; m &lt;= n} -&gt; X &amp;
(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))} &lt;~&gt;
{x : _ &amp; <span class="nl">?P</span> x}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk210">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({m : N &amp; m &lt;= n} -&gt; X) * X -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk211"><span class="nb">intros</span> [f xsn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">srefine ((f (zero_seg n) = x0) *
           ((<span class="kr">forall</span> (<span class="nv">mh</span> : {m:N &amp; m &lt; n}),
             f (succ_seg n mh) = xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
           (xsn = xs (f (refl_seg n))))).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk212">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ({m : N &amp; m &lt;= n} -&gt; X) * X,
(<span class="kr">fun</span> <span class="nv">X0</span> : ({m : N &amp; m &lt;= n} -&gt; X) * X =&gt;
 (<span class="kr">fun</span> (<span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X) (<span class="nv">xsn</span> : X) =&gt;
  (f (zero_seg n) = x0) *
  ((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
    f (succ_seg n mh) =
    xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
   (xsn = xs (f (refl_seg n))))) (fst X0) (snd X0)) a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= succ n} -&gt; X =&gt;
 (f (zero_seg (succ n)) = x0) *
 (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
  f (succ_seg (succ n) mh) =
  xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))))
  (equiv_N_segment_succ_maps n a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk213" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk213"><hr></label><div class="goal-conclusion">{f : {m : N &amp; m &lt;= n} -&gt; X &amp;
(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))} &lt;~&gt;
{X0 : ({m : N &amp; m &lt;= n} -&gt; X) * X &amp;
(<span class="kr">fun</span> (<span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X) (<span class="nv">xsn</span> : X) =&gt;
 (f (zero_seg n) = x0) *
 ((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
   f (succ_seg n mh) =
   xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
  (xsn = xs (f (refl_seg n))))) (fst X0) (snd X0)}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk214">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ({m : N &amp; m &lt;= n} -&gt; X) * X,
(<span class="kr">fun</span> <span class="nv">X0</span> : ({m : N &amp; m &lt;= n} -&gt; X) * X =&gt;
 (<span class="kr">fun</span> (<span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X) (<span class="nv">xsn</span> : X) =&gt;
  (f (zero_seg n) = x0) *
  ((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
    f (succ_seg n mh) =
    xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
   (xsn = xs (f (refl_seg n))))) (fst X0) (snd X0)) a &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= succ n} -&gt; X =&gt;
 (f (zero_seg (succ n)) = x0) *
 (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
  f (succ_seg (succ n) mh) =
  xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))))
  (equiv_N_segment_succ_maps n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk215"><span class="nb">intros</span> [f xsn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (zero_seg n) = x0) *
((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
  f (succ_seg n mh) =
  xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
 (xsn = xs (f (refl_seg n)))) &lt;~&gt;
(equiv_N_segment_succ_maps n (f, xsn)
   (zero_seg (succ n)) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n) mh) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk216"><span class="nb">apply</span> equiv_functor_prod&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (zero_seg n) = x0 &lt;~&gt;
equiv_N_segment_succ_maps n (f, xsn)
  (zero_seg (succ n)) = x0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk217" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="nat-v-chk217"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(xsn = xs (f (refl_seg n))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n) mh) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk218">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (zero_seg n) = x0 &lt;~&gt;
equiv_N_segment_succ_maps n (f, xsn)
  (zero_seg (succ n)) = x0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk219"><span class="nb">apply</span> equiv_concat_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (zero_seg (succ n)) = f (zero_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk21a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span>
       N_le_eq_or_lt zero (succ n)
         (N_zero_le (succ n))
     <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (zero; n0)
     <span class="kr">end</span>) = f (zero_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk21b"><span class="nb">generalize</span> (N_le_eq_or_lt zero (succ n) (N_zero_le (succ n))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : (zero = succ n) + (zero &lt; succ n),
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span> s <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (zero; n0)
     <span class="kr">end</span>) = f (zero_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk21c"><span class="nb">intros</span> [H0|Hs].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt)) = f (zero_seg n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk21d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>zero &lt; succ n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk21d"><hr></label><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (zero; Hs))) = f (zero_seg n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk21e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>zero = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt)) = f (zero_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (zero_neq_succ n (H0)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk21f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>zero &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (zero; Hs))) = f (zero_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk220"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>zero &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (functor_sigma idmap
     (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n))
     (zero; Hs)) = f (zero_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk221"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>zero &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_sigma idmap
  (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)) (zero; Hs) =
zero_seg n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk222">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(xsn = xs (f (refl_seg n))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n) mh) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk223">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(xsn = xs (f (refl_seg n))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n) mh) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk224">srefine ((equiv_functor_forall_pb
                     (equiv_N_segment_lt_succ n)^-<span class="mi">1</span>)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(xsn = xs (f (refl_seg n))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">b</span> : {m : N &amp; m &lt;= n},
 (<span class="kr">fun</span> <span class="nv">a</span> : {m : N &amp; m &lt; succ n} =&gt;
  equiv_N_segment_succ_maps n (f, xsn)
    (succ_seg (succ n) a) =
  xs
    (equiv_N_segment_succ_maps n (f, xsn)
       ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl a))))
   ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk225">srefine ((equiv_functor_forall_pb (equiv_N_segment n)^-<span class="mi">1</span>)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(xsn = xs (f (refl_seg n))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">b</span> : {m : N &amp; m &lt; n} + Unit,
 (<span class="kr">fun</span> <span class="nv">a</span> : {m : N &amp; m &lt;= n} =&gt;
  (<span class="kr">fun</span> <span class="nv">a0</span> : {m : N &amp; m &lt; succ n} =&gt;
   equiv_N_segment_succ_maps n (f, xsn)
     (succ_seg (succ n) a0) =
   xs
     (equiv_N_segment_succ_maps n (f, xsn)
        ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl a0))))
    ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv a))
   ((equiv_N_segment n)^-<span class="mi">1</span>%equiv b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk226">srefine (equiv_sum_ind _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(xsn = xs (f (refl_seg n))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : {m : N &amp; m &lt; n},
 (<span class="kr">fun</span> <span class="nv">s</span> : {m : N &amp; m &lt; n} + Unit =&gt;
  (<span class="kr">fun</span> <span class="nv">a0</span> : {m : N &amp; m &lt;= n} =&gt;
   (<span class="kr">fun</span> <span class="nv">a1</span> : {m : N &amp; m &lt; succ n} =&gt;
    equiv_N_segment_succ_maps n (f, xsn)
      (succ_seg (succ n) a1) =
    xs
      (equiv_N_segment_succ_maps n (f, xsn)
         ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl a1))))
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv a0))
    ((equiv_N_segment n)^-<span class="mi">1</span>%equiv s)) (inl a)) *
(<span class="kr">forall</span> <span class="nv">b</span> : Unit,
 (<span class="kr">fun</span> <span class="nv">s</span> : {m : N &amp; m &lt; n} + Unit =&gt;
  (<span class="kr">fun</span> <span class="nv">a</span> : {m : N &amp; m &lt;= n} =&gt;
   (<span class="kr">fun</span> <span class="nv">a0</span> : {m : N &amp; m &lt; succ n} =&gt;
    equiv_N_segment_succ_maps n (f, xsn)
      (succ_seg (succ n) a0) =
    xs
      (equiv_N_segment_succ_maps n (f, xsn)
         ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl a0))))
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv a))
    ((equiv_N_segment n)^-<span class="mi">1</span>%equiv s)) (inr b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk227"><span class="nb">apply</span> equiv_functor_prod&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : {m : N &amp; m &lt; n},
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n)
      ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
         ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl a)))) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span>
         (inl
            ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
               ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl a)))))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk228" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="nat-v-chk228"><hr></label><div class="goal-conclusion">xsn = xs (f (refl_seg n)) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">b</span> : Unit,
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n)
      ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
         ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inr b)))) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span>
         (inl
            ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
               ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inr b)))))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk229">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : {m : N &amp; m &lt; n},
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n)
      ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
         ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl a)))) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span>
         (inl
            ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
               ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl a)))))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk22a"><span class="nb">apply</span> equiv_functor_forall_id; <span class="nb">intros</span> [m H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (succ_seg n (m; H)) =
xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl (m; H)))) &lt;~&gt;
equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H))))) =
xs
  (equiv_N_segment_succ_maps n (f, xsn)
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
              ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
                 (inl (m; H)))))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk22b"><span class="nb">apply</span> equiv_concat_lr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H))))) =
f (succ_seg n (m; H))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk22c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk22c"><hr></label><div class="goal-conclusion">xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl (m; H)))) =
xs
  (equiv_N_segment_succ_maps n (f, xsn)
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
              ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
                 (inl (m; H)))))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk22d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H))))) =
f (succ_seg n (m; H))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk22e"><span class="nb">transitivity</span> ((equiv_N_segment_succ_maps n)
                              (f,xsn)
                              (succ m; N_lt_le _ _ (N_succ_lt m n H))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H))))) =
equiv_N_segment_succ_maps n (f, xsn)
  (succ m;
  N_lt_le (succ m) (succ n) (N_succ_lt m n H))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk22f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk22f"><hr></label><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ m;
  N_lt_le (succ m) (succ n) (N_succ_lt m n H)) =
f (succ_seg n (m; H))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk230">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H))))) =
equiv_N_segment_succ_maps n (f, xsn)
  (succ m;
  N_lt_le (succ m) (succ n) (N_succ_lt m n H))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk231"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">succ_seg (succ n)
  ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
     ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H)))) =
(succ m; N_lt_le (succ m) (succ n) (N_succ_lt m n H))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk232"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(succ_seg (succ n)
   ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
      ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H))))).<span class="mi">1</span> =
(succ m; N_lt_le (succ m) (succ n) (N_succ_lt m n H)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk233">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ m;
  N_lt_le (succ m) (succ n) (N_succ_lt m n H)) =
f (succ_seg n (m; H))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk234"><span class="nb">rewrite</span> equiv_seg_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (succ m;
  fst (N_lt_succ_iff_le (succ m) n) (N_succ_lt m n H)) =
f (succ_seg n (m; H))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk235">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl (m; H)))) =
xs
  (equiv_N_segment_succ_maps n (f, xsn)
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
              ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
                 (inl (m; H)))))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk236"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((equiv_N_segment n)^-<span class="mi">1</span> (inl (m; H))) =
equiv_N_segment_succ_maps n (f, xsn)
  ((equiv_N_segment (succ n))^-<span class="mi">1</span>
     (inl
        ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
           ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inl (m; H))))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk237"><span class="nb">cbv</span> [equiv_fun equiv_inv equiv_isequiv equiv_inverse equiv_adjointify isequiv_adjointify equiv_compose&#39; equiv_compose equiv_precompose&#39; equiv_functor_sigma_id equiv_N_segment_succ equiv_sum_ind equiv_functor_prod_l equiv_functor_sum_r equiv_functor_sigma&#39; equiv_functor_sum equiv_functor_sum&#39; equiv_functor_sigma equiv_functor_prod equiv_functor_prod&#39; equiv_idmap isequiv_idmap equiv_unit_rec isequiv_functor_sigma equiv_iff_hprop equiv_iff_hprop_uncurried eisretr inverse transport succ_seg equiv_N_segment_succ_maps equiv_N_segment_lt_succ equiv_N_segment];
                <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (m; N_lt_le m n H) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span>
       N_le_eq_or_lt m (succ n)
         (N_lt_le m (succ n)
            (snd (N_lt_succ_iff_le m n)
               (N_lt_le m n H)))
     <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (m; n0)
     <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk238"><span class="kr">match goal with</span>
              | [ |- <span class="kp">context</span>[<span class="kr">match</span> <span class="nl">?L</span> <span class="kr">with</span> | inl _ =&gt; inr tt | inr Hs =&gt; inl (<span class="nl">?k</span>; Hs) <span class="kr">end</span>] ] =&gt; <span class="nb">generalize</span> L
              <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : (m = succ n) + (m &lt; succ n),
f (m; N_lt_le m n H) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span> s <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (m; n0)
     <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk239"><span class="nb">intros</span> [L|L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (m; N_lt_le m n H) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk23a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk23a"><hr></label><div class="goal-conclusion">f (m; N_lt_le m n H) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (m; L)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk23b">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (m; N_lt_le m n H) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk23c"><span class="nb">apply</span> Empty_rec; <span class="nb">rewrite</span> L <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>succ n &lt; n</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (N_succ_nlt n H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk23d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (m; N_lt_le m n H) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (m; L)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk23e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>m &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (m; N_lt_le m n H) =
f
  (functor_sigma idmap
     (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)) (m; L))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk23f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsn = xs (f (refl_seg n)) &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">b</span> : Unit,
 equiv_N_segment_succ_maps n (f, xsn)
   (succ_seg (succ n)
      ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
         ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inr b)))) =
 xs
   (equiv_N_segment_succ_maps n (f, xsn)
      ((equiv_N_segment (succ n))^-<span class="mi">1</span>
         (inl
            ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
               ((equiv_N_segment n)^-<span class="mi">1</span>%equiv (inr b)))))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk240"><span class="nb">refine</span> ((equiv_contr_forall _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xsn = xs (f (refl_seg n)) &lt;~&gt;
equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
           (inr (center Unit))))) =
xs
  (equiv_N_segment_succ_maps n (f, xsn)
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
              ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
                 (inr (center Unit)))))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk241"><span class="nb">apply</span> equiv_concat_lr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
           (inr (center Unit))))) = xsn</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk242" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="nat-v-chk242"><hr></label><div class="goal-conclusion">xs (f (refl_seg n)) =
xs
  (equiv_N_segment_succ_maps n (f, xsn)
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
              ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
                 (inr (center Unit)))))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk243">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_N_segment_succ_maps n (f, xsn)
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
        ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
           (inr (center Unit))))) = xsn</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk244"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span>
       N_le_eq_or_lt (succ n) (succ n)
         (fst (N_lt_iff_succ_le n (succ n))
            (snd (N_lt_succ_iff_le n n)
               (reflexive_N_le n)))
     <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (succ n; n0)
     <span class="kr">end</span>) = xsn</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk245"><span class="kr">match goal with</span>
              | [ |- <span class="kp">context</span>[<span class="kr">match</span> <span class="nl">?L</span> <span class="kr">with</span> | inl _ =&gt; inr tt | inr Hs =&gt; inl (<span class="nl">?k</span>; Hs) <span class="kr">end</span>] ] =&gt; <span class="nb">generalize</span> L
              <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : (succ n = succ n) + (succ n &lt; succ n),
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span> s <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (succ n; n0)
     <span class="kr">end</span>) = xsn</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk246"><span class="nb">intros</span> [L|L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>succ n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt)) = xsn</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk247" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>succ n &lt; succ n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk247"><hr></label><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (succ n; L))) = xsn</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk248">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>succ n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt)) = xsn</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk249">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>succ n &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (succ n; L))) = xsn</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">case</span> (N_lt_irref _ L).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk24a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk24a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs (f (refl_seg n)) =
xs
  (equiv_N_segment_succ_maps n (f, xsn)
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
              ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
                 (inr (center Unit)))))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk24b"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (refl_seg n) =
equiv_N_segment_succ_maps n (f, xsn)
  ((equiv_N_segment (succ n))^-<span class="mi">1</span>
     (inl
        ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>%equiv
           ((equiv_N_segment n)^-<span class="mi">1</span>%equiv
              (inr (center Unit))))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk24c"><span class="nb">cbv</span> [eisretr equiv_adjointify equiv_compose equiv_compose&#39; equiv_fun equiv_functor_prod equiv_functor_prod&#39; equiv_functor_prod_l equiv_functor_sigma equiv_functor_sigma&#39; equiv_functor_sigma_id equiv_functor_sum equiv_functor_sum&#39; equiv_functor_sum_r equiv_idmap equiv_iff_hprop equiv_iff_hprop_uncurried equiv_inv equiv_inverse equiv_isequiv equiv_N_segment equiv_N_segment_lt_succ equiv_N_segment_succ equiv_N_segment_succ_maps equiv_precompose&#39; equiv_sum_ind equiv_unit_rec inverse isequiv_adjointify isequiv_functor_sigma isequiv_idmap transport];
                <span class="nb">cbn</span> [fst snd pr1 pr2 functor_sigma].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (refl_seg n) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span>
       N_le_eq_or_lt n (succ n)
         (N_lt_le n (succ n)
            (snd (N_lt_succ_iff_le n n)
               (reflexive_N_le n)))
     <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (n; n0)
     <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk24d"><span class="kr">match goal with</span>
              | [ |- <span class="kp">context</span>[<span class="kr">match</span> <span class="nl">?L</span> <span class="kr">with</span> | inl _ =&gt; inr tt | inr Hs =&gt; inl (<span class="nl">?k</span>; Hs) <span class="kr">end</span>] ] =&gt; <span class="nb">generalize</span> L
              <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : (n = succ n) + (n &lt; succ n),
f (refl_seg n) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap
     <span class="kr">match</span> s <span class="kr">with</span>
     | inl _ =&gt; inr tt
     | inr n0 =&gt; inl (n; n0)
     <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk24e"><span class="nb">intros</span> [L|L].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (refl_seg n) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk24f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>n &lt; succ n</span></span></span><br></div><label class="goal-separator" for="nat-v-chk24f"><hr></label><div class="goal-conclusion">f (refl_seg n) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (n; L)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk250">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>n = succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (refl_seg n) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inr tt))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">case</span> (N_neq_succ n L).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk251">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>n &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (refl_seg n) =
sum_ind_uncurried
  (<span class="kr">fun</span> <span class="nv">_</span> : {m : N &amp; m &lt;= n} + Unit =&gt; X)
  (functor_prod idmap (Unit_ind (A:=unit_name X))
     (f, xsn))
  (functor_sum
     (functor_sigma idmap
        (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)))
     idmap (inl (n; L)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk252"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>n &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (refl_seg n) =
f
  (functor_sigma idmap
     (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)) (n; L))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk253"><span class="nb">apply</span> ap, path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>xsn</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>n &lt; succ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(refl_seg n).<span class="mi">1</span> =
(functor_sigma idmap
   (<span class="kr">fun</span> <span class="nv">a</span> : N =&gt; fst (N_lt_succ_iff_le a n)) (n; L)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk254">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : {m : N &amp; m &lt;= n} -&gt; X &amp;
(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))} &lt;~&gt;
{X0 : ({m : N &amp; m &lt;= n} -&gt; X) * X &amp;
(<span class="kr">fun</span> (<span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X) (<span class="nv">xsn</span> : X) =&gt;
 (f (zero_seg n) = x0) *
 ((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
   f (succ_seg n mh) =
   xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
  (xsn = xs (f (refl_seg n))))) (fst X0) (snd X0)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk255">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : {m : N &amp; m &lt;= n} -&gt; X &amp;
(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))} &lt;~&gt;
{X0 : ({m : N &amp; m &lt;= n} -&gt; X) * X &amp;
(<span class="kr">fun</span> (<span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X) (<span class="nv">xsn</span> : X) =&gt;
 (f (zero_seg n) = x0) *
 ((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
   f (succ_seg n mh) =
   xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
  (xsn = xs (f (refl_seg n))))) (fst X0) (snd X0)}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk256"><span class="nb">refine</span> (equiv_sigma_prod _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : {m : N &amp; m &lt;= n} -&gt; X &amp;
(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))} &lt;~&gt;
{a : {m : N &amp; m &lt;= n} -&gt; X &amp;
{b : X &amp;
(a (zero_seg n) = x0) *
((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
  a (succ_seg n mh) =
  xs (a ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
 (b = xs (a (refl_seg n))))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk257"><span class="nb">apply</span> equiv_functor_sigma_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {m : N &amp; m &lt;= n} -&gt; X,
(a (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 a (succ_seg n mh) =
 xs (a ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
{b : X &amp;
(a (zero_seg n) = x0) *
((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
  a (succ_seg n mh) =
  xs (a ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
 (b = xs (a (refl_seg n))))}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk258"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
{b : X &amp;
(f (zero_seg n) = x0) *
((<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
  f (succ_seg n mh) =
  xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
 (b = xs (f (refl_seg n))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk259"><span class="nb">refine</span> (equiv_functor_sigma_id (<span class="kr">fun</span> <span class="nv">b</span>:X =&gt; equiv_sigma_prod0 _ _) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
{b : X &amp;
{_ : f (zero_seg n) = x0 &amp;
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(b = xs (f (refl_seg n)))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk25a"><span class="nb">refine</span> (equiv_sigma_symm _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (zero_seg n) = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
{_ : f (zero_seg n) = x0 &amp;
{b : X &amp;
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(b = xs (f (refl_seg n)))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk25b"><span class="nb">refine</span> (_ oE (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{_ : f (zero_seg n) = x0 &amp;
<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
f (succ_seg n mh) =
xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))} &lt;~&gt;
{_ : f (zero_seg n) = x0 &amp;
{b : X &amp;
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(b = xs (f (refl_seg n)))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk25c"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> f0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg n) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
{b : X &amp;
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) *
(b = xs (f (refl_seg n)))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk25d"><span class="nb">refine</span> (equiv_functor_sigma_id (<span class="kr">fun</span> <span class="nv">b</span>:X =&gt; equiv_sigma_prod0 _ _) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg n) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
{b : X &amp;
{_
: <span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
  f (succ_seg n mh) =
  xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))) &amp;
b = xs (f (refl_seg n))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk25e"><span class="nb">refine</span> (equiv_sigma_symm _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg n) = x0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f (succ_seg n mh) =
 xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) &lt;~&gt;
{_
: <span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
  f (succ_seg n mh) =
  xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))) &amp;
{b : X &amp; b = xs (f (refl_seg n))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((equiv_sigma_contr _)^-<span class="mi">1</span>%equiv).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">partial_Nrec_succ</span>@{}
      := <span class="kn">Eval</span> <span class="nb">unfold</span> partial_Nrec_succ0
        <span class="kr">in</span> partial_Nrec_succ0@{nr nr}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk25f"><span class="kn">Local Instance</span> <span class="nf">contr_partial_Nrec</span>@{} (n : N) : Contr (partial_Nrec n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (partial_Nrec n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk260"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (partial_Nrec n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk261"><span class="nb">revert</span> n; <span class="nb">apply</span> N_propind; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : N,
Contr (partial_Nrec n) -&gt;
Contr (partial_Nrec (succ n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk262"><span class="nb">intros</span> n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Contr (partial_Nrec n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (partial_Nrec (succ n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (istrunc_equiv_istrunc _ (partial_Nrec_succ n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** This will be useful later. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk263"><span class="kn">Local Definition</span> <span class="nf">partial_Nrec_restr</span>@{} (n : N)
      : partial_Nrec (succ n) -&gt; partial_Nrec n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec (succ n) -&gt; partial_Nrec n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk264"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec (succ n) -&gt; partial_Nrec n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk265"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>partial_Nrec (succ n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk266"><span class="nb">destruct</span> f <span class="kr">as</span> [f [f0 fs]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk267"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">mh</span> =&gt; f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl mh))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (zero_seg n))) =
 x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (succ_seg n mh))) =
 xs
   (f
      ((equiv_N_segment_succ n)^-<span class="mi">1</span>
         (inl ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk268"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (zero_seg n))) =
x0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk269" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><label class="goal-separator" for="nat-v-chk269"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (succ_seg n mh))) =
xs
  (f
     ((equiv_N_segment_succ n)^-<span class="mi">1</span>
        (inl ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk26a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (zero_seg n))) =
x0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk26b"><span class="nb">refine</span> (_ @ f0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (zero_seg n))) =
f (zero_seg (succ n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk26c"><span class="nb">apply</span> ap, path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (zero_seg n))).<span class="mi">1</span> =
(zero_seg (succ n)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk26d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (succ_seg n mh))) =
xs
  (f
     ((equiv_N_segment_succ n)^-<span class="mi">1</span>
        (inl ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk26e"><span class="nb">intros</span> mh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (succ_seg n mh))) =
xs
  (f
     ((equiv_N_segment_succ n)^-<span class="mi">1</span>
        (inl ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk26f"><span class="nb">refine</span> (_ @ fs (((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>)
                          ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (succ_seg n mh))) =
f
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>
        ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk270" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><label class="goal-separator" for="nat-v-chk270"><hr></label><div class="goal-conclusion">xs
  (f
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>
              ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))) =
xs
  (f
     ((equiv_N_segment_succ n)^-<span class="mi">1</span>
        (inl ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk271">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ((equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (succ_seg n mh))) =
f
  (succ_seg (succ n)
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>
        ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk272"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (succ_seg n mh)) =
succ_seg (succ n)
  ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>
     ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk273">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs
  (f
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl
           ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>
              ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))) =
xs
  (f
     ((equiv_N_segment_succ n)^-<span class="mi">1</span>
        (inl ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk274"><span class="nb">apply</span> ap, ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= succ n} -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f (zero_seg (succ n)) = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n},
f (succ_seg (succ n) mh) =
xs (f ((equiv_N_segment (succ n))^-<span class="mi">1</span> (inl mh)))</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_N_segment (succ n))^-<span class="mi">1</span>
  (inl
     ((equiv_N_segment_lt_succ n)^-<span class="mi">1</span>
        ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))) =
(equiv_N_segment_succ n)^-<span class="mi">1</span>
  (inl ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Finally, we want to put all this together to show that the</span>
<span class="sd">    type of fully defined recursive functions is contractible, so that</span>
<span class="sd">    N has the universal property of a natural numbers object.  If we</span>
<span class="sd">    attack it directly, this can lead to quite annoying path algebra.</span>
<span class="sd">    Instead, we will show that it is a retract of the product of all</span>
<span class="sd">    the types of partial attempts, which is contractible since each of</span>
<span class="sd">    them is.  *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">partials</span>@{} := <span class="kr">forall</span> <span class="nv">n</span>, partial_Nrec n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Instance</span> <span class="nf">contr_partials</span>@{} : Contr partials := istrunc_forall@{p nr nr}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** From a family of partial attempts, we get a totally defined</span>
<span class="sd">    recursive function. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Partials</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">pf</span> : partials).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">N_rec&#39;</span>@{} : N -&gt; X
        := <span class="kr">fun</span> <span class="nv">n</span> =&gt; (pf n).<span class="mi">1</span> (refl_seg n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk275"><span class="kn">Definition</span> <span class="nf">N_rec_beta_zero&#39;</span>@{} : N_rec&#39; zero = x0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N_rec&#39; zero = x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk276"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N_rec&#39; zero = x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk277"><span class="nb">refine</span> (_ @ fst (pf zero).<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N_rec&#39; zero = (pf zero).<span class="mi">1</span> (zero_seg zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk278"><span class="nb">unfold</span> N_rec&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pf zero).<span class="mi">1</span> (refl_seg zero) =
(pf zero).<span class="mi">1</span> (zero_seg zero)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk279"><span class="kn">Definition</span> <span class="nf">N_rec_beta_succ&#39;</span>@{} (n : N)
        : N_rec&#39; (succ n) = xs (N_rec&#39; n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N_rec&#39; (succ n) = xs (N_rec&#39; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk27a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">N_rec&#39; (succ n) = xs (N_rec&#39; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk27b"><span class="nb">unfold</span> N_rec&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pf (succ n)).<span class="mi">1</span> (refl_seg (succ n)) =
xs ((pf n).<span class="mi">1</span> (refl_seg n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk27c"><span class="nb">refine</span> (_ @ snd (pf (succ n)).<span class="mi">2</span>
                  (n ; N_lt_succ n) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pf (succ n)).<span class="mi">1</span> (refl_seg (succ n)) =
(pf (succ n)).<span class="mi">1</span> (succ_seg (succ n) (n; N_lt_succ n))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk27d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk27d"><hr></label><div class="goal-conclusion">xs
  ((pf (succ n)).<span class="mi">1</span>
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl (n; N_lt_succ n)))) =
xs ((pf n).<span class="mi">1</span> (refl_seg n))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk27e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pf (succ n)).<span class="mi">1</span> (refl_seg (succ n)) =
(pf (succ n)).<span class="mi">1</span> (succ_seg (succ n) (n; N_lt_succ n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk27f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs
  ((pf (succ n)).<span class="mi">1</span>
     ((equiv_N_segment (succ n))^-<span class="mi">1</span>
        (inl (n; N_lt_succ n)))) =
xs ((pf n).<span class="mi">1</span> (refl_seg n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk280"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pf (succ n)).<span class="mi">1</span>
  ((equiv_N_segment (succ n))^-<span class="mi">1</span>
     (inl (n; N_lt_succ n))) = (pf n).<span class="mi">1</span> (refl_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk281"><span class="nb">transitivity</span> ((partial_Nrec_restr n (pf (succ n))).<span class="mi">1</span> (refl_seg n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pf (succ n)).<span class="mi">1</span>
  ((equiv_N_segment (succ n))^-<span class="mi">1</span>
     (inl (n; N_lt_succ n))) =
(partial_Nrec_restr n (pf (succ n))).<span class="mi">1</span> (refl_seg n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk282" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk282"><hr></label><div class="goal-conclusion">(partial_Nrec_restr n (pf (succ n))).<span class="mi">1</span> (refl_seg n) =
(pf n).<span class="mi">1</span> (refl_seg n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk283" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk283">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pf (succ n)).<span class="mi">1</span>
  ((equiv_N_segment (succ n))^-<span class="mi">1</span>
     (inl (n; N_lt_succ n))) =
(partial_Nrec_restr n (pf (succ n))).<span class="mi">1</span> (refl_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk284"><span class="nb">refine</span> (ap (pf (succ n)).<span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_N_segment (succ n))^-<span class="mi">1</span> (inl (n; N_lt_succ n)) =
(equiv_N_segment_succ n)^-<span class="mi">1</span> (inl (refl_seg n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_sigma_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk285">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(partial_Nrec_restr n (pf (succ n))).<span class="mi">1</span> (refl_seg n) =
(pf n).<span class="mi">1</span> (refl_seg n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk286"><span class="nb">apply</span> ap10@{p x nr}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(partial_Nrec_restr n (pf (succ n))).<span class="mi">1</span> = (pf n).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Partials</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Applying this to the &quot;canonical&quot; partial attempts, we get &quot;the recursor&quot;. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">N_rec</span>@{} : N -&gt; X := N_rec&#39; (center partials).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">N_rec_beta_zero</span>@{} : N_rec zero = x0
      := N_rec_beta_zero&#39; (center partials).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">N_rec_beta_succ</span>@{} (n : N)
      : N_rec (succ n) = xs (N_rec n)
      := N_rec_beta_succ&#39; (center partials) n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Here is the type of totally defined recursive functions that</span>
<span class="sd">    we want to prove to be contractible. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">NRec</span> : <span class="kt">Type</span>@{nr}
      := sig@{nr nr} (<span class="kr">fun</span> <span class="nv">f</span> : N -&gt; X =&gt;
                        prod@{x nr} (f zero = x0)
                            (<span class="kr">forall</span> <span class="nv">m</span>:N, f (succ m) = xs (f m))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk287"><span class="kn">Local Definition</span> <span class="nf">nrec_partials</span>@{} : NRec -&gt; partials.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NRec -&gt; partials</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk288"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NRec -&gt; partials</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk289"><span class="nb">intros</span> f n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk28a"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">mh</span> =&gt; f.<span class="mi">1</span> mh.<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f.<span class="mi">1</span> (zero_seg n).<span class="mi">1</span> = x0) *
(<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
 f.<span class="mi">1</span> (succ_seg n mh).<span class="mi">1</span> =
 xs (f.<span class="mi">1</span> ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)).<span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk28b"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f.<span class="mi">1</span> (zero_seg n).<span class="mi">1</span> = x0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk28c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><label class="goal-separator" for="nat-v-chk28c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
f.<span class="mi">1</span> (succ_seg n mh).<span class="mi">1</span> =
xs (f.<span class="mi">1</span> ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)).<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk28d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f.<span class="mi">1</span> (zero_seg n).<span class="mi">1</span> = x0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fst f.<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk28e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
f.<span class="mi">1</span> (succ_seg n mh).<span class="mi">1</span> =
xs (f.<span class="mi">1</span> ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk28f"><span class="nb">intros</span> mh.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>mh</var><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt; n}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f.<span class="mi">1</span> (succ_seg n mh).<span class="mi">1</span> =
xs (f.<span class="mi">1</span> ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd f.<span class="mi">2</span> mh.<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** This is a weird lemma.  We could prove it by [path_contr], but</span>
<span class="sd">    we give an explicit proof instead using [path_sigma], so that</span>
<span class="sd">    later on we know what happens when [pr1_path] is applied to it. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk290"><span class="kn">Local Definition</span> <span class="nf">nrec_partials_succ</span>@{} (n : N) (f : NRec)
      : partial_Nrec_restr n (nrec_partials f (succ n)) = nrec_partials f n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec_restr n (nrec_partials f (succ n)) =
nrec_partials f n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk291"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partial_Nrec_restr n (nrec_partials f (succ n)) =
nrec_partials f n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk292"><span class="nb">change</span> (<span class="nl">?x</span> = <span class="nl">?y</span>) <span class="kr">with</span> ((x.<span class="mi">1</span>; x.<span class="mi">2</span>) = (y.<span class="mi">1</span>; y.<span class="mi">2</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((partial_Nrec_restr n (nrec_partials f (succ n))).<span class="mi">1</span>;
(partial_Nrec_restr n (nrec_partials f (succ n))).<span class="mi">2</span>) =
((nrec_partials f n).<span class="mi">1</span>; (nrec_partials f n).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk293">srefine (path_sigma&#39;@{nr nr nr} _ <span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X =&gt;
   (f (zero_seg n) = x0) *
   (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
    f (succ_seg n mh) =
    xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh))))) <span class="mi">1</span>
  (partial_Nrec_restr n (nrec_partials f (succ n))).<span class="mi">2</span> =
(nrec_partials f n).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="nb">rewrite</span> transport_1;
      <span class="nb">apply</span> path_prod;
      [ <span class="nb">cbn</span> [partial_Nrec_restr nrec_partials fst pr2 pr1];
        <span class="nb">rewrite</span> ap_compose;
        <span class="nb">rewrite</span> ap_pr1_path_sigma_hprop;
        <span class="nb">apply</span> concat_1p
      | <span class="nb">cbn</span> [partial_Nrec_restr nrec_partials pr1 pr2 snd];
        <span class="nb">apply</span> path_forall; <span class="nb">intros</span> mh;
        <span class="nb">rewrite</span> ap_compose;
        <span class="nb">rewrite</span> ap_pr1_path_sigma_hprop;
        <span class="nb">rewrite</span> ap_1, concat_1p;
        <span class="nb">refine</span> (_ @ concat_p1 _); <span class="nb">apply</span> whiskerL;
        <span class="nb">refine</span> (_ @ ap_1 _ xs); <span class="nb">apply</span> ap;
        <span class="nb">rewrite</span> ap_compose;
        <span class="nb">rewrite</span> ap_pr1_path_sigma_hprop;
        <span class="bp">reflexivity</span> ]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk294"><span class="kn">Local Definition</span> <span class="nf">partials_nrec</span>@{} : partials -&gt; NRec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partials -&gt; NRec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk295"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partials -&gt; NRec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk296"><span class="nb">intros</span> pf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NRec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk297"><span class="kr">exists</span> (<span class="nv">N_rec&#39;</span> <span class="nv">pf</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>pf</var><span class="hyp-type"><b>: </b><span>partials</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(N_rec&#39; pf zero = x0) *
(<span class="kr">forall</span> <span class="nv">m</span> : N, N_rec&#39; pf (succ m) = xs (N_rec&#39; pf m))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (N_rec_beta_zero&#39; pf, N_rec_beta_succ&#39; pf).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk298"><span class="kn">Local Definition</span> <span class="nf">nrec_partials_sect</span>@{} (f : NRec)
      : partials_nrec (nrec_partials f) = f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partials_nrec (nrec_partials f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk299"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>NRec</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partials_nrec (nrec_partials f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk29a"><span class="nb">destruct</span> f <span class="kr">as</span> [f [f0 fs]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">partials_nrec (nrec_partials (f; (f0, fs))) =
(f; (f0, fs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk29b"><span class="nb">unfold</span> partials_nrec, nrec_partials.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(N_rec&#39;
   (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
    (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; (f; (f0, fs)).<span class="mi">1</span> mh.<span class="mi">1</span>;
    (fst (f; (f0, fs)).<span class="mi">2</span>,
    <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt;
    snd (f; (f0, fs)).<span class="mi">2</span> mh.<span class="mi">1</span>)));
(N_rec_beta_zero&#39;
   (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
    (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; (f; (f0, fs)).<span class="mi">1</span> mh.<span class="mi">1</span>;
    (fst (f; (f0, fs)).<span class="mi">2</span>,
    <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt;
    snd (f; (f0, fs)).<span class="mi">2</span> mh.<span class="mi">1</span>))),
N_rec_beta_succ&#39;
  (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
   (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; (f; (f0, fs)).<span class="mi">1</span> mh.<span class="mi">1</span>;
   (fst (f; (f0, fs)).<span class="mi">2</span>,
   <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt;
   snd (f; (f0, fs)).<span class="mi">2</span> mh.<span class="mi">1</span>))))) = (f; (f0, fs))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk29c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(N_rec&#39;
   (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
    (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
    (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>)));
(N_rec_beta_zero&#39;
   (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
    (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
    (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))),
N_rec_beta_succ&#39;
  (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
   (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
   (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))) =
(f; (f0, fs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk29d"><span class="nb">unfold</span> N_rec&#39;, N_rec_beta_zero&#39;; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> : N =&gt; f n;
(ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
   (path_sigma_hprop (refl_seg zero) (zero_seg zero) <span class="mi">1</span>) @
 f0,
N_rec_beta_succ&#39;
  (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
   (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
   (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))) =
(f; (f0, fs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk29e"><span class="nb">apply</span> ap@{nr nr}, path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop (refl_seg zero) (zero_seg zero)
        <span class="mi">1</span>) @ f0,
  N_rec_beta_succ&#39;
    (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
     (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
     (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>)))) =
fst (f0, fs)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk29f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><label class="goal-separator" for="nat-v-chk29f"><hr></label><div class="goal-conclusion">snd
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop (refl_seg zero) (zero_seg zero)
        <span class="mi">1</span>) @ f0,
  N_rec_beta_succ&#39;
    (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
     (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
     (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>)))) =
snd (f0, fs)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop (refl_seg zero) (zero_seg zero)
        <span class="mi">1</span>) @ f0,
  N_rec_beta_succ&#39;
    (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
     (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
     (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>)))) =
fst (f0, fs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a1"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
  (path_sigma_hprop (refl_seg zero) (zero_seg zero) <span class="mi">1</span>) @
f0 = f0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a2"><span class="nb">rewrite</span> ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : {m : N &amp; m &lt;= zero} =&gt; x.<span class="mi">1</span>)
     (path_sigma_hprop (refl_seg zero) (zero_seg zero)
        <span class="mi">1</span>)) @ f0 = f0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a3"><span class="nb">rewrite</span> ap_pr1_path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f <span class="mi">1</span> @ f0 = f0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop (refl_seg zero) (zero_seg zero)
        <span class="mi">1</span>) @ f0,
  N_rec_beta_succ&#39;
    (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
     (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
     (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>)))) =
snd (f0, fs)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a5"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop (refl_seg zero) (zero_seg zero)
        <span class="mi">1</span>) @ f0,
  N_rec_beta_succ&#39;
    (<span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
     (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
     (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>)))) n =
snd (f0, fs) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a6"><span class="nb">unfold</span> N_rec_beta_succ&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= zero} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop (refl_seg zero) (zero_seg zero)
        <span class="mi">1</span>) @ f0,
  <span class="kr">fun</span> <span class="nv">n</span> : N =&gt;
  (ap
     (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>;
     (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)).<span class="mi">1</span>
     (path_sigma_hprop (refl_seg (succ n))
        (succ_seg (succ n) (n; N_lt_succ n)) <span class="mi">1</span>) @
   snd
     (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>;
     (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)).<span class="mi">2</span>
     (n; N_lt_succ n)) @
  ap xs
    (ap
       (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>;
       (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)).<span class="mi">1</span>
       (path_sigma_hprop
          ((equiv_N_segment (succ n))^-<span class="mi">1</span>
             (inl (n; N_lt_succ n)))
          ((equiv_N_segment_succ n)^-<span class="mi">1</span>
             (inl (refl_seg n))) <span class="mi">1</span>) @
     ap10
       (ap pr1
          (path_contr
             (partial_Nrec_restr n
                (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
                 f mh.<span class="mi">1</span>;
                (f0,
                <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt;
                fs mh.<span class="mi">1</span>)))
             (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
             (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
       (refl_seg n))) n = snd (f0, fs) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a7"><span class="nb">cbn</span> [fst snd pr1 pr2];
          <span class="nb">cbv</span> [equiv_fun equiv_inverse equiv_inv equiv_isequiv equiv_compose&#39; equiv_compose isequiv_compose equiv_functor_sum_r equiv_functor_sigma_id equiv_functor_sigma&#39; equiv_functor_sigma equiv_functor_sum&#39; equiv_functor_sum equiv_adjointify isequiv_adjointify isequiv_functor_sum isequiv_idmap equiv_idmap isequiv_functor_sigma equiv_iff_hprop_uncurried functor_sum functor_sigma equiv_N_segment equiv_N_segment_succ inverse transport eisretr];
          <span class="nb">cbn</span> [fst snd pr1 pr2 refl_seg].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>)
   (path_sigma_hprop (refl_seg (succ n))
      (succ_seg (succ n) (n; N_lt_succ n)) <span class="mi">1</span>) @ fs n) @
ap xs
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop
        (n; N_lt_le n (succ n) (N_lt_succ n))
        (n;
        N_lt_le n (succ n)
          (snd (N_lt_succ_iff_le n n)
             (reflexive_N_le n))) <span class="mi">1</span>) @
   ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = fs n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a8"><span class="nb">rewrite</span> ap_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f
   (ap (<span class="kr">fun</span> <span class="nv">x</span> : {m : N &amp; m &lt;= succ n} =&gt; x.<span class="mi">1</span>)
      (path_sigma_hprop (refl_seg (succ n))
         (succ_seg (succ n) (n; N_lt_succ n)) <span class="mi">1</span>)) @
 fs n) @
ap xs
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop
        (n; N_lt_le n (succ n) (N_lt_succ n))
        (n;
        N_lt_le n (succ n)
          (snd (N_lt_succ_iff_le n n)
             (reflexive_N_le n))) <span class="mi">1</span>) @
   ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = fs n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2a9"><span class="nb">rewrite</span> ap_pr1_path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f <span class="mi">1</span> @ fs n) @
ap xs
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop
        (n; N_lt_le n (succ n) (N_lt_succ n))
        (n;
        N_lt_le n (succ n)
          (snd (N_lt_succ_iff_le n n)
             (reflexive_N_le n))) <span class="mi">1</span>) @
   ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = fs n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2aa"><span class="nb">rewrite</span> ap_1, concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fs n @
ap xs
  (ap (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>)
     (path_sigma_hprop
        (n; N_lt_le n (succ n) (N_lt_succ n))
        (n;
        N_lt_le n (succ n)
          (snd (N_lt_succ_iff_le n n)
             (reflexive_N_le n))) <span class="mi">1</span>) @
   ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = fs n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2ab"><span class="nb">rewrite</span> (ap_compose pr1 f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fs n @
ap xs
  (ap f
     (ap pr1
        (path_sigma_hprop
           (n; N_lt_le n (succ n) (N_lt_succ n))
           (n;
           N_lt_le n (succ n)
             (snd (N_lt_succ_iff_le n n)
                (reflexive_N_le n))) <span class="mi">1</span>)) @
   ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = fs n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2ac"><span class="nb">rewrite</span> ap_pr1_path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fs n @
ap xs
  (ap f <span class="mi">1</span> @
   ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = fs n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2ad"><span class="nb">rewrite</span> ap_1, concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fs n @
ap xs
  (ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = fs n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2ae"><span class="nb">refine</span> (_ @ (concat_p1 _)); <span class="nb">apply</span> whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs
  (ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     (refl_seg n)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2af"><span class="nb">set</span> (refl_seg_n := refl_seg n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs
  (ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     refl_seg_n) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        <span class="sd">(** Here is where we use [nrec_partials_succ]: the [path_contr] equal to it, which allows us to identify [ap pr1] of the latter.  (Note that [ap pr1] of a [path_contr] can be nontrivial even when the endpoints happen to coincide judgmentally, for instance (x;p) and (x;1) in {y:X &amp; y = x}, so there really is something to prove here.) *)</span>
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b0"><span class="nb">transitivity</span> (ap xs (ap10 (ap pr1 (nrec_partials_succ n (f;(f0,fs)))) refl_seg_n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs
  (ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     refl_seg_n) =
ap xs
  (ap10 (ap pr1 (nrec_partials_succ n (f; (f0, fs))))
     refl_seg_n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk2b1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><label class="goal-separator" for="nat-v-chk2b1"><hr></label><div class="goal-conclusion">ap xs
  (ap10 (ap pr1 (nrec_partials_succ n (f; (f0, fs))))
     refl_seg_n) = <span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs
  (ap10
     (ap pr1
        (path_contr
           (partial_Nrec_restr n
              (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt;
               f mh.<span class="mi">1</span>;
              (f0,
              <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
           (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
     refl_seg_n) =
ap xs
  (ap10 (ap pr1 (nrec_partials_succ n (f; (f0, fs))))
     refl_seg_n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b3"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10
  (ap pr1
     (path_contr
        (partial_Nrec_restr n
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>;
           (f0,
           <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
        (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
        (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
  refl_seg_n =
ap10 (ap pr1 (nrec_partials_succ n (f; (f0, fs))))
  refl_seg_n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b4"><span class="nb">assert</span> (p : path_contr _ _ =  nrec_partials_succ n (f; (f0, fs))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_contr
  (partial_Nrec_restr n
     (nrec_partials (f; (f0, fs)) (succ n)))
  (nrec_partials (f; (f0, fs)) n) =
nrec_partials_succ n (f; (f0, fs))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="nat-v-chk2b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>path_contr
  (partial_Nrec_restr n
     (nrec_partials (f; (f0, fs)) (succ n)))
  (nrec_partials (f; (f0, fs)) n) =
nrec_partials_succ n (f; (f0, fs))</span></span></span><br></div><label class="goal-separator" for="nat-v-chk2b5"><hr></label><div class="goal-conclusion">ap10
  (ap pr1
     (path_contr
        (partial_Nrec_restr n
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>;
           (f0,
           <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
        (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
        (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
  refl_seg_n =
ap10 (ap pr1 (nrec_partials_succ n (f; (f0, fs))))
  refl_seg_n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b6" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b6">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_contr
  (partial_Nrec_restr n
     (nrec_partials (f; (f0, fs)) (succ n)))
  (nrec_partials (f; (f0, fs)) n) =
nrec_partials_succ n (f; (f0, fs))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>path_contr
  (partial_Nrec_restr n
     (nrec_partials (f; (f0, fs)) (succ n)))
  (nrec_partials (f; (f0, fs)) n) =
nrec_partials_succ n (f; (f0, fs))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap10
  (ap pr1
     (path_contr
        (partial_Nrec_restr n
           (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= succ n} =&gt; f mh.<span class="mi">1</span>;
           (f0,
           <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; succ n} =&gt; fs mh.<span class="mi">1</span>)))
        (<span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt;= n} =&gt; f mh.<span class="mi">1</span>;
        (f0, <span class="kr">fun</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n} =&gt; fs mh.<span class="mi">1</span>))))
  refl_seg_n =
ap10 (ap pr1 (nrec_partials_succ n (f; (f0, fs))))
  refl_seg_n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">h</span> =&gt; ap10 (ap pr1 h) refl_seg_n) p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs
  (ap10 (ap pr1 (nrec_partials_succ n (f; (f0, fs))))
     refl_seg_n) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2b9"><span class="nb">unfold</span> nrec_partials_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs
  (ap10
     (ap pr1
        (path_sigma&#39;
           (<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X =&gt;
            (f (zero_seg n) = x0) *
            (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
             f (succ_seg n mh) =
             xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))
           <span class="mi">1</span>
           (nrec_partials_succ_subproof n
              (f; (f0, fs))))) refl_seg_n) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2ba"><span class="nb">unfold</span> path_sigma&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs
  (ap10
     (ap pr1
        (path_sigma
           (<span class="kr">fun</span> <span class="nv">f</span> : {m : N &amp; m &lt;= n} -&gt; X =&gt;
            (f (zero_seg n) = x0) *
            (<span class="kr">forall</span> <span class="nv">mh</span> : {m : N &amp; m &lt; n},
             f (succ_seg n mh) =
             xs (f ((equiv_N_segment n)^-<span class="mi">1</span> (inl mh)))))
           ((partial_Nrec_restr n
               (nrec_partials (f; (f0, fs)) (succ n))).<span class="mi">1</span>;
           (partial_Nrec_restr n
              (nrec_partials (f; (f0, fs)) (succ n))).<span class="mi">2</span>)
           ((partial_Nrec_restr n
               (nrec_partials (f; (f0, fs)) (succ n))).<span class="mi">1</span>;
           (nrec_partials (f; (f0, fs)) n).<span class="mi">2</span>) <span class="mi">1</span>
           (nrec_partials_succ_subproof n
              (f; (f0, fs))))) refl_seg_n) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2bb"><span class="nb">rewrite</span> ap_pr1_path_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>N -&gt; X</span></span></span><br><span><var>f0</var><span class="hyp-type"><b>: </b><span>f zero = x0</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : N, f (succ m) = xs (f m)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>N</span></span></span><br><span><var>refl_seg_n</var><span><span class="hyp-body"><b>:= </b><span>refl_seg n</span></span><span class="hyp-type"><b>: </b><span>{m : N &amp; m &lt;= n}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap xs (ap10 <span class="mi">1</span> refl_seg_n) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** And we&#39;re done! *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2bc">#[export] <span class="kn">Instance</span> <span class="nf">contr_NRec</span>@{} : Contr NRec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr NRec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2bd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr NRec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2be"><span class="nb">refine</span> (istrunc_isequiv_istrunc partials partials_nrec).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv partials_nrec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="nat-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="nat-v-chk2bf"><span class="nb">refine</span> (isequiv_adjointify _ nrec_partials nrec_partials_sect _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>UA</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>PR</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>X -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : partials =&gt; nrec_partials (partials_nrec x)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x; <span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">NRec</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AssumeStuff</span>.</span></span></pre>
</div>
</div></body>
</html>
