<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Smash.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.PathGroupoids Basics.Tactics Basics.Equivalences.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Sum Types.Bool Types.Paths Types.Forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.Core WildCat.Bifunctor WildCat.Equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Pushout.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Cubical.DPath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> dpath_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Definition of smash product *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sum_to_prod</span> (<span class="nv">X</span> <span class="nv">Y</span> : pType) : X + Y -&gt; X * Y
  := sum_ind _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x, point Y)) (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (point X, y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sum_to_bool</span> <span class="nv">X</span> <span class="nv">Y</span> : X + Y -&gt; Bool
  := sum_ind _ (<span class="kr">fun</span> <span class="nv">_</span> =&gt; false) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; true).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Smash</span>@{u v w | u &lt;= w, v &lt;= w} (X : pType@{u}) (Y : pType@{v}) : pType@{w}
  := [Pushout@{w w w w} (sum_to_prod@{w w w} X Y) (sum_to_bool@{u v w} X Y), pushl (point X, point Y)].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Smash</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sm</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) : Smash X Y := pushl (x, y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">auxl</span> : Smash X Y := pushr false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">auxr</span> : Smash X Y := pushr true.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">gluel</span> (<span class="nv">x</span> : X) : sm x pt = auxl
    := pglue (f:=sum_to_prod X Y) (g:=sum_to_bool X Y) (inl x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">gluer</span> (<span class="nv">y</span> : Y) : sm pt y = auxr
    := pglue (f:=sum_to_prod X Y) (g:=sum_to_bool X Y) (inr y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">gluel&#39;</span> (<span class="nv">x</span> <span class="nv">x&#39;</span> : X) : sm x pt = sm x&#39; pt
    := gluel x @ (gluel x&#39;)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">gluer&#39;</span> (<span class="nv">y</span> <span class="nv">y&#39;</span> : Y) : sm pt y = sm pt y&#39;
    := gluer y @ (gluer y&#39;)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">glue</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y) : sm x pt = sm pt y
    := gluel&#39; x pt @ gluer&#39; pt y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk1"><span class="kn">Definition</span> <span class="nf">glue_pt_left</span> (<span class="nv">y</span> : Y) : glue pt y = gluer&#39; pt y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue pt y = gluer&#39; pt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue pt y = gluer&#39; pt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk3"><span class="nb">refine</span> (_ @ concat_1p _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue pt y = <span class="mi">1</span> @ gluer&#39; pt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> whiskerR, concat_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk4"><span class="kn">Definition</span> <span class="nf">glue_pt_right</span> (<span class="nv">x</span> : X) : glue x pt = gluel&#39; x pt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue x pt = gluel&#39; x pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue x pt = gluel&#39; x pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk6"><span class="nb">refine</span> (_ @ concat_p1 _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">glue x pt = gluel&#39; x pt @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> whiskerL, concat_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk7"><span class="kn">Definition</span> <span class="nf">ap_sm_left</span> {<span class="nv">x</span> <span class="nv">x&#39;</span> : X} (<span class="nv">p</span> : x = x&#39;)
    : ap (<span class="kr">fun</span> <span class="nv">t</span> =&gt; sm t pt) p = gluel&#39; x x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">t</span> : X =&gt; sm t pt) p = gluel&#39; x x&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">t</span> : X =&gt; sm t pt) p = gluel&#39; x x&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk9"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">t</span> : X =&gt; sm t pt) <span class="mi">1</span> = gluel&#39; x x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">gluel&#39; x x = ap (<span class="kr">fun</span> <span class="nv">t</span> : X =&gt; sm t pt) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkb"><span class="kn">Definition</span> <span class="nf">ap_sm_right</span> {<span class="nv">y</span> <span class="nv">y&#39;</span> : Y} (<span class="nv">p</span> : y = y&#39;)
    : ap (sm pt) p = gluer&#39; y y&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sm pt) p = gluer&#39; y y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y, y'</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>y = y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sm pt) p = gluer&#39; y y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sm pt) <span class="mi">1</span> = gluer&#39; y y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">gluer&#39; y y = ap (sm pt) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_pV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf"><span class="kn">Definition</span> <span class="nf">Smash_ind</span> {<span class="nv">P</span> : Smash X Y -&gt; <span class="kt">Type</span>}
    (<span class="nv">Psm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (sm a b)) (<span class="nv">Pl</span> : P auxl) (<span class="nv">Pr</span> : P auxr)
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, DPath P (gluel a) (Psm a pt) Pl)
    (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, DPath P (gluer b) (Psm pt b) Pr)
    : <span class="kr">forall</span> <span class="nv">x</span> : Smash X Y, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Smash X Y, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Smash X Y, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk11">srapply Pushout_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : X * Y, P (pushl b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><label class="goal-separator" for="smash-v-chk12"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : Bool, P (pushr c)</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><label class="goal-separator" for="smash-v-chk13"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X + Y,
transport P (pglue a) (<span class="nl">?pushb</span> (sum_to_prod X Y a)) =
<span class="nl">?pushc</span> (sum_to_bool X Y a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk14">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : X * Y, P (pushl b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk15"><span class="nb">intros</span> [a b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (pushl (a, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Psm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk16">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : Bool, P (pushr c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Bool_ind _ Pr Pl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk17">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X + Y,
transport P (pglue a)
  ((<span class="kr">fun</span> <span class="nv">b0</span> : X * Y =&gt;
    (<span class="kr">fun</span> (<span class="nv">a0</span> : X) (<span class="nv">b</span> : Y) =&gt; Psm a0 b) (fst b0)
      (snd b0)) (sum_to_prod X Y a)) =
Bool_ind (<span class="kr">fun</span> <span class="nv">b</span> : Bool =&gt; P (pushr b)) Pr Pl
  (sum_to_bool X Y a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk18">srapply sum_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
(<span class="kr">fun</span> <span class="nv">s</span> : X + Y =&gt;
 transport P (pglue s)
   ((<span class="kr">fun</span> <span class="nv">b0</span> : X * Y =&gt;
     (<span class="kr">fun</span> (<span class="nv">a0</span> : X) (<span class="nv">b</span> : Y) =&gt; Psm a0 b) (fst b0)
       (snd b0)) (sum_to_prod X Y s)) =
 Bool_ind (<span class="kr">fun</span> <span class="nv">b</span> : Bool =&gt; P (pushr b)) Pr Pl
   (sum_to_bool X Y s)) (inl a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><label class="goal-separator" for="smash-v-chk19"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y,
(<span class="kr">fun</span> <span class="nv">s</span> : X + Y =&gt;
 transport P (pglue s)
   ((<span class="kr">fun</span> <span class="nv">b0</span> : X * Y =&gt;
     (<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b1</span> : Y) =&gt; Psm a b1) (fst b0)
       (snd b0)) (sum_to_prod X Y s)) =
 Bool_ind (<span class="kr">fun</span> <span class="nv">b0</span> : Bool =&gt; P (pushr b0)) Pr Pl
   (sum_to_bool X Y s)) (inr b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
(<span class="kr">fun</span> <span class="nv">s</span> : X + Y =&gt;
 transport P (pglue s)
   ((<span class="kr">fun</span> <span class="nv">b0</span> : X * Y =&gt;
     (<span class="kr">fun</span> (<span class="nv">a0</span> : X) (<span class="nv">b</span> : Y) =&gt; Psm a0 b) (fst b0)
       (snd b0)) (sum_to_prod X Y s)) =
 Bool_ind (<span class="kr">fun</span> <span class="nv">b</span> : Bool =&gt; P (pushr b)) Pr Pl
   (sum_to_bool X Y s)) (inl a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Pgl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk1b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y,
(<span class="kr">fun</span> <span class="nv">s</span> : X + Y =&gt;
 transport P (pglue s)
   ((<span class="kr">fun</span> <span class="nv">b0</span> : X * Y =&gt;
     (<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b1</span> : Y) =&gt; Psm a b1) (fst b0)
       (snd b0)) (sum_to_prod X Y s)) =
 Bool_ind (<span class="kr">fun</span> <span class="nv">b0</span> : Bool =&gt; P (pushr b0)) Pr Pl
   (sum_to_bool X Y s)) (inr b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Pgr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Smash_ind_beta_gluel</span> {<span class="nv">P</span> : Smash X Y -&gt; <span class="kt">Type</span>}
    {<span class="nv">Psm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (sm a b)} {<span class="nv">Pl</span> : P auxl} {<span class="nv">Pr</span> : P auxr}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, DPath P (gluel a) (Psm a pt) Pl)
    (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, DPath P (gluer b) (Psm pt b) Pr) (<span class="nv">a</span> : X)
    : apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel a) = Pgl a
    := Pushout_ind_beta_pglue P _ _ _ (inl a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Smash_ind_beta_gluer</span> {<span class="nv">P</span> : Smash X Y -&gt; <span class="kt">Type</span>}
    {<span class="nv">Psm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (sm a b)} {<span class="nv">Pl</span> : P auxl} {<span class="nv">Pr</span> : P auxr}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, DPath P (gluel a) (Psm a pt) Pl)
    (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, DPath P (gluer b) (Psm pt b) Pr) (<span class="nv">b</span> : Y)
    : apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer b) = Pgr b
    := Pushout_ind_beta_pglue P _ _ _ (inr b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk1c"><span class="kn">Definition</span> <span class="nf">Smash_ind_beta_gluel&#39;</span> {<span class="nv">P</span> : Smash X Y -&gt; <span class="kt">Type</span>}
    {<span class="nv">Psm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (sm a b)} {<span class="nv">Pl</span> : P auxl} {<span class="nv">Pr</span> : P auxr}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, DPath P (gluel a) (Psm a pt) Pl)
    (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, DPath P (gluer b) (Psm pt b) Pr) (<span class="nv">a</span> <span class="nv">b</span> : X)
    : apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel&#39; a b)
    = (Pgl a) @Dp ((Pgl b)^D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel&#39; a b) =
Pgl a @Dp (Pgl b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel&#39; a b) =
Pgl a @Dp (Pgl b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk1e">lhs napply dp_apD_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel a) @Dp
apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel b)^ =
Pgl a @Dp (Pgl b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk1f"><span class="nb">apply</span> ap011.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel a) = Pgl a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="smash-v-chk20"><hr></label><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel b)^ =
(Pgl b) ^D</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk21"><span class="mi">1</span>: <span class="nb">apply</span> Smash_ind_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel b)^ =
(Pgl b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk22">lhs napply dp_apD_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel b)) ^D =
(Pgl b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk23"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel b) = Pgl b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_ind_beta_gluel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk24"><span class="kn">Definition</span> <span class="nf">Smash_ind_beta_gluer&#39;</span> {<span class="nv">P</span> : Smash X Y -&gt; <span class="kt">Type</span>}
    {<span class="nv">Psm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (sm a b)} {<span class="nv">Pl</span> : P auxl} {<span class="nv">Pr</span> : P auxr}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, DPath P (gluel a) (Psm a pt) Pl)
    (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, DPath P (gluer b) (Psm pt b) Pr) (<span class="nv">a</span> <span class="nv">b</span> : Y)
    : apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer&#39; a b)
    = (Pgr a) @Dp ((Pgr b)^D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer&#39; a b) =
Pgr a @Dp (Pgr b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer&#39; a b) =
Pgr a @Dp (Pgr b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk26">lhs napply dp_apD_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer a) @Dp
apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer b)^ =
Pgr a @Dp (Pgr b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk27"><span class="nb">apply</span> ap011.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer a) = Pgr a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk28"><hr></label><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer b)^ =
(Pgr b) ^D</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk29"><span class="mi">1</span>: <span class="nb">apply</span> Smash_ind_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer b)^ =
(Pgr b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk2a">lhs napply dp_apD_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer b)) ^D =
(Pgr b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk2b"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer b) = Pgr b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_ind_beta_gluer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk2c"><span class="kn">Definition</span> <span class="nf">Smash_ind_beta_glue</span> {<span class="nv">P</span> : Smash X Y -&gt; <span class="kt">Type</span>}
    {<span class="nv">Psm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (sm a b)} {<span class="nv">Pl</span> : P auxl} {<span class="nv">Pr</span> : P auxr}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, DPath P (gluel a) (Psm a pt) Pl)
    (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, DPath P (gluer b) (Psm pt b) Pr) (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y)
    : apD (Smash_ind Psm Pl Pr Pgl Pgr) (glue a b)
    = ((Pgl a) @Dp ((Pgl pt)^D)) @Dp ((Pgr pt) @Dp ((Pgr b)^D)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (glue a b) =
(Pgl a @Dp (Pgl pt) ^D) @Dp (Pgr pt @Dp (Pgr b) ^D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (glue a b) =
(Pgl a @Dp (Pgl pt) ^D) @Dp (Pgr pt @Dp (Pgr b) ^D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk2e">lhs napply dp_apD_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel&#39; a pt) @Dp
apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer&#39; pt b) =
(Pgl a @Dp (Pgl pt) ^D) @Dp (Pgr pt @Dp (Pgr b) ^D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk2f"><span class="nb">apply</span> ap011.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel&#39; a pt) =
Pgl a @Dp (Pgl pt) ^D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk30"><hr></label><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer&#39; pt b) =
Pgr pt @Dp (Pgr b) ^D</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluel&#39; a pt) =
Pgl a @Dp (Pgl pt) ^D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_ind_beta_gluel&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Smash X Y -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y), P (sm a b)</span></span></span><br><span><var>Pl</var><span class="hyp-type"><b>: </b><span>P auxl</span></span></span><br><span><var>Pr</var><span class="hyp-type"><b>: </b><span>P auxr</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, DPath P (gluel a) (Psm a pt) Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, DPath P (gluer b) (Psm pt b) Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_ind Psm Pl Pr Pgl Pgr) (gluer&#39; pt b) =
Pgr pt @Dp (Pgr b) ^D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_ind_beta_gluer&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Smash_rec</span> {<span class="nv">P</span> : <span class="kt">Type</span>} (<span class="nv">Psm</span> : X -&gt; Y -&gt; P) (<span class="nv">Pl</span> <span class="nv">Pr</span> : P)
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, Psm a pt = Pl) (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, Psm pt b = Pr)
    : Smash X Y -&gt; P
    := Smash_ind Psm Pl Pr (<span class="kr">fun</span> <span class="nv">x</span> =&gt; dp_const (Pgl x)) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; dp_const (Pgr x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* Version of smash_rec that forces (Pgl pt) and (Pgr pt) to be idpath *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Smash_rec&#39;</span> {<span class="nv">P</span> : <span class="kt">Type</span>} {<span class="nv">Psm</span> : X -&gt; Y -&gt; P}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, Psm a pt = Psm pt pt) (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, Psm pt b = Psm pt pt)
    (<span class="nv">ql</span> : Pgl pt = <span class="mi">1</span>) (<span class="nv">qr</span> : Pgr pt = <span class="mi">1</span>)
    : Smash X Y -&gt; P
    := Smash_rec Psm (Psm pt pt) (Psm pt pt) Pgl Pgr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk33"><span class="kn">Definition</span> <span class="nf">Smash_rec_beta_gluel</span> {<span class="nv">P</span> : <span class="kt">Type</span>} {<span class="nv">Psm</span> : X -&gt; Y -&gt; P} {<span class="nv">Pl</span> <span class="nv">Pr</span> : P}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, Psm a pt = Pl) (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, Psm pt b = Pr) (<span class="nv">a</span> : X)
    : ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a) = Pgl a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a) = Pgl a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a) = Pgl a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk35">rhs_V napply (eissect dp_const).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a) =
dp_const^-<span class="mi">1</span> (dp_const (Pgl a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk36"><span class="nb">apply</span> moveL_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dp_const (ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a)) =
dp_const (Pgl a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk37">lhs_V napply dp_apD_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a) =
dp_const (Pgl a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply Smash_ind_beta_gluel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk38"><span class="kn">Definition</span> <span class="nf">Smash_rec_beta_gluer</span> {<span class="nv">P</span> : <span class="kt">Type</span>} {<span class="nv">Psm</span> : X -&gt; Y -&gt; P} {<span class="nv">Pl</span> <span class="nv">Pr</span> : P}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, Psm a pt = Pl) (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, Psm pt b = Pr) (<span class="nv">b</span> : Y)
    : ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b) = Pgr b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b) = Pgr b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b) = Pgr b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk3a">rhs_V napply (eissect dp_const).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b) =
dp_const^-<span class="mi">1</span> (dp_const (Pgr b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk3b"><span class="nb">apply</span> moveL_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dp_const (ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b)) =
dp_const (Pgr b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk3c">lhs_V napply dp_apD_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b) =
dp_const (Pgr b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply Smash_ind_beta_gluer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk3d"><span class="kn">Definition</span> <span class="nf">Smash_rec_beta_gluel&#39;</span> {<span class="nv">P</span> : <span class="kt">Type</span>} {<span class="nv">Psm</span> : X -&gt; Y -&gt; P} {<span class="nv">Pl</span> <span class="nv">Pr</span> : P}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, Psm a pt = Pl) (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, Psm pt b = Pr) (<span class="nv">a</span> <span class="nv">b</span> : X)
    : ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel&#39; a b) = Pgl a @ (Pgl b)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel&#39; a b) =
Pgl a @ (Pgl b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel&#39; a b) =
Pgl a @ (Pgl b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk3f">lhs napply ap_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a) @
(ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel b))^ =
Pgl a @ (Pgl b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk40">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel a) = Pgl a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="smash-v-chk41"><hr></label><div class="goal-conclusion">(ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel b))^ =
(Pgl b)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk42"><span class="mi">1</span>: <span class="nb">apply</span> Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel b))^ =
(Pgl b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk43"><span class="nb">apply</span> inverse2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel b) = Pgl b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_rec_beta_gluel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk44"><span class="kn">Definition</span> <span class="nf">Smash_rec_beta_gluer&#39;</span> {<span class="nv">P</span> : <span class="kt">Type</span>} {<span class="nv">Psm</span> : X -&gt; Y -&gt; P} {<span class="nv">Pl</span> <span class="nv">Pr</span> : P}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, Psm a pt = Pl) (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, Psm pt b = Pr) (<span class="nv">a</span> <span class="nv">b</span> : Y)
    : ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer&#39; a b) = Pgr a @ (Pgr b)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer&#39; a b) =
Pgr a @ (Pgr b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk45"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer&#39; a b) =
Pgr a @ (Pgr b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk46">lhs napply ap_pV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer a) @
(ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b))^ =
Pgr a @ (Pgr b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk47">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer a) = Pgr a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk48"><hr></label><div class="goal-conclusion">(ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b))^ =
(Pgr b)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk49"><span class="mi">1</span>: <span class="nb">apply</span> Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b))^ =
(Pgr b)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk4a"><span class="nb">apply</span> inverse2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer b) = Pgr b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_rec_beta_gluer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk4b"><span class="kn">Definition</span> <span class="nf">Smash_rec_beta_glue</span> {<span class="nv">P</span> : <span class="kt">Type</span>} {<span class="nv">Psm</span> : X -&gt; Y -&gt; P} {<span class="nv">Pl</span> <span class="nv">Pr</span> : P}
    (<span class="nv">Pgl</span> : <span class="kr">forall</span> <span class="nv">a</span>, Psm a pt = Pl) (<span class="nv">Pgr</span> : <span class="kr">forall</span> <span class="nv">b</span>, Psm pt b = Pr) (<span class="nv">a</span> : X)
    (<span class="nv">b</span> : Y) : ap (Smash_rec Psm Pl Pr Pgl Pgr) (glue a b)
    = ((Pgl a) @ (Pgl pt)^) @ (Pgr pt @ (Pgr b)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (glue a b) =
(Pgl a @ (Pgl pt)^) @ (Pgr pt @ (Pgr b)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (glue a b) =
(Pgl a @ (Pgl pt)^) @ (Pgr pt @ (Pgr b)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk4d">lhs napply ap_pp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel&#39; a pt) @
ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer&#39; pt b) =
(Pgl a @ (Pgl pt)^) @ (Pgr pt @ (Pgr b)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk4e">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel&#39; a pt) =
Pgl a @ (Pgl pt)^</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk4f"><hr></label><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer&#39; pt b) =
Pgr pt @ (Pgr b)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluel&#39; a pt) =
Pgl a @ (Pgl pt)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_rec_beta_gluel&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Psm</var><span class="hyp-type"><b>: </b><span>X -&gt; Y -&gt; P</span></span></span><br><span><var>Pl, Pr</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>Pgl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : X, Psm a pt = Pl</span></span></span><br><span><var>Pgr</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : Y, Psm pt b = Pr</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec Psm Pl Pr Pgl Pgr) (gluer&#39; pt b) =
Pgr pt @ (Pgr b)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Smash_rec_beta_gluer&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Smash</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> sm : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> auxl : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> gluel : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> gluer : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Miscellaneous lemmas about Smash *)</span>

<span class="sd">(** A version of [Smash_ind] specifically for proving that two functions from a [Smash] are homotopic. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk52"><span class="kn">Definition</span> <span class="nf">Smash_ind_FlFr</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} {<span class="nv">P</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : Smash A B -&gt; P)
  (<span class="nv">Hsm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, f (sm a b) = g (sm a b))
  (<span class="nv">Hl</span> : f auxl = g auxl) (<span class="nv">Hr</span> : f auxr = g auxr)
  (<span class="nv">Hgluel</span> : <span class="kr">forall</span> <span class="nv">a</span>, ap f (gluel a) @ Hl = Hsm a pt @ ap g (gluel a))
  (<span class="nv">Hgluer</span> : <span class="kr">forall</span> <span class="nv">b</span>, ap f (gluer b) @ Hr = Hsm pt b @ ap g (gluer b))
  : f == g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk54">snapply (Smash_ind Hsm Hl Hr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; f x = g x) 
  (gluel a) (Hsm a pt) Hl</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br></div><label class="goal-separator" for="smash-v-chk55"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; f x = g x) 
  (gluer b) (Hsm pt b) Hr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; f x = g x) 
  (gluel a) (Hsm a pt) Hl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk57"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; f x = g x) 
  (gluel a) (Hsm a pt) Hl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk58">transport_paths FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (gluel a) @ Hl = Hsm a pt @ ap g (gluel a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hgluel a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; f x = g x) 
  (gluer b) (Hsm pt b) Hr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk5a"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; f x = g x) 
  (gluer b) (Hsm pt b) Hr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk5b">transport_paths FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), f (sm a b) = g (sm a b)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>f auxl = g auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>f auxr = g auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap f (gluel a) @ Hl =
Hsm a pt @ ap g (gluel a)</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap f (gluer b) @ Hr =
Hsm pt b @ ap g (gluer b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap f (gluer b) @ Hr = Hsm pt b @ ap g (gluer b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hgluer b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version of [Smash_ind]j specifically for proving that the composition of two functions is the identity map. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk5c"><span class="kn">Definition</span> <span class="nf">Smash_ind_FFlr</span> {<span class="nv">A</span> <span class="nv">B</span> : pType} {<span class="nv">P</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : Smash A B -&gt; P) (<span class="nv">g</span> : P -&gt; Smash A B)
  (<span class="nv">Hsm</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, g (f (sm a b)) = sm a b)
  (<span class="nv">Hl</span> : g (f auxl) = auxl) (<span class="nv">Hr</span> : g (f auxr) = auxr)
  (<span class="nv">Hgluel</span> : <span class="kr">forall</span> <span class="nv">a</span>, ap g (ap f (gluel a)) @ Hl = Hsm a pt @ gluel a)
  (<span class="nv">Hgluer</span> : <span class="kr">forall</span> <span class="nv">b</span>, ap g (ap f (gluer b)) @ Hr = Hsm pt b @ gluer b)
  : g o f == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk5d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g o f == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk5e">snapply (Smash_ind Hsm Hl Hr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; (g o f) x = idmap x)
  (gluel a) (Hsm a pt) Hl</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br></div><label class="goal-separator" for="smash-v-chk5f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; (g o f) x = idmap x)
  (gluer b) (Hsm pt b) Hr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; (g o f) x = idmap x)
  (gluel a) (Hsm a pt) Hl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk61"><span class="nb">intros</span> a; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; g (f x) = x) 
  (gluel a) (Hsm a pt) Hl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk62">transport_paths FFlr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (gluel a)) @ Hl = Hsm a pt @ gluel a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hgluel a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; (g o f) x = idmap x)
  (gluer b) (Hsm pt b) Hr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk64"><span class="nb">intros</span> b; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath (<span class="kr">fun</span> <span class="nv">x</span> : Smash A B =&gt; g (f x) = x) 
  (gluer b) (Hsm pt b) Hr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk65">transport_paths FFlr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Smash A B -&gt; P</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>P -&gt; Smash A B</span></span></span><br><span><var>Hsm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), g (f (sm a b)) = sm a b</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>g (f auxl) = auxl</span></span></span><br><span><var>Hr</var><span class="hyp-type"><b>: </b><span>g (f auxr) = auxr</span></span></span><br><span><var>Hgluel</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A,
ap g (ap f (gluel a)) @ Hl =
Hsm a pt @ gluel a</span></span></span><br><span><var>Hgluer</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B,
ap g (ap f (gluer b)) @ Hr =
Hsm pt b @ gluer b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap g (ap f (gluer b)) @ Hr = Hsm pt b @ gluer b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Hgluer b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality of the smash product *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk66"><span class="kn">Definition</span> <span class="nf">functor_smash</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">X</span> <span class="nv">Y</span> : pType} (<span class="nv">f</span> : A $-&gt; X) (<span class="nv">g</span> : B $-&gt; Y)
  : Smash A B $-&gt; Smash X Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash A B $-&gt; Smash X Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk67"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash A B $-&gt; Smash X Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk68">srapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash A B -&gt; Smash X Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk69"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk6a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash A B -&gt; Smash X Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk6b">snapply (Smash_rec (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; sm (f a) (g b)) auxl auxr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">b</span> : B) =&gt; sm (f a0) (g b)) a pt = auxl</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk6c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
(<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b0</span> : B) =&gt; sm (f a) (g b0)) pt b = auxr</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk6d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">b</span> : B) =&gt; sm (f a0) (g b)) a pt = auxl</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk6e"><span class="nb">intro</span> a; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sm (f a) (g pt) = auxl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk6f">rhs_V napply (gluel (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sm (f a) (g pt) = sm (f a) pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011 _ <span class="mi">1</span> (point_eq g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk70">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B,
(<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b0</span> : B) =&gt; sm (f a) (g b0)) pt b = auxr</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk71"><span class="nb">intro</span> b; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sm (f pt) (g b) = auxr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk72">rhs_V napply (gluer (g b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sm (f pt) (g b) = sm pt (g b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011 _ (point_eq f) <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk73">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash_rec (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B) =&gt; sm (f a) (g b)) auxl
  auxr
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ap011 sm <span class="mi">1</span> (point_eq g) @ gluel (f a)
   :
   (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">b</span> : B) =&gt; sm (f a0) (g b)) a pt =
   auxl)
  (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
   ap011 sm (point_eq f) <span class="mi">1</span> @ gluer (g b)
   :
   (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b0</span> : B) =&gt; sm (f a) (g b0)) pt b =
   auxr) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011 _ (point_eq f) (point_eq g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk74"><span class="kn">Definition</span> <span class="nf">functor_smash_idmap</span> (<span class="nv">X</span> <span class="nv">Y</span> : pType)
  : functor_smash (@pmap_idmap X) (@pmap_idmap Y) $== pmap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash pmap_idmap pmap_idmap $== pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash pmap_idmap pmap_idmap $== pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk76">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash pmap_idmap pmap_idmap == pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk77"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (functor_smash pmap_idmap pmap_idmap) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk78">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash pmap_idmap pmap_idmap == pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk79">snapply Smash_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y),
functor_smash pmap_idmap pmap_idmap (sm a b) =
pmap_idmap (sm a b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk7a"><hr></label><div class="goal-conclusion">functor_smash pmap_idmap pmap_idmap auxl =
pmap_idmap auxl</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk7b"><hr></label><div class="goal-conclusion">functor_smash pmap_idmap pmap_idmap auxr =
pmap_idmap auxr</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk7c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
ap (functor_smash pmap_idmap pmap_idmap) (gluel a) @
<span class="nl">?Hl</span> = <span class="nl">?Hsm</span> a pt @ ap pmap_idmap (gluel a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk7d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y,
ap (functor_smash pmap_idmap pmap_idmap) (gluer b) @
<span class="nl">?Hr</span> = <span class="nl">?Hsm</span> pt b @ ap pmap_idmap (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk7e"><span class="mi">1</span>-<span class="mi">3</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
ap (functor_smash pmap_idmap pmap_idmap) (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : X) (<span class="nv">b</span> : Y) =&gt; <span class="mi">1</span>) a pt @
ap pmap_idmap (gluel a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk7f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y,
ap (functor_smash pmap_idmap pmap_idmap) (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b0</span> : Y) =&gt; <span class="mi">1</span>) pt b @
ap pmap_idmap (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk80">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X,
ap (functor_smash pmap_idmap pmap_idmap) (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : X) (<span class="nv">b</span> : Y) =&gt; <span class="mi">1</span>) a pt @
ap pmap_idmap (gluel a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk81"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_smash pmap_idmap pmap_idmap) (gluel x) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y) =&gt; <span class="mi">1</span>) x pt @
ap pmap_idmap (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk82"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_smash pmap_idmap pmap_idmap) (gluel x) =
ap pmap_idmap (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk83">rhs napply ap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_smash pmap_idmap pmap_idmap) (gluel x) =
gluel x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk84">lhs napply Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm <span class="mi">1</span> (point_eq pmap_idmap) @
gluel (pmap_idmap x) = gluel x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk85">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : Y,
ap (functor_smash pmap_idmap pmap_idmap) (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b0</span> : Y) =&gt; <span class="mi">1</span>) pt b @
ap pmap_idmap (gluer b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk86"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_smash pmap_idmap pmap_idmap) (gluer y) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y) =&gt; <span class="mi">1</span>) pt y @
ap pmap_idmap (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk87"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_smash pmap_idmap pmap_idmap) (gluer y) =
ap pmap_idmap (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk88">rhs napply ap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (functor_smash pmap_idmap pmap_idmap) (gluer y) =
gluer y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk89">lhs napply Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm (point_eq pmap_idmap) <span class="mi">1</span> @
gluer (pmap_idmap y) = gluer y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk8a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash_ind_FlFr (functor_smash pmap_idmap pmap_idmap)
  pmap_idmap (<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b</span> : Y) =&gt; <span class="mi">1</span>) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     ((Smash_rec_beta_gluel
         (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt;
          ap011 sm <span class="mi">1</span> (point_eq pmap_idmap) @
          gluel (pmap_idmap a)
          :
          (<span class="kr">fun</span> (<span class="nv">a0</span> : X) (<span class="nv">b</span> : Y) =&gt;
           sm (pmap_idmap a0) (pmap_idmap b)) a pt =
          auxl)
         (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt;
          ap011 sm (point_eq pmap_idmap) <span class="mi">1</span> @
          gluer (pmap_idmap b)
          :
          (<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b0</span> : Y) =&gt;
           sm (pmap_idmap a) (pmap_idmap b0)) pt b =
          auxr) x @ concat_1p (gluel x)) @
      (ap_idmap (gluel x))^))
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     ((Smash_rec_beta_gluer
         (<span class="kr">fun</span> <span class="nv">a</span> : X =&gt;
          ap011 sm <span class="mi">1</span> (point_eq pmap_idmap) @
          gluel (pmap_idmap a)
          :
          (<span class="kr">fun</span> (<span class="nv">a0</span> : X) (<span class="nv">b</span> : Y) =&gt;
           sm (pmap_idmap a0) (pmap_idmap b)) a pt =
          auxl)
         (<span class="kr">fun</span> <span class="nv">b</span> : Y =&gt;
          ap011 sm (point_eq pmap_idmap) <span class="mi">1</span> @
          gluer (pmap_idmap b)
          :
          (<span class="kr">fun</span> (<span class="nv">a</span> : X) (<span class="nv">b0</span> : Y) =&gt;
           sm (pmap_idmap a) (pmap_idmap b0)) pt b =
          auxr) y @ concat_1p (gluer y)) @
      (ap_idmap (gluer y))^)) pt =
dpoint_eq (functor_smash pmap_idmap pmap_idmap) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk8b"><span class="kn">Definition</span> <span class="nf">functor_smash_compose</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : pType}
  (<span class="nv">f</span> : X $-&gt; A) (<span class="nv">g</span> : Y $-&gt; B) (<span class="nv">h</span> : A $-&gt; C) (<span class="nv">k</span> : B $-&gt; D)
  : functor_smash (h $o f) (k $o g) $== functor_smash h k $o functor_smash f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X $-&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B $-&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash (h $o f) (k $o g) $==
functor_smash h k $o functor_smash f g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk8c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X $-&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B $-&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash (h $o f) (k $o g) $==
functor_smash h k $o functor_smash f g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk8d">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash
  ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) ==*
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
o* functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk8e">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash
  ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) ==
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
o* functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><label class="goal-separator" for="smash-v-chk8f"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})) @
(dpoint_eq
   (functor_smash
      {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
    o* functor_smash
         {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
         {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk90">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash
  ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) ==
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
o* functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk91">snapply Smash_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : [X, point4]) 
(<span class="nv">b</span> : [Y, point3]),
functor_smash
  ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (sm a b) =
(functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
 o* functor_smash
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (sm a b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><label class="goal-separator" for="smash-v-chk92"><hr></label><div class="goal-conclusion">functor_smash
  ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) auxl =
(functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
 o* functor_smash
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) auxl</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><label class="goal-separator" for="smash-v-chk93"><hr></label><div class="goal-conclusion">functor_smash
  ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) auxr =
(functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
   {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
 o* functor_smash
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) auxr</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><label class="goal-separator" for="smash-v-chk94"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [X, point4],
ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluel a) @ <span class="nl">?Hl</span> =
<span class="nl">?Hsm</span> a pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk95" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><label class="goal-separator" for="smash-v-chk95"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [Y, point3],
ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluer b) @ <span class="nl">?Hr</span> =
<span class="nl">?Hsm</span> pt b @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk96"><span class="mi">1</span>-<span class="mi">3</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [X, point4],
ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point4]) (<span class="nv">b</span> : [Y, point3]) =&gt; <span class="mi">1</span>) a pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><label class="goal-separator" for="smash-v-chk97"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [Y, point3],
ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4]) (<span class="nv">b0</span> : [Y, point3]) =&gt; <span class="mi">1</span>) pt b @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk98">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [X, point4],
ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point4]) (<span class="nv">b</span> : [Y, point3]) =&gt; <span class="mi">1</span>) a pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk99"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluel x) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4]) (<span class="nv">b</span> : [Y, point3]) =&gt; <span class="mi">1</span>) x pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk9a"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluel x) =
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk9b">lhs napply Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm <span class="mi">1</span>
  (point_eq
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})) @
gluel
  (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) x) =
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk9c"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel x) =
ap011 sm <span class="mi">1</span>
  (point_eq
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})) @
gluel
  (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk9d">lhs napply (ap_compose (functor_smash _ _) _ (gluel x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |})
  (ap
     (functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
     (gluel x)) =
ap011 sm <span class="mi">1</span>
  (point_eq
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})) @
gluel
  (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk9e">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel x) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><label class="goal-separator" for="smash-v-chk9f"><hr></label><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  <span class="nl">?Goal</span> =
ap011 sm <span class="mi">1</span>
  (point_eq
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})) @
gluel
  (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka0"><span class="mi">2</span>: napply Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel x) =
gluel
  ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     (fst (x, pt)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka1">lhs napply Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point4]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm <span class="mi">1</span>
  (point_eq {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) @
gluel ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} x) =
gluel ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [Y, point3],
ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4]) (<span class="nv">b0</span> : [Y, point3]) =&gt; <span class="mi">1</span>) pt b @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka3"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluer y) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4]) (<span class="nv">b</span> : [Y, point3]) =&gt; <span class="mi">1</span>) pt y @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka4"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (gluer y) =
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka5">lhs napply Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm
  (point_eq
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) <span class="mi">1</span> @
gluer
  (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) y) =
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka6"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer y) =
ap011 sm
  (point_eq
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) <span class="mi">1</span> @
gluer
  (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka7">lhs napply (ap_compose (functor_smash _ _) _ (gluer y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |})
  (ap
     (functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
     (gluer y)) =
ap011 sm
  (point_eq
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) <span class="mi">1</span> @
gluer
  (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chka8">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer y) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><label class="goal-separator" for="smash-v-chka9"><hr></label><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  <span class="nl">?Goal</span> =
ap011 sm
  (point_eq
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})) <span class="mi">1</span> @
gluer
  (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
    o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkaa"><span class="mi">2</span>: napply Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer y) =
gluer
  ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     (snd (pt, y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkab">lhs napply Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point3]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
gluer ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} y) =
gluer ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkac">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point4</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point3</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash_ind_FlFr
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4]) (<span class="nv">b</span> : [Y, point3]) =&gt; <span class="mi">1</span>) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : [X, point4] =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     (Smash_rec_beta_gluel
        (<span class="kr">fun</span> <span class="nv">a</span> : [X, point4] =&gt;
         ap011 sm <span class="mi">1</span>
           (point_eq
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
               o* {|
                    pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                  |})) @
         gluel
           (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
             o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
              a)
         :
         (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point4]) (<span class="nv">b</span> : [Y, point3]) =&gt;
          sm
            (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) a0)
            (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |}) b)) a pt = auxl)
        (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point3] =&gt;
         ap011 sm
           (point_eq
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
               o* {|
                    pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                  |})) <span class="mi">1</span> @
         gluer
           (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
             o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
              b)
         :
         (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4]) (<span class="nv">b0</span> : [Y, point3]) =&gt;
          sm
            (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) a)
            (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |}) b0)) pt b = auxr) x @
      (ap_compose
         (functor_smash
            {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
            {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
         (functor_smash
            {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
            {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |})
         (gluel x) @
       (ap
          (ap
             (functor_smash
                {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}))
          (Smash_rec_beta_gluel
             (<span class="kr">fun</span> <span class="nv">a</span> : [X, point4] =&gt;
              ap011 sm <span class="mi">1</span>
                (point_eq
                   {|
                     pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                   |}) @
              gluel
                ({|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |} a)
              :
              (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point4])
                 (<span class="nv">b</span> : [Y, point3]) =&gt;
               sm ({| ... |} a0) ({| ... |} b)) a pt =
              auxl)
             (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point3] =&gt;
              ap011 sm
                (point_eq
                   {|
                     pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                   |}) <span class="mi">1</span> @
              gluer
                ({|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |} b)
              :
              (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4])
                 (<span class="nv">b0</span> : [Y, point3]) =&gt;
               sm ({| ... |} a) ({| ... |} b0)) pt b =
              auxr) x @
           concat_1p
             (gluel
                ({|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |} x))) @
        Smash_rec_beta_gluel
          (<span class="kr">fun</span> <span class="nv">a</span> : [A, f point4] =&gt;
           ap011 sm <span class="mi">1</span>
             (point_eq
                {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) @
           gluel
             ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |} a)
           :
           (<span class="kr">fun</span> (<span class="nv">a0</span> : [A, f point4])
              (<span class="nv">b</span> : [B, g point3]) =&gt;
            sm
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                 a0)
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                 b)) a pt = auxl)
          (<span class="kr">fun</span> <span class="nv">b</span> : [B, g point3] =&gt;
           ap011 sm
             (point_eq
                {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |})
             <span class="mi">1</span> @
           gluer
             ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} b)
           :
           (<span class="kr">fun</span> (<span class="nv">a</span> : [A, f point4])
              (<span class="nv">b0</span> : [B, g point3]) =&gt;
            sm
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                 a)
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                 b0)) pt b = auxr)
          ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
             (fst (x, pt)))))^))
  (<span class="kr">fun</span> <span class="nv">y</span> : [Y, point3] =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     (Smash_rec_beta_gluer
        (<span class="kr">fun</span> <span class="nv">a</span> : [X, point4] =&gt;
         ap011 sm <span class="mi">1</span>
           (point_eq
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
               o* {|
                    pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                  |})) @
         gluel
           (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
             o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
              a)
         :
         (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point4]) (<span class="nv">b</span> : [Y, point3]) =&gt;
          sm
            (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) a0)
            (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |}) b)) a pt = auxl)
        (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point3] =&gt;
         ap011 sm
           (point_eq
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
               o* {|
                    pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                  |})) <span class="mi">1</span> @
         gluer
           (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
             o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
              b)
         :
         (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4]) (<span class="nv">b0</span> : [Y, point3]) =&gt;
          sm
            (({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) a)
            (({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
              o* {|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |}) b0)) pt b = auxr) y @
      (ap_compose
         (functor_smash
            {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
            {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
         (functor_smash
            {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
            {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |})
         (gluer y) @
       (ap
          (ap
             (functor_smash
                {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}))
          (Smash_rec_beta_gluer
             (<span class="kr">fun</span> <span class="nv">a</span> : [X, point4] =&gt;
              ap011 sm <span class="mi">1</span>
                (point_eq
                   {|
                     pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                   |}) @
              gluel
                ({|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |} a)
              :
              (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point4])
                 (<span class="nv">b</span> : [Y, point3]) =&gt;
               sm ({| ... |} a0) ({| ... |} b)) a pt =
              auxl)
             (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point3] =&gt;
              ap011 sm
                (point_eq
                   {|
                     pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                   |}) <span class="mi">1</span> @
              gluer
                ({|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |} b)
              :
              (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point4])
                 (<span class="nv">b0</span> : [Y, point3]) =&gt;
               sm ({| ... |} a) ({| ... |} b0)) pt b =
              auxr) y @
           concat_1p
             (gluer
                ({|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |} y))) @
        Smash_rec_beta_gluer
          (<span class="kr">fun</span> <span class="nv">a</span> : [A, f point4] =&gt;
           ap011 sm <span class="mi">1</span>
             (point_eq
                {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) @
           gluel
             ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |} a)
           :
           (<span class="kr">fun</span> (<span class="nv">a0</span> : [A, f point4])
              (<span class="nv">b</span> : [B, g point3]) =&gt;
            sm
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                 a0)
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                 b)) a pt = auxl)
          (<span class="kr">fun</span> <span class="nv">b</span> : [B, g point3] =&gt;
           ap011 sm
             (point_eq
                {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |})
             <span class="mi">1</span> @
           gluer
             ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} b)
           :
           (<span class="kr">fun</span> (<span class="nv">a</span> : [A, f point4])
              (<span class="nv">b0</span> : [B, g point3]) =&gt;
            sm
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                 a)
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                 b0)) pt b = auxr)
          ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
             (snd (pt, y)))))^)) pt =
dpoint_eq
  (functor_smash
     ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
      o* {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})) @
(dpoint_eq
   (functor_smash
      {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
    o* functor_smash
         {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
         {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkad"><span class="kn">Definition</span> <span class="nf">functor_smash_homotopic</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">A</span> <span class="nv">B</span> : pType}
  {<span class="nv">f</span> <span class="nv">h</span> : X $-&gt; A} {<span class="nv">g</span> <span class="nv">k</span> : Y $-&gt; B}
  (<span class="nv">p</span> : f $== h) (<span class="nv">q</span> : g $== k)
  : functor_smash f g $== functor_smash h k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X $-&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $== k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash f g $== functor_smash h k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X $-&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== h</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $== k</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash f g $== functor_smash h k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkaf">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |} ==*
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkb0">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |} ==
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkb1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkb1"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}) @
(dpoint_eq
   (functor_smash
      {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkb2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |} ==
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkb3">snapply Smash_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : [X, point2]) 
(<span class="nv">b</span> : [Y, point1]),
functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}
  (sm a b) =
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} 
  (sm a b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkb4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkb4"><hr></label><div class="goal-conclusion">functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}
  auxl =
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} auxl</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkb5"><hr></label><div class="goal-conclusion">functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}
  auxr =
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} auxr</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkb6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [X, point2],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluel a) @ <span class="nl">?Hl</span> =
<span class="nl">?Hsm</span> a pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkb7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [Y, point1],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluer b) @ <span class="nl">?Hr</span> =
<span class="nl">?Hsm</span> pt b @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkb8"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; ap011 _ (p x) (q y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}
  auxl =
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} auxl</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkb9"><hr></label><div class="goal-conclusion">functor_smash
  {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
  {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}
  auxr =
functor_smash {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} auxr</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkba"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [X, point2],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluel a) @ <span class="nl">?Hl</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) a pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkbb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkbb"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [Y, point1],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluer b) @ <span class="nl">?Hr</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) pt b @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkbc"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [X, point2],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) a pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><label class="goal-separator" for="smash-v-chkbd"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [Y, point1],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) pt b @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkbe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [X, point2],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) a pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkbf"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluel x) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) x pt @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc0">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluel x) =
ap011 sm (p x) (q pt) @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc1">lhs napply Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm <span class="mi">1</span>
  (point_eq
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}) @
gluel
  ({| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |} x) =
ap011 sm (p x) (q pt) @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc2">rhs napply whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm <span class="mi">1</span>
  (point_eq
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}) @
gluel
  ({| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |} x) =
ap011 sm (p x) (q pt) @ <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkc3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><label class="goal-separator" for="smash-v-chkc3"><hr></label><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel x) = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc4"><span class="mi">2</span>: napply Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm <span class="mi">1</span>
  (point_eq
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}) @
gluel
  ({| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |} x) =
ap011 sm (p x) (q pt) @
(ap011 sm <span class="mi">1</span>
   (point_eq {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) @
 gluel ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |} x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc5"><span class="nb">simpl</span>; <span class="nb">induction</span> (p x); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sm (f x)) (q point1 @ <span class="mi">1</span>) @ gluel (f x) =
ap (sm (f x)) (q pt) @ (<span class="mi">1</span> @ gluel (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc6">rhs_V napply concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sm (f x)) (q point1 @ <span class="mi">1</span>) @ gluel (f x) =
(ap (sm (f x)) (q pt) @ <span class="mi">1</span>) @ gluel (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc7"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>[X, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (sm (f x)) (q point1 @ <span class="mi">1</span>) =
ap (sm (f x)) (q pt) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply ap_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [Y, point1],
ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) pt b @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkc9"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluer y) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
 ap011 sm (p x) (q y)) pt y @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkca">lhs napply concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (gluer y) =
ap011 sm (p pt) (q y) @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkcb">lhs napply Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm
  (point_eq
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |})
  <span class="mi">1</span> @
gluer
  ({| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |} y) =
ap011 sm (p pt) (q y) @
ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkcc">rhs napply whiskerL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm
  (point_eq
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |})
  <span class="mi">1</span> @
gluer
  ({| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |} y) =
ap011 sm (p pt) (q y) @ <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkcd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><label class="goal-separator" for="smash-v-chkcd"><hr></label><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer y) = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkce"><span class="mi">2</span>: napply Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm
  (point_eq
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |})
  <span class="mi">1</span> @
gluer
  ({| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |} y) =
ap011 sm (p pt) (q y) @
(ap011 sm
   (point_eq {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
 gluer ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkcf"><span class="nb">simpl</span>; <span class="nb">induction</span> (q y); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm (p point2 @ <span class="mi">1</span>) <span class="mi">1</span> @ gluer (g y) =
ap011 sm (p pt) <span class="mi">1</span> @ (<span class="mi">1</span> @ gluer (g y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd0">rhs_V napply concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm (p point2 @ <span class="mi">1</span>) <span class="mi">1</span> @ gluer (g y) =
(ap011 sm (p pt) <span class="mi">1</span> @ <span class="mi">1</span>) @ gluer (g y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd1"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>[Y, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm (p point2 @ <span class="mi">1</span>) <span class="mi">1</span> = ap011 sm (p pt) <span class="mi">1</span> @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011_pp _ _ _ <span class="mi">1</span> <span class="mi">1</span>).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd2">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed Y</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, h</var><span class="hyp-type"><b>: </b><span>X -&gt; A</span></span></span><br><span><var>g, k</var><span class="hyp-type"><b>: </b><span>Y -&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f x = h x</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Y, g x = k x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash_ind_FlFr
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |})
  (functor_smash
     {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |})
  (<span class="kr">fun</span> (<span class="nv">x</span> : [X, point2]) (<span class="nv">y</span> : [Y, point1]) =&gt;
   ap011 sm (p x) (q y)) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : [X, point2] =&gt;
   concat_p1
     (ap
        (functor_smash
           {|
             pointed_fun := f;
             dpoint_eq := p point2 @ <span class="mi">1</span>
           |}
           {|
             pointed_fun := g;
             dpoint_eq := q point1 @ <span class="mi">1</span>
           |}) (gluel x)) @
   (Smash_rec_beta_gluel
      (<span class="kr">fun</span> <span class="nv">a</span> : [X, point2] =&gt;
       ap011 sm <span class="mi">1</span>
         (point_eq
            {|
              pointed_fun := g;
              dpoint_eq := q point1 @ <span class="mi">1</span>
            |}) @
       gluel
         ({|
            pointed_fun := f;
            dpoint_eq := p point2 @ <span class="mi">1</span>
          |} a)
       :
       (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point2]) (<span class="nv">b</span> : [Y, point1]) =&gt;
        sm
          ({|
             pointed_fun := f;
             dpoint_eq := p point2 @ <span class="mi">1</span>
           |} a0)
          ({|
             pointed_fun := g;
             dpoint_eq := q point1 @ <span class="mi">1</span>
           |} b)) a pt = auxl)
      (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point1] =&gt;
       ap011 sm
         (point_eq
            {|
              pointed_fun := f;
              dpoint_eq := p point2 @ <span class="mi">1</span>
            |}) <span class="mi">1</span> @
       gluer
         ({|
            pointed_fun := g;
            dpoint_eq := q point1 @ <span class="mi">1</span>
          |} b)
       :
       (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point2]) (<span class="nv">b0</span> : [Y, point1]) =&gt;
        sm
          ({|
             pointed_fun := f;
             dpoint_eq := p point2 @ <span class="mi">1</span>
           |} a)
          ({|
             pointed_fun := g;
             dpoint_eq := q point1 @ <span class="mi">1</span>
           |} b0)) pt b = auxr) x @
    (((<span class="kr">let</span> <span class="nv">p0</span> := p x <span class="kr">in</span>
       <span class="kr">let</span> <span class="nv">a</span> := h x <span class="kr">in</span>
       paths_rect A (f x)
         (<span class="kr">fun</span> (<span class="nv">a0</span> : A) (<span class="nv">p1</span> : f x = a0) =&gt;
          ap (sm (f x)) (q point1 @ <span class="mi">1</span>) @ gluel (f x) =
          ap011 sm p1 (q pt) @ (<span class="mi">1</span> @ gluel a0))
         (whiskerR (ap_pp (sm (f x)) (q point1) <span class="mi">1</span>)
            (gluel (f x)) @
          concat_pp_p (ap (sm (f x)) (q pt)) <span class="mi">1</span>
            (gluel (f x))
          :
          ap (sm (f x)) (q point1 @ <span class="mi">1</span>) @ gluel (f x) =
          ap011 sm <span class="mi">1</span> (q pt) @ (<span class="mi">1</span> @ gluel (f x))) a p0)
      :
      ap011 sm <span class="mi">1</span>
        (point_eq
           {|
             pointed_fun := g;
             dpoint_eq := q point1 @ <span class="mi">1</span>
           |}) @
      gluel
        ({|
           pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span>
         |} x) =
      ap011 sm (p x) (q pt) @
      (ap011 sm <span class="mi">1</span>
         (point_eq
            {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}) @
       gluel
         ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |} x))) @
     (whiskerL (ap011 sm (p x) (q pt))
        (Smash_rec_beta_gluel
           (<span class="kr">fun</span> <span class="nv">a</span> : [X, point2] =&gt;
            ap011 sm <span class="mi">1</span>
              (point_eq
                 {|
                   pointed_fun := k; dpoint_eq := <span class="mi">1</span>
                 |}) @
            gluel
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                 a)
            :
            (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point2]) (<span class="nv">b</span> : [Y, point1])
             =&gt;
             sm
               ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                  a0)
               ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                  b)) a pt = auxl)
           (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point1] =&gt;
            ap011 sm
              (point_eq
                 {|
                   pointed_fun := h; dpoint_eq := <span class="mi">1</span>
                 |}) <span class="mi">1</span> @
            gluer
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                 b)
            :
            (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point2]) (<span class="nv">b0</span> : [Y, point1])
             =&gt;
             sm
               ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                  a)
               ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                  b0)) pt b = auxr) x))^)))
  (<span class="kr">fun</span> <span class="nv">y</span> : [Y, point1] =&gt;
   concat_p1
     (ap
        (functor_smash
           {|
             pointed_fun := f;
             dpoint_eq := p point2 @ <span class="mi">1</span>
           |}
           {|
             pointed_fun := g;
             dpoint_eq := q point1 @ <span class="mi">1</span>
           |}) (gluer y)) @
   (Smash_rec_beta_gluer
      (<span class="kr">fun</span> <span class="nv">a</span> : [X, point2] =&gt;
       ap011 sm <span class="mi">1</span>
         (point_eq
            {|
              pointed_fun := g;
              dpoint_eq := q point1 @ <span class="mi">1</span>
            |}) @
       gluel
         ({|
            pointed_fun := f;
            dpoint_eq := p point2 @ <span class="mi">1</span>
          |} a)
       :
       (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point2]) (<span class="nv">b</span> : [Y, point1]) =&gt;
        sm
          ({|
             pointed_fun := f;
             dpoint_eq := p point2 @ <span class="mi">1</span>
           |} a0)
          ({|
             pointed_fun := g;
             dpoint_eq := q point1 @ <span class="mi">1</span>
           |} b)) a pt = auxl)
      (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point1] =&gt;
       ap011 sm
         (point_eq
            {|
              pointed_fun := f;
              dpoint_eq := p point2 @ <span class="mi">1</span>
            |}) <span class="mi">1</span> @
       gluer
         ({|
            pointed_fun := g;
            dpoint_eq := q point1 @ <span class="mi">1</span>
          |} b)
       :
       (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point2]) (<span class="nv">b0</span> : [Y, point1]) =&gt;
        sm
          ({|
             pointed_fun := f;
             dpoint_eq := p point2 @ <span class="mi">1</span>
           |} a)
          ({|
             pointed_fun := g;
             dpoint_eq := q point1 @ <span class="mi">1</span>
           |} b0)) pt b = auxr) y @
    (((<span class="kr">let</span> <span class="nv">p0</span> := q y <span class="kr">in</span>
       <span class="kr">let</span> <span class="nv">b</span> := k y <span class="kr">in</span>
       paths_rect B (g y)
         (<span class="kr">fun</span> (<span class="nv">b0</span> : B) (<span class="nv">p1</span> : g y = b0) =&gt;
          ap011 sm (p point2 @ <span class="mi">1</span>) <span class="mi">1</span> @ gluer (g y) =
          ap011 sm (p pt) p1 @ (<span class="mi">1</span> @ gluer b0))
         (whiskerR (ap011_pp sm (p point2) <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>)
            (gluer (g y)) @
          concat_pp_p (ap011 sm (p pt) <span class="mi">1</span>) <span class="mi">1</span>
            (gluer (g y))
          :
          ap011 sm (p point2 @ <span class="mi">1</span>) <span class="mi">1</span> @ gluer (g y) =
          ap011 sm (p pt) <span class="mi">1</span> @ (<span class="mi">1</span> @ gluer (g y))) b p0)
      :
      ap011 sm
        (point_eq
           {|
             pointed_fun := f;
             dpoint_eq := p point2 @ <span class="mi">1</span>
           |}) <span class="mi">1</span> @
      gluer
        ({|
           pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span>
         |} y) =
      ap011 sm (p pt) (q y) @
      (ap011 sm
         (point_eq
            {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
       gluer
         ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |} y))) @
     (whiskerL (ap011 sm (p pt) (q y))
        (Smash_rec_beta_gluer
           (<span class="kr">fun</span> <span class="nv">a</span> : [X, point2] =&gt;
            ap011 sm <span class="mi">1</span>
              (point_eq
                 {|
                   pointed_fun := k; dpoint_eq := <span class="mi">1</span>
                 |}) @
            gluel
              ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                 a)
            :
            (<span class="kr">fun</span> (<span class="nv">a0</span> : [X, point2]) (<span class="nv">b</span> : [Y, point1])
             =&gt;
             sm
               ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                  a0)
               ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                  b)) a pt = auxl)
           (<span class="kr">fun</span> <span class="nv">b</span> : [Y, point1] =&gt;
            ap011 sm
              (point_eq
                 {|
                   pointed_fun := h; dpoint_eq := <span class="mi">1</span>
                 |}) <span class="mi">1</span> @
            gluer
              ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                 b)
            :
            (<span class="kr">fun</span> (<span class="nv">a</span> : [X, point2]) (<span class="nv">b0</span> : [Y, point1])
             =&gt;
             sm
               ({| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
                  a)
               ({| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}
                  b0)) pt b = auxr) y))^))) pt =
dpoint_eq
  (functor_smash
     {| pointed_fun := f; dpoint_eq := p point2 @ <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := q point1 @ <span class="mi">1</span> |}) @
(dpoint_eq
   (functor_smash
      {| pointed_fun := h; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := k; dpoint_eq := <span class="mi">1</span> |}))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap022 _ (concat_p1 (p pt))^ (concat_p1 (q pt))^ @ (concat_p1 _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd3">#[export] <span class="kn">Instance</span> <span class="nf">is0bifunctor_smash</span> : Is0Bifunctor Smash.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Bifunctor Smash</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Bifunctor Smash</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd5">snapply Build_Is0Bifunctor&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is01Cat pType</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is01Cat pType</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (uncurry Smash)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd6"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (uncurry Smash)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd7">napply Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : pType * pType,
(a $-&gt; b) -&gt; uncurry Smash a $-&gt; uncurry Smash b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd8"><span class="nb">intros</span> [X Y] [A B] [f g].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fst (X, Y) $-&gt; fst (A, B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>snd (X, Y) $-&gt; snd (A, B)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">uncurry Smash (X, Y) $-&gt; uncurry Smash (A, B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_smash f g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkd9">#[export] <span class="kn">Instance</span> <span class="nf">is1bifunctor_smash</span> : Is1Bifunctor Smash.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor Smash</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkda"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Bifunctor Smash</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkdb">snapply Build_Is1Bifunctor&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (uncurry Smash)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkdc">snapply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType * pType) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt;
fmap (uncurry Smash) f $== fmap (uncurry Smash) g</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pType * pType,
fmap (uncurry Smash) (Id a) $== Id (uncurry Smash a)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType * pType) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c),
fmap (uncurry Smash) (g $o f) $==
fmap (uncurry Smash) g $o fmap (uncurry Smash) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkdd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : pType * pType) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt;
fmap (uncurry Smash) f $== fmap (uncurry Smash) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkde"><span class="nb">intros</span> [X Y] [A B] [f g] [h i] [p q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fst (X, Y) $-&gt; fst (A, B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>snd (X, Y) $-&gt; snd (A, B)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>fst (X, Y) $-&gt; fst (A, B)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>snd (X, Y) $-&gt; snd (A, B)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fst (f, g) $-&gt; fst (h, i)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>snd (f, g) $-&gt; snd (h, i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (uncurry Smash) (f, g) $==
fmap (uncurry Smash) (h, i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_smash_homotopic p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkdf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : pType * pType,
fmap (uncurry Smash) (Id a) $== Id (uncurry Smash a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke0"><span class="nb">intros</span> [X Y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (uncurry Smash) (Id (X, Y)) $==
Id (uncurry Smash (X, Y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_smash_idmap X Y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : pType * pType) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c),
fmap (uncurry Smash) (g $o f) $==
fmap (uncurry Smash) g $o fmap (uncurry Smash) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke2"><span class="nb">intros</span> [X Y] [A B] [C D] [f g] [h i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, A, B, C, D</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fst (X, Y) $-&gt; fst (A, B)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>snd (X, Y) $-&gt; snd (A, B)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>fst (A, B) $-&gt; fst (C, D)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>snd (A, B) $-&gt; snd (C, D)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (uncurry Smash) ((h, i) $o (f, g)) $==
fmap (uncurry Smash) (h, i) $o
fmap (uncurry Smash) (f, g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_smash_compose f g h i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Symmetry of the smash product *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pswap</span> (<span class="nv">X</span> <span class="nv">Y</span> : pType) : Smash X Y $-&gt; Smash Y X
  := Build_pMap (Smash_rec (flip sm) auxr auxl gluer gluel) <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke3"><span class="kn">Definition</span> <span class="nf">pswap_pswap</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType}
  : pswap X Y $o pswap Y X $== pmap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap X Y $o pswap Y X $== pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap X Y $o pswap Y X $== pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke5">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap X Y $o pswap Y X == pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chke6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chke6"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (pswap X Y $o pswap Y X) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap X Y $o pswap Y X == pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chke8">snapply Smash_ind_FFlr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Y) (<span class="nv">b</span> : X),
pswap X Y (pswap Y X (sm a b)) = sm a b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chke9"><hr></label><div class="goal-conclusion">pswap X Y (pswap Y X auxl) = auxl</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chkea"><hr></label><div class="goal-conclusion">pswap X Y (pswap Y X auxr) = auxr</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkeb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chkeb"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Y,
ap (pswap X Y) (ap (pswap Y X) (gluel a)) @ <span class="nl">?Hl</span> =
<span class="nl">?Hsm</span> a pt @ gluel a</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chkec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chkec"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : X,
ap (pswap X Y) (ap (pswap Y X) (gluer b)) @ <span class="nl">?Hr</span> =
<span class="nl">?Hsm</span> pt b @ gluer b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chked"><span class="mi">1</span>-<span class="mi">3</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Y,
ap (pswap X Y) (ap (pswap Y X) (gluel a)) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : Y) (<span class="nv">b</span> : X) =&gt; <span class="mi">1</span>) a pt @ gluel a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chkee"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : X,
ap (pswap X Y) (ap (pswap Y X) (gluer b)) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : Y) (<span class="nv">b0</span> : X) =&gt; <span class="mi">1</span>) pt b @ gluer b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkef">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Y,
ap (pswap X Y) (ap (pswap Y X) (gluel a)) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : Y) (<span class="nv">b</span> : X) =&gt; <span class="mi">1</span>) a pt @ gluel a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf0"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap X Y) (ap (pswap Y X) (gluel y)) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : Y) (<span class="nv">b</span> : X) =&gt; <span class="mi">1</span>) y pt @ gluel y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf1"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap X Y) (ap (pswap Y X) (gluel y)) = gluel y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf2">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap Y X) (gluel y) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chkf3"><hr></label><div class="goal-conclusion">ap (pswap X Y) <span class="nl">?Goal</span> = gluel y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf4"><span class="mi">1</span>: <span class="nb">apply</span> Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap X Y) (gluer y) = gluel y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply Smash_rec_beta_gluer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf5">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : X,
ap (pswap X Y) (ap (pswap Y X) (gluer b)) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : Y) (<span class="nv">b0</span> : X) =&gt; <span class="mi">1</span>) pt b @ gluer b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf6"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap X Y) (ap (pswap Y X) (gluer x)) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : Y) (<span class="nv">b</span> : X) =&gt; <span class="mi">1</span>) pt x @ gluer x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf7"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap X Y) (ap (pswap Y X) (gluer x)) = gluer x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkf8">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap Y X) (gluer x) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkf9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="smash-v-chkf9"><hr></label><div class="goal-conclusion">ap (pswap X Y) <span class="nl">?Goal</span> = gluer x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkfa"><span class="mi">1</span>: <span class="nb">apply</span> Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap X Y) (gluel x) = gluer x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply Smash_rec_beta_gluel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkfb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash_ind_FFlr (pswap Y X) (pswap X Y)
  (<span class="kr">fun</span> (<span class="nv">a</span> : Y) (<span class="nv">b</span> : X) =&gt; <span class="mi">1</span>) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">y</span> : Y =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     (ap (ap (pswap X Y))
        (Smash_rec_beta_gluel gluer gluel y) @
      Smash_rec_beta_gluer gluer gluel y))
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     (ap (ap (pswap X Y))
        (Smash_rec_beta_gluer gluer gluel x) @
      Smash_rec_beta_gluel gluer gluel x)) pt =
dpoint_eq (pswap X Y $o pswap Y X) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkfc"><span class="kn">Definition</span> <span class="nf">pequiv_pswap</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} : Smash X Y $&lt;~&gt; Smash Y X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash X Y $&lt;~&gt; Smash Y X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash X Y $&lt;~&gt; Smash Y X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chkfe">snapply cate_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash X Y $-&gt; Smash Y X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chkff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chkff"><hr></label><div class="goal-conclusion">Smash Y X $-&gt; Smash X Y</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk100" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk100"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> $o <span class="nl">?g</span> $== Id (Smash Y X)</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk101" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk101"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> $o <span class="nl">?f</span> $== Id (Smash X Y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk102"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> (pswap _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap X Y $o pswap Y X $== Id (Smash Y X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk103" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="smash-v-chk103"><hr></label><div class="goal-conclusion">pswap Y X $o pswap X Y $== Id (Smash X Y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> pswap_pswap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk104"><span class="kn">Definition</span> <span class="nf">pswap_natural</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">X</span> <span class="nv">Y</span> : pType} (<span class="nv">f</span> : A $-&gt; X) (<span class="nv">g</span> : B $-&gt; Y)
  : pswap X Y $o functor_smash f g $== functor_smash g f $o pswap A B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap X Y $o functor_smash f g $==
functor_smash g f $o pswap A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk105"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap X Y $o functor_smash f g $==
functor_smash g f $o pswap A B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk106">pointed_reduce.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap [X, f point2] [Y, g point1]
o* functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} ==*
functor_smash {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
o* pswap [A, point2] [B, point1]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk107">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap [X, f point2] [Y, g point1]
o* functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} ==
functor_smash {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
o* pswap [A, point2] [B, point1]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk108" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk108"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) @
(dpoint_eq
   (functor_smash
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
    o* pswap [A, point2] [B, point1]))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk109">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pswap [X, f point2] [Y, g point1]
o* functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} ==
functor_smash {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
  {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
o* pswap [A, point2] [B, point1]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk10a">snapply Smash_ind_FlFr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : [A, point2]) 
(<span class="nv">b</span> : [B, point1]),
(pswap [X, f point2] [Y, g point1]
 o* functor_smash
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (sm a b) =
(functor_smash {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
   {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
 o* pswap [A, point2] [B, point1]) 
  (sm a b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk10b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk10b"><hr></label><div class="goal-conclusion">(pswap [X, f point2] [Y, g point1]
 o* functor_smash
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) auxl =
(functor_smash {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
   {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
 o* pswap [A, point2] [B, point1]) auxl</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk10c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk10c"><hr></label><div class="goal-conclusion">(pswap [X, f point2] [Y, g point1]
 o* functor_smash
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) auxr =
(functor_smash {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
   {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
 o* pswap [A, point2] [B, point1]) auxr</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk10d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk10d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [A, point2],
ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) @ <span class="nl">?Hl</span> =
<span class="nl">?Hsm</span> a pt @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluel a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="smash-v-chk10e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk10e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [B, point1],
ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) @ <span class="nl">?Hr</span> =
<span class="nl">?Hsm</span> pt b @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk10f"><span class="mi">1</span>-<span class="mi">3</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [A, point2],
ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : [A, point2]) (<span class="nv">b</span> : [B, point1]) =&gt; <span class="mi">1</span>) a pt @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluel a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk110" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><label class="goal-separator" for="smash-v-chk110"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [B, point1],
ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [A, point2]) (<span class="nv">b0</span> : [B, point1]) =&gt; <span class="mi">1</span>) pt b @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluer b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk111">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : [A, point2],
ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a0</span> : [A, point2]) (<span class="nv">b</span> : [B, point1]) =&gt; <span class="mi">1</span>) a pt @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluel a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk112"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [A, point2]) (<span class="nv">b</span> : [B, point1]) =&gt; <span class="mi">1</span>) a pt @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluel a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk113"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluel a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk114">rhs napply (ap_compose (pswap _ _) _ (gluel a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  (ap (pswap [A, point2] [B, point1]) (gluel a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk115">rhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) 
  <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><label class="goal-separator" for="smash-v-chk116"><hr></label><div class="goal-conclusion">ap (pswap [A, point2] [B, point1]) (gluel a) = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk117"><span class="mi">2</span>: <span class="nb">apply</span> Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk118">rhs napply Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluel a) =
ap011 sm
  (point_eq {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
gluer ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk119">lhs napply (ap_compose (functor_smash _ _) (pswap _ _) (gluel a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1])
  (ap
     (functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
     (gluel a)) =
ap011 sm
  (point_eq {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
gluer ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk11a">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk11b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><label class="goal-separator" for="smash-v-chk11b"><hr></label><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1]) <span class="nl">?Goal</span> =
ap011 sm
  (point_eq {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
gluer ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk11c"><span class="mi">1</span>: <span class="nb">apply</span> Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1])
  (ap011 sm <span class="mi">1</span>
     (point_eq {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) @
   gluel ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} a)) =
ap011 sm
  (point_eq {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
gluer ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk11d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec (flip sm) auxr auxl gluer gluel)
  (<span class="mi">1</span> @ gluel (f a)) = <span class="mi">1</span> @ gluer (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk11e">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @ gluel (f a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk11f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><label class="goal-separator" for="smash-v-chk11f"><hr></label><div class="goal-conclusion">ap (Smash_rec (flip sm) auxr auxl gluer gluel) <span class="nl">?Goal</span> =
<span class="mi">1</span> @ gluer (f a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk120"><span class="mi">1</span>: <span class="nb">apply</span> concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec (flip sm) auxr auxl gluer gluel)
  (gluel (f a)) = <span class="mi">1</span> @ gluer (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk121">rhs napply concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>[A, point2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Smash_rec (flip sm) auxr auxl gluer gluel)
  (gluel (f a)) = gluer (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply Smash_rec_beta_gluel.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk122">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : [B, point1],
ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [A, point2]) (<span class="nv">b0</span> : [B, point1]) =&gt; <span class="mi">1</span>) pt b @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluer b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk123"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) @ <span class="mi">1</span> =
(<span class="kr">fun</span> (<span class="nv">a</span> : [A, point2]) (<span class="nv">b</span> : [B, point1]) =&gt; <span class="mi">1</span>) pt b @
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluer b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk124"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1]) 
  (gluer b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk125">rhs napply (ap_compose (pswap _ _) (functor_smash _ _) (gluer b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
  (ap (pswap [A, point2] [B, point1]) (gluer b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk126">rhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) 
  <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk127" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><label class="goal-separator" for="smash-v-chk127"><hr></label><div class="goal-conclusion">ap (pswap [A, point2] [B, point1]) (gluer b) = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk128"><span class="mi">2</span>: <span class="nb">apply</span> Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) =
ap
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) 
  (gluel b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk129">rhs napply Smash_rec_beta_gluel.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (gluer b) =
ap011 sm <span class="mi">1</span>
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) @
gluel ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk12a">lhs napply (ap_compose (functor_smash _ _) (pswap _ _) (gluer b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1])
  (ap
     (functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
     (gluer b)) =
ap011 sm <span class="mi">1</span>
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) @
gluel ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk12b">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (functor_smash
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) 
  (gluer b) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk12c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><label class="goal-separator" for="smash-v-chk12c"><hr></label><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1]) <span class="nl">?Goal</span> =
ap011 sm <span class="mi">1</span>
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) @
gluel ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk12d"><span class="mi">1</span>: <span class="nb">apply</span> Smash_rec_beta_gluer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1])
  (ap011 sm
     (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
     <span class="mi">1</span> @
   gluer ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)) =
ap011 sm <span class="mi">1</span>
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) @
gluel ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk12e">lhs napply ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap011 sm
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) <span class="mi">1</span> @
gluer ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b) =
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smash-v-chk12f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><label class="goal-separator" for="smash-v-chk12f"><hr></label><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1]) <span class="nl">?Goal</span> =
ap011 sm <span class="mi">1</span>
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) @
gluel ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk130"><span class="mi">1</span>: <span class="nb">apply</span> concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1])
  (gluer ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)) =
ap011 sm <span class="mi">1</span>
  (point_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}) @
gluel ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk131">rhs napply concat_1p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>[B, point1]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (pswap [X, f point2] [Y, g point1])
  (gluer ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)) =
gluel ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |} b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply Smash_rec_beta_gluer.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smash-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="smash-v-chk132">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point2</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>point1</var><span class="hyp-type"><b>: </b><span>IsPointed B</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; X</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Smash_ind_FlFr
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
  (functor_smash
     {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
     {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
   o* pswap [A, point2] [B, point1])
  (<span class="kr">fun</span> (<span class="nv">a</span> : [A, point2]) (<span class="nv">b</span> : [B, point1]) =&gt; <span class="mi">1</span>) <span class="mi">1</span> <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">a</span> : [A, point2] =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     ((((ap_compose
           (functor_smash
              {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
              {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
           (pswap [X, f point2] [Y, g point1])
           (gluel a) @
         (ap (ap (pswap [X, f point2] [Y, g point1]))
            (Smash_rec_beta_gluel
               (<span class="kr">fun</span> <span class="nv">a0</span> : [A, point2] =&gt;
                ap011 sm <span class="mi">1</span> (point_eq {| ...; ... |}) @
                gluel ({| ...; ... |} a0))
               (<span class="kr">fun</span> <span class="nv">b</span> : [B, point1] =&gt;
                ap011 sm (point_eq {| ...; ... |}) <span class="mi">1</span> @
                gluer ({| ...; ... |} b)) a) @
          (ap
             (ap
                (Smash_rec 
                   (flip sm) auxr auxl gluer gluel))
             (concat_1p (gluel (f a))) @
           (Smash_rec_beta_gluel gluer gluel (f a) @
            (concat_1p (gluer (f a)))^)
           :
           ap (pswap [X, f point2] [Y, g point1])
             (ap011 sm <span class="mi">1</span> (point_eq {| ...; ... |}) @
              gluel ({| ...; ... |} a)) =
           ap011 sm
             (point_eq
                {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
             <span class="mi">1</span> @
           gluer
             ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} a)))) @
        (Smash_rec_beta_gluer
           (<span class="kr">fun</span> <span class="nv">a0</span> : [B, point1] =&gt;
            ap011 sm <span class="mi">1</span>
              (point_eq
                 {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) @
            gluel
              ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                 a0)
            :
            (<span class="kr">fun</span> (<span class="nv">a1</span> : [B, point1]) (<span class="nv">b</span> : [A, point2])
             =&gt;
             sm
               ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                  a1)
               ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
                  b)) a0 pt = auxl)
           (<span class="kr">fun</span> <span class="nv">b</span> : [A, point2] =&gt;
            ap011 sm
              (point_eq
                 {|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |}) <span class="mi">1</span> @
            gluer
              ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
                 b)
            :
            (<span class="kr">fun</span> (<span class="nv">a0</span> : [B, point1]) (<span class="nv">b0</span> : [A, point2])
             =&gt;
             sm
               ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                  a0)
               ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
                  b0)) pt b = auxr) a)^) @
       (ap
          (ap
             (functor_smash
                {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}))
          (Smash_rec_beta_gluel gluer gluel a))^) @
      (ap_compose (pswap [A, point2] [B, point1])
         (functor_smash
            {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
            {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
         (gluel a))^))
  (<span class="kr">fun</span> <span class="nv">b</span> : [B, point1] =&gt;
   <span class="kr">let</span> <span class="nv">X0</span> := equiv_fun equiv_p1_1q <span class="kr">in</span>
   X0
     ((((ap_compose
           (functor_smash
              {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
              {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |})
           (pswap [X, f point2] [Y, g point1])
           (gluer b) @
         (ap (ap (pswap [X, f point2] [Y, g point1]))
            (Smash_rec_beta_gluer
               (<span class="kr">fun</span> <span class="nv">a</span> : [A, point2] =&gt;
                ap011 sm <span class="mi">1</span> (point_eq {| ...; ... |}) @
                gluel ({| ...; ... |} a))
               (<span class="kr">fun</span> <span class="nv">b0</span> : [B, point1] =&gt;
                ap011 sm (point_eq {| ...; ... |}) <span class="mi">1</span> @
                gluer ({| ...; ... |} b0)) b) @
          (ap (ap (pswap [X, f point2] [Y, g point1]))
             (concat_1p (gluer ({| ...; ... |} b))) @
           (Smash_rec_beta_gluer gluer gluel
              ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                 (snd (pt, b))) @
            (concat_1p (gluel ({| ... |} b)))^)))) @
        (Smash_rec_beta_gluel
           (<span class="kr">fun</span> <span class="nv">a</span> : [B, point1] =&gt;
            ap011 sm <span class="mi">1</span>
              (point_eq
                 {|
                   pointed_fun := f; dpoint_eq := <span class="mi">1</span>
                 |}) @
            gluel
              ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                 a)
            :
            (<span class="kr">fun</span> (<span class="nv">a0</span> : [B, point1]) (<span class="nv">b0</span> : [A, point2])
             =&gt;
             sm
               ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                  a0)
               ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
                  b0)) a pt = auxl)
           (<span class="kr">fun</span> <span class="nv">b0</span> : [A, point2] =&gt;
            ap011 sm
              (point_eq
                 {|
                   pointed_fun := g; dpoint_eq := <span class="mi">1</span>
                 |}) <span class="mi">1</span> @
            gluer
              ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
                 b0)
            :
            (<span class="kr">fun</span> (<span class="nv">a</span> : [B, point1]) (<span class="nv">b1</span> : [A, point2])
             =&gt;
             sm
               ({| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                  a)
               ({| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
                  b1)) pt b0 = auxr) b)^) @
       (ap
          (ap
             (functor_smash
                {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
                {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}))
          (Smash_rec_beta_gluer gluer gluel b))^) @
      (ap_compose (pswap [A, point2] [B, point1])
         (functor_smash
            {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
            {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})
         (gluer b))^)) pt =
dpoint_eq
  (pswap [X, f point2] [Y, g point1]
   o* functor_smash
        {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
        {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}) @
(dpoint_eq
   (functor_smash
      {| pointed_fun := g; dpoint_eq := <span class="mi">1</span> |}
      {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
    o* pswap [A, point2] [B, point1]))^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
