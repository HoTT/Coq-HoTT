<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>SixTerm.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT.WildCat <span class="kn">Require Import</span> Core Opposite Equiv Bifunctor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core Pointed.pTrunc Pointed.pEquiv
  Modalities.ReflectiveSubuniverse Truncations.Core Truncations.SeparatedTrunc
  AbGroups Homotopy.ExactSequence Spaces.Int Spaces.FreeInt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT.Algebra.AbSES <span class="kn">Require Import</span> Core Pullback Pushout BaerSum
  Ext PullbackFiberSequence.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HSet.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The contravariant six-term sequence of Ext *)</span>

<span class="sd">(** We construct the contravariant six-term exact sequence of Ext groups associated to any short exact sequence [A -&gt; E -&gt; B] and coefficient group [G]. The existence of this exact sequence follows from the final result in [PullbackFiberSequence]. However, with that definition it becomes a bit tricky to show that the connecting map is given by pushing out [E]. Instead, we give a direct proof.</span>

<span class="sd">  As an application, we use the six-term exact sequence to show that [Ext Z/n A] is isomorphic to [A/n], for nonzero natural numbers [n]. (See [ext_cyclic_ab].) *)</span>

<span class="sd">(** Exactness of [0 -&gt; ab_hom B G -&gt; ab_hom E G] follows from the rightmost map being an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk1"><span class="kn">Definition</span> <span class="nf">isexact_abses_sixterm_i</span> `{Funext}
  {B A G : AbGroup} (E : AbSES B A)
  : IsExact (Tr (-<span class="mi">1</span>))
      (pconst : pUnit -&gt;* ab_hom B G)
      (fmap10 (A:=Group^op) ab_hom (projection E) G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (pconst : pUnit -&gt;* ab_hom B G)
  (fmap10 ab_hom (projection E) G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (pconst : pUnit -&gt;* ab_hom B G)
  (fmap10 ab_hom (projection E) G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk3"><span class="nb">apply</span> isexact_purely_O.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact Identity.purely pconst
  (fmap10 ab_hom (projection E) G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk4">rapply isexact_homotopic_i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk5"><hr></label><div class="goal-conclusion">IsExact Identity.purely <span class="nl">?Goal</span>
  (fmap10 ab_hom (projection E) G)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk6"><span class="mi">2</span>: <span class="nb">apply</span> iff_grp_isexact_isembedding.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* grp_trivial_rec (ab_hom B G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk7"><hr></label><div class="goal-conclusion">IsEmbedding (fmap10 ab_hom (projection E) G)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk8"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">apply</span> phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (fmap10 ab_hom (projection E) G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _. <span class="c">(* [isembedding_precompose_surjection_ab] *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Exactness of [ab_hom B G -&gt; ab_hom E G -&gt; ab_hom A G]. One can also deduce this from [isexact_abses_pullback]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk9"><span class="kn">Definition</span> <span class="nf">isexact_ext_contra_sixterm_ii</span> `{Funext}
  {B A G : AbGroup} (E : AbSES B A)
  : IsExact (Tr (-<span class="mi">1</span>))
      (fmap10 (A:=Group^op) ab_hom (projection E) G)
      (fmap10 (A:=Group^op) ab_hom (inclusion E) G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (fmap10 ab_hom (projection E) G)
  (fmap10 ab_hom (inclusion E) G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (fmap10 ab_hom (projection E) G)
  (fmap10 ab_hom (inclusion E) G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chkb">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (fmap10 ab_hom (projection E) G)
  (fmap10 ab_hom (inclusion E) G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chkc"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chkd">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (fmap10 ab_hom (projection E) G)
  (fmap10 ab_hom (inclusion E) G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chke"><span class="nb">apply</span> phomotopy_homotopy_hset; <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap10 ab_hom (inclusion E) G
 o* fmap10 ab_hom (projection E) G) f = pconst f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chkf"><span class="nb">apply</span> equiv_path_grouphomomorphism; <span class="nb">intro</span> b; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom B G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (projection E (inclusion E b)) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk10"><span class="nb">refine</span> (ap f _ @ grp_homo_unit f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom B G</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E b) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isexact_inclusion_projection.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk11">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (phomotopy_homotopy_hset
        ((<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
          <span class="kr">let</span> <span class="nv">X</span> :=
            equiv_fun equiv_path_grouphomomorphism <span class="kr">in</span>
          X
            ((<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
              ap f
                (<span class="kr">let</span> <span class="nv">X0</span> :=
                   <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
                 <span class="kr">let</span> <span class="nv">X1</span> :=
                   <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt;
                   pointed_fun (X0 a) <span class="kr">in</span>
                 X1 E b) @ grp_homo_unit f
              :
              (fmap10 ab_hom (inclusion E) G
               o* fmap10 ab_hom (projection E) G) f b =
              pconst f b)
             :
             (fmap10 ab_hom (inclusion E) G
              o* fmap10 ab_hom (projection E) G) f ==
             pconst f))
         :
         fmap10 ab_hom (inclusion E) G
         o* fmap10 ab_hom (projection E) G == pconst)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk12"><span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : pFiber.pfiber (fmap10 ab_hom (inclusion E) G),
IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
            <span class="kr">let</span> <span class="nv">X</span> :=
              equiv_fun equiv_path_grouphomomorphism
              <span class="kr">in</span>
            X
              (<span class="kr">fun</span> <span class="nv">b0</span> : A =&gt;
               ap f
                 (<span class="kr">let</span> <span class="nv">X0</span> :=
                    <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact
                    <span class="kr">in</span>
                  <span class="kr">let</span> <span class="nv">X1</span> :=
                    <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt;
                    pointed_fun (X0 a) <span class="kr">in</span>
                  X1 E b0) @ grp_homo_unit f)))) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk13"><span class="nb">intros</span> [f q]; rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
            <span class="kr">let</span> <span class="nv">X</span> :=
              equiv_fun equiv_path_grouphomomorphism
              <span class="kr">in</span>
            X
              (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
               ap f
                 (<span class="kr">let</span> <span class="nv">X0</span> :=
                    <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact
                    <span class="kr">in</span>
                  <span class="kr">let</span> <span class="nv">X1</span> :=
                    <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt;
                    pointed_fun (X0 a) <span class="kr">in</span>
                  X1 E b) @ grp_homo_unit f)))) (f; q))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk14">srefine (tr (_; _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_hom B G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk15"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : ab_hom B G =&gt;
 cxfib
   (phomotopy_homotopy_hset
      (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
       <span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_path_grouphomomorphism
         <span class="kr">in</span>
       X
         (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
          ap f
            (<span class="kr">let</span> <span class="nv">X0</span> :=
               <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">X1</span> :=
               <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt;
               pointed_fun (X0 a) <span class="kr">in</span>
             X1 E b) @ grp_homo_unit f))) x = (f; q))
  <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk16">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_hom B G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk17"><span class="nb">refine</span> (grp_homo_compose _ (abses_cokernel_iso (inclusion E) (projection E))^-<span class="mi">1</span>$).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (ab_cokernel (inclusion E)) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk18"><span class="nb">apply</span> (quotient_abgroup_rec _ _ f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : E,
grp_image (inclusion E) n -&gt; f n = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk19"><span class="nb">intros</span> e; rapply Trunc_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : A &amp; inclusion E x = e} -&gt; f e = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk1a"><span class="nb">intros</span> [b r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>inclusion E b = e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f e = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk1b"><span class="nb">refine</span> (ap f r^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>inclusion E b = e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (inclusion E b) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_path_grouphomomorphism^-<span class="mi">1</span> q _).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk1c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : ab_hom B G =&gt;
 cxfib
   (phomotopy_homotopy_hset
      (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
       <span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_path_grouphomomorphism
         <span class="kr">in</span>
       X
         (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
          ap f
            (<span class="kr">let</span> <span class="nv">X0</span> :=
               <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">X1</span> :=
               <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt;
               pointed_fun (X0 a) <span class="kr">in</span>
             X1 E b) @ grp_homo_unit f))) x = (f; q))
  (grp_homo_compose
     (quotient_abgroup_rec (grp_image (inclusion E)) G
        f
        (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
         Trunc_ind
           (<span class="kr">fun</span>
              <span class="nv">_</span> : Trunc (-<span class="mi">1</span>)
                    {x : A &amp; inclusion E x = e} =&gt;
            f e = mon_unit)
           (<span class="kr">fun</span> <span class="nv">a</span> : {x : A &amp; inclusion E x = e} =&gt;
            (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">r</span> : inclusion E b = e) =&gt;
             ap f r^ @
             equiv_path_grouphomomorphism^-<span class="mi">1</span> q b) a.<span class="mi">1</span>
              a.<span class="mi">2</span>)))
     (abses_cokernel_iso (inclusion E) (projection E))^-<span class="mi">1</span>$)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk1d"><span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib
  (phomotopy_homotopy_hset
     (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
      <span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_path_grouphomomorphism
        <span class="kr">in</span>
      X
        (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
         ap f
           (<span class="kr">let</span> <span class="nv">X0</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact
              <span class="kr">in</span>
            <span class="kr">let</span> <span class="nv">X1</span> :=
              <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X0 a)
              <span class="kr">in</span>
            X1 E b) @ grp_homo_unit f)))
  (grp_homo_compose
     (quotient_abgroup_rec (grp_image (inclusion E)) G
        f
        (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
         Trunc_ind
           (<span class="kr">fun</span>
              <span class="nv">_</span> : Trunc (-<span class="mi">1</span>)
                    {x : A &amp; inclusion E x = e} =&gt;
            f e = mon_unit)
           (<span class="kr">fun</span> <span class="nv">a</span> : {x : A &amp; inclusion E x = e} =&gt;
            ap f (a.<span class="mi">2</span>)^ @
            equiv_path_grouphomomorphism^-<span class="mi">1</span> q a.<span class="mi">1</span>)))
     (abses_cokernel_iso (inclusion E) (projection E))^-<span class="mi">1</span>$) =
(f; q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk1e"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cxfib
   (phomotopy_homotopy_hset
      (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
       <span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_path_grouphomomorphism
         <span class="kr">in</span>
       X
         (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
          ap f
            (<span class="kr">let</span> <span class="nv">X0</span> :=
               <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
             <span class="kr">let</span> <span class="nv">X1</span> :=
               <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt;
               pointed_fun (X0 a) <span class="kr">in</span>
             X1 E b) @ grp_homo_unit f)))
   (grp_homo_compose
      (quotient_abgroup_rec (grp_image (inclusion E))
         G f
         (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
          Trunc_ind
            (<span class="kr">fun</span>
               <span class="nv">_</span> : Trunc (-<span class="mi">1</span>)
                     {x : A &amp; inclusion E x = e} =&gt;
             f e = mon_unit)
            (<span class="kr">fun</span> <span class="nv">a</span> : {x : A &amp; inclusion E x = e} =&gt;
             ap f (a.<span class="mi">2</span>)^ @
             equiv_path_grouphomomorphism^-<span class="mi">1</span> q a.<span class="mi">1</span>)))
      (abses_cokernel_iso (inclusion E) (projection E))^-<span class="mi">1</span>$)).<span class="mi">1</span> =
(f; q).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk1f"><span class="nb">apply</span> equiv_path_grouphomomorphism; <span class="nb">unfold</span> pr1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cxfib
   (phomotopy_homotopy_hset
      (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
       equiv_path_grouphomomorphism
         (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
          ap f (cx_isexact b) @ grp_homo_unit f)))
   (grp_homo_compose
      (quotient_abgroup_rec (grp_image (inclusion E))
         G f
         (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
          Trunc_ind
            (<span class="kr">fun</span>
               <span class="nv">_</span> : Trunc (-<span class="mi">1</span>)
                     {x : A &amp; inclusion E x = e} =&gt;
             f e = mon_unit)
            (<span class="kr">fun</span> <span class="nv">a</span> : {x : A &amp; inclusion E x = e} =&gt;
             ap f (a.<span class="mi">2</span>)^ @
             equiv_path_grouphomomorphism^-<span class="mi">1</span> q a.<span class="mi">1</span>)))
      (abses_cokernel_iso (inclusion E) (projection E))^-<span class="mi">1</span>$)).<span class="mi">1</span> ==
f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk20"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>fmap10 ab_hom (inclusion E) G f = pt</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(cxfib
   (phomotopy_homotopy_hset
      (<span class="kr">fun</span> <span class="nv">f</span> : ab_hom B G =&gt;
       equiv_path_grouphomomorphism
         (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt;
          ap f (cx_isexact b) @ grp_homo_unit f)))
   (grp_homo_compose
      (quotient_abgroup_rec (grp_image (inclusion E))
         G f
         (<span class="kr">fun</span> <span class="nv">e</span> : E =&gt;
          Trunc_ind
            (<span class="kr">fun</span>
               <span class="nv">_</span> : Trunc (-<span class="mi">1</span>)
                     {x : A &amp; inclusion E x = e} =&gt;
             f e = mon_unit)
            (<span class="kr">fun</span> <span class="nv">a</span> : {x : A &amp; inclusion E x = e} =&gt;
             ap f (a.<span class="mi">2</span>)^ @
             equiv_path_grouphomomorphism^-<span class="mi">1</span> q a.<span class="mi">1</span>)))
      (abses_cokernel_iso (inclusion E) (projection E))^-<span class="mi">1</span>$)).<span class="mi">1</span>
  x = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (quotient_abgroup_rec _ _ f _)
            (abses_cokernel_iso_inv_beta _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Exactness of [ab_hom E G -&gt; ab_hom A G -&gt; Ext B G] *)</span>

<span class="sd">(** If a pushout [abses_pushout alpha E] is trivial, then [alpha] factors through [inclusion E]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk21"><span class="kn">Lemma</span> <span class="nf">abses_pushout_trivial_factors_inclusion</span> `{Univalence}
  {B A A&#39; : AbGroup} (alpha : A $-&gt; A&#39;) (E : AbSES B A)
  : abses_pushout alpha E = pt -&gt; <span class="kr">exists</span> <span class="nv">phi</span>, alpha = phi $o inclusion E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout alpha E = pt -&gt;
{phi : E $-&gt; A&#39; &amp; alpha = phi $o inclusion E}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout alpha E = pt -&gt;
{phi : E $-&gt; A&#39; &amp; alpha = phi $o inclusion E}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk23">equiv_intros (equiv_path_abses (E:=abses_pushout alpha E) (F:=pt)) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data (abses_pushout alpha E) pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : E $-&gt; A&#39; &amp; alpha = phi $o inclusion E}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk24"><span class="nb">destruct</span> p <span class="kr">as</span> [phi [p q]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : E $-&gt; A&#39; &amp; alpha = phi $o inclusion E}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk25"><span class="kr">exists</span> (<span class="nv">ab_biprod_pr1</span> $o phi $o ab_pushout_inr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">alpha =
ab_biprod_pr1 $o phi $o ab_pushout_inr $o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk26"><span class="nb">apply</span> equiv_path_grouphomomorphism; <span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">alpha a =
(ab_biprod_pr1 $o phi $o ab_pushout_inr $o inclusion E)
  a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We embed into the biproduct and prove equality there. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk27"><span class="nb">apply</span> (isinj_embedding (@ab_biprod_inl A&#39; B) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_inl (alpha a) =
ab_biprod_inl
  ((ab_biprod_pr1 $o phi $o ab_pushout_inr $o
    inclusion E) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk28"><span class="nb">refine</span> ((p (alpha a))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(phi $o inclusion (abses_pushout alpha E)) (alpha a) =
ab_biprod_inl
  ((ab_biprod_pr1 $o phi $o ab_pushout_inr $o
    inclusion E) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk29"><span class="nb">refine</span> (ap phi _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pushout alpha E) (alpha a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk2a"><hr></label><div class="goal-conclusion">phi <span class="nl">?Goal</span> =
ab_biprod_inl
  ((ab_biprod_pr1 $o phi $o ab_pushout_inr $o
    inclusion E) a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk2b"><span class="mi">1</span>: <span class="bp">exact</span> (left_square (abses_pushout_morphism E alpha) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">phi
  ((component2 (abses_pushout_morphism E alpha) $o
    inclusion E) a) =
ab_biprod_inl
  ((ab_biprod_pr1 $o phi $o ab_pushout_inr $o
    inclusion E) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk2c"><span class="nb">apply</span> (path_prod&#39; idpath).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  (phi
     ((component2 (abses_pushout_morphism E alpha) $o
       inclusion E) a)) =
grp_homo_const
  ((ab_biprod_pr1 $o phi $o ab_pushout_inr $o
    inclusion E) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk2d"><span class="nb">refine</span> ((q _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pushout alpha E)
  ((component2 (abses_pushout_morphism E alpha) $o
    inclusion E) a) =
grp_homo_const
  ((ab_biprod_pr1 $o phi $o ab_pushout_inr $o
    inclusion E) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk2e"><span class="nb">refine</span> (right_square (abses_pushout_morphism E alpha) _ @ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, A'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>alpha</var><span class="hyp-type"><b>: </b><span>A $-&gt; A&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>abses_pushout alpha E $-&gt; pt</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>phi $o inclusion (abses_pushout alpha E) ==
inclusion pt</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection (abses_pushout alpha E) ==
projection pt $o phi</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E a) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isexact_inclusion_projection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk2f"><span class="kn">Instance</span> <span class="nf">isexact_ext_contra_sixterm_iii</span>@{u v +} `{Univalence}
  {B A G : AbGroup@{u}} (E : AbSES@{u v} B A)
  : IsExact (Tr (-<span class="mi">1</span>))
      (fmap10 (A:=Group^op) ab_hom (inclusion E) G)
      (abses_pushout_ext E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (fmap10 ab_hom (inclusion E) G)
  (abses_pushout_ext E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (fmap10 ab_hom (inclusion E) G)
  (abses_pushout_ext E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk31">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (fmap10 ab_hom (inclusion E) G)
  (abses_pushout_ext E)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk32"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (fmap10 ab_hom (inclusion E) G)
  (abses_pushout_ext E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk34"><span class="nb">apply</span> phomotopy_homotopy_hset; <span class="nb">intro</span> g; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tr
  (abses_pushout (grp_homo_compose g (inclusion E)) E) =
tr ispointed_abses</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* this equation holds purely *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk35"><span class="nb">apply</span> (ap tr@{v}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (grp_homo_compose g (inclusion E)) E =
ispointed_abses</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk36"><span class="nb">refine</span> (abses_pushout_compose _ _ _ @ ap _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout (inclusion E) E = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk37"><hr></label><div class="goal-conclusion">abses_pushout g <span class="nl">?Goal</span> = ispointed_abses</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk38"><span class="mi">1</span>: <span class="nb">apply</span> abses_pushout_inclusion.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom E G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout g pt = ispointed_abses</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_point.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (phomotopy_homotopy_hset
        ((<span class="kr">fun</span> <span class="nv">g</span> : ab_hom E G =&gt;
          ap tr
            ((abses_pushout_compose (inclusion E) g E @
              ap (abses_pushout g)
                (abses_pushout_inclusion E)) @
             abses_pushout_point g)
          :
          (abses_pushout_ext E
           o* fmap10 ab_hom (inclusion E) G) g =
          pconst g)
         :
         abses_pushout_ext E
         o* fmap10 ab_hom (inclusion E) G == pconst)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk3a"><span class="nb">intros</span> [F p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout_ext E F = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom E G =&gt;
            ap tr
              ((abses_pushout_compose (inclusion E) g
                  E @
                ap (abses_pushout g)
                  (abses_pushout_inclusion E)) @
               abses_pushout_point g)))) (F; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* since we are proving a proposition, we may convert [p] to an actual path *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk3b"><span class="nb">pose proof</span> (p&#39; := (equiv_path_Tr _ _)^-<span class="mi">1</span> p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout_ext E F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>)
  (fmap
     ((AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>) B)
     F E = pt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom E G =&gt;
            ap tr
              ((abses_pushout_compose (inclusion E) g
                  E @
                ap (abses_pushout g)
                  (abses_pushout_inclusion E)) @
               abses_pushout_point g)))) (F; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* slightly faster than [strip_truncations]: *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk3c"><span class="nb">revert</span> p&#39;; <span class="nb">apply</span> Trunc_rec; <span class="nb">intro</span> p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout_ext E F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>fmap ((AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>) B)
  F E = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom E G =&gt;
            ap tr
              ((abses_pushout_compose (inclusion E) g
                  E @
                ap (abses_pushout g)
                  (abses_pushout_inclusion E)) @
               abses_pushout_point g)))) (F; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk3d">rapply contr_inhabited_hprop; <span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout_ext E F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>fmap ((AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>) B)
  F E = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (cxfib
     (phomotopy_homotopy_hset
        (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom E G =&gt;
         ap tr
           ((abses_pushout_compose (inclusion E) g E @
             ap (abses_pushout g)
               (abses_pushout_inclusion E)) @
            abses_pushout_point g)))) (F; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* now we construct a preimage *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk3e"><span class="nb">pose</span> (g := abses_pushout_trivial_factors_inclusion _ E p&#39;);
      <span class="nb">destruct</span> g <span class="kr">as</span> [g k].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout_ext E F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>fmap ((AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>) B)
  F E = pt</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E $-&gt; G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>F = g $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (cxfib
     (phomotopy_homotopy_hset
        (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom E G =&gt;
         ap tr
           ((abses_pushout_compose (inclusion E) g E @
             ap (abses_pushout g)
               (abses_pushout_inclusion E)) @
            abses_pushout_point g)))) (F; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk3f"><span class="kr">exists</span> <span class="nv">g</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout_ext E F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>fmap ((AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>) B)
  F E = pt</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E $-&gt; G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>F = g $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib
  (phomotopy_homotopy_hset
     (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom E G =&gt;
      ap tr
        ((abses_pushout_compose (inclusion E) g E @
          ap (abses_pushout g)
            (abses_pushout_inclusion E)) @
         abses_pushout_point g))) g = (F; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk40"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pushout_ext E F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>fmap ((AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>) B)
  F E = pt</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>E $-&gt; G</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>F = g $o inclusion E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose g (inclusion E) = F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> k^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Exactness of [ab_hom A G -&gt; Ext1 B G -&gt; Ext1 E G]. *)</span>

<span class="sd">(** We construct a morphism which witnesses exactness. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk41"><span class="kn">Definition</span> <span class="nf">isexact_ext_contra_sixterm_iv_mor</span> `{Univalence}
  {B A G : AbGroup} (E : AbSES B A)
  (F : AbSES B G) (p : abses_pullback (projection E) F = pt)
  : AbSESMorphism E F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk43"><span class="nb">pose</span> (p&#39; := equiv_path_abses^-<span class="mi">1</span> p^);
    <span class="nb">destruct</span> p&#39; <span class="kr">as</span> [p&#39; [pl pr]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk44">srefine (Build_AbSESMorphism _ _ grp_homo_id _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk45"><hr></label><div class="goal-conclusion">E $-&gt; F</div></blockquote><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk46"><hr></label><div class="goal-conclusion">inclusion F $o <span class="nl">?component1</span> ==
<span class="nl">?component2</span> $o inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk47"><hr></label><div class="goal-conclusion">projection F $o <span class="nl">?component2</span> ==
grp_homo_id $o projection E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk48">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk49"><span class="nb">refine</span> (grp_homo_compose
              (grp_iso_inverse
                 (abses_kernel_iso (inclusion F) (projection F))) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A (ab_kernel (projection F))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* now it&#39;s easy to construct map into the kernel *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk4a">snapply grp_kernel_corec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A $-&gt; F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk4b"><hr></label><div class="goal-conclusion">projection F $o <span class="nl">?g</span> == grp_homo_const</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk4c"><span class="mi">1</span>: <span class="bp">exact</span> (grp_pullback_pr1 _ _ $o p&#39; $o ab_biprod_inr $o inclusion E).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F $o
(grp_pullback_pr1 (projection F) (projection E) $o p&#39; $o
 ab_biprod_inr $o inclusion E) == grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk4d"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(projection F $o
 (grp_pullback_pr1 (projection F) (projection E) $o p&#39; $o
  ab_biprod_inr $o inclusion E)) x = grp_homo_const x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk4e"><span class="nb">refine</span> (right_square (abses_pullback_morphism F _) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(component3 (abses_pullback_morphism F (projection E)) $o
 projection (abses_pullback (projection E) F))
  (p&#39; (ab_biprod_inr (inclusion E x))) =
grp_homo_const x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk4f"><span class="nb">refine</span> (ap (projection E) (pr _)^ @ _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E x) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isexact_inclusion_projection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_pullback_pr1 _ _ $o p&#39; $o ab_biprod_inr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F $o
grp_homo_compose
  (grp_iso_inverse
     (abses_kernel_iso (inclusion F) (projection F)))
  (grp_kernel_corec
     (grp_pullback_pr1 (projection F) (projection E) $o
      p&#39; $o ab_biprod_inr $o inclusion E)
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       right_square
         (abses_pullback_morphism F (projection E))
         (p&#39; (ab_biprod_inr (inclusion E x))) @
       (ap (projection E)
          (pr (ab_biprod_inr (inclusion E x)))^ @
        ((<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
          <span class="kr">let</span> <span class="nv">X0</span> :=
            <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
          X0 E x)
         :
         projection E
           (projection pt
              (ab_biprod_inr (inclusion E x))) =
         grp_homo_const x)))
      :
      projection F $o
      (grp_pullback_pr1 (projection F) (projection E) $o
       p&#39; $o ab_biprod_inr $o inclusion E) ==
      grp_homo_const)) ==
grp_pullback_pr1 (projection F) (projection E) $o p&#39; $o
ab_biprod_inr $o inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk52"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(inclusion F $o
 grp_homo_compose
   (grp_iso_inverse
      (abses_kernel_iso (inclusion F) (projection F)))
   (grp_kernel_corec
      (grp_pullback_pr1 (projection F) (projection E) $o
       p&#39; $o ab_biprod_inr $o inclusion E)
      (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       right_square
         (abses_pullback_morphism F (projection E))
         (p&#39; (ab_biprod_inr (inclusion E x))) @
       (ap (projection E)
          (pr (ab_biprod_inr (inclusion E x)))^ @
        (<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
         <span class="kr">let</span> <span class="nv">X0</span> :=
           <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
         X0 E x))))) a =
(grp_pullback_pr1 (projection F) (projection E) $o p&#39; $o
 ab_biprod_inr $o inclusion E) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply abses_kernel_iso_inv_beta.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F $o
(grp_pullback_pr1 (projection F) (projection E) $o p&#39; $o
 ab_biprod_inr) == grp_homo_id $o projection E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk54"><span class="nb">intro</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(projection F $o
 (grp_pullback_pr1 (projection F) (projection E) $o p&#39; $o
  ab_biprod_inr)) e = (grp_homo_id $o projection E) e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk55"><span class="nb">refine</span> (right_square (abses_pullback_morphism F _) _
              @ ap (projection E) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>pt $-&gt; abses_pullback (projection E) F</span></span></span><br><span><var>pl</var><span class="hyp-type"><b>: </b><span>p&#39; $o inclusion pt ==
inclusion (abses_pullback (projection E) F)</span></span></span><br><span><var>pr</var><span class="hyp-type"><b>: </b><span>projection pt ==
projection (abses_pullback (projection E) F) $o
p&#39;</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback (projection E) F)
  (p&#39; (ab_biprod_inr e)) = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pr _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk56"><span class="kn">Instance</span> <span class="nf">isexact_ext_contra_sixterm_iv</span> `{Univalence}
  {B A G : AbGroup@{u}} (E : AbSES@{u v} B A)
  : IsExact (Tr (-<span class="mi">1</span>)) (abses_pushout_ext E)
      (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (A:=G) (projection E))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (abses_pushout_ext E)
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (abses_pushout_ext E)
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk58">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (abses_pushout_ext E)
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk59"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (abses_pushout_ext E)
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk5b"><span class="nb">apply</span> phomotopy_homotopy_hset; <span class="nb">intro</span> g; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tr (abses_pullback (projection E) (abses_pushout g E)) =
tr ispointed_abses</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* this equation holds purely *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk5c"><span class="nb">apply</span> (ap tr@{v}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (projection E) (abses_pushout g E) =
ispointed_abses</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk5d"><span class="nb">refine</span> ((abses_pushout_pullback_reorder _ _ _)^
              @ ap _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (projection E) E = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk5e"><hr></label><div class="goal-conclusion">abses_pushout g <span class="nl">?Goal</span> = ispointed_abses</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk5f"><span class="mi">1</span>: <span class="bp">exact</span> (abses_pullback_projection _)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>ab_hom A G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pushout g pt = ispointed_abses</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pushout_point.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* since we are proving a proposition, we may convert [p] to an actual path *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (phomotopy_homotopy_hset
        ((<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
          ap tr
            (((abses_pushout_pullback_reorder E g
                 (projection E))^ @
              ap (abses_pushout g)
                (abses_pullback_projection E)^) @
             abses_pushout_point g)
          :
          (fmap (pTr <span class="mi">0</span>)
             (abses_pullback_pmap (projection E))
           o* abses_pushout_ext E) g = pconst g)
         :
         fmap (pTr <span class="mi">0</span>)
           (abses_pullback_pmap (projection E))
         o* abses_pushout_ext E == pconst)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk61"><span class="nb">intros</span> [F p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>ab_ext B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E))
  F = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
            ap tr
              (((abses_pushout_pullback_reorder E g
                   (projection E))^ @
                ap (abses_pushout g)
                  (abses_pullback_projection E)^) @
               abses_pushout_point g)))) (F; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk62"><span class="nb">revert dependent</span> F; napply (Trunc_ind (n:=<span class="mi">0</span>) (A:=AbSES B G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (AbSES B G),
IsHSet
  (<span class="kr">forall</span>
   <span class="nv">p</span> : fmap (pTr <span class="mi">0</span>)
         (abses_pullback_pmap (projection E)) aa = pt,
   IsConnected (Tr (-<span class="mi">1</span>))
     (hfiber
        (cxfib
           (phomotopy_homotopy_hset
              (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
               ap tr
                 (((abses_pushout_pullback_reorder E g
                      (projection E))^ @
                   ap (abses_pushout g)
                     (abses_pullback_projection E)^) @
                  abses_pushout_point g)))) (aa; p)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk63"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : AbSES B G)
(<span class="nv">p</span> : fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E))
       (tr a) = pt),
IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
            ap tr
              (((abses_pushout_pullback_reorder E g
                   (projection E))^ @
                ap (abses_pushout g)
                  (abses_pullback_projection E)^) @
               abses_pushout_point g)))) (tr a; p))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* [exact _.] works here, but is slow. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk64">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (AbSES B G),
IsHSet
  (<span class="kr">forall</span>
   <span class="nv">p</span> : fmap (pTr <span class="mi">0</span>)
         (abses_pullback_pmap (projection E)) aa = pt,
   IsConnected (Tr (-<span class="mi">1</span>))
     (hfiber
        (cxfib
           (phomotopy_homotopy_hset
              (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
               ap tr
                 (((abses_pushout_pullback_reorder E g
                      (projection E))^ @
                   ap (abses_pushout g)
                     (abses_pullback_projection E)^) @
                  abses_pushout_point g)))) (aa; p)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk65"><span class="nb">intro</span> x; napply istrunc_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Trunc <span class="mi">0</span> (AbSES B G)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">a</span> : fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E))
      x = pt,
IsHSet
  (IsConnected (Tr (-<span class="mi">1</span>))
     (hfiber
        (cxfib
           (phomotopy_homotopy_hset
              (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
               ap tr
                 (((abses_pushout_pullback_reorder E g
                      (projection E))^ @
                   ap (abses_pushout g)
                     (abses_pullback_projection E)^) @
                  abses_pushout_point g)))) (x; a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> y; <span class="bp">exact</span> (istrunc_leq (trunc_index_leq_succ _)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk66">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : AbSES B G)
(<span class="nv">p</span> : fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E))
       (tr a) = pt),
IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
            ap tr
              (((abses_pushout_pullback_reorder E g
                   (projection E))^ @
                ap (abses_pushout g)
                  (abses_pullback_projection E)^) @
               abses_pushout_point g)))) (tr a; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk67"><span class="nb">intro</span> F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">p</span> : fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E))
      (tr F) = pt,
IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
            ap tr
              (((abses_pushout_pullback_reorder E g
                   (projection E))^ @
                ap (abses_pushout g)
                  (abses_pullback_projection E)^) @
               abses_pushout_point g)))) (tr F; p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk68">equiv_intros (equiv_path_Tr (n:=-<span class="mi">1</span>) (abses_pullback (projection E) F) pt) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) (abses_pullback (projection E) F = pt)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
            ap tr
              (((abses_pushout_pullback_reorder E g
                   (projection E))^ @
                ap (abses_pushout g)
                  (abses_pullback_projection E)^) @
               abses_pushout_point g))))
     (tr F;
     equiv_path_Tr (abses_pullback (projection E) F)
       pt p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk69">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (phomotopy_homotopy_hset
           (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
            ap tr
              (((abses_pushout_pullback_reorder E g
                   (projection E))^ @
                ap (abses_pushout g)
                  (abses_pullback_projection E)^) @
               abses_pushout_point g))))
     (tr F;
     equiv_path_Tr (abses_pullback (projection E) F)
       pt (tr p)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk6a">rapply contr_inhabited_hprop; <span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (cxfib
     (phomotopy_homotopy_hset
        (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
         ap tr
           (((abses_pushout_pullback_reorder E g
                (projection E))^ @
             ap (abses_pushout g)
               (abses_pullback_projection E)^) @
            abses_pushout_point g))))
  (tr F;
  equiv_path_Tr (abses_pullback (projection E) F) pt
    (tr p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk6b"><span class="nb">pose</span> (g := isexact_ext_contra_sixterm_iv_mor E F p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>isexact_ext_contra_sixterm_iv_mor E F p</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber
  (cxfib
     (phomotopy_homotopy_hset
        (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
         ap tr
           (((abses_pushout_pullback_reorder E g
                (projection E))^ @
             ap (abses_pushout g)
               (abses_pullback_projection E)^) @
            abses_pushout_point g))))
  (tr F;
  equiv_path_Tr (abses_pullback (projection E) F) pt
    (tr p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk6c"><span class="kr">exists</span> (<span class="nv">component1</span> <span class="nv">g</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>isexact_ext_contra_sixterm_iv_mor E F p</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib
  (phomotopy_homotopy_hset
     (<span class="kr">fun</span> <span class="nv">g</span> : ab_hom A G =&gt;
      ap tr
        (((abses_pushout_pullback_reorder E g
             (projection E))^ @
          ap (abses_pushout g)
            (abses_pullback_projection E)^) @
         abses_pushout_point g))) (component1 g) =
(tr F;
equiv_path_Tr (abses_pullback (projection E) F) pt
  (tr p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk6d"><span class="nb">apply</span> path_sigma_hprop, (ap tr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback (projection E) F = pt</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>isexact_ext_contra_sixterm_iv_mor E F p</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap ((AbSES&#39; : AbGroup^op -&gt; AbGroup -&gt; <span class="kt">Type</span>) B)
  (component1 g) E = F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply (abses_pushout_component3_id g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Exactness of [Ext B G -&gt; Ext E G -&gt; Ext A G] *)</span>

<span class="sd">(** This is an immediate consequence of [isexact_abses_pullback]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk6e"><span class="kn">Instance</span> <span class="nf">isexact_ext_contra_sixterm_v</span> `{Univalence}
  {B A G : AbGroup} (E : AbSES B A)
  : IsExact (Tr (-<span class="mi">1</span>))
      (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (A:=G) (projection E)))
      (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (A:=G) (inclusion E))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>))
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E)))
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (inclusion E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>))
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (projection E)))
  (fmap (pTr <span class="mi">0</span>) (abses_pullback_pmap (inclusion E)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk70">rapply isexact_ptr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>B, A, G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (abses_pullback_pmap (projection E))
  (abses_pullback_pmap (inclusion E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isexact_purely_O.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** [Ext Z/n A] is isomorphic to [A/n] *)</span>

<span class="sd">(** An easy consequence of the contravariant six-term exact sequence is that [Ext Z/n A] is isomorphic to the cokernel of the multiplication-by-n endomorphism [A -&gt; A], for any abelian group [A]. This falls out of the six-term exact sequence associated to [Z -&gt; Z -&gt; Z/n] and projectivity of [Z]. A minor point is that the library does not currently contain a proof that multiplication by a nonzero natural number is a self-injection of [Z]. Thus we work directly with the assumption that [Z1_mul_nat n] is an embedding. *)</span>

<span class="sd">(** We define our own cyclic groups using [ab_cokernel_embedding] under the assumption that [Z1_mul_nat n] is an embedding. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cyclic&#39;</span> `{Funext} (n : nat) `{IsEmbedding (Z1_mul_nat n)}
  : AbGroup := ab_cokernel_embedding (Z1_mul_nat n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We first show that [ab_hom Z A -&gt; ab_hom Z A -&gt; Ext (cyclic n) A] is exact. We could inline the proof below, but factoring it out is faster. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Definition</span> <span class="nf">isexact_ext_cyclic_ab_iii</span>@{u v w | u &lt; v, v &lt; w} `{Univalence}
  (n : nat) `{IsEmbedding (Z1_mul_nat n)} {A : AbGroup@{u}}
  : IsExact (Tr (-<span class="mi">1</span>))
      (fmap10 (A:=Group^op) ab_hom (Z1_mul_nat n) A)
      (abses_pushout_ext (abses_from_inclusion (Z1_mul_nat n)))
  := isexact_ext_contra_sixterm_iii
       (abses_from_inclusion (Z1_mul_nat n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We show exactness of [A -&gt; A -&gt; Ext Z/n A] where the first map is multiplication by [n], but considered in universe [v]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk71"><span class="kn">Local Definition</span> <span class="nf">ext_cyclic_exact</span>@{u v w} `{Univalence}
  (n : nat) `{IsEmbedding (Z1_mul_nat n)} {A : AbGroup@{u}}
  : IsExact@{v v v v v} (Tr (-<span class="mi">1</span>))
      (ab_mul (A:=A) n)
      (abses_pushout_ext@{u w v} (abses_from_inclusion (Z1_mul_nat n))
         o* (pequiv_groupisomorphism (equiv_Z1_hom A))^-<span class="mi">1</span>*).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (ab_mul n)
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n))
   o* (equiv_Z1_hom A)^-<span class="mi">1</span>*)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (ab_mul n)
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n))
   o* (equiv_Z1_hom A)^-<span class="mi">1</span>*)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* we first move [equiv_Z1_hom] across the total space *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk73"><span class="nb">apply</span> moveL_isexact_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) ((equiv_Z1_hom A)^-<span class="mi">1</span>* o* ab_mul n)
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* now we change the left map so as to apply exactness at iii from above *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk74">snapply (isexact_homotopic_i (Tr (-<span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;* ab_hom ab_Z1 A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk75"><hr></label><div class="goal-conclusion">(equiv_Z1_hom A)^-<span class="mi">1</span>* o* ab_mul n ==* <span class="nl">?i</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk76"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) <span class="nl">?i</span>
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk77"><span class="mi">1</span>: <span class="bp">exact</span> (fmap10 (A:=Group^op) ab_hom (Z1_mul_nat n) A o*
              (pequiv_inverse
                 (pequiv_groupisomorphism (equiv_Z1_hom A)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_Z1_hom A)^-<span class="mi">1</span>* o* ab_mul n ==*
fmap10 ab_hom (Z1_mul_nat n) A
o* pequiv_inverse (equiv_Z1_hom A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk78"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>))
  (fmap10 ab_hom (Z1_mul_nat n) A
   o* pequiv_inverse (equiv_Z1_hom A))
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_Z1_hom A)^-<span class="mi">1</span>* o* ab_mul n ==*
fmap10 ab_hom (Z1_mul_nat n) A
o* pequiv_inverse (equiv_Z1_hom A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk7a"><span class="nb">apply</span> phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_Z1_hom A)^-<span class="mi">1</span>* o* ab_mul n ==
fmap10 ab_hom (Z1_mul_nat n) A
o* pequiv_inverse (equiv_Z1_hom A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk7b">rapply (equiv_ind (equiv_Z1_hom A)); <span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom ab_Z1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((equiv_Z1_hom A)^-<span class="mi">1</span>* o* ab_mul n) (equiv_Z1_hom A f) =
(fmap10 ab_hom (Z1_mul_nat n) A
 o* pequiv_inverse (equiv_Z1_hom A))
  (equiv_Z1_hom A f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk7c"><span class="nb">refine</span> (_ @ ap _ (eissect _ _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom ab_Z1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((equiv_Z1_hom A)^-<span class="mi">1</span>* o* ab_mul n) (equiv_Z1_hom A f) =
fmap10 ab_hom (Z1_mul_nat n) A f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk7d"><span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom ab_Z1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_Z1_hom A (fmap10 ab_hom (Z1_mul_nat n) A f) =
ab_mul n (equiv_Z1_hom A f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk7e"><span class="nb">refine</span> (ap f _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom ab_Z1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z1_mul_nat n (freegroup_in tt) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom ab_Z1 A</span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk7f"><hr></label><div class="goal-conclusion">f <span class="nl">?Goal</span> = ab_mul n (equiv_Z1_hom A f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk80"><span class="mi">1</span>: <span class="nb">apply</span> Z1_rec_beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ab_hom ab_Z1 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (nat_to_Z1 n) = ab_mul n (equiv_Z1_hom A f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ab_mul_natural f n Z1_gen).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk81">- <span class="c">(* we get rid of [equiv_Z1_hom] *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>))
  (fmap10 ab_hom (Z1_mul_nat n) A
   o* pequiv_inverse (equiv_Z1_hom A))
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk82"><span class="nb">apply</span> isexact_equiv_fiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (fmap10 ab_hom (Z1_mul_nat n) A)
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isexact_ext_cyclic_ab_iii.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The main result of this section. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk83"><span class="kn">Theorem</span> <span class="nf">ext_cyclic_ab</span>@{u v w | u &lt; v, v &lt; w} `{Univalence}
  (n : nat) `{emb : IsEmbedding (Z1_mul_nat n)} {A : AbGroup@{u}}
  : ab_cokernel@{v w} (ab_mul (A:=A) n)
      $&lt;~&gt; ab_ext@{u v} (cyclic&#39;@{u v} n) A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel (ab_mul n) $&lt;~&gt; ab_ext (cyclic&#39; n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We take a large cokernel in order to apply [abses_cokernel_iso]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk84"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel (ab_mul n) $&lt;~&gt; ab_ext (cyclic&#39; n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk85"><span class="nb">pose</span> (E := abses_from_inclusion (Z1_mul_nat n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel (ab_mul n) $&lt;~&gt; ab_ext (cyclic&#39; n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk86">snrefine (abses_cokernel_iso (ab_mul n) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A (ab_ext (cyclic&#39; n) A)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk87"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) <span class="nl">?g</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk88"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (ab_mul n) <span class="nl">?g</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk89">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A (ab_ext (cyclic&#39; n) A)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_compose
             (abses_pushout_ext E)
             (grp_iso_inverse (equiv_Z1_hom A))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk8a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>))
  (grp_homo_compose (abses_pushout_ext E)
     (grp_iso_inverse (equiv_Z1_hom A)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk8b"><span class="nb">apply</span> (conn_map_compose _ (grp_iso_inverse (equiv_Z1_hom A))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (grp_iso_inverse (equiv_Z1_hom A))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk8c"><hr></label><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (abses_pushout_ext E)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk8d"><span class="mi">1</span>: rapply conn_map_isequiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) (abses_pushout_ext E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Coq knows that [Ext Z1 A] is contractible since [Z1] is projective, so exactness at spot iv gives us this: *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnmap_O_isexact_base_contr _ _
             (fmap (pTr <span class="mi">0</span>)
                (abses_pullback_pmap (A:=A)
                   (projection E)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk8e">- <span class="c">(* we change [grp_homo_compose] to [o*] *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (ab_mul n)
  (grp_homo_compose (abses_pushout_ext E)
     (grp_iso_inverse (equiv_Z1_hom A)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk8f">srapply isexact_homotopic_f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt;* ab_ext (cyclic&#39; n) A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk90"><hr></label><div class="goal-conclusion">grp_homo_compose (abses_pushout_ext E)
  (grp_iso_inverse (equiv_Z1_hom A)) ==* <span class="nl">?f</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk91"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (ab_mul n) <span class="nl">?f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk92"><span class="mi">1</span>: <span class="bp">exact</span> (abses_pushout_ext (abses_from_inclusion (Z1_mul_nat n))
                o* (pequiv_groupisomorphism (equiv_Z1_hom A))^-<span class="mi">1</span>*).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose (abses_pushout_ext E)
  (grp_iso_inverse (equiv_Z1_hom A)) ==*
abses_pushout_ext
  (abses_from_inclusion (Z1_mul_nat n))
o* (equiv_Z1_hom A)^-<span class="mi">1</span>*</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sixterm-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><label class="goal-separator" for="sixterm-v-chk93"><hr></label><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (ab_mul n)
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n))
   o* (equiv_Z1_hom A)^-<span class="mi">1</span>*)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sixterm-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="sixterm-v-chk94"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">apply</span> phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>emb</var><span class="hyp-type"><b>: </b><span>IsEmbedding (Z1_mul_nat n)</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span><span class="hyp-body"><b>:= </b><span>abses_from_inclusion (Z1_mul_nat n)</span></span><span class="hyp-type"><b>: </b><span>AbSES
  (QuotientAbGroup ab_Z1
     (grp_image_embedding (Z1_mul_nat n))) ab_Z1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Tr (-<span class="mi">1</span>)) (ab_mul n)
  (abses_pushout_ext
     (abses_from_inclusion (Z1_mul_nat n))
   o* (equiv_Z1_hom A)^-<span class="mi">1</span>*)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ext_cyclic_exact.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
