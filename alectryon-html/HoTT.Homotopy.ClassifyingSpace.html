<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>ClassifyingSpace.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT.WildCat <span class="kn">Require Import</span> Core <span class="kn">Universe</span> <span class="nf">Equiv</span> NatTrans Yoneda.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Cubical.DPath Cubical.PathSquare Cubical.DPathSquare.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.AbGroups.AbelianGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.HSpace.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> TruncType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core Truncations.Connectedness.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.HomotopyGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Homotopy.WhiteheadsPrinciple.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Classifying spaces of groups *)</span>

<span class="sd">(** We define the classifying space of a group to be the following HIT:</span>

<span class="sd">&lt;&lt;</span>
<span class="sd">  HIT ClassifyingSpace (G : Group) : 1-Type</span>
<span class="sd">   | bbase : ClassifyingSpace</span>
<span class="sd">   | bloop : X -&gt; bbase = bbase</span>
<span class="sd">   | bloop_pp : forall x y, bloop (x * y) = bloop x @ bloop y.</span>
<span class="sd">&gt;&gt;</span>

<span class="sd">  We implement this is a private inductive type. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Export</span> ClassifyingSpace.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk1"><span class="kn">Section</span> <span class="nf">ClassifyingSpace</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Trying to mask the absolute name <span class="s2">&quot;ClassifyingSpace.ClassifyingSpace&quot;</span>!
[masking-absolute-name,deprecated-since-<span class="mi">8</span>.<span class="mi">8</span>,deprecated,default]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">Private <span class="kn">Inductive</span> <span class="nf">ClassifyingSpace</span> (<span class="nv">G</span> : Group) :=
      | bbase : ClassifyingSpace G.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">bloop</span> : G -&gt; bbase G = bbase G.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> bbase {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">bloop_pp</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, bloop (x * y) = bloop x @ bloop y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk2">#[export] <span class="kn">Instance</span> <span class="nf">istrunc_ClassifyingSpace</span>
      : IsTrunc <span class="mi">1</span> (ClassifyingSpace G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> (ClassifyingSpace G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> (ClassifyingSpace G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ClassifyingSpace</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> bloop {G} _%_mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now we can state the expected dependent elimination principle, and derive other versions of the elimination principle from it. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ClassifyingSpace_ind</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> dpath_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Note that since our classifying space is 1-truncated, we can only eliminate into 1-truncated type families. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ClassifyingSpace_ind</span>
      (<span class="nv">P</span> : ClassifyingSpace G -&gt; <span class="kt">Type</span>)
      `{<span class="kr">forall</span> <span class="nv">b</span>, IsTrunc <span class="mi">1</span> (P b)}
      (bbase&#39; : P bbase)
      (bloop&#39; : <span class="kr">forall</span> <span class="nv">x</span>, DPath P (bloop x) bbase&#39; bbase&#39;)
      (bloop_pp&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>,  DPathSquare P (sq_G1 (bloop_pp x y))
        (bloop&#39; (x * y)) ((bloop&#39; x) @Dp (bloop&#39; y)) <span class="mi">1</span> <span class="mi">1</span>)
      (b : ClassifyingSpace G)
      : P b
      := <span class="kr">match</span> b <span class="kr">with</span>
            bbase =&gt; (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; bbase&#39;)
         <span class="kr">end</span> bloop&#39; bloop_pp&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Here we state the computation rule for [ClassifyingSpace_ind] over [bloop] as an axiom. We don&#39;t need one for [bloop_pp] since we have a 1-type. We leave this as admitted since the computation rule is an axiom. **)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk4"><span class="kn">Definition</span> <span class="nf">ClassifyingSpace_ind_beta_bloop</span>
      (<span class="nv">P</span> : ClassifyingSpace G -&gt; <span class="kt">Type</span>)
     `{<span class="kr">forall</span> <span class="nv">b</span>, IsTrunc <span class="mi">1</span> (P b)}
      (bbase&#39; : P bbase) (bloop&#39; : <span class="kr">forall</span> <span class="nv">x</span>, DPath P (bloop x) bbase&#39; bbase&#39;)
      (bloop_pp&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>,  DPathSquare P (sq_G1 (bloop_pp x y))
        (bloop&#39; (x * y)) ((bloop&#39; x) @Dp (bloop&#39; y)) <span class="mi">1</span> <span class="mi">1</span>)
      (x : G)
      : apD (ClassifyingSpace_ind P bbase&#39; bloop&#39; bloop_pp&#39;) (bloop x) = bloop&#39; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsTrunc <span class="mi">1</span> (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
DPathSquare P (sq_G1 (bloop_pp x y))
  (bloop&#39; (x * y)) (bloop&#39; x @Dp bloop&#39; y)
  <span class="mi">1</span> <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (ClassifyingSpace_ind P bbase&#39; bloop&#39; bloop_pp&#39;)
  (bloop x) = bloop&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsTrunc <span class="mi">1</span> (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
DPathSquare P (sq_G1 (bloop_pp x y))
  (bloop&#39; (x * y)) (bloop&#39; x @Dp bloop&#39; y)
  <span class="mi">1</span> <span class="mi">1</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (ClassifyingSpace_ind P bbase&#39; bloop&#39; bloop_pp&#39;)
  (bloop x) = bloop&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ClassifyingSpace_ind</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ClassifyingSpace</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Other eliminators *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Eliminators</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The non-dependent eliminator *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk6"><span class="kn">Definition</span> <span class="nf">ClassifyingSpace_rec</span>
    (<span class="nv">P</span> : <span class="kt">Type</span>) `{IsTrunc <span class="mi">1</span> P} (bbase&#39; : P) (bloop&#39; : G -&gt; bbase&#39; = bbase&#39;)
    (bloop_pp&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G, bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y)
    : ClassifyingSpace G -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace G -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace G -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk8">srefine (ClassifyingSpace_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) bbase&#39; _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath (<span class="kr">fun</span> <span class="nv">_</span> : ClassifyingSpace G =&gt; P) (bloop x)
  bbase&#39; bbase&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
DPathSquare (<span class="kr">fun</span> <span class="nv">_</span> : ClassifyingSpace G =&gt; P)
  (sq_G1 (bloop_pp x y)) 
  (<span class="nl">?bloop&#39;</span> (x * y)) (<span class="nl">?bloop&#39;</span> x @Dp <span class="nl">?bloop&#39;</span> y)%dpath
  <span class="mi">1</span>%dpath <span class="mi">1</span>%dpath</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka"><span class="mi">1</span>: <span class="nb">intro</span> x; <span class="nb">apply</span> dp_const, bloop&#39;, x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
DPathSquare (<span class="kr">fun</span> <span class="nv">_</span> : ClassifyingSpace G =&gt; P)
  (sq_G1 (bloop_pp x y))
  ((<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
    <span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x0))
     (x * y))
  ((<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
    <span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x0)) x @Dp
   (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
    <span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x0)) y)%dpath
  <span class="mi">1</span>%dpath <span class="mi">1</span>%dpath</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare (<span class="kr">fun</span> <span class="nv">_</span> : ClassifyingSpace G =&gt; P)
  (sq_G1 (bloop_pp x y))
  ((<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
    <span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x))
     (x * y))
  ((<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
    <span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x)) x @Dp
   (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
    <span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x)) y)%dpath
  <span class="mi">1</span>%dpath <span class="mi">1</span>%dpath</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc"><span class="nb">apply</span> ds_const&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare
  (dp_const^-<span class="mi">1</span>
     (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span>
      X (bloop&#39; (x * y))))
  (dp_const^-<span class="mi">1</span>
     ((<span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x)) @Dp
      (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; y)))%dpath)
  (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath) (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd">rapply sq_GGcc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
dp_const^-<span class="mi">1</span>
  (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; (x * y)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chke"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> =
dp_const^-<span class="mi">1</span>
  ((<span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; x)) @Dp
   (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; y)))%dpath</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkf"><hr></label><div class="goal-conclusion">PathSquare <span class="nl">?Goal</span> <span class="nl">?Goal0</span> 
  (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath) 
  (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk10"><span class="mi">2</span>: <span class="nb">refine</span> (_ @ ap _ (dp_const_pp _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
dp_const^-<span class="mi">1</span>
  (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun dp_const <span class="kr">in</span> X (bloop&#39; (x * y)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk11"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> = dp_const^-<span class="mi">1</span> (dp_const (bloop&#39; x @ bloop&#39; y))</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk12"><hr></label><div class="goal-conclusion">PathSquare <span class="nl">?Goal</span> <span class="nl">?Goal0</span> 
  (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath) 
  (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk13"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">symmetry</span>; <span class="nb">apply</span> eissect.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare (bloop&#39; (x * y)) (bloop&#39; x @ bloop&#39; y)
  (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath) (dp_const^-<span class="mi">1</span> <span class="mi">1</span>%dpath)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> sq_G1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Computation rule for non-dependent eliminator *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk14"><span class="kn">Definition</span> <span class="nf">ClassifyingSpace_rec_beta_bloop</span>
    (<span class="nv">P</span> : <span class="kt">Type</span>) `{IsTrunc <span class="mi">1</span> P} (bbase&#39; : P) (bloop&#39; : G -&gt; bbase&#39; = bbase&#39;)
    (bloop_pp&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G, bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y) (x : G)
    : ap (ClassifyingSpace_rec P bbase&#39; bloop&#39; bloop_pp&#39;) (bloop x) = bloop&#39; x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (ClassifyingSpace_rec P bbase&#39; bloop&#39; bloop_pp&#39;)
  (bloop x) = bloop&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (ClassifyingSpace_rec P bbase&#39; bloop&#39; bloop_pp&#39;)
  (bloop x) = bloop&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk16">lhs_V napply dp_apD_const&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dp_const^-<span class="mi">1</span>
  (apD
     (ClassifyingSpace_rec P bbase&#39; bloop&#39; bloop_pp&#39;)
     (bloop x)) = bloop&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk17"><span class="nb">apply</span> moveR_equiv_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (ClassifyingSpace_rec P bbase&#39; bloop&#39; bloop_pp&#39;)
  (bloop x) = dp_const (bloop&#39; x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply ClassifyingSpace_ind_beta_bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Sometimes we want to induct into a set which means we can ignore the bloop_pp arguments. Since this is a routine argument, we turn it into a special case of our induction principle. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk18"><span class="kn">Definition</span> <span class="nf">ClassifyingSpace_ind_hset</span>
    (<span class="nv">P</span> : ClassifyingSpace G -&gt; <span class="kt">Type</span>)
    `{<span class="kr">forall</span> <span class="nv">b</span>, IsTrunc <span class="mi">0</span> (P b)}
    (bbase&#39; : P bbase) (bloop&#39; : <span class="kr">forall</span> <span class="nv">x</span>, DPath P (bloop x) bbase&#39; bbase&#39;)
    : <span class="kr">forall</span> <span class="nv">b</span>, P b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHSet (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHSet (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk1a"><span class="nb">refine</span> (ClassifyingSpace_ind P bbase&#39; bloop&#39; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHSet (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
DPathSquare P (sq_G1 (bloop_pp x y)) (bloop&#39; (x * y))
  (bloop&#39; x @Dp bloop&#39; y)%dpath <span class="mi">1</span>%dpath <span class="mi">1</span>%dpath</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk1b"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHSet (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPathSquare P (sq_G1 (bloop_pp x y)) (bloop&#39; (x * y))
  (bloop&#39; x @Dp bloop&#39; y)%dpath <span class="mi">1</span>%dpath <span class="mi">1</span>%dpath</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk1c"><span class="nb">apply</span> ds_G1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHSet (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath
  (<span class="kr">fun</span> <span class="nv">x</span> : bbase = bbase =&gt; DPath P x bbase&#39; bbase&#39;)
  (bloop_pp x y) (bloop&#39; (x * y))
  (bloop&#39; x @Dp bloop&#39; y)%dpath</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk1d"><span class="kn">Definition</span> <span class="nf">ClassifyingSpace_rec_hset</span>
    (<span class="nv">P</span> : <span class="kt">Type</span>) `{IsTrunc <span class="mi">0</span> P} (bbase&#39; : P) (bloop&#39; : G -&gt; bbase&#39; = bbase&#39;)
    : ClassifyingSpace G -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace G -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace G -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk1f">srapply (ClassifyingSpace_rec P bbase&#39; bloop&#39; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; bbase&#39; = bbase&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G, bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Similarly, when eliminating into an hprop, we only have to handle the basepoint. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk20"><span class="kn">Definition</span> <span class="nf">ClassifyingSpace_ind_hprop</span> (<span class="nv">P</span> : ClassifyingSpace G -&gt; <span class="kt">Type</span>)
    `{<span class="kr">forall</span> <span class="nv">b</span>, IsTrunc (-<span class="mi">1</span>) (P b)} (bbase&#39; : P bbase)
    : <span class="kr">forall</span> <span class="nv">b</span>, P b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHProp (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHProp (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, P b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk22"><span class="nb">refine</span> (ClassifyingSpace_ind_hset P bbase&#39; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, IsHProp (P b)</span></span></span><br><span><var>bbase'</var><span class="hyp-type"><b>: </b><span>P bbase</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, DPath P (bloop x) bbase&#39; bbase&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; rapply dp_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Eliminators</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The classifying space is 0-connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk23"><span class="kn">Instance</span> <span class="nf">isconnected_classifyingspace</span> {<span class="nv">G</span> : Group}
  : IsConnected <span class="mi">0</span> (ClassifyingSpace G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) (ClassifyingSpace G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) (ClassifyingSpace G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk25"><span class="nb">apply</span> (Build_Contr _ (tr bbase)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Trunc <span class="mi">0</span> (ClassifyingSpace G), tr bbase = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk26">srapply Trunc_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : ClassifyingSpace G, tr bbase = tr a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply ClassifyingSpace_ind_hprop; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The classifying space of a group is pointed. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ispointed_classifyingspace</span> (<span class="nv">G</span> : Group)
  : IsPointed (ClassifyingSpace G)
  := bbase.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pClassifyingSpace</span> (<span class="nv">G</span> : Group) := [ClassifyingSpace G, bbase].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** To use the [B G] notation for [pClassifyingSpace] import this module. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Import</span> ClassifyingSpaceNotation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">B</span> <span class="nv">G</span> := pClassifyingSpace G.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ClassifyingSpaceNotation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [bloop] takes the unit of the group to reflexivity. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk27"><span class="kn">Definition</span> <span class="nf">bloop_id</span> {<span class="nv">G</span> : Group} : bloop (mon_unit : G) = idpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (mon_unit : G) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (mon_unit : G) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk29"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = bloop (mon_unit : G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk2a"><span class="nb">apply</span> (cancelL (bloop mon_unit)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop <span class="mi">1</span> @ <span class="mi">1</span> = bloop <span class="mi">1</span> @ bloop <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk2b"><span class="nb">refine</span> (_ @ bloop_pp _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop <span class="mi">1</span> @ <span class="mi">1</span> = bloop (mon_unit * mon_unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk2c"><span class="nb">refine</span> (_ @ ap _ (left_identity _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop <span class="mi">1</span> @ <span class="mi">1</span> = bloop <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [bloop] &quot;preserves inverses&quot; by taking inverses in [G] to inverses of paths in [BG]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk2d"><span class="kn">Definition</span> <span class="nf">bloop_inv</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> : G) : bloop x^ = (bloop x)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop x^ = (bloop x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop x^ = (bloop x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk2f"><span class="nb">refine</span> (_ @ concat_p1 _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop x^ = (bloop x)^ @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk30"><span class="nb">apply</span> moveL_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop x @ bloop x^ = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk31"><span class="nb">refine</span> (_ @ bloop_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop x @ bloop x^ = bloop <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk32"><span class="nb">refine</span> ((bloop_pp _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (x * inv x) = bloop <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, right_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The underlying pointed map of [pequiv_g_loops_bg]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk33"><span class="kn">Definition</span> <span class="nf">pbloop</span> {<span class="nv">G</span> : Group} : G -&gt;* loops (B G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt;* loops (B G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt;* loops (B G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk35">srapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; loops (B G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk36"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk37"><span class="mi">1</span>: <span class="bp">exact</span> bloop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> bloop_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This says that [B] is left adjoint to the loop space functor from pointed 1-types to groups. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pClassifyingSpace_rec</span> {<span class="nv">G</span> : Group} (<span class="nv">P</span> : pType) `{IsTrunc <span class="mi">1</span> P}
           (bloop&#39; : G -&gt; loops P)
           (bloop_pp&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G, bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y)
  : B G -&gt;* P
  := Build_pMap (ClassifyingSpace_rec P (point P) bloop&#39; bloop_pp&#39;) idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And this is one of the standard facts about adjoint functors: [(R h&#39;) o eta = h], where [h : G -&gt; R P], [h&#39; : L G -&gt; P] is the adjunct, and eta ([bloop]) is the unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk38"><span class="kn">Definition</span> <span class="nf">pClassifyingSpace_rec_beta_bloop</span> {<span class="nv">G</span> : Group} (<span class="nv">P</span> : pType)
  `{IsTrunc <span class="mi">1</span> P} (bloop&#39; : G -&gt; loops P)
  (bloop_pp&#39; : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G, bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y)
  : fmap loops (pClassifyingSpace_rec P bloop&#39; bloop_pp&#39;) o bloop == bloop&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; loops P</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (pClassifyingSpace_rec P bloop&#39; bloop_pp&#39;)
o bloop == bloop&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; loops P</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (pClassifyingSpace_rec P bloop&#39; bloop_pp&#39;)
o bloop == bloop&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk3a"><span class="nb">intro</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; loops P</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> @
(ap (ClassifyingSpace_rec P pt bloop&#39; bloop_pp&#39;)
   (bloop x) @ <span class="mi">1</span>) = bloop&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk3b"><span class="nb">refine</span> (concat_1p _ @ concat_p1 _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> P</span></span></span><br><span><var>bloop'</var><span class="hyp-type"><b>: </b><span>G -&gt; loops P</span></span></span><br><span><var>bloop_pp'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
bloop&#39; (x * y) = bloop&#39; x @ bloop&#39; y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (ClassifyingSpace_rec P pt bloop&#39; bloop_pp&#39;)
  (bloop x) = bloop&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ClassifyingSpace_rec_beta_bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Here we prove that [BG] is a delooping of [G], i.e. that [loops BG &lt;~&gt; G]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">EncodeDecode</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence} {G : Group}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk3c"><span class="kn">Local Definition</span> <span class="nf">codes</span> : B G -&gt; HSet.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B G -&gt; HSet</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B G -&gt; HSet</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk3e">srapply ClassifyingSpace_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HSet</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk3f"><hr></label><div class="goal-conclusion">G -&gt; <span class="nl">?bbase&#39;</span> = <span class="nl">?bbase&#39;</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk40"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
<span class="nl">?bloop&#39;</span> (x * y) = <span class="nl">?bloop&#39;</span> x @ <span class="nl">?bloop&#39;</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk41">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HSet</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Build_HSet G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk42">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; Build_HSet G = Build_HSet G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk43"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_HSet G = Build_HSet G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk44"><span class="nb">apply</span> path_trunctype.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_HSet G &lt;~&gt; Build_HSet G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Build_Equiv _ _ (<span class="kr">fun</span> <span class="nv">t</span> =&gt; t * x) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk45">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
(<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
 path_trunctype
   {|
     equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * x0;
     equiv_isequiv := isequiv_group_right_op G x0
   |}) (x * y) =
(<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
 path_trunctype
   {|
     equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * x0;
     equiv_isequiv := isequiv_group_right_op G x0
   |}) x @
(<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
 path_trunctype
   {|
     equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * x0;
     equiv_isequiv := isequiv_group_right_op G x0
   |}) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk46"><span class="nb">intros</span> x y; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_trunctype
  {|
    equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * (x * y);
    equiv_isequiv := isequiv_group_right_op G (x * y)
  |} =
path_trunctype
  {|
    equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * x;
    equiv_isequiv := isequiv_group_right_op G x
  |} @
path_trunctype
  {|
    equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * y;
    equiv_isequiv := isequiv_group_right_op G y
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk47"><span class="nb">refine</span> (_ @ path_trunctype_pp _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_trunctype
  {|
    equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * (x * y);
    equiv_isequiv := isequiv_group_right_op G (x * y)
  |} =
path_trunctype
  ({|
     equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * y;
     equiv_isequiv := isequiv_group_right_op G y
   |}
   oE {|
        equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * x;
        equiv_isequiv := isequiv_group_right_op G x
      |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk48"><span class="nb">apply</span> ap, path_equiv, path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * (x * y);
  equiv_isequiv := isequiv_group_right_op G (x * y)
|} ==
{|
  equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * y;
  equiv_isequiv := isequiv_group_right_op G y
|}
oE {|
     equiv_fun := <span class="kr">fun</span> <span class="nv">t</span> : G =&gt; t * x;
     equiv_isequiv := isequiv_group_right_op G x
   |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk49"><span class="nb">intro</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>Build_HSet G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x0 * (x * y) = x0 * x * y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> associativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk4a"><span class="kn">Local Definition</span> <span class="nf">encode</span> : <span class="kr">forall</span> <span class="nv">b</span>, bbase = b -&gt; codes b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, bbase = b -&gt; codes b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G, bbase = b -&gt; codes b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk4c"><span class="nb">intros</span> b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>ClassifyingSpace G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>bbase = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">codes b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (transport codes p mon_unit).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk4d"><span class="kn">Local Definition</span> <span class="nf">codes_transport</span>
    : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G, transport codes (bloop x) y = y * x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
transport (<span class="kr">fun</span> <span class="nv">x0</span> : B G =&gt; codes x0) (bloop x) y =
y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
transport (<span class="kr">fun</span> <span class="nv">x0</span> : B G =&gt; codes x0) (bloop x) y =
y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk4f"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : B G =&gt; codes x) (bloop x) y = y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk50">lhs napply (transport_idmap_ap _ (bloop x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : B G =&gt; codes x) (bloop x)) y = y * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk51">rhs_V rapply (transport_path_universe (.* x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap
  (ap (<span class="kr">fun</span> <span class="nv">x</span> : B G =&gt; codes x) (bloop x)) y =
transport idmap (path_universe (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk52">napply (transport2 idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">x</span> : B G =&gt; codes x) (bloop x) =
path_universe (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk53">lhs napply (ap_compose _ trunctype_type (bloop x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap trunctype_type (ap codes (bloop x)) =
path_universe (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk54">rhs_V napply ap_trunctype; <span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap codes (bloop x) =
path_trunctype
  {|
    equiv_fun := <span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x;
    equiv_isequiv := isequiv_group_right_op G x
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply ClassifyingSpace_rec_beta_bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk55"><span class="kn">Local Definition</span> <span class="nf">decode</span> : <span class="kr">forall</span> (<span class="nv">b</span> : B G), codes b -&gt; bbase = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G, codes b -&gt; bbase = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G, codes b -&gt; bbase = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk57">srapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; codes b -&gt; bbase = b)
  bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk58"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; codes b -&gt; bbase = b)
  (bloop x) <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk59">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; codes b -&gt; bbase = b)
  bbase</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk5a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; codes b -&gt; bbase = b)
  (bloop x) bloop bloop</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk5b"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; codes b -&gt; bbase = b)
  (bloop x) bloop bloop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk5c"><span class="nb">apply</span> dp_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : codes bbase,
DPath (paths bbase) (bloop x) (bloop x0)
  (bloop
     (transport
        (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt; codes x)
        (bloop x) x0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk5d"><span class="nb">intro</span> y; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (paths bbase) (bloop x) (bloop y) =
bloop
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt; codes x)
     (bloop x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk5e"><span class="nb">apply</span> dp_paths_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop y @ bloop x =
bloop
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt; codes x)
     (bloop x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk5f"><span class="nb">refine</span> ((bloop_pp _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (y * x) =
bloop
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt; codes x)
     (bloop x) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk60"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop
  (transport (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt; codes x)
     (bloop x) y) = bloop (y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, codes_transport.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk61"><span class="kn">Local Lemma</span> <span class="nf">decode_encode</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">p</span>, decode b (encode b p) = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B G) (<span class="nv">p</span> : bbase = b),
decode b (encode b p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> : B G) (<span class="nv">p</span> : bbase = b),
decode b (encode b p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk63"><span class="nb">intros</span> b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>bbase = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decode b (encode b p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk64"><span class="nb">destruct</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">decode bbase (encode bbase <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> bloop_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk65">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_bloop</span> : IsEquiv (@bloop G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv bloop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv bloop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk67">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bbase = bbase -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk68"><hr></label><div class="goal-conclusion">bloop o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk69"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o bloop == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk6a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bbase = bbase -&gt; G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (encode _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk6b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop o encode bbase == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply decode_encode.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk6c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encode bbase o bloop == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk6d"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">encode bbase (bloop x) = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk6e"><span class="nb">refine</span> (codes_transport _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit * x = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The defining property of BG. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_g_loops_bg</span> : G &lt;~&gt; loops (B G)
    := Build_Equiv _ _ bloop _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Pointed version of the defining property. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_g_loops_bg</span> : G &lt;~&gt;* loops (B G)
    := Build_pEquiv pbloop _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_loops_bg_g</span> := pequiv_g_loops_bg^-<span class="mi">1</span>*%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We also have that the equivalence is a group isomorphism. *)</span>

  <span class="sd">(** First we show that the loop space of a pointed 1-type is a group. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">LoopGroup</span> (<span class="nv">X</span> : pType) `{IsTrunc <span class="mi">1</span> X} : Group
    := Build_Group (loops X) concat idpath inverse
      (Build_IsGroup _ _ _ _
        (Build_IsMonoid _ _ _
          (Build_IsSemiGroup _ _ _ concat_p_pp) concat_1p concat_p1)
        concat_Vp concat_pV).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk6f"><span class="kn">Definition</span> <span class="nf">grp_iso_g_loopgroup_bg</span> : GroupIsomorphism G (LoopGroup (B G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G (LoopGroup (B G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G (LoopGroup (B G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk71">snapply Build_GroupIsomorphism&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G &lt;~&gt; LoopGroup (B G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk72"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk73"><span class="mi">1</span>: <span class="bp">exact</span> equiv_g_loops_bg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving equiv_g_loops_bg</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk74"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_g_loops_bg (x * y) =
equiv_g_loops_bg x * equiv_g_loops_bg y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> bloop_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk75"><span class="kn">Definition</span> <span class="nf">grp_iso_g_pi1_bg</span> : GroupIsomorphism G (Pi1 (B G)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G (Pi1 (B G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G (Pi1 (B G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk77">snapply (transitive_groupisomorphism _ _ _ grp_iso_g_loopgroup_bg).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (LoopGroup (B G)) (Pi1 (B G))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk78">snapply Build_GroupIsomorphism&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LoopGroup (B G) &lt;~&gt; Pi1 (B G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk79"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk7a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LoopGroup (B G) &lt;~&gt; Pi1 (B G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_tr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk7b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (equiv_tr <span class="mi">0</span> (LoopGroup (B G)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* We also record this fact. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk7c"><span class="kn">Definition</span> <span class="nf">grp_homo_loops</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} `{IsTrunc <span class="mi">1</span> X} `{IsTrunc <span class="mi">1</span> Y}
    : (X -&gt;** Y) -&gt;* [LoopGroup X $-&gt; LoopGroup Y, grp_homo_const].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X -&gt;** Y) -&gt;*
[LoopGroup X $-&gt; LoopGroup Y, grp_homo_const]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X -&gt;** Y) -&gt;*
[LoopGroup X $-&gt; LoopGroup Y, grp_homo_const]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk7e">snapply Build_pMap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X -&gt;** Y) -&gt;
[LoopGroup X $-&gt; LoopGroup Y, grp_homo_const]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk7f"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> pt = pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk80">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(X -&gt;** Y) -&gt;
[LoopGroup X $-&gt; LoopGroup Y, grp_homo_const]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk81"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;** Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[LoopGroup X $-&gt; LoopGroup Y, grp_homo_const]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk82">snapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;** Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LoopGroup X -&gt; LoopGroup Y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;** Y</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk83"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk84">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;** Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LoopGroup X -&gt; LoopGroup Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap loops f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk85">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt;** Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (fmap loops f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">napply fmap_loops_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk86">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : X -&gt;** Y =&gt;
 {|
   grp_homo_map := fmap loops f;
   issemigrouppreserving_grp_homo := fmap_loops_pp f
 |}) pt = pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk87"><span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := fmap loops pt;
  issemigrouppreserving_grp_homo := fmap_loops_pp pt
|} = pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk88"><span class="nb">apply</span> equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>IsTrunc1</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := fmap loops pt;
  issemigrouppreserving_grp_homo := fmap_loops_pp pt
|} == pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pointed_htpy fmap_loops_pconst).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">EncodeDecode</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** When [G] is an abelian group, [BG] is an H-space. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">HSpace_bg</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : AbGroup}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk89"><span class="kn">Definition</span> <span class="nf">bg_mul</span> : B G -&gt; B G -&gt; B G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B G -&gt; B G -&gt; B G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B G -&gt; B G -&gt; B G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk8b"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B G -&gt; B G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk8c">snapply ClassifyingSpace_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> (B G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk8d"><hr></label><div class="goal-conclusion">B G</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk8e"><hr></label><div class="goal-conclusion">G -&gt; <span class="nl">?bbase&#39;</span> = <span class="nl">?bbase&#39;</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk8f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
<span class="nl">?bloop&#39;</span> (x * y) = <span class="nl">?bloop&#39;</span> x @ <span class="nl">?bloop&#39;</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk90"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk91"><hr></label><div class="goal-conclusion">G -&gt; <span class="nl">?bbase&#39;</span> = <span class="nl">?bbase&#39;</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk92"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
<span class="nl">?bloop&#39;</span> (x * y) = <span class="nl">?bloop&#39;</span> x @ <span class="nl">?bloop&#39;</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk93"><span class="mi">1</span>: <span class="bp">exact</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; b = b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk94"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
<span class="nl">?bloop&#39;</span> (x * y) = <span class="nl">?bloop&#39;</span> x @ <span class="nl">?bloop&#39;</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk95">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; b = b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk96"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk97"><span class="nb">revert</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G, b = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk98">snapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G,
IsHSet ((<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk99"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) bbase</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk9a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : G,
DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x0)
  <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk9b"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk9c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : G,
DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x0)
  <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk9d"><span class="mi">1</span>: <span class="bp">exact</span> (bloop x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : G,
DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x0)
  (bloop x) (bloop x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk9e"><span class="nb">cbn</span>; <span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
  (bloop y) (bloop x) = bloop x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk9f"><span class="nb">apply</span> dp_paths_lr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((bloop y)^ @ bloop x) @ bloop y = bloop x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka0"><span class="nb">refine</span> (concat_pp_p _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(bloop y)^ @ (bloop x @ bloop y) = bloop x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka1"><span class="nb">apply</span> moveR_Vp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop x @ bloop y = bloop y @ bloop x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka2"><span class="nb">refine</span> ((bloop_pp _ _)^ @ _ @ bloop_pp _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (x * y) = bloop (y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, commutativity.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
(<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x0)
   ((<span class="kr">fun</span> <span class="nv">y0</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y0) (bloop x0) (bloop x0)
       (concat_pp_p (bloop y0)^ (bloop x0) (bloop y0) @
        moveR_Vp (bloop x0 @ bloop y0) (bloop x0)
          (bloop y0)
          (((bloop_pp x0 y0)^ @
            ap bloop (commutativity x0 y0)) @
           bloop_pp y0 x0)))
    :
    <span class="kr">forall</span> <span class="nv">x1</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
      (bloop x1) (bloop x0) (bloop x0)) b) (x * y) =
(<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x0)
   ((<span class="kr">fun</span> <span class="nv">y0</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y0) (bloop x0) (bloop x0)
       (concat_pp_p (bloop y0)^ (bloop x0) (bloop y0) @
        moveR_Vp (bloop x0 @ bloop y0) (bloop x0)
          (bloop y0)
          (((bloop_pp x0 y0)^ @
            ap bloop (commutativity x0 y0)) @
           bloop_pp y0 x0)))
    :
    <span class="kr">forall</span> <span class="nv">x1</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
      (bloop x1) (bloop x0) (bloop x0)) b) x @
(<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x0)
   ((<span class="kr">fun</span> <span class="nv">y0</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y0) (bloop x0) (bloop x0)
       (concat_pp_p (bloop y0)^ (bloop x0) (bloop y0) @
        moveR_Vp (bloop x0 @ bloop y0) (bloop x0)
          (bloop y0)
          (((bloop_pp x0 y0)^ @
            ap bloop (commutativity x0 y0)) @
           bloop_pp y0 x0)))
    :
    <span class="kr">forall</span> <span class="nv">x1</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
      (bloop x1) (bloop x0) (bloop x0)) b) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka4"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x)
   ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y) (bloop x) (bloop x)
       (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
        moveR_Vp (bloop x @ bloop y) (bloop x)
          (bloop y)
          (((bloop_pp x y)^ @
            ap bloop (commutativity x y)) @
           bloop_pp y x)))
    :
    <span class="kr">forall</span> <span class="nv">x0</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
      (bloop x0) (bloop x) (bloop x)) b) (x * y) =
(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x)
   ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y) (bloop x) (bloop x)
       (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
        moveR_Vp (bloop x @ bloop y) (bloop x)
          (bloop y)
          (((bloop_pp x y)^ @
            ap bloop (commutativity x y)) @
           bloop_pp y x)))
    :
    <span class="kr">forall</span> <span class="nv">x0</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
      (bloop x0) (bloop x) (bloop x)) b) x @
(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b) (bloop x)
   ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y) (bloop x) (bloop x)
       (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
        moveR_Vp (bloop x @ bloop y) (bloop x)
          (bloop y)
          (((bloop_pp x y)^ @
            ap bloop (commutativity x y)) @
           bloop_pp y x)))
    :
    <span class="kr">forall</span> <span class="nv">x0</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
      (bloop x0) (bloop x) (bloop x)) b) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka5"><span class="nb">revert</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G,
(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0) (bloop x)
   ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y) (bloop x) (bloop x)
       (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
        moveR_Vp (bloop x @ bloop y) (bloop x)
          (bloop y)
          (((bloop_pp x y)^ @
            ap bloop (commutativity x y)) @
           bloop_pp y x)))
    :
    <span class="kr">forall</span> <span class="nv">x0</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0)
      (bloop x0) (bloop x) (bloop x)) b) (x * y) =
(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0) (bloop x)
   ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y) (bloop x) (bloop x)
       (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
        moveR_Vp (bloop x @ bloop y) (bloop x)
          (bloop y)
          (((bloop_pp x y)^ @
            ap bloop (commutativity x y)) @
           bloop_pp y x)))
    :
    <span class="kr">forall</span> <span class="nv">x0</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0)
      (bloop x0) (bloop x) (bloop x)) b) x @
(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0) (bloop x)
   ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
     <span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
       equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
     X (bloop y) (bloop x) (bloop x)
       (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
        moveR_Vp (bloop x @ bloop y) (bloop x)
          (bloop y)
          (((bloop_pp x y)^ @
            ap bloop (commutativity x y)) @
           bloop_pp y x)))
    :
    <span class="kr">forall</span> <span class="nv">x0</span> : G,
    DPath (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0)
      (bloop x0) (bloop x) (bloop x)) b) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka6">srapply ClassifyingSpace_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
  ClassifyingSpace_ind_hset
    (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0) (bloop x)
    ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
      <span class="kr">let</span> <span class="nv">X</span> :=
        <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
        equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
      X (bloop y) (bloop x) (bloop x)
        (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
         moveR_Vp (bloop x @ bloop y) (bloop x)
           (bloop y)
           (((bloop_pp x y)^ @
             ap bloop (commutativity x y)) @
            bloop_pp y x)))
     :
     <span class="kr">forall</span> <span class="nv">x0</span> : G,
     DPath (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0)
       (bloop x0) (bloop x) (bloop x)) b) (x * y) =
 (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
  ClassifyingSpace_ind_hset
    (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0) (bloop x)
    ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
      <span class="kr">let</span> <span class="nv">X</span> :=
        <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
        equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
      X (bloop y) (bloop x) (bloop x)
        (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
         moveR_Vp (bloop x @ bloop y) (bloop x)
           (bloop y)
           (((bloop_pp x y)^ @
             ap bloop (commutativity x y)) @
            bloop_pp y x)))
     :
     <span class="kr">forall</span> <span class="nv">x0</span> : G,
     DPath (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0)
       (bloop x0) (bloop x) (bloop x)) b) x @
 (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
  ClassifyingSpace_ind_hset
    (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0) (bloop x)
    ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
      <span class="kr">let</span> <span class="nv">X</span> :=
        <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : bbase = bbase =&gt;
        equiv_fun (dp_paths_lr p q r) <span class="kr">in</span>
      X (bloop y) (bloop x) (bloop x)
        (concat_pp_p (bloop y)^ (bloop x) (bloop y) @
         moveR_Vp (bloop x @ bloop y) (bloop x)
           (bloop y)
           (((bloop_pp x y)^ @
             ap bloop (commutativity x y)) @
            bloop_pp y x)))
     :
     <span class="kr">forall</span> <span class="nv">x0</span> : G,
     DPath (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt; b0 = b0)
       (bloop x0) (bloop x) (bloop x)) b) y) bbase</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (bloop_pp x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka7"><span class="kn">Definition</span> <span class="nf">bg_mul_symm</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, bg_mul x y = bg_mul y x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : B G, bg_mul x y = bg_mul y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : B G, bg_mul x y = bg_mul y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chka9"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : B G, bg_mul x y = bg_mul y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkaa">srapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; bg_mul x b = bg_mul b x)
  bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkab"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   bg_mul x b = bg_mul b x) (bloop x0) <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkac">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; bg_mul x b = bg_mul b x)
  bbase</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkad"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = bg_mul bbase x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkae"><span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : B G, x = bg_mul bbase x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkaf">srapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
  bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkb0"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
  (bloop x) <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb1"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
  (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb2"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
  (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb3"><span class="nb">apply</span> sq_dp^-<span class="mi">1</span>, sq_1G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap idmap (bloop x) = ap (bg_mul bbase) (bloop x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb4"><span class="nb">refine</span> (ap_idmap _ @ _^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (bg_mul bbase) (bloop x) = bloop x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input">napply ClassifyingSpace_rec_beta_bloop.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>B G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   bg_mul x b = bg_mul b x) (bloop x0)
  (ClassifyingSpace_ind_hset
     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
     <span class="mi">1</span>
     (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
      sq_dp^-<span class="mi">1</span>
        (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_1G <span class="kr">in</span>
         X
           (ap_idmap (bloop x) @
            (ClassifyingSpace_rec_beta_bloop
               (ClassifyingSpace G) bbase
               (<span class="kr">fun</span> <span class="nv">x1</span> : G =&gt;
                ClassifyingSpace_ind_hset
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
                  (bloop x1)
                  ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
                    <span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : ... =&gt;
                      equiv_fun (...) <span class="kr">in</span>
                    X0 (bloop y) (bloop x1) (bloop x1)
                      (concat_pp_p ...^ ... ... @
                       moveR_Vp ... ... ... ...))
                   :
                   <span class="kr">forall</span> <span class="nv">x2</span> : G,
                   DPath
                     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                      b = b) (bloop x2) (bloop x1)
                     (bloop x1)) bbase)
               (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> : G =&gt;
                ClassifyingSpace_ind_hprop
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset
                      (... =&gt; ...) (bloop x2)
                      (... : ...) b) (x1 * y) =
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) x1 @
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) y)
                  (bloop_pp x1 y) bbase) x)^))) x
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    bg_mul x b = bg_mul b x) bbase)
  (ClassifyingSpace_ind_hset
     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
     <span class="mi">1</span>
     (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
      sq_dp^-<span class="mi">1</span>
        (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_1G <span class="kr">in</span>
         X
           (ap_idmap (bloop x) @
            (ClassifyingSpace_rec_beta_bloop
               (ClassifyingSpace G) bbase
               (<span class="kr">fun</span> <span class="nv">x1</span> : G =&gt;
                ClassifyingSpace_ind_hset
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
                  (bloop x1)
                  ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
                    <span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : ... =&gt;
                      equiv_fun (...) <span class="kr">in</span>
                    X0 (bloop y) (bloop x1) (bloop x1)
                      (concat_pp_p ...^ ... ... @
                       moveR_Vp ... ... ... ...))
                   :
                   <span class="kr">forall</span> <span class="nv">x2</span> : G,
                   DPath
                     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                      b = b) (bloop x2) (bloop x1)
                     (bloop x1)) bbase)
               (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> : G =&gt;
                ClassifyingSpace_ind_hprop
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset
                      (... =&gt; ...) (bloop x2)
                      (... : ...) b) (x1 * y) =
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) x1 @
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) y)
                  (bloop_pp x1 y) bbase) x)^))) x
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    bg_mul x b = bg_mul b x) bbase)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb6"><span class="nb">intros</span> y; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : B G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   bg_mul x b = bg_mul b x) (bloop y)
  (ClassifyingSpace_ind_hset
     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
     <span class="mi">1</span>
     (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
      sq_dp^-<span class="mi">1</span>
        (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_1G <span class="kr">in</span>
         X
           (ap_idmap (bloop x0) @
            (ClassifyingSpace_rec_beta_bloop
               (ClassifyingSpace G) bbase
               (<span class="kr">fun</span> <span class="nv">x1</span> : G =&gt;
                ClassifyingSpace_ind_hset
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
                  (bloop x1)
                  ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
                    <span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : ... =&gt;
                      equiv_fun (...) <span class="kr">in</span>
                    X0 (bloop y) (bloop x1) (bloop x1)
                      (concat_pp_p ...^ ... ... @
                       moveR_Vp ... ... ... ...))
                   :
                   <span class="kr">forall</span> <span class="nv">x2</span> : G,
                   DPath
                     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                      b = b) (bloop x2) (bloop x1)
                     (bloop x1)) bbase)
               (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> : G =&gt;
                ClassifyingSpace_ind_hprop
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset
                      (... =&gt; ...) (bloop x2)
                      (... : ...) b) (x1 * y) =
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) x1 @
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) y)
                  (bloop_pp x1 y) bbase) x0)^))) x
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    bg_mul x b = bg_mul b x) bbase)
  (ClassifyingSpace_ind_hset
     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
     <span class="mi">1</span>
     (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
      sq_dp^-<span class="mi">1</span>
        (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_1G <span class="kr">in</span>
         X
           (ap_idmap (bloop x0) @
            (ClassifyingSpace_rec_beta_bloop
               (ClassifyingSpace G) bbase
               (<span class="kr">fun</span> <span class="nv">x1</span> : G =&gt;
                ClassifyingSpace_ind_hset
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = b)
                  (bloop x1)
                  ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt;
                    <span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">r</span> : ... =&gt;
                      equiv_fun (...) <span class="kr">in</span>
                    X0 (bloop y) (bloop x1) (bloop x1)
                      (concat_pp_p ...^ ... ... @
                       moveR_Vp ... ... ... ...))
                   :
                   <span class="kr">forall</span> <span class="nv">x2</span> : G,
                   DPath
                     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                      b = b) (bloop x2) (bloop x1)
                     (bloop x1)) bbase)
               (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> : G =&gt;
                ClassifyingSpace_ind_hprop
                  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset
                      (... =&gt; ...) (bloop x2)
                      (... : ...) b) (x1 * y) =
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) x1 @
                   (<span class="kr">fun</span> <span class="nv">x2</span> : G =&gt;
                    ClassifyingSpace_ind_hset (...)
                      (...) (...) b) y)
                  (bloop_pp x1 y) bbase) x0)^))) x
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    bg_mul x b = bg_mul b x) bbase)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb7"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : ClassifyingSpace G,
transport
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   bg_mul x b = bg_mul b x) (bloop y)
  (ClassifyingSpace_ind_hset
     (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b)
     <span class="mi">1</span>
     (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
      sq_dp^-<span class="mi">1</span>
        (<span class="kr">match</span>
           ap idmap (bloop x0) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
           <span class="kr">return</span>
             (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
              <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x0) =
              p @ px1 -&gt;
              PathSquare <span class="mi">1</span> px1 p
                (ap (bg_mul bbase) (bloop x0)))
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt;
             <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
             <span class="kr">match</span>
               ap (bg_mul bbase) (bloop x0) <span class="kr">as</span> p <span class="kr">in</span>
               (_ = a)
               <span class="kr">return</span>
                 (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
                  <span class="mi">1</span> @ p = <span class="mi">1</span> @ px2 -&gt;
                  PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                   (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
                 <span class="kr">match</span>
                   e @ concat_1p px2 <span class="kr">in</span> (_ = p)
                   <span class="kr">return</span>
                     (<span class="mi">1</span> = <span class="mi">1</span> @ p -&gt; PathSquare <span class="mi">1</span> p <span class="mi">1</span> <span class="mi">1</span>)
                 <span class="kr">with</span>
                 | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">1</span> = <span class="mi">1</span> =&gt; <span class="mi">1</span>%square
                 <span class="kr">end</span> e
             <span class="kr">end</span> px1
         <span class="kr">end</span> <span class="mi">1</span>
           ((concat_1p (ap (bg_mul bbase) (bloop x0)) @
             (ap_idmap (bloop x0) @
              (ClassifyingSpace_rec_beta_bloop
                 (ClassifyingSpace G) bbase
                 (<span class="kr">fun</span> <span class="nv">x1</span> : G =&gt; bloop x1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> : G =&gt; bloop_pp x1 y) x0)^)^) @
            (concat_p1 (ap idmap (bloop x0)))^))) x) =
ClassifyingSpace_ind_hset
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; b = bg_mul bbase b) <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt;
   sq_dp^-<span class="mi">1</span>
     (<span class="kr">match</span>
        ap idmap (bloop x0) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
        <span class="kr">return</span>
          (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
           <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x0) = p @ px1 -&gt;
           PathSquare <span class="mi">1</span> px1 p
             (ap (bg_mul bbase) (bloop x0)))
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt;
          <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
          <span class="kr">match</span>
            ap (bg_mul bbase) (bloop x0) <span class="kr">as</span> p <span class="kr">in</span>
            (_ = a)
            <span class="kr">return</span>
              (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
               <span class="mi">1</span> @ p = <span class="mi">1</span> @ px2 -&gt; PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
              <span class="kr">match</span>
                e @ concat_1p px2 <span class="kr">in</span> (_ = p)
                <span class="kr">return</span>
                  (<span class="mi">1</span> = <span class="mi">1</span> @ p -&gt; PathSquare <span class="mi">1</span> p <span class="mi">1</span> <span class="mi">1</span>)
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">1</span> = <span class="mi">1</span> =&gt; <span class="mi">1</span>%square
              <span class="kr">end</span> e
          <span class="kr">end</span> px1
      <span class="kr">end</span> <span class="mi">1</span>
        ((concat_1p (ap (bg_mul bbase) (bloop x0)) @
          (ap_idmap (bloop x0) @
           (ClassifyingSpace_rec_beta_bloop
              (ClassifyingSpace G) bbase
              (<span class="kr">fun</span> <span class="nv">x1</span> : G =&gt; bloop x1)
              (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> : G =&gt; bloop_pp x1 y) x0)^)^) @
         (concat_p1 (ap idmap (bloop x0)))^))) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkb8">snapply ClassifyingSpace_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G,
IsHProp
  ((<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    transport
      (<span class="kr">fun</span> <span class="nv">b1</span> : ClassifyingSpace G =&gt;
       bg_mul b0 b1 = bg_mul b1 b0) (bloop y)
      (ClassifyingSpace_ind_hset
         (<span class="kr">fun</span> <span class="nv">b1</span> : ClassifyingSpace G =&gt;
          b1 = bg_mul bbase b1) <span class="mi">1</span>
         (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
          sq_dp^-<span class="mi">1</span>
            (<span class="kr">match</span>
               ap idmap (bloop x) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
               <span class="kr">return</span>
                 (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
                  <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x) =
                  p @ px1 -&gt;
                  PathSquare <span class="mi">1</span> px1 p
                    (ap (bg_mul bbase) (bloop x)))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
                 <span class="kr">match</span>
                   ap (bg_mul bbase) (bloop x) <span class="kr">as</span> p <span class="kr">in</span>
                   (_ = a)
                   <span class="kr">return</span>
                     (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
                      ... = ... -&gt;
                      PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
                 <span class="kr">with</span>
                 | <span class="mi">1</span> =&gt;
                     <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                       (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
                     <span class="kr">match</span> ... <span class="kr">in</span> ... <span class="kr">return</span> ... <span class="kr">with</span>
                     | <span class="mi">1</span> =&gt; <span class="kr">fun</span> ... =&gt; <span class="mi">1</span>%square
                     <span class="kr">end</span> e
                 <span class="kr">end</span> px1
             <span class="kr">end</span> <span class="mi">1</span>
               ((concat_1p
                   (ap (bg_mul bbase) (bloop x)) @
                 (ap_idmap (bloop x) @
                  (ClassifyingSpace_rec_beta_bloop
                     (ClassifyingSpace G) bbase
                     (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
                     (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; bloop_pp x0 y) x)^)^) @
                (concat_p1 (ap idmap (bloop x)))^)))
         b0) =
    ClassifyingSpace_ind_hset
      (<span class="kr">fun</span> <span class="nv">b1</span> : ClassifyingSpace G =&gt;
       b1 = bg_mul bbase b1) <span class="mi">1</span>
      (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
       sq_dp^-<span class="mi">1</span>
         (<span class="kr">match</span>
            ap idmap (bloop x) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
            <span class="kr">return</span>
              (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
               <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x) =
               p @ px1 -&gt;
               PathSquare <span class="mi">1</span> px1 p
                 (ap (bg_mul bbase) (bloop x)))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
              <span class="kr">match</span>
                ap (bg_mul bbase) (bloop x) <span class="kr">as</span> p <span class="kr">in</span>
                (_ = a)
                <span class="kr">return</span>
                  (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
                   <span class="mi">1</span> @ p = <span class="mi">1</span> @ px2 -&gt;
                   PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                    (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
                  <span class="kr">match</span>
                    e @ concat_1p px2 <span class="kr">in</span> (_ = p)
                    <span class="kr">return</span> (... -&gt; ...)
                  <span class="kr">with</span>
                  | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">1</span> = <span class="mi">1</span> =&gt; <span class="mi">1</span>%square
                  <span class="kr">end</span> e
              <span class="kr">end</span> px1
          <span class="kr">end</span> <span class="mi">1</span>
            ((concat_1p (ap (bg_mul bbase) (bloop x)) @
              (ap_idmap (bloop x) @
               (ClassifyingSpace_rec_beta_bloop
                  (ClassifyingSpace G) bbase
                  (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
                  (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; bloop_pp x0 y) x)^)^) @
             (concat_p1 (ap idmap (bloop x)))^))) b0)
     b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkb9"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 transport
   (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    bg_mul b b0 = bg_mul b0 b) (bloop y)
   (ClassifyingSpace_ind_hset
      (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
       b0 = bg_mul bbase b0) <span class="mi">1</span>
      (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
       sq_dp^-<span class="mi">1</span>
         (<span class="kr">match</span>
            ap idmap (bloop x) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
            <span class="kr">return</span>
              (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
               <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x) =
               p @ px1 -&gt;
               PathSquare <span class="mi">1</span> px1 p
                 (ap (bg_mul bbase) (bloop x)))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
              <span class="kr">match</span>
                ap (bg_mul bbase) (bloop x) <span class="kr">as</span> p <span class="kr">in</span>
                (_ = a)
                <span class="kr">return</span>
                  (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
                   <span class="mi">1</span> @ p = <span class="mi">1</span> @ px2 -&gt;
                   PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                    (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
                  <span class="kr">match</span>
                    e @ concat_1p px2 <span class="kr">in</span> (_ = p)
                    <span class="kr">return</span>
                      (<span class="mi">1</span> = ... -&gt; PathSquare <span class="mi">1</span> p <span class="mi">1</span> <span class="mi">1</span>)
                  <span class="kr">with</span>
                  | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">1</span> = <span class="mi">1</span> =&gt; <span class="mi">1</span>%square
                  <span class="kr">end</span> e
              <span class="kr">end</span> px1
          <span class="kr">end</span> <span class="mi">1</span>
            ((concat_1p (ap (bg_mul bbase) (bloop x)) @
              (ap_idmap (bloop x) @
               (ClassifyingSpace_rec_beta_bloop
                  (ClassifyingSpace G) bbase
                  (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
                  (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; bloop_pp x0 y) x)^)^) @
             (concat_p1 (ap idmap (bloop x)))^))) b) =
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    b0 = bg_mul bbase b0) <span class="mi">1</span>
   (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
    sq_dp^-<span class="mi">1</span>
      (<span class="kr">match</span>
         ap idmap (bloop x) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
            <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x) = p @ px1 -&gt;
            PathSquare <span class="mi">1</span> px1 p
              (ap (bg_mul bbase) (bloop x)))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
           <span class="kr">match</span>
             ap (bg_mul bbase) (bloop x) <span class="kr">as</span> p <span class="kr">in</span>
             (_ = a)
             <span class="kr">return</span>
               (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
                <span class="mi">1</span> @ p = <span class="mi">1</span> @ px2 -&gt;
                PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt;
               <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                 (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
               <span class="kr">match</span>
                 e @ concat_1p px2 <span class="kr">in</span> (_ = p)
                 <span class="kr">return</span>
                   (<span class="mi">1</span> = <span class="mi">1</span> @ p -&gt; PathSquare <span class="mi">1</span> p <span class="mi">1</span> <span class="mi">1</span>)
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">1</span> = <span class="mi">1</span> =&gt; <span class="mi">1</span>%square
               <span class="kr">end</span> e
           <span class="kr">end</span> px1
       <span class="kr">end</span> <span class="mi">1</span>
         ((concat_1p (ap (bg_mul bbase) (bloop x)) @
           (ap_idmap (bloop x) @
            (ClassifyingSpace_rec_beta_bloop
               (ClassifyingSpace G) bbase
               (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
               (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; bloop_pp x0 y) x)^)^) @
          (concat_p1 (ap idmap (bloop x)))^))) b)
  bbase</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkba"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 transport
   (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    bg_mul b b0 = bg_mul b0 b) (bloop y)
   (ClassifyingSpace_ind_hset
      (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
       b0 = bg_mul bbase b0) <span class="mi">1</span>
      (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
       sq_dp^-<span class="mi">1</span>
         (<span class="kr">match</span>
            ap idmap (bloop x) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
            <span class="kr">return</span>
              (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
               <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x) =
               p @ px1 -&gt;
               PathSquare <span class="mi">1</span> px1 p
                 (ap (bg_mul bbase) (bloop x)))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
              <span class="kr">match</span>
                ap (bg_mul bbase) (bloop x) <span class="kr">as</span> p <span class="kr">in</span>
                (_ = a)
                <span class="kr">return</span>
                  (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
                   <span class="mi">1</span> @ p = <span class="mi">1</span> @ px2 -&gt;
                   PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                    (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
                  <span class="kr">match</span>
                    e @ concat_1p px2 <span class="kr">in</span> (_ = p)
                    <span class="kr">return</span>
                      (<span class="mi">1</span> = ... -&gt; PathSquare <span class="mi">1</span> p <span class="mi">1</span> <span class="mi">1</span>)
                  <span class="kr">with</span>
                  | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">1</span> = <span class="mi">1</span> =&gt; <span class="mi">1</span>%square
                  <span class="kr">end</span> e
              <span class="kr">end</span> px1
          <span class="kr">end</span> <span class="mi">1</span>
            ((concat_1p (ap (bg_mul bbase) (bloop x)) @
              (ap_idmap (bloop x) @
               (ClassifyingSpace_rec_beta_bloop
                  (ClassifyingSpace G) bbase
                  (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
                  (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; bloop_pp x0 y) x)^)^) @
             (concat_p1 (ap idmap (bloop x)))^))) b) =
 ClassifyingSpace_ind_hset
   (<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    b0 = bg_mul bbase b0) <span class="mi">1</span>
   (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
    sq_dp^-<span class="mi">1</span>
      (<span class="kr">match</span>
         ap idmap (bloop x) <span class="kr">as</span> p <span class="kr">in</span> (_ = a)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">px1</span> : a = bbase,
            <span class="mi">1</span> @ ap (bg_mul bbase) (bloop x) = p @ px1 -&gt;
            PathSquare <span class="mi">1</span> px1 p
              (ap (bg_mul bbase) (bloop x)))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           <span class="kr">fun</span> <span class="nv">px1</span> : bbase = bbase =&gt;
           <span class="kr">match</span>
             ap (bg_mul bbase) (bloop x) <span class="kr">as</span> p <span class="kr">in</span>
             (_ = a)
             <span class="kr">return</span>
               (<span class="kr">forall</span> <span class="nv">px2</span> : bbase = a,
                <span class="mi">1</span> @ p = <span class="mi">1</span> @ px2 -&gt;
                PathSquare <span class="mi">1</span> px2 <span class="mi">1</span> p)
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt;
               <span class="kr">fun</span> (<span class="nv">px2</span> : bbase = bbase)
                 (<span class="nv">e</span> : <span class="mi">1</span> = <span class="mi">1</span> @ px2) =&gt;
               <span class="kr">match</span>
                 e @ concat_1p px2 <span class="kr">in</span> (_ = p)
                 <span class="kr">return</span>
                   (<span class="mi">1</span> = <span class="mi">1</span> @ p -&gt; PathSquare <span class="mi">1</span> p <span class="mi">1</span> <span class="mi">1</span>)
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">1</span> = <span class="mi">1</span> =&gt; <span class="mi">1</span>%square
               <span class="kr">end</span> e
           <span class="kr">end</span> px1
       <span class="kr">end</span> <span class="mi">1</span>
         ((concat_1p (ap (bg_mul bbase) (bloop x)) @
           (ap_idmap (bloop x) @
            (ClassifyingSpace_rec_beta_bloop
               (ClassifyingSpace G) bbase
               (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
               (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; bloop_pp x0 y) x)^)^) @
          (concat_p1 (ap idmap (bloop x)))^))) b)
  bbase</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkbb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; bg_mul bbase b = b)
  (bloop y) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkbc">transport_paths Flr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (bg_mul bbase) (bloop y) @ <span class="mi">1</span> = <span class="mi">1</span> @ bloop y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkbd"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (bg_mul bbase) (bloop y) = bloop y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply ClassifyingSpace_rec_beta_bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkbe"><span class="kn">Definition</span> <span class="nf">bg_mul_left_id</span>
    : <span class="kr">forall</span> <span class="nv">b</span> : B G, bg_mul bbase b = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G, bg_mul bbase b = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkbf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G, bg_mul bbase b = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> bg_mul_symm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc0"><span class="kn">Definition</span> <span class="nf">bg_mul_right_id</span>
    : <span class="kr">forall</span> <span class="nv">b</span> : B G, bg_mul b bbase = b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G, bg_mul b bbase = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B G, bg_mul b bbase = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">ishspace_bg</span> : IsHSpace (B G)
    := Build_IsHSpace _
          bg_mul
          bg_mul_left_id
          bg_mul_right_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">HSpace_bg</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Functoriality of B(-) *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc2"><span class="kn">Instance</span> <span class="nf">is0functor_pclassifyingspace</span> : Is0Functor B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc4"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; B a $-&gt; B b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc5"><span class="nb">intros</span> G H f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B G $-&gt; B H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc6">snapply pClassifyingSpace_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> (B H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkc7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkc7"><hr></label><div class="goal-conclusion">G -&gt; loops (B H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkc8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkc8"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
<span class="nl">?bloop&#39;</span> (x * y) = <span class="nl">?bloop&#39;</span> x @ <span class="nl">?bloop&#39;</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkc9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> (B H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkca">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; loops (B H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (bloop o f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkcb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G,
(bloop o f) (x * y) = (bloop o f) x @ (bloop o f) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkcc"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(bloop o f) (x * y) = (bloop o f) x @ (bloop o f) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkcd"><span class="nb">refine</span> (ap bloop (grp_homo_op f x y) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (f x * f y) = bloop (f x) @ bloop (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> bloop_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkce"><span class="kn">Definition</span> <span class="nf">bloop_natural</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f</span> : G $-&gt; H)
  : fmap loops (fmap B f) o bloop == bloop o f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (fmap B f) o bloop == bloop o f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkcf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (fmap B f) o bloop == bloop o f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply pClassifyingSpace_rec_beta_bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd0"><span class="kn">Lemma</span> <span class="nf">pbloop_natural</span> (<span class="nv">G</span> <span class="nv">K</span> : Group) (<span class="nv">f</span> : G $-&gt; K)
  : fmap loops (fmap B f) o* pbloop ==* pbloop o* f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (fmap B f) o* pbloop ==* pbloop o* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (fmap B f) o* pbloop ==* pbloop o* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd2">srapply phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops (fmap B f) o* pbloop == pbloop o* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> bloop_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd3"><span class="kn">Definition</span> <span class="nf">natequiv_g_loops_bg</span> `{Univalence}
  : NatEquiv ptype_group (loops o B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv ptype_group (loops o B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv ptype_group (loops o B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd5">snapply Build_NatEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Group,
a $&lt;~&gt; (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; loops (B x)) a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkd6"><hr></label><div class="goal-conclusion">Is1Natural ptype_group (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; loops (B x))
  (<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt; <span class="nl">?e</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd7"><span class="mi">1</span>: <span class="nb">intros</span> G; <span class="bp">exact</span> pequiv_g_loops_bg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural ptype_group (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; loops (B x))
  (<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt;
   (<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; pequiv_g_loops_bg) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd8">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : Group) (<span class="nv">f</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">a0</span> : Group =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; pequiv_g_loops_bg) a0))
  a&#39; $o fmap ptype_group f $==
fmap (loops o B) f $o
(<span class="kr">fun</span> <span class="nv">a0</span> : Group =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; pequiv_g_loops_bg) a0)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkd9"><span class="nb">intros</span> X Y f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; pequiv_g_loops_bg) a)) Y $o
fmap ptype_group f $==
fmap (loops o B) f $o
(<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; pequiv_g_loops_bg) a)) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkda"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X $-&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (loops o B) f $o
(<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; pequiv_g_loops_bg) a)) X $==
(<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt;
 cate_fun ((<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; pequiv_g_loops_bg) a)) Y $o
fmap ptype_group f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pbloop_natural.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkdb"><span class="kn">Instance</span> <span class="nf">is1functor_pclassifyingspace</span> : Is1Functor B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkdc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkdd"><span class="nb">apply</span> Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap B f $== fmap B g</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Group, fmap B (Id a) $== Id (B a)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap B (g $o f) $== fmap B g $o fmap B f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Action on 2-cells *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkde">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap B f $== fmap B g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkdf"><span class="nb">intros</span> G H f g p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B f $== fmap B g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chke0">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B f == fmap B g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chke1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chke1"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt = dpoint_eq (fmap B f) @ (dpoint_eq (fmap B g))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chke2">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B f == fmap B g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chke3">snapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G,
IsHSet
  ((<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    fmap B f b0 = fmap B g b0) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chke4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chke4"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; fmap B f b = fmap B g b)
  bbase</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chke5"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B f b = fmap B g b) (bloop x) <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chke6"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt; fmap B f b = fmap B g b)
  bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chke7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chke7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B f b = fmap B g b) (bloop x) <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chke8"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B f b = fmap B g b) (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chke9"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B f b = fmap B g b) (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkea">rapply equiv_sq_dp^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> (ap (fmap B f) (bloop x))
  (ap (fmap B g) (bloop x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkeb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span>
  (ap
     (ClassifyingSpace_rec (ClassifyingSpace H) pt
        (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop (f x))
        (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
         ap bloop (grp_homo_op f x y) @
         bloop_pp (f x) (f y))) (bloop x))
  (ap
     (ClassifyingSpace_rec (ClassifyingSpace H) pt
        (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop (g x))
        (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
         ap bloop (grp_homo_op g x y) @
         bloop_pp (g x) (g y))) (bloop x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkec"><span class="nb">rewrite</span> <span class="mi">2</span> ClassifyingSpace_rec_beta_bloop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> (bloop (f x)) (bloop (g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chked"><span class="nb">apply</span> sq_1G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (f x) = bloop (g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkee"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p x).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkef">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace_ind_hset
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B f b = fmap B g b) <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
   sq_dp^-<span class="mi">1</span>
     (internal_paths_rew_r
        (<span class="kr">fun</span>
           <span class="nv">p</span> : ClassifyingSpace_rec
                 (ClassifyingSpace H) pt
                 (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (f x0))
                 (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
                  ap bloop (grp_homo_op f x0 y) @
                  bloop_pp (f x0) (f y)) bbase =
               ClassifyingSpace_rec
                 (ClassifyingSpace H) pt
                 (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (f x0))
                 (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
                  ap bloop (grp_homo_op f x0 y) @
                  bloop_pp (f x0) (f y)) bbase =&gt;
         PathSquare <span class="mi">1</span> <span class="mi">1</span> p
           (ap
              (ClassifyingSpace_rec
                 (ClassifyingSpace H) pt
                 (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
                 (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
                  ap bloop (grp_homo_op g x0 y) @
                  bloop_pp (g x0) (g y))) (bloop x)))
        (internal_paths_rew_r
           (<span class="kr">fun</span>
              <span class="nv">p</span> : ClassifyingSpace_rec
                    (ClassifyingSpace H) pt
                    (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
                    (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
                     ap bloop (grp_homo_op g x0 y) @
                     bloop_pp (g x0) (g y)) bbase =
                  ClassifyingSpace_rec
                    (ClassifyingSpace H) pt
                    (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
                    (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
                     ap bloop (grp_homo_op g x0 y) @
                     bloop_pp (g x0) (g y)) bbase =&gt;
            PathSquare <span class="mi">1</span> <span class="mi">1</span> (bloop (f x)) p)
           (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_1G <span class="kr">in</span>
            X (ap bloop (p x)))
           (ClassifyingSpace_rec_beta_bloop
              (ClassifyingSpace H) pt
              (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
              (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
               ap bloop (grp_homo_op g x0 y) @
               bloop_pp (g x0) (g y)) x))
        (ClassifyingSpace_rec_beta_bloop
           (ClassifyingSpace H) pt
           (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (f x0))
           (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
            ap bloop (grp_homo_op f x0 y) @
            bloop_pp (f x0) (f y)) x)
      :
      PathSquare <span class="mi">1</span> <span class="mi">1</span> (ap (fmap B f) (bloop x))
        (ap (fmap B g) (bloop x)))) pt =
dpoint_eq (fmap B f) @ (dpoint_eq (fmap B g))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Preservation of identity *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkf0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Group, fmap B (Id a) $== Id (B a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkf1"><span class="nb">intros</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B (Id G) $== Id (B G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkf2">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B (Id G) == Id (B G)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkf3"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap B (Id G)) @ (dpoint_eq (Id (B G)))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkf4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B (Id G) == Id (B G)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkf5">snapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G,
IsHSet
  ((<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    fmap B (Id G) b0 = Id (B G) b0) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkf6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkf6"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 fmap B (Id G) b = Id (B G) b) bbase</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkf7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkf7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (Id G) b = Id (B G) b) (bloop x) <span class="nl">?bbase&#39;</span>
  <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkf8"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 fmap B (Id G) b = Id (B G) b) bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chkf9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chkf9"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (Id G) b = Id (B G) b) (bloop x) <span class="nl">?bbase&#39;</span>
  <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkfa"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (Id G) b = Id (B G) b) (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkfb"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (Id G) b = Id (B G) b) (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkfc">rapply equiv_sq_dp^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> (ap (fmap B (Id G)) (bloop x))
  (ap (Id (B G)) (bloop x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkfd"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span>
  (ap
     (ClassifyingSpace_rec (ClassifyingSpace G) pt
        (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop x)
        (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt; <span class="mi">1</span> @ bloop_pp x y)) (bloop x))
  (ap idmap (bloop x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkfe"><span class="nb">rewrite</span> ClassifyingSpace_rec_beta_bloop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> (bloop x) (ap idmap (bloop x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chkff"><span class="nb">apply</span> sq_1G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop x = ap idmap (bloop x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk100"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap idmap (bloop x) = bloop x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap_idmap.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk101">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace_ind_hset
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (Id G) b = Id (B G) b) <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
   sq_dp^-<span class="mi">1</span>
     (internal_paths_rew_r
        (<span class="kr">fun</span>
           <span class="nv">p</span> : ClassifyingSpace_rec
                 (ClassifyingSpace G) pt
                 (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
                 (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; <span class="mi">1</span> @ bloop_pp x0 y)
                 bbase =
               ClassifyingSpace_rec
                 (ClassifyingSpace G) pt
                 (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
                 (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; <span class="mi">1</span> @ bloop_pp x0 y)
                 bbase =&gt;
         PathSquare <span class="mi">1</span> <span class="mi">1</span> p (ap idmap (bloop x)))
        (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_1G <span class="kr">in</span>
         X (ap_idmap (bloop x))^)
        (ClassifyingSpace_rec_beta_bloop
           (ClassifyingSpace G) pt
           (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop x0)
           (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt; <span class="mi">1</span> @ bloop_pp x0 y) x)
      :
      PathSquare <span class="mi">1</span> <span class="mi">1</span> (ap (fmap B (Id G)) (bloop x))
        (ap (Id (B G)) (bloop x)))) pt =
dpoint_eq (fmap B (Id G)) @ (dpoint_eq (Id (B G)))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Preservation of composition *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk102">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap B (g $o f) $== fmap B g $o fmap B f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk103"><span class="nb">intros</span> G H K g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B (f $o g) $== fmap B f $o fmap B g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk104">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B (f $o g) == fmap B f $o fmap B g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk105" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk105"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (fmap B (f $o g)) @
(dpoint_eq (fmap B f $o fmap B g))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk106">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B (f $o g) == fmap B f $o fmap B g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk107">snapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G,
IsHSet
  ((<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    fmap B (f $o g) b0 = (fmap B f $o fmap B g) b0) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk108" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk108"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 fmap B (f $o g) b = (fmap B f $o fmap B g) b) bbase</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk109" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk109"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (f $o g) b = (fmap B f $o fmap B g) b)
  (bloop x) <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk10a"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 fmap B (f $o g) b = (fmap B f $o fmap B g) b) bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk10b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk10b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (f $o g) b = (fmap B f $o fmap B g) b)
  (bloop x) <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk10c"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (f $o g) b = (fmap B f $o fmap B g) b)
  (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk10d"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (f $o g) b = (fmap B f $o fmap B g) b)
  (bloop x) <span class="mi">1</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk10e">rapply equiv_sq_dp^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> (ap (fmap B (f $o g)) (bloop x))
  (ap (fmap B f $o fmap B g) (bloop x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk10f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span>
  (ap
     (ClassifyingSpace_rec (ClassifyingSpace K) pt
        (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop (f (g x)))
        (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
         ap bloop
           (abstract_algebra.compose_sg_morphism g f
              (issemigrouppreserving_grp_homo g)
              (issemigrouppreserving_grp_homo f) x y) @
         bloop_pp (f (g x)) (f (g y)))) (bloop x))
  (ap
     (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt;
      ClassifyingSpace_rec (ClassifyingSpace K) pt
        (<span class="kr">fun</span> <span class="nv">x0</span> : H =&gt; bloop (f x0))
        (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : H =&gt;
         ap bloop (grp_homo_op f x0 y) @
         bloop_pp (f x0) (f y))
        (ClassifyingSpace_rec (ClassifyingSpace H) pt
           (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
           (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
            ap bloop (grp_homo_op g x0 y) @
            bloop_pp (g x0) (g y)) x)) (bloop x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk110">rapply sq_ccGG.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
ap
  (ClassifyingSpace_rec (ClassifyingSpace K) pt
     (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop (f (g x)))
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
      ap bloop
        (abstract_algebra.compose_sg_morphism g f
           (issemigrouppreserving_grp_homo g)
           (issemigrouppreserving_grp_homo f) x y) @
      bloop_pp (f (g x)) (f (g y)))) (bloop x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk111" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk111"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> =
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt;
   ClassifyingSpace_rec (ClassifyingSpace K) pt
     (<span class="kr">fun</span> <span class="nv">x0</span> : H =&gt; bloop (f x0))
     (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : H =&gt;
      ap bloop (grp_homo_op f x0 y) @
      bloop_pp (f x0) (f y))
     (ClassifyingSpace_rec (ClassifyingSpace H) pt
        (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
        (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
         ap bloop (grp_homo_op g x0 y) @
         bloop_pp (g x0) (g y)) x)) (bloop x)</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk112" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk112"><hr></label><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> <span class="nl">?Goal</span> <span class="nl">?Goal0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk113"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (ClassifyingSpace_rec (ClassifyingSpace K) pt
     (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop (f (g x)))
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
      ap bloop
        (abstract_algebra.compose_sg_morphism g f
           (issemigrouppreserving_grp_homo g)
           (issemigrouppreserving_grp_homo f) x y) @
      bloop_pp (f (g x)) (f (g y)))) (bloop x) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk114" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk114"><hr></label><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : ClassifyingSpace G =&gt;
   ClassifyingSpace_rec (ClassifyingSpace K) pt
     (<span class="kr">fun</span> <span class="nv">x0</span> : H =&gt; bloop (f x0))
     (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : H =&gt;
      ap bloop (grp_homo_op f x0 y) @
      bloop_pp (f x0) (f y))
     (ClassifyingSpace_rec (ClassifyingSpace H) pt
        (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
        (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
         ap bloop (grp_homo_op g x0 y) @
         bloop_pp (g x0) (g y)) x)) (bloop x) = <span class="nl">?Goal0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk115" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk115"><hr></label><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> <span class="nl">?Goal</span> <span class="nl">?Goal0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk116"><span class="mi">2</span>: <span class="nb">refine</span> (ap_compose (ClassifyingSpace_rec _ _ _ (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt;
        ap bloop (grp_homo_op g x y) @ bloop_pp (g x) (g y))) _ (bloop x)
        @ ap _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (ClassifyingSpace_rec (ClassifyingSpace K) pt
     (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop (f (g x)))
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
      ap bloop
        (abstract_algebra.compose_sg_morphism g f
           (issemigrouppreserving_grp_homo g)
           (issemigrouppreserving_grp_homo f) x y) @
      bloop_pp (f (g x)) (f (g y)))) (bloop x) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk117"><hr></label><div class="goal-conclusion">ap
  (ClassifyingSpace_rec (ClassifyingSpace H) bbase
     (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; bloop (g x))
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
      ap bloop (grp_homo_op g x y) @
      bloop_pp (g x) (g y))) (bloop x) = <span class="nl">?Goal3</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk118"><hr></label><div class="goal-conclusion">ap
  (ClassifyingSpace_rec (ClassifyingSpace K) pt
     (<span class="kr">fun</span> <span class="nv">x</span> : H =&gt; bloop (f x))
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : H =&gt;
      ap bloop (grp_homo_op f x y) @
      bloop_pp (f x) (f y))) <span class="nl">?Goal3</span> = <span class="nl">?Goal0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk119"><hr></label><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> <span class="nl">?Goal</span> <span class="nl">?Goal0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk11a"><span class="mi">1</span>-<span class="mi">3</span>: napply ClassifyingSpace_rec_beta_bloop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare <span class="mi">1</span> <span class="mi">1</span> (bloop (f (g x))) (bloop (f (g x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk11b"><span class="nb">apply</span> sq_1G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bloop (f (g x)) = bloop (f (g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk11c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>H $-&gt; K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace_ind_hset
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B (f $o g) b = (fmap B f $o fmap B g) b) <span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
   sq_dp^-<span class="mi">1</span>
     (sq_ccGG
        (ClassifyingSpace_rec_beta_bloop
           (ClassifyingSpace K) bbase
           (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (f (g x0)))
           (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
            ap bloop
              (abstract_algebra.compose_sg_morphism g
                 f (issemigrouppreserving_grp_homo g)
                 (issemigrouppreserving_grp_homo f) x0
                 y) @ bloop_pp (f (g x0)) (f (g y))) x)^
        ((ap_compose
            (ClassifyingSpace_rec (ClassifyingSpace H)
               bbase (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
               (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
                ap bloop (grp_homo_op g x0 y) @
                bloop_pp (g x0) (g y)))
            (ClassifyingSpace_rec (ClassifyingSpace K)
               pt (<span class="kr">fun</span> <span class="nv">x0</span> : H =&gt; bloop (f x0))
               (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : H =&gt;
                ap bloop (grp_homo_op f x0 y) @
                bloop_pp (f x0) (f y))) (bloop x) @
          ap
            (ap
               (ClassifyingSpace_rec
                  (ClassifyingSpace K) pt
                  (<span class="kr">fun</span> <span class="nv">x0</span> : H =&gt; bloop (f x0))
                  (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : H =&gt;
                   ap bloop (grp_homo_op f x0 y) @
                   bloop_pp (f x0) (f y))))
            (ClassifyingSpace_rec_beta_bloop
               (ClassifyingSpace H) bbase
               (<span class="kr">fun</span> <span class="nv">x0</span> : G =&gt; bloop (g x0))
               (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : G =&gt;
                ap bloop (grp_homo_op g x0 y) @
                bloop_pp (g x0) (g y)) x)) @
         ClassifyingSpace_rec_beta_bloop
           (ClassifyingSpace K) pt
           (<span class="kr">fun</span> <span class="nv">x0</span> : H =&gt; bloop (f x0))
           (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : H =&gt;
            ap bloop (grp_homo_op f x0 y) @
            bloop_pp (f x0) (f y)) (g x))^
        (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_1G <span class="kr">in</span> X <span class="mi">1</span>)
      :
      PathSquare <span class="mi">1</span> <span class="mi">1</span> (ap (fmap B (f $o g)) (bloop x))
        (ap (fmap B f $o fmap B g) (bloop x)))) pt =
dpoint_eq (fmap B (f $o g)) @
(dpoint_eq (fmap B f $o fmap B g))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Interestingly, [fmap B] is an equivalence *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk11d"><span class="kn">Instance</span> <span class="nf">isequiv_fmap_pclassifyingspace</span> `{U : Univalence} (G H : Group)
  : IsEquiv (fmap B (a := G) (b := H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (fmap B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk11e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (fmap B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk11f">snapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B G $-&gt; B H) -&gt; G $-&gt; H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk120" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk120"><hr></label><div class="goal-conclusion">fmap B o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk121" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk121"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o fmap B == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk122">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(B G $-&gt; B H) -&gt; G $-&gt; H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk123"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G $-&gt; H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk124"><span class="nb">refine</span> (grp_homo_compose (grp_iso_inverse _) (grp_homo_compose _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism H <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk125" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk125"><hr></label><div class="goal-conclusion">GroupHomomorphism <span class="nl">?Goal1</span> <span class="nl">?Goal</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk126" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk126"><hr></label><div class="goal-conclusion">GroupHomomorphism G <span class="nl">?Goal1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk127"><span class="mi">1</span>,<span class="mi">3</span>: <span class="bp">exact</span> grp_iso_g_loopgroup_bg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (LoopGroup (B G)) (LoopGroup (B H))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_loops f).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk128">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B
o (<span class="kr">fun</span> <span class="nv">f</span> : B G $-&gt; B H =&gt;
   grp_homo_compose
     (grp_iso_inverse grp_iso_g_loopgroup_bg)
     (grp_homo_compose (grp_homo_loops f)
        grp_iso_g_loopgroup_bg)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk129" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk129"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : B G $-&gt; B H =&gt;
 grp_homo_compose
   (grp_iso_inverse grp_iso_g_loopgroup_bg)
   (grp_homo_compose (grp_homo_loops f)
      grp_iso_g_loopgroup_bg)) o fmap B == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk12a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B
o (<span class="kr">fun</span> <span class="nv">f</span> : B G $-&gt; B H =&gt;
   grp_homo_compose
     (grp_iso_inverse grp_iso_g_loopgroup_bg)
     (grp_homo_compose (grp_homo_loops f)
        grp_iso_g_loopgroup_bg)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk12b"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B
  (grp_homo_compose
     (grp_iso_inverse grp_iso_g_loopgroup_bg)
     (grp_homo_compose (grp_homo_loops f)
        grp_iso_g_loopgroup_bg)) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk12c">rapply equiv_path_pforall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B
  (grp_homo_compose
     (grp_iso_inverse grp_iso_g_loopgroup_bg)
     (grp_homo_compose (grp_homo_loops f)
        grp_iso_g_loopgroup_bg)) ==* f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk12d">snapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B
  (grp_homo_compose
     (grp_iso_inverse grp_iso_g_loopgroup_bg)
     (grp_homo_compose (grp_homo_loops f)
        grp_iso_g_loopgroup_bg)) == f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk12e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk12e"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq
  (fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg))) @ (dpoint_eq f)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk12f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap B
  (grp_homo_compose
     (grp_iso_inverse grp_iso_g_loopgroup_bg)
     (grp_homo_compose (grp_homo_loops f)
        grp_iso_g_loopgroup_bg)) == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk130">snapply ClassifyingSpace_ind_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : ClassifyingSpace G,
IsHSet
  ((<span class="kr">fun</span> <span class="nv">b0</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b0 = f b0) b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk131" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk131"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 fmap B
   (grp_homo_compose
      (grp_iso_inverse grp_iso_g_loopgroup_bg)
      (grp_homo_compose (grp_homo_loops f)
         grp_iso_g_loopgroup_bg)) b = f b) bbase</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk132" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk132"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg)) b = f b) (bloop x)
  <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk133"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 fmap B
   (grp_homo_compose
      (grp_iso_inverse grp_iso_g_loopgroup_bg)
      (grp_homo_compose (grp_homo_loops f)
         grp_iso_g_loopgroup_bg)) b = f b) bbase</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk134" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk134"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg)) b = f b) (bloop x)
  <span class="nl">?bbase&#39;</span> <span class="nl">?bbase&#39;</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk135">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
 fmap B
   (grp_homo_compose
      (grp_iso_inverse grp_iso_g_loopgroup_bg)
      (grp_homo_compose (grp_homo_loops f)
         grp_iso_g_loopgroup_bg)) b = f b) bbase</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk136"><span class="nb">cbn</span>; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f bbase = bbase</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (point_eq f).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk137">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg)) b = f b) (bloop x)
  ((point_eq f)^
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b = f b) bbase)
  ((point_eq f)^
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b = f b) bbase)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk138">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg)) b = f b) (bloop x)
  ((point_eq f)^
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b = f b) bbase)
  ((point_eq f)^
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b = f b) bbase)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk139"><span class="nb">intro</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DPath
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg)) b = f b) (bloop g)
  ((point_eq f)^
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b = f b) bbase)
  ((point_eq f)^
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b = f b) bbase)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk13a">rapply equiv_sq_dp^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare (point_eq f)^ (point_eq f)^
  (ap
     (fmap B
        (grp_homo_compose
           (grp_iso_inverse grp_iso_g_loopgroup_bg)
           (grp_homo_compose (grp_homo_loops f)
              grp_iso_g_loopgroup_bg))) (bloop g))
  (ap f (bloop g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk13b"><span class="nb">rewrite</span> ClassifyingSpace_rec_beta_bloop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare (point_eq f)^ (point_eq f)^
  (bloop
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg) g))
  (ap f (bloop g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk13c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare (point_eq f)^ (point_eq f)^
  (bloop
     (encode bbase
        ((point_eq f)^ @ (ap f (bloop g) @ point_eq f))))
  (ap f (bloop g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk13d">rapply sq_ccGc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> =
bloop
  (encode bbase
     ((point_eq f)^ @ (ap f (bloop g) @ point_eq f)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk13e"><hr></label><div class="goal-conclusion">PathSquare (point_eq f)^ (point_eq f)^ <span class="nl">?Goal</span>
  (ap f (bloop g))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk13f"><span class="mi">1</span>: <span class="nb">symmetry</span>; rapply decode_encode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PathSquare (point_eq f)^ (point_eq f)^
  ((point_eq f)^ @ (ap f (bloop g) @ point_eq f))
  (ap f (bloop g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk140"><span class="nb">apply</span> equiv_sq_path.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(point_eq f)^ @ ap f (bloop g) =
((point_eq f)^ @ (ap f (bloop g) @ point_eq f)) @
(point_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk141"><span class="nb">rewrite</span> concat_pp_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(point_eq f)^ @ ap f (bloop g) =
(point_eq f)^ @
((ap f (bloop g) @ point_eq f) @ (point_eq f)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk142"><span class="nb">rewrite</span> concat_pp_V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(point_eq f)^ @ ap f (bloop g) =
(point_eq f)^ @ ap f (bloop g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk143">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B G $-&gt; B H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ClassifyingSpace_ind_hset
  (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
   fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg)) b = f b)
  ((point_eq f)^
   :
   (<span class="kr">fun</span> <span class="nv">b</span> : ClassifyingSpace G =&gt;
    fmap B
      (grp_homo_compose
         (grp_iso_inverse grp_iso_g_loopgroup_bg)
         (grp_homo_compose (grp_homo_loops f)
            grp_iso_g_loopgroup_bg)) b = f b) bbase)
  (<span class="kr">fun</span> <span class="nv">g</span> : G =&gt;
   sq_dp^-<span class="mi">1</span>
     (internal_paths_rew_r
        (<span class="kr">fun</span>
           <span class="nv">p</span> : ClassifyingSpace_rec (B H) pt
                 (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
                  bloop
                    (grp_homo_compose
                       (grp_iso_inverse
                          grp_iso_g_loopgroup_bg)
                       (grp_homo_compose
                          (grp_homo_loops f)
                          grp_iso_g_loopgroup_bg) x))
                 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
                  ap bloop
                    (grp_homo_op
                       (grp_homo_compose
                          (grp_iso_inverse
                             grp_iso_g_loopgroup_bg)
                          (grp_homo_compose
                             (grp_homo_loops f)
                             grp_iso_g_loopgroup_bg))
                       x y) @
                  bloop_pp
                    (grp_homo_compose
                       (grp_iso_inverse
                          grp_iso_g_loopgroup_bg)
                       (grp_homo_compose
                          (grp_homo_loops f)
                          grp_iso_g_loopgroup_bg) x)
                    (grp_homo_compose
                       (grp_iso_inverse
                          grp_iso_g_loopgroup_bg)
                       (grp_homo_compose
                          (grp_homo_loops f)
                          grp_iso_g_loopgroup_bg) y))
                 bbase =
               ClassifyingSpace_rec (B H) pt
                 (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
                  bloop
                    (grp_homo_compose
                       (grp_iso_inverse
                          grp_iso_g_loopgroup_bg)
                       (grp_homo_compose
                          (grp_homo_loops f)
                          grp_iso_g_loopgroup_bg) x))
                 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
                  ap bloop
                    (grp_homo_op
                       (grp_homo_compose
                          (grp_iso_inverse
                             grp_iso_g_loopgroup_bg)
                          (grp_homo_compose
                             (grp_homo_loops f)
                             grp_iso_g_loopgroup_bg))
                       x y) @
                  bloop_pp
                    (grp_homo_compose
                       (grp_iso_inverse
                          grp_iso_g_loopgroup_bg)
                       (grp_homo_compose
                          (grp_homo_loops f)
                          grp_iso_g_loopgroup_bg) x)
                    (grp_homo_compose
                       (grp_iso_inverse
                          grp_iso_g_loopgroup_bg)
                       (grp_homo_compose
                          (grp_homo_loops f)
                          grp_iso_g_loopgroup_bg) y))
                 bbase =&gt;
         PathSquare (point_eq f)^ (point_eq f)^ p
           (ap f (bloop g)))
        (sq_ccGc
           (decode_encode pt
              ((point_eq f)^ @
               (ap f (bloop g) @ point_eq f)))^
           (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun sq_path <span class="kr">in</span>
            X
              (internal_paths_rew_r
                 (<span class="kr">fun</span> <span class="nv">p</span> : pt = f bbase =&gt;
                  (point_eq f)^ @ ap f (bloop g) = p)
                 (internal_paths_rew_r
                    (<span class="kr">fun</span> <span class="nv">p</span> : f pt = f bbase =&gt;
                     (point_eq f)^ @ ap f (bloop g) =
                     (point_eq f)^ @ p) <span class="mi">1</span>
                    (concat_pp_V (ap f (bloop g))
                       (point_eq f)))
                 (concat_pp_p (point_eq f)^
                    (ap f (bloop g) @ point_eq f)
                    (point_eq f)^)))
         :
         PathSquare (point_eq f)^ (point_eq f)^
           (bloop
              (grp_homo_compose
                 (grp_iso_inverse
                    grp_iso_g_loopgroup_bg)
                 (grp_homo_compose (grp_homo_loops f)
                    grp_iso_g_loopgroup_bg) g))
           (ap f (bloop g)))
        (ClassifyingSpace_rec_beta_bloop (B H) pt
           (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
            bloop
              (grp_homo_compose
                 (grp_iso_inverse
                    grp_iso_g_loopgroup_bg)
                 (grp_homo_compose (grp_homo_loops f)
                    grp_iso_g_loopgroup_bg) x))
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : G =&gt;
            ap bloop
              (grp_homo_op
                 (grp_homo_compose
                    (grp_iso_inverse
                       grp_iso_g_loopgroup_bg)
                    (grp_homo_compose
                       (grp_homo_loops f)
                       grp_iso_g_loopgroup_bg)) x y) @
            bloop_pp
              (grp_homo_compose
                 (grp_iso_inverse
                    grp_iso_g_loopgroup_bg)
                 (grp_homo_compose (grp_homo_loops f)
                    grp_iso_g_loopgroup_bg) x)
              (grp_homo_compose
                 (grp_iso_inverse
                    grp_iso_g_loopgroup_bg)
                 (grp_homo_compose (grp_homo_loops f)
                    grp_iso_g_loopgroup_bg) y)) g)))
  pt =
dpoint_eq
  (fmap B
     (grp_homo_compose
        (grp_iso_inverse grp_iso_g_loopgroup_bg)
        (grp_homo_compose (grp_homo_loops f)
           grp_iso_g_loopgroup_bg))) @ (dpoint_eq f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> concat_1p.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk144">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : B G $-&gt; B H =&gt;
 grp_homo_compose
   (grp_iso_inverse grp_iso_g_loopgroup_bg)
   (grp_homo_compose (grp_homo_loops f)
      grp_iso_g_loopgroup_bg)) o fmap B == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk145"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (grp_iso_inverse grp_iso_g_loopgroup_bg)
  (grp_homo_compose (grp_homo_loops (fmap B f))
     grp_iso_g_loopgroup_bg) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk146">rapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (grp_iso_inverse grp_iso_g_loopgroup_bg)
  (grp_homo_compose (grp_homo_loops (fmap B f))
     grp_iso_g_loopgroup_bg) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk147"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (grp_iso_inverse grp_iso_g_loopgroup_bg)
  (grp_homo_compose (grp_homo_loops (fmap B f))
     grp_iso_g_loopgroup_bg) x = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk148">rapply (moveR_equiv_V&#39; equiv_g_loops_bg).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose (grp_homo_loops (fmap B f))
  grp_iso_g_loopgroup_bg x = equiv_g_loops_bg (f x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply pClassifyingSpace_rec_beta_bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Hence we have that group homomorphisms are equivalent to pointed maps between their deloopings. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk149"><span class="kn">Theorem</span> <span class="nf">equiv_grp_homo_pmap_bg</span> `{U : Univalence} (G H : Group)
  : (G $-&gt; H) &lt;~&gt; (B G $-&gt; B H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G $-&gt; H) &lt;~&gt; (B G $-&gt; B H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk14a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G $-&gt; H) &lt;~&gt; (B G $-&gt; B H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk14b">snapply Build_Equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G $-&gt; H) -&gt; B G $-&gt; B H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk14c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk14c"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?equiv_fun</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">2</span>: <span class="nb">apply</span> isequiv_fmap_pclassifyingspace.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk14d"><span class="kn">Instance</span> <span class="nf">is1natural_grp_homo_pmap_bg_r</span> {<span class="nv">U</span> : Univalence} (<span class="nv">G</span> : Group)
  : Is1Natural (opyon G) (opyon (B G) o B) (equiv_grp_homo_pmap_bg G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (opyon G) (opyon (B G) o B)
  (<span class="kr">fun</span> <span class="nv">H</span> : Group =&gt; equiv_grp_homo_pmap_bg G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk14e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (opyon G) (opyon (B G) o B)
  (<span class="kr">fun</span> <span class="nv">H</span> : Group =&gt; equiv_grp_homo_pmap_bg G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk14f">snapply Build_Is1Natural.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : Group) (<span class="nv">f</span> : a $-&gt; a&#39;),
(<span class="kr">fun</span> <span class="nv">H</span> : Group =&gt;
 equiv_fun (equiv_grp_homo_pmap_bg G H)) a&#39; $o
fmap (opyon G) f $==
fmap (opyon (B G) o B) f $o
(<span class="kr">fun</span> <span class="nv">H</span> : Group =&gt;
 equiv_fun (equiv_grp_homo_pmap_bg G H)) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk150"><span class="nb">intros</span> K H f h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, K, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>opyon G K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_grp_homo_pmap_bg G H $o fmap (opyon G) f) h =
(fmap (opyon (B G) o B) f $o
 equiv_grp_homo_pmap_bg G K) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk151"><span class="nb">apply</span> path_hom.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, K, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>opyon G K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_grp_homo_pmap_bg G H $o fmap (opyon G) f) h $==
(fmap (opyon (B G) o B) f $o
 equiv_grp_homo_pmap_bg G K) h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (fmap_comp B h f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk152"><span class="kn">Theorem</span> <span class="nf">natequiv_grp_homo_pmap_bg</span> `{U : Univalence} (G : Group)
  : NatEquiv (opyon G) (opyon (B G) o B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon G) (opyon (B G) o B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk153"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon G) (opyon (B G) o B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply Build_NatEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [B(Pi 1 X) &lt;~&gt;* X] for a 0-connected 1-truncated [X]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk154"><span class="kn">Theorem</span> <span class="nf">pequiv_pclassifyingspace_pi1</span> `{Univalence}
  (X : pType) `{IsConnected <span class="mi">0</span> X} `{IsTrunc <span class="mi">1</span> X}
  : B (Pi1 X) &lt;~&gt;* X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (Pi1 X) &lt;~&gt;* X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk155"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (Pi1 X) &lt;~&gt;* X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** The pointed map [f] is the adjunct to the inverse of the natural map [loops X -&gt; Pi1 X]. We define it first, to make the later goals easier to read. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk156">transparent <span class="nb">assert</span> (f : (B (Pi1 X) -&gt;* X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (Pi1 X) -&gt;* X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk157" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk157"><hr></label><div class="goal-conclusion">B (Pi1 X) &lt;~&gt;* X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk158">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (Pi1 X) -&gt;* X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk159">snapply pClassifyingSpace_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc <span class="mi">1</span> X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk15a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk15a"><hr></label><div class="goal-conclusion">Pi1 X -&gt; loops X</div></blockquote><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk15b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk15b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X,
<span class="nl">?bloop&#39;</span> (x * y) = <span class="nl">?bloop&#39;</span> x @ <span class="nl">?bloop&#39;</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk15c"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pi1 X -&gt; loops X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk15d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk15d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X,
<span class="nl">?bloop&#39;</span> (x * y) = <span class="nl">?bloop&#39;</span> x @ <span class="nl">?bloop&#39;</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk15e"><span class="mi">1</span>: <span class="bp">exact</span> (equiv_tr <span class="mi">0</span> _)^-<span class="mi">1</span>%equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X,
(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * y) =
(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk15f"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Pi1 X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * y) =
(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk160">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>loops X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr x * tr y) =
(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr x) @
(equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk161">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>pClassifyingSpace_rec X
  (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X =&gt;
   Trunc_ind
     (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * aa) =
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa)
     (<span class="kr">fun</span> <span class="nv">y0</span> : loops X =&gt;
      Trunc_ind
        (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
           (aa * tr y0) =
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa @
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y0))
        (<span class="kr">fun</span> <span class="nv">x0</span> : loops X =&gt; <span class="mi">1</span>) x) y)</span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (Pi1 X) &lt;~&gt;* X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk162">snapply (Build_pEquiv f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>pClassifyingSpace_rec X
  (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X =&gt;
   Trunc_ind
     (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * aa) =
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa)
     (<span class="kr">fun</span> <span class="nv">y0</span> : loops X =&gt;
      Trunc_ind
        (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
           (aa * tr y0) =
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa @
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y0))
        (<span class="kr">fun</span> <span class="nv">x0</span> : loops X =&gt; <span class="mi">1</span>) x) y)</span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** [f] is an equivalence since [loops_functor f o bloop == tr^-1], and the other two maps are equivalences. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk163"><span class="nb">apply</span> isequiv_is0connected_isequiv_loops.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>pClassifyingSpace_rec X
  (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X =&gt;
   Trunc_ind
     (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * aa) =
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa)
     (<span class="kr">fun</span> <span class="nv">y0</span> : loops X =&gt;
      Trunc_ind
        (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
           (aa * tr y0) =
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa @
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y0))
        (<span class="kr">fun</span> <span class="nv">x0</span> : loops X =&gt; <span class="mi">1</span>) x) y)</span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (fmap loops f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk164">snapply (cancelR_isequiv bloop).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>pClassifyingSpace_rec X
  (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X =&gt;
   Trunc_ind
     (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * aa) =
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa)
     (<span class="kr">fun</span> <span class="nv">y0</span> : loops X =&gt;
      Trunc_ind
        (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
           (aa * tr y0) =
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa @
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y0))
        (<span class="kr">fun</span> <span class="nv">x0</span> : loops X =&gt; <span class="mi">1</span>) x) y)</span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv bloop</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk165" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>pClassifyingSpace_rec X
  (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X =&gt;
   Trunc_ind
     (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * aa) =
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa)
     (<span class="kr">fun</span> <span class="nv">y0</span> : loops X =&gt;
      Trunc_ind
        (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
           (aa * tr y0) =
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa @
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y0))
        (<span class="kr">fun</span> <span class="nv">x0</span> : loops X =&gt; <span class="mi">1</span>) x) y)</span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk165"><hr></label><div class="goal-conclusion">IsEquiv (fmap loops f o bloop)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk166"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>pClassifyingSpace_rec X
  (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X =&gt;
   Trunc_ind
     (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * aa) =
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa)
     (<span class="kr">fun</span> <span class="nv">y0</span> : loops X =&gt;
      Trunc_ind
        (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
           (aa * tr y0) =
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa @
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y0))
        (<span class="kr">fun</span> <span class="nv">x0</span> : loops X =&gt; <span class="mi">1</span>) x) y)</span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (fmap loops f o bloop)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk167">rapply isequiv_homotopic&#39;; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc <span class="mi">1</span> X</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>pClassifyingSpace_rec X
  (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : Pi1 X =&gt;
   Trunc_ind
     (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (x * aa) =
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv x @
      (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa)
     (<span class="kr">fun</span> <span class="nv">y0</span> : loops X =&gt;
      Trunc_ind
        (<span class="kr">fun</span> <span class="nv">aa</span> : Trunc <span class="mi">0</span> (loops X) =&gt;
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv
           (aa * tr y0) =
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv aa @
         (equiv_tr <span class="mi">0</span> (loops X))^-<span class="mi">1</span>%equiv (tr y0))
        (<span class="kr">fun</span> <span class="nv">x0</span> : loops X =&gt; <span class="mi">1</span>) x) y)</span></span><span class="hyp-type"><b>: </b><span>B (Pi1 X) -&gt;* X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Pi1 X =&gt; fmap loops f (bloop x)) == <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply pClassifyingSpace_rec_beta_bloop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk168"><span class="kn">Lemma</span> <span class="nf">natequiv_bg_pi1_adjoint</span> `{Univalence} (X : pType) `{IsConnected <span class="mi">0</span> X}
  : NatEquiv (opyon (Pi1 X)) (opyon X o B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (Pi1 X)) (opyon X o B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk169"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (Pi1 X)) (opyon X o B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk16a">nrefine (natequiv_compose (G := opyon (Pi1 (pTr <span class="mi">1</span> X))) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (Pi1 (pTr <span class="mi">1</span> X)))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk16b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk16b"><hr></label><div class="goal-conclusion">NatEquiv (opyon (Pi1 X)) (opyon (Pi1 (pTr <span class="mi">1</span> X)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk16c"><span class="mi">2</span>: <span class="bp">exact</span> (natequiv_opyon_equiv (A:=Group) (grp_iso_inverse (grp_iso_pi_Tr <span class="mi">0</span> X))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (Pi1 (pTr <span class="mi">1</span> X)))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk16d"><span class="nb">refine</span> (natequiv_compose _ (natequiv_grp_homo_pmap_bg _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (B (Pi1 (pTr <span class="mi">1</span> X))) (B x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk16e"><span class="nb">refine</span> (natequiv_compose (G := opyon (pTr <span class="mi">1</span> X) o B) _ _); <span class="nb">revgoals</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (B (Pi1 (pTr <span class="mi">1</span> X))) (B x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (pTr <span class="mi">1</span> X) (B x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk16f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk16f"><hr></label><div class="goal-conclusion">NatEquiv (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (pTr <span class="mi">1</span> X) (B x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk170">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (B (Pi1 (pTr <span class="mi">1</span> X))) (B x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (pTr <span class="mi">1</span> X) (B x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk171"><span class="nb">refine</span> (natequiv_prewhisker _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (opyon (B (Pi1 (pTr <span class="mi">1</span> X)))) (opyon (pTr <span class="mi">1</span> X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk172"><span class="nb">refine</span> (natequiv_opyon_equiv _^-<span class="mi">1</span>$).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B (Pi1 (pTr <span class="mi">1</span> X)) $&lt;~&gt; pTr <span class="mi">1</span> X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply pequiv_pclassifyingspace_pi1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk173">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NatEquiv (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (pTr <span class="mi">1</span> X) (B x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk174">snapply Build_NatEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Group,
(<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (pTr <span class="mi">1</span> X) (B x)) a $&lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x)) a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="classifyingspace-v-chk175" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><label class="goal-separator" for="classifyingspace-v-chk175"><hr></label><div class="goal-conclusion">Is1Natural (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (pTr <span class="mi">1</span> X) (B x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x))
  (<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt; <span class="nl">?e</span> a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk176"><span class="mi">1</span>: <span class="nb">intro</span>; <span class="bp">exact</span> pequiv_ptr_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon (pTr <span class="mi">1</span> X) (B x))
  (<span class="kr">fun</span> <span class="nv">x</span> : Group =&gt; opyon X (B x))
  (<span class="kr">fun</span> <span class="nv">a</span> : Group =&gt;
   (<span class="kr">fun</span> <span class="nv">a0</span> : Group =&gt;
    pointed_equiv_equiv pequiv_ptr_rec) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (is1natural_prewhisker (G:=opyon X) B (opyoneda _ _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The classifying space functor and the fundamental group functor form an adjunction ([pType] needs to be restricted to the subcategory of 0-connected pointed types). Note that the full adjunction should also be natural in [X], but this was not needed yet. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk177"><span class="kn">Theorem</span> <span class="nf">equiv_bg_pi1_adjoint</span> `{Univalence} (X : pType)
  `{IsConnected <span class="mi">0</span> X} (G : Group)
  : (Pi <span class="mi">1</span> X $-&gt; G) &lt;~&gt; (X $-&gt; B G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Pi <span class="mi">1</span> X $-&gt; G) &lt;~&gt; (X $-&gt; B G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk178"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Pi <span class="mi">1</span> X $-&gt; G) &lt;~&gt; (X $-&gt; B G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply natequiv_bg_pi1_adjoint.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk179"><span class="kn">Lemma</span> <span class="nf">is1natural_equiv_bg_pi1_adjoint_r</span> `{Univalence}
  (X : pType) `{IsConnected <span class="mi">0</span> X}
  : Is1Natural (opyon (Pi1 X)) (opyon X o B)
      (equiv_bg_pi1_adjoint X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (opyon (Pi1 X)) (opyon X o B)
  (<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; equiv_bg_pi1_adjoint X G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="classifyingspace-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="classifyingspace-v-chk17a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Natural (opyon (Pi1 X)) (opyon X o B)
  (<span class="kr">fun</span> <span class="nv">G</span> : Group =&gt; equiv_bg_pi1_adjoint X G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (is1natural_natequiv (natequiv_bg_pi1_adjoint X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Why so slow? Fixed by making this opaque. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Opaque</span> equiv_bg_pi1_adjoint.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Transparent</span> equiv_bg_pi1_adjoint.</span></span></pre>
</div>
</div></body>
</html>
