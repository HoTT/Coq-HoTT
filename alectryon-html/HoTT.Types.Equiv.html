<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Equiv.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk58"><span class="kn">Require Import</span> HoTT.Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Sigma Types.Forall Types.Arrow Types.Paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Equivalences *)</span>

<span class="sd">(** ** [IsEquiv f] is logically equivalent to [IsTruncMap (-2) f] *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk59"><span class="kn">Instance</span> <span class="nf">contr_map_isequiv</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv _ _ f}
  : IsTruncMap (-<span class="mi">2</span>) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk5b"><span class="nb">intros</span> b; <span class="nb">refine</span> (contr_equiv&#39; {a : A &amp; a = f^-<span class="mi">1</span> b} _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : A &amp; a = f^-<span class="mi">1</span> b} &lt;~&gt; hfiber f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk5c"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = f^-<span class="mi">1</span> b &lt;~&gt; f a = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_moveR_equiv_M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk5d"><span class="kn">Definition</span> <span class="nf">isequiv_contr_map</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{IsTruncMap (-<span class="mi">2</span>) A B f}
  : IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk5f">srapply Build_IsEquiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equiv-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk60"><hr></label><div class="goal-conclusion">f o <span class="nl">?equiv_inv</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="equiv-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk61"><hr></label><div class="goal-conclusion"><span class="nl">?equiv_inv</span> o f == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="equiv-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk62"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A, <span class="nl">?eisretr</span> (f x) = ap f (<span class="nl">?eissect</span> x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> b; <span class="bp">exact</span> (center {a : A &amp; f a = b}).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f o (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (center {a : A &amp; f a = b}).<span class="mi">1</span>) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk65"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (center {a : A &amp; f a = b}).<span class="mi">1</span> = b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (center {a : A &amp; f a = b}).<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (center {a : A &amp; f a = b}).<span class="mi">1</span>) o f ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk67"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(center {a0 : A &amp; f a0 = f a}).<span class="mi">1</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@contr {x : A &amp; f x = f a} _ (a;<span class="mi">1</span>))..<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk68">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (center {a : A &amp; f a = b}).<span class="mi">2</span>)
 :
 f o (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (center {a : A &amp; f a = b}).<span class="mi">1</span>) ==
 idmap) (f x) =
ap f
  (((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (contr (a; <span class="mi">1</span>)) ..<span class="mi">1</span>)
    :
    (<span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (center {a : A &amp; f a = b}).<span class="mi">1</span>) o f ==
    idmap) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk69"><span class="nb">intros</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(center {a0 : A &amp; f a0 = f a}).<span class="mi">2</span> =
ap f (contr (a; <span class="mi">1</span>)) ..<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk6a"><span class="nb">apply</span> moveL_M1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap f (contr (a; <span class="mi">1</span>)) ..<span class="mi">1</span>)^ @
(center {a0 : A &amp; f a0 = f a}).<span class="mi">2</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk6b">lhs_V napply transport_paths_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; x = f a)
  (ap f (contr (a; <span class="mi">1</span>)) ..<span class="mi">1</span>)
  (center {a0 : A &amp; f a0 = f a}).<span class="mi">2</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk6c">lhs_V napply transport_compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap (-<span class="mi">2</span>) f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = f a) (contr (a; <span class="mi">1</span>)) ..<span class="mi">1</span>
  (center {a0 : A &amp; f a0 = f a}).<span class="mi">2</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((@contr {x : A &amp; f x = f a} _ (a;<span class="mi">1</span>))..<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As usual, we can&#39;t make both of these [Instances]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> isequiv_contr_map : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that when proving a map is an equivalence, we may assume its codomain is inhabited. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk6d"><span class="kn">Definition</span> <span class="nf">isequiv_inhab_codomain</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">feq</span> : B -&gt; IsEquiv f)
  : IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>B -&gt; IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>B -&gt; IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk6f"><span class="nb">apply</span> isequiv_contr_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>B -&gt; IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk70"><span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>B -&gt; IsEquiv f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">pose</span> (feq b); <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [functor_sigma idmap g] is an equivalence then so is g. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk71"><span class="kn">Definition</span> <span class="nf">isequiv_from_functor_sigma</span> {<span class="nv">A</span>} (<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a) `{!IsEquiv (functor_sigma idmap g)}
  : <span class="kr">forall</span> (<span class="nv">a</span> : A), IsEquiv (g a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (functor_sigma idmap g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (functor_sigma idmap g)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk73"><span class="nb">intros</span> a; <span class="nb">apply</span> isequiv_contr_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (functor_sigma idmap g)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) (g a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk74"><span class="nb">apply</span> istruncmap_from_functor_sigma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (functor_sigma idmap g)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) (functor_sigma idmap g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Theorem 4.7.7: [functor_sigma idmap g] is an equivalence if and only if g is. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk75"><span class="kn">Definition</span> <span class="nf">equiv_total_iff_equiv_fiberwise</span> {<span class="nv">A</span>} (<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Type</span>)
  (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a)
  : IsEquiv (functor_sigma idmap g) &lt;-&gt; <span class="kr">forall</span> <span class="nv">a</span>, IsEquiv (g a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_sigma idmap g) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_sigma idmap g) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk77"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_sigma idmap g) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equiv-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk78"><hr></label><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)) -&gt;
IsEquiv (functor_sigma idmap g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_sigma idmap g) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isequiv_from_functor_sigma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk7a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)) -&gt;
IsEquiv (functor_sigma idmap g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk7b"><span class="nb">intro</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a -&gt; Q a</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (g a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_sigma idmap g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> isequiv_functor_sigma.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Assuming [Funext], [IsEquiv f] is an hprop, which has further consequences *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AssumeFunext</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk7c">#[export] <span class="kn">Instance</span> <span class="nf">contr_sect_equiv</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv A B f}
    : Contr {g : B -&gt; A &amp; f o g == idmap}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : B -&gt; A &amp; f o g == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : B -&gt; A &amp; f o g == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk7e"><span class="nb">refine</span> (contr_change_center (f^-<span class="mi">1</span> ; eisretr f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk7f"><span class="nb">refine</span> (contr_equiv&#39; { g : B -&gt; A &amp; f o g = idmap } _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) = idmap} &lt;~&gt;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Typeclass inference finds this contractible instance: it&#39;s the fiber over [idmap] of postcomposition with [f], and the latter is an equivalence since [f] is. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk80"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) = idmap &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_ap10.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk81">#[export] <span class="kn">Instance</span> <span class="nf">contr_retr_equiv</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv A B f}
    : Contr {g : B -&gt; A &amp; g o f == idmap}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : B -&gt; A &amp; g o f == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : B -&gt; A &amp; g o f == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk83"><span class="nb">refine</span> (contr_change_center (f^-<span class="mi">1</span> ; eissect f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk84"><span class="nb">refine</span> (contr_equiv&#39; { g : B -&gt; A &amp; g o f = idmap } _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) = idmap} &lt;~&gt;
{g : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk85"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) = idmap &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_ap10.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk86">#[export] <span class="kn">Instance</span> <span class="nf">hprop_isequiv</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B)
    : IsHProp (IsEquiv f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsEquiv f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsEquiv f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* We will show that assuming [f] is an equivalence, [IsEquiv f] decomposes into a sigma of two contractible types. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk88"><span class="nb">apply</span> hprop_inhabited_contr; <span class="nb">intros</span> feq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (IsEquiv f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk89">nrefine (contr_equiv&#39; _ (issig_isequiv f oE (equiv_sigma_assoc&#39; _ _)^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {ap0
  : {a : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (a x)) == idmap} &amp;
  {s : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; ap0.<span class="mi">1</span> (f x)) == idmap &amp;
  <span class="kr">forall</span> <span class="nv">x</span> : A, ap0.<span class="mi">2</span> (f x) = ap f (s x)}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk8a">srefine (contr_equiv&#39; _ (equiv_contr_sigma _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {a : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (a x)) == idmap}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equiv-v-chk8b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk8b"><hr></label><div class="goal-conclusion">Contr
  ((<span class="kr">fun</span>
      <span class="nv">x</span> : {a : B -&gt; A &amp;
          (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (a x)) == idmap} =&gt;
    {s : (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; x.<span class="mi">1</span> (f x0)) == idmap &amp;
    <span class="kr">forall</span> <span class="nv">x0</span> : A, x.<span class="mi">2</span> (f x0) = ap f (s x0)})
     (center
        {a : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (a x)) == idmap}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Each of these types is equivalent to a based homotopy space.  The first is exactly [contr_sect_equiv]. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk8c"><span class="mi">1</span>: rapply contr_sect_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((<span class="kr">fun</span>
      <span class="nv">x</span> : {a : B -&gt; A &amp;
          (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (a x)) == idmap} =&gt;
    {s : (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; x.<span class="mi">1</span> (f x0)) == idmap &amp;
    <span class="kr">forall</span> <span class="nv">x0</span> : A, x.<span class="mi">2</span> (f x0) = ap f (s x0)})
     (center
        {a : B -&gt; A &amp; (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (a x)) == idmap}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* The second requires a bit more work. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk8d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {s : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap &amp;
  <span class="kr">forall</span> <span class="nv">x</span> : A, eisretr f (f x) = ap f (s x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk8e"><span class="nb">refine</span> (contr_equiv&#39; { s : f^-<span class="mi">1</span> o f == idmap &amp; eissect f == s } _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap &amp;
eissect f == s} &lt;~&gt;
{s : (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap &amp;
<span class="kr">forall</span> <span class="nv">x</span> : A, eisretr f (f x) = ap f (s x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk8f"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> s; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f == s &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, eisretr f (f x) = ap f (s x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk90"><span class="nb">apply</span> equiv_functor_forall_id; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f a = s a &lt;~&gt; eisretr f (f a) = ap f (s a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk91"><span class="nb">refine</span> (equiv_concat_l (eisadj f a) _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>feq</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f^-<span class="mi">1</span> (f x)) == idmap</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eissect f a = s a &lt;~&gt; ap f (eissect f a) = ap f (s a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Now since [IsEquiv f] and the assertion that its fibers are contractible are both HProps, logical equivalence implies equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk92"><span class="kn">Definition</span> <span class="nf">equiv_contr_map_isequiv</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B)
    : IsTruncMap (-<span class="mi">2</span>) f &lt;~&gt; IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) f &lt;~&gt; IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk93"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap (-<span class="mi">2</span>) f &lt;~&gt; IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply equiv_iff_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="sd">(** Both directions are found by typeclass inference! *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** It also follows that paths of equivalences are equivalent to paths of functions. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk94"><span class="kn">Lemma</span> <span class="nf">equiv_path_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">e1</span> <span class="nv">e2</span> : A &lt;~&gt; B)
    : (e1 = e2 :&gt; (A -&gt; B)) &lt;~&gt; (e1 = e2 :&gt; (A &lt;~&gt; B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e1 = e2 &lt;~&gt; e1 = e2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk95"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e1 = e2 &lt;~&gt; e1 = e2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk96">equiv_via ((issig_equiv A B) ^<span class="mf">-1 e1</span> = (issig_equiv A B) ^<span class="mf">-1 e2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e1 = e2 &lt;~&gt;
(issig_equiv A B)^<span class="mf">-1 e1</span> = (issig_equiv A B)^<span class="mf">-1 e2</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equiv-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk97"><hr></label><div class="goal-conclusion">(issig_equiv A B)^<span class="mf">-1 e1</span> = (issig_equiv A B)^<span class="mf">-1 e2</span> &lt;~&gt;
e1 = e2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk98"><span class="mi">2</span>: <span class="nb">symmetry</span>; rapply equiv_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e1 = e2 &lt;~&gt;
(issig_equiv A B)^<span class="mf">-1 e1</span> = (issig_equiv A B)^<span class="mf">-1 e2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_path_sigma_hprop ((issig_equiv A B)^<span class="mf">-1 e1</span>) ((issig_equiv A B)^<span class="mf">-1 e2</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">e1</span> <span class="nv">e2</span> : A &lt;~&gt; B}
    : (e1 = e2 :&gt; (A -&gt; B)) -&gt; (e1 = e2 :&gt; (A &lt;~&gt; B))
    := equiv_path_equiv e1 e2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_path_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">e1</span> <span class="nv">e2</span> : A &lt;~&gt; B}
    : IsEquiv (@path_equiv _ _ e1 e2)
    <span class="c">(* Coq can find this instance by itself, but it&#39;s slow. *)</span>
    := equiv_isequiv (equiv_path_equiv e1 e2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The inverse equivalence is homotopic to [ap equiv_fun], so that is also an equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk99">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_ap_equiv_fun</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">e1</span> <span class="nv">e2</span> : A &lt;~&gt; B)
    : IsEquiv (ap (x:=e1) (y:=e2) (@equiv_fun A B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (ap equiv_fun)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk9a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (ap equiv_fun)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk9b">snapply isequiv_homotopic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e1 = e2 -&gt; e1 = e2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equiv-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk9c"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?f</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equiv-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><label class="goal-separator" for="equiv-v-chk9d"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> == ap equiv_fun</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk9e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e1 = e2 -&gt; e1 = e2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_path_equiv e1 e2)^-<span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chk9f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (equiv_path_equiv e1 e2)^-<span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_equiv e1 e2)^-<span class="mi">1</span>%equiv == ap equiv_fun</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka1"><span class="nb">intro</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>e1 = e2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_path_equiv e1 e2)^-<span class="mi">1</span>%equiv p = ap equiv_fun p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap_compose (<span class="kr">fun</span> <span class="nv">v</span> =&gt; (equiv_fun v; equiv_isequiv v)) pr1 p)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** This implies that types of equivalences inherit truncation.  Note that we only state the theorem for [n.+1]-truncatedness, since it is not true for contractibility: if [B] is contractible but [A] is not, then [A &lt;~&gt; B] is not contractible because it is not inhabited.</span>

<span class="sd">   Don&#39;t confuse this lemma with [trunc_equiv], which says that if [A] is truncated and [A] is equivalent to [B], then [B] is truncated.  It would be nice to find a better pair of names for them. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka2">#[export] <span class="kn">Instance</span> <span class="nf">istrunc_equiv</span> {<span class="nv">n</span> : trunc_index} {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{IsTrunc n.+<span class="mi">1</span> B}
    : IsTrunc n.+<span class="mi">1</span> (A &lt;~&gt; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (A &lt;~&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (A &lt;~&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka4"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A &lt;~&gt; B, IsTrunc n (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka5"><span class="nb">intros</span> e1 e2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br><span><var>e1, e2</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (e1 = e2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_equiv_istrunc _ (equiv_path_equiv e1 e2)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** In the contractible case, we have to assume that *both* types are contractible to get a contractible type of equivalences. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka6">#[export] <span class="kn">Instance</span> <span class="nf">contr_equiv_contr_contr</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{Contr A} `{Contr B}
    : Contr (A &lt;~&gt; B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Contr1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A &lt;~&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Contr1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A &lt;~&gt; B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka8"><span class="nb">apply</span> (Build_Contr _ equiv_contr_contr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Contr1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : A &lt;~&gt; B, equiv_contr_contr = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chka9"><span class="nb">intros</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Contr1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_contr_contr = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkaa"><span class="nb">apply</span> path_equiv, path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Contr0</var><span class="hyp-type"><b>: </b><span>Contr A</span></span></span><br><span><var>Contr1</var><span class="hyp-type"><b>: </b><span>Contr B</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_contr_contr == e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?; <span class="nb">apply</span> contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The type of *automorphisms* of an hprop is always contractible *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkab">#[export] <span class="kn">Instance</span> <span class="nf">contr_aut_hprop</span> <span class="nv">A</span> `{IsHProp A}
    : Contr (A &lt;~&gt; A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A &lt;~&gt; A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkac"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (A &lt;~&gt; A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkad"><span class="nb">apply</span> (Build_Contr _ <span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : A &lt;~&gt; A, <span class="mi">1</span>%equiv = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkae"><span class="nb">intros</span> e; <span class="nb">apply</span> path_equiv, path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span>%equiv == e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ?; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Equivalences are functorial under equivalences. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>} (<span class="nv">h</span> : A &lt;~&gt; C) (<span class="nv">k</span> : B &lt;~&gt; D)
    : (A &lt;~&gt; B) -&gt; (C &lt;~&gt; D)
    := <span class="kr">fun</span> <span class="nv">f</span> =&gt; ((k oE f) oE h^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkaf">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_functor_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>} (<span class="nv">h</span> : A &lt;~&gt; C) (<span class="nv">k</span> : B &lt;~&gt; D)
    : IsEquiv (functor_equiv h k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_equiv h k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (functor_equiv h k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb1"><span class="nb">refine</span> (isequiv_adjointify _
              (functor_equiv (equiv_inverse h) (equiv_inverse k)) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : C &lt;~&gt; D =&gt;
 functor_equiv h k (functor_equiv h^-<span class="mi">1</span> k^-<span class="mi">1</span> x)) ==
idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equiv-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br></div><label class="goal-separator" for="equiv-v-chkb2"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A &lt;~&gt; B =&gt;
 functor_equiv h^-<span class="mi">1</span> k^-<span class="mi">1</span> (functor_equiv h k x)) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : C &lt;~&gt; D =&gt;
 functor_equiv h k (functor_equiv h^-<span class="mi">1</span> k^-<span class="mi">1</span> x)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb4"><span class="nb">intros</span> f; <span class="nb">apply</span> path_equiv, path_arrow; <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>C &lt;~&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k (k^-<span class="mi">1</span> (f (h (h^-<span class="mi">1</span> x)))) = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (eisretr k _ @ ap f (eisretr h x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A &lt;~&gt; B =&gt;
 functor_equiv h^-<span class="mi">1</span> k^-<span class="mi">1</span> (functor_equiv h k x)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb6"><span class="nb">intros</span> g; <span class="nb">apply</span> path_equiv, path_arrow; <span class="nb">intros</span> x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; D</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k^-<span class="mi">1</span> (k (g (h^-<span class="mi">1</span> (h x)))) = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (eissect k _ @ ap g (eissect h x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>} (<span class="nv">h</span> : A &lt;~&gt; C) (<span class="nv">k</span> : B &lt;~&gt; D)
    : (A &lt;~&gt; B) &lt;~&gt; (C &lt;~&gt; D)
    := Build_Equiv _ _ (functor_equiv h k) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_precompose_equiv</span>@{i j k u v | i &lt;= u, j &lt;= v, k &lt;= u, k &lt;= v}
    {X : <span class="kt">Type</span>@{i}} {Y : <span class="kt">Type</span>@{j}} (Z : <span class="kt">Type</span>@{k}) (e : X &lt;~&gt; Y)
    : Equiv@{v u} (Y &lt;~&gt; Z) (X &lt;~&gt; Z)
    := equiv_functor_equiv e^-<span class="mi">1</span>%equiv <span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_postcompose_equiv</span>@{i j k u v | i &lt;= u, j &lt;= v, k &lt;= u, k &lt;= v}
    {X : <span class="kt">Type</span>@{i}} {Y : <span class="kt">Type</span>@{j}} (Z : <span class="kt">Type</span>@{k}) (e : X &lt;~&gt; Y)
    : Equiv@{u v} (Z &lt;~&gt; X) (Z &lt;~&gt; Y)
    := equiv_functor_equiv <span class="mi">1</span>%equiv e.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Reversing equivalences is an equivalence *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb7">#[export]  <span class="kn">Instance</span> <span class="nf">isequiv_equiv_inverse</span> {<span class="nv">A</span> <span class="nv">B</span>}
    : IsEquiv (@equiv_inverse A B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv equiv_inverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv equiv_inverse</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (isequiv_adjointify _ equiv_inverse _ _);
      <span class="nb">intros</span> e; <span class="nb">apply</span> path_equiv; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_equiv_inverse</span> <span class="nv">A</span> <span class="nv">B</span>
    : (A &lt;~&gt; B) &lt;~&gt; (B &lt;~&gt; A)
    := Build_Equiv _ _ (@equiv_inverse A B) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AssumeFunext</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Other facts about equivalences *)</span>

<span class="sd">(** This is like [transport_arrow], but for a family of equivalence types. It just shows that the functions are homotopic. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkb9"><span class="kn">Definition</span> <span class="nf">transport_equiv</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> <span class="nv">C</span> : A -&gt; <span class="kt">Type</span>}
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">f</span> : B x1 &lt;~&gt; C x1) (<span class="nv">y</span> : B x2)
  : (transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; B x &lt;~&gt; C x) p f) y = p # (f (p^ # y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B x1 &lt;~&gt; C x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; B x &lt;~&gt; C x) p f y =
transport C p (f (transport B p^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B x1 &lt;~&gt; C x1</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>B x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; B x &lt;~&gt; C x) p f y =
transport C p (f (transport B p^ y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version that shows that the underlying functions are equal. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkbb"><span class="kn">Definition</span> <span class="nf">transport_equiv&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> <span class="nv">C</span> : A -&gt; <span class="kt">Type</span>}
  {<span class="nv">x1</span> <span class="nv">x2</span> : A} (<span class="nv">p</span> : x1 = x2) (<span class="nv">f</span> : B x1 &lt;~&gt; C x1)
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; B x &lt;~&gt; C x) p f = (equiv_transport _ p) oE f oE (equiv_transport _ p^) :&gt; (B x2 -&gt; C x2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B x1 &lt;~&gt; C x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; B x &lt;~&gt; C x) p f =
equiv_transport C p oE f oE equiv_transport B p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkbc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B x1 &lt;~&gt; C x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; B x &lt;~&gt; C x) p f =
equiv_transport C p oE f oE equiv_transport B p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version that shows that the equivalences are equal.  Here we do need [Funext], for [path_equiv]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkbd"><span class="kn">Definition</span> <span class="nf">transport_equiv&#39;&#39;</span> `{Funext} {A : <span class="kt">Type</span>} {B C : A -&gt; <span class="kt">Type</span>}
  {x1 x2 : A} (p : x1 = x2) (f : B x1 &lt;~&gt; C x1)
  : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; B x &lt;~&gt; C x) p f = (equiv_transport _ p) oE f oE (equiv_transport _ p^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B x1 &lt;~&gt; C x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; B x &lt;~&gt; C x) p f =
equiv_transport C p oE f oE equiv_transport B p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkbe"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B x1 &lt;~&gt; C x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; B x &lt;~&gt; C x) p f =
equiv_transport C p oE f oE equiv_transport B p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equiv-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="equiv-v-chkbf"><span class="nb">apply</span> path_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B, C</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x1 = x2</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B x1 &lt;~&gt; C x1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; B x &lt;~&gt; C x) p f =
equiv_transport C p oE f oE equiv_transport B p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
