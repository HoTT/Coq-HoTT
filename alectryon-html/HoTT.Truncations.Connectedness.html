<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Connectedness.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Connectedness *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HFiber.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Extensions.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Factorization.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Modalities.Modality.        <span class="c">(* [Export] since the actual definitions of connectedness appear there, in the generality of a modality. *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.Descent.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core Truncations.SeparatedTrunc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This reduces universe variables in [conn_pointed_type] and [conn_point_elim], which refer to [Unit]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> trunc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** There is a slight controversy of indexing for connectedness ‚Äî in particular, how the indexing for maps should relate to the indexing for types.  One may reasonably take the connectedness of a map to correspond either to that of its *fibers*, or of its *cofiber*; these differ by 1.  The traditional topological indexing uses the cofiber.  We use the fiber, as does Lurie in [HTT]; but we choose to agree with the traditional indexing on types, while Lurie agrees with it on maps.</span>

<span class="sd">Currently, the translation is therefore as follows:</span>

<span class="sd">       HoTT              Traditional       Lurie</span>

<span class="sd">Map    (n-1)-connected   n-connected       n-connective</span>
<span class="sd">Type   n-connected       n-connected       (n+1)-connective</span>

<span class="sd">A handy benchmark: under our indexing, the map [S1 -&gt; 1] is 0-connected but not 1-connected, while the map [1 -&gt; S1] is (‚Äì1)‚Äìconnected but not 0-connected.</span>


<span class="sd">One reason for our choice is that this way, the n-truncated and n-connected maps are the modal and modally-connected maps for the n-truncation modality.  Many of the basic lemmas about connected maps are in fact true for any modality, and can be found in [Modality.v].  Thus, here we consider mainly properties that involve the interaction of connectedness at different truncation levels. *)</span>

<span class="sd">(** ** Truncatedness of the type of extensions *)</span>

<span class="sd">(** A key lemma on the interaction between connectedness and truncatedness: suppose one is trying to extend along an n-connected map, into a k-truncated family of types (k ‚â• n).  Then the space of possible extensions is (k‚Äìn‚Äì2)-truncated.</span>

<span class="sd">(Mnemonic for the indexing: think of the base case, where k=n; then we know we can eliminate, so the space of extensions is contractible.)</span>

<span class="sd">This lemma is most useful via corollaries like the wedge-inclusion, the wiggly wedge, and their n-ary generalizations. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk1"><span class="kn">Lemma</span> <span class="nf">istrunc_extension_along_conn</span> `{Funext} {m n : trunc_index}
  {A B : <span class="kt">Type</span>} (f : A -&gt; B) `{IsConnMap n _ _ f}
  (P : B -&gt; <span class="kt">Type</span>) {HP : <span class="kr">forall</span> <span class="nv">b</span>:B, IsTrunc (m +<span class="mi">2</span>+ n) (P b)}
  (d : <span class="kr">forall</span> <span class="nv">a</span>:A, P (f a))
  : IsTrunc m (ExtensionAlong f P d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m +<span class="mi">2</span>+ n) (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc m (ExtensionAlong f P d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m +<span class="mi">2</span>+ n) (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc m (ExtensionAlong f P d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk3"><span class="nb">revert</span> P HP d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m +<span class="mi">2</span>+ n) (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
IsTrunc m (ExtensionAlong f P d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk4">simple_induction m m&#39; IH; <span class="nb">intros</span> P HP d; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc n (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (ExtensionAlong f P d)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n) (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
IsTrunc m&#39; (ExtensionAlong f P d)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n).+<span class="mi">1</span> (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk5"><hr></label><div class="goal-conclusion">IsTrunc m&#39;.+<span class="mi">1</span> (ExtensionAlong f P d)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* m = ‚Äì2 *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc n (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (ExtensionAlong f P d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk7"><span class="nb">apply</span> (Build_Contr _ (extension_conn_map_elim n f P d)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc n (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : ExtensionAlong f P d,
extension_conn_map_elim (Tr n) f P d = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk8"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc n (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f P d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">extension_conn_map_elim (Tr n) f P d = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (allpath_extension_conn_map n); <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* m = S m&#39; *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n) (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
IsTrunc m&#39; (ExtensionAlong f P d)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n).+<span class="mi">1</span> (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc m&#39;.+<span class="mi">1</span> (ExtensionAlong f P d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chka"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n) (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
IsTrunc m&#39; (ExtensionAlong f P d)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n).+<span class="mi">1</span> (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : ExtensionAlong f P d, IsTrunc m&#39; (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chkb"><span class="nb">intros</span> e e&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) f</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">P</span> : B -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n) (P b)) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, P (f a),
IsTrunc m&#39; (ExtensionAlong f P d)</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m&#39; +<span class="mi">2</span>+ n).+<span class="mi">1</span> (P b)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (f a)</span></span></span><br><span><var>e, e'</var><span class="hyp-type"><b>: </b><span>ExtensionAlong f P d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc m&#39; (e = e&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (istrunc_isequiv_istrunc _ (path_extension e e&#39;)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Magically infers: paths in extensions = extensions into paths, which by induction is [m&#39;]-truncated. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Connectedness of path spaces *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chkc"><span class="kn">Instance</span> <span class="nf">isconnected_paths</span> `{Univalence} {n A}
       `{IsConnected n.+<span class="mi">1</span> A} (x y : A)
  : IsConnected n (x = y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_equiv&#39; _ (equiv_path_Tr x y)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As a consequence, we have that [ap f] is n-connected when [f] is (n+1)-connected.  See HFiber.v and Loops.v for similar results about truncated maps. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">isconnmap_ap_isconnmap</span> `{Univalence} (n : trunc_index) {A B : <span class="kt">Type</span>}
  (f : A -&gt; B) `{!IsConnMap n.+<span class="mi">1</span> f} (x y : A)
  : IsConnMap n (@ap _ _ f x y)
  := <span class="kr">fun</span> <span class="nv">p</span> =&gt; isconnected_equiv (Tr n) _ (hfiber_ap p)^-<span class="mi">1</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The converse to [isconnected_paths] holds when [A] is merely inhabited. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chke"><span class="kn">Definition</span> <span class="nf">isconnected_isconnected_allpath</span> `{Univalence} (n : trunc_index)
  (A : <span class="kt">Type</span>) `{mA : merely A}
  (isc : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected n (x = y))
  : IsConnected n.+<span class="mi">1</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected (Tr n) (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected (Tr n) (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk10">strip_truncations; <span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected (Tr n) (x = y)</span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Tr n.+<span class="mi">1</span> A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk11"><span class="nb">apply</span> (Build_Contr _ (tr mA)); <span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected (Tr n) (x = y)</span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Trunc n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tr mA = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk12">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected (Tr n) (x = y)</span></span></span><br><span><var>mA, a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tr mA = tr a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_Tr, center, isc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As a consequence, we get a converse to [isconnmap_ap_isconnmap] for (-1)-connected maps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk13"><span class="kn">Definition</span> <span class="nf">isconnmap_isconnmap_ap_surj</span> `{Univalence} (n : trunc_index) {A B : <span class="kt">Type</span>}
  (f : A -&gt; B) {surj : IsConnMap (-<span class="mi">1</span>) f}
  (isc : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap n (@ap _ _ f x y))
  : IsConnMap n.+<span class="mi">1</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>surj</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap (Tr n) (ap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n.+<span class="mi">1</span>) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>surj</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap (Tr n) (ap f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n.+<span class="mi">1</span>) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk15"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>surj</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap (Tr n) (ap f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk16"><span class="nb">apply</span> isconnected_isconnected_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>surj</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap (Tr n) (ap f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (hfiber f b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>surj</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap (Tr n) (ap f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk17"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : hfiber f b, IsConnected (Tr n) (x = y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk18"><span class="mi">1</span>: <span class="nb">apply</span> center, surj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>surj</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap (Tr n) (ap f)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : hfiber f b, IsConnected (Tr n) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk19"><span class="nb">intros</span> [x p] [y q]; <span class="nb">destruct</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>surj</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>isc</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnMap (Tr n) (ap f)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) ((x; p) = (y; <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_equiv _ _ (hfiber_ap p) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Connectivity of pointed types *)</span>

<span class="sd">(** The connectivity of a pointed type and (the inclusion of) its point are intimately connected. *)</span>

<span class="sd">(** We can&#39;t make both of these [Instance]s, as that would result in infinite loops. And the first one is not likely to be useful as an instance, as it requires guessing the point [a0]. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk1a"><span class="kn">Definition</span> <span class="nf">conn_pointed_type</span>@{u} {n : trunc_index} {A : <span class="kt">Type</span>@{u}} (a0:A)
  `{IsConnMap@{u} n _ _ (unit_name a0)}
  : IsConnected n.+<span class="mi">1</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) (unit_name a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) (unit_name a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk1c"><span class="nb">apply</span> isconnected_conn_map_to_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr n) (unit_name a0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n.+<span class="mi">1</span>) (const_tt A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (OO_cancelR_conn_map (Tr n.+<span class="mi">1</span>) (Tr n) (unit_name a0) (const_tt A)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk1d"><span class="kn">Definition</span> <span class="nf">conn_point_incl</span> `{Univalence} {n : trunc_index} {A : <span class="kt">Type</span>} (a0:A)
  `{IsConnected n.+<span class="mi">1</span> A}
  : IsConnMap n (unit_name a0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) (unit_name a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) (unit_name a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk1f">rapply (OO_cancelL_conn_map (Tr n.+<span class="mi">1</span>) (Tr n) (unit_name a0) (const_tt A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n &lt;&lt;&lt; Tr n.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> O_lex_leq_Tr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [conn_point_incl] can be made an instance, but at the time of writing, this doesn&#39;t cause any additional goals to be solved compared to making it an immediate hint, so we do the latter. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> conn_point_incl : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Note that [OO_cancelR_conn_map] and [OO_cancelL_conn_map] (Proposition 2.31 of CORS) generalize the above statements to 2/3 of a 2-out-of-3 property for connected maps, for any reflective subuniverse and its subuniverse of separated types.  If useful, we could specialize that more general form explicitly to truncations. *)</span>

<span class="sd">(** To prove an [n]-truncated predicate on an (n+1)-connected, pointed type, it&#39;s enough to prove it for the basepoint. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk20"><span class="kn">Definition</span> <span class="nf">conn_point_elim</span> `{Univalence} (n : trunc_index) {A : pType@{u}} `{IsConnected n.+<span class="mi">1</span> A}
           (P : A -&gt; <span class="kt">Type</span>@{u}) `{<span class="kr">forall</span> <span class="nv">a</span>, IsTrunc n (P a)} (p0 : P (point A))
  : <span class="kr">forall</span> <span class="nv">a</span>, P a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* This follows from [conn_point_incl] and [conn_map_elim], but we give a direct proof. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk22"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Since [A] is [n+1]-connected, [a0 = a] is [n]-connected, which means that [Tr n (a0 = a)] has an element. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk23"><span class="nb">pose proof</span> (p := center (Tr n ((point A) = a))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Tr n (point A = a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk24">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>point A = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p # p0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A computation rule for [conn_point_elim_comp]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk25"><span class="kn">Definition</span> <span class="nf">conn_point_elim_comp</span> `{Univalence} (n : trunc_index) {A : pType@{u}} `{IsConnected n.+<span class="mi">1</span> A}
  (P : A -&gt; <span class="kt">Type</span>@{u}) `{<span class="kr">forall</span> <span class="nv">a</span>, IsTrunc n (P a)} (p0 : P (point A))
  : conn_point_elim n P p0 (point A) = p0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_point_elim n P p0 (point A) = p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conn_point_elim n P p0 (point A) = p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk27"><span class="nb">unfold</span> conn_point_elim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n (P a)</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>P (point A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trunc_ind
  (<span class="kr">fun</span> <span class="nv">_</span> : Trunc n (point A = point A) =&gt; P (point A))
  (<span class="kr">fun</span> <span class="nv">p</span> : point A = point A =&gt; transport P p p0)
  (center (Tr n (point A = point A))) = p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The center of truncation isn&#39;t definitionally [tr 1], but is equal to it: *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (Trunc_ind _ _) (contr (tr idpath))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Decreasing connectedness *)</span>

<span class="sd">(** An [n.+1]-connected type is also [n]-connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk28"><span class="kn">Definition</span> <span class="nf">isconnected_pred</span> <span class="nv">n</span> <span class="nv">A</span> `{IsConnected n.+<span class="mi">1</span> A}
  : IsConnected n A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk2a"><span class="nb">apply</span> isconnected_from_elim; <span class="nb">intros</span> C ? f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>In (Tr n) C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NullHomotopy.NullHomotopy f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_elim n.+<span class="mi">1</span> C f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* As an instance, this would cause loops, but it can be added as an immediate hint. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Immediate</span> isconnected_pred : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version explicitly using the predecessor function. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk2b"><span class="kn">Definition</span> <span class="nf">isconnected_pred&#39;</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsConnected n A}
  : IsConnected n.-<span class="mi">1</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.-<span class="mi">1</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.-<span class="mi">1</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk2d"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">2</span>)) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">2</span>).-<span class="mi">1</span>) A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk2e"><hr></label><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>.-<span class="mi">1</span>) A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk2f"><span class="mi">1</span>: <span class="nb">unfold</span> IsConnected; <span class="nb">simpl</span>; <span class="nb">apply</span> istrunc_truncation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n.+<span class="mi">1</span>.-<span class="mi">1</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> isconnected_pred.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A [k]-connected type is [n]-connected, when [k &gt;= n].  We constrain [k] by making it of the form [n +2+ m], which makes the induction go through smoothly. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk30"><span class="kn">Definition</span> <span class="nf">isconnected_pred_add</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">A</span> `{H : IsConnected (n +<span class="mi">2</span>+ m) A}
  : IsConnected m A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (n +<span class="mi">2</span>+ m)) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (n +<span class="mi">2</span>+ m)) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk32"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">2</span> +<span class="mi">2</span>+ m)) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m) A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (n.+<span class="mi">1</span> +<span class="mi">2</span>+ m)) A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (n +<span class="mi">2</span>+ m)) A -&gt; IsConnected (Tr m) A</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk33"><hr></label><div class="goal-conclusion">IsConnected (Tr m) A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk34"><span class="mi">1</span>: <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (n.+<span class="mi">1</span> +<span class="mi">2</span>+ m)) A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (n +<span class="mi">2</span>+ m)) A -&gt; IsConnected (Tr m) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version with the order of summands swapped, which is sometimes handy, e.g. in the next two results. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk35"><span class="kn">Definition</span> <span class="nf">isconnected_pred_add&#39;</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">A</span> `{H : IsConnected (m +<span class="mi">2</span>+ n) A}
  : IsConnected m A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (m +<span class="mi">2</span>+ n)) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (m +<span class="mi">2</span>+ n)) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk37"><span class="nb">apply</span> (isconnected_pred_add n m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (m +<span class="mi">2</span>+ n)) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (n +<span class="mi">2</span>+ m)) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (trunc_index_add_comm m n); <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It follows that an [n.+1]-connected type is also [-1]-connected. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">merely_isconnected</span> <span class="nv">n</span> <span class="nv">A</span> `{IsConnected n.+<span class="mi">1</span> A}
  : merely A
  := @center _ (isconnected_pred_add&#39; n (-<span class="mi">1</span>) A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And that an [n.+2]-connected type is [0]-connected. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is0connected_isconnected</span> (<span class="nv">n</span> : trunc_index) <span class="nv">A</span> `{IsConnected n.+<span class="mi">2</span> A}
  : IsConnected <span class="mi">0</span> A
  := isconnected_pred_add&#39; n <span class="mi">0</span> A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isconnmap_pred&#39;</span> (<span class="nv">n</span> : trunc_index) {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  `{IsConnMap n _ _ f}
  : IsConnMap n.-<span class="mi">1</span> f
  := <span class="kr">fun</span> <span class="nv">b</span> =&gt; isconnected_pred&#39; n _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk38"><span class="kn">Definition</span> <span class="nf">isconnmap_pred_add</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B) `{IsConnMap (n +<span class="mi">2</span>+ m) _ _ f}
  : IsConnMap m f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (n +<span class="mi">2</span>+ m)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr m) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (n +<span class="mi">2</span>+ m)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr m) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk3a"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (n +<span class="mi">2</span>+ m)) f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr m) (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isconnected_pred_add n m _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** (-2)-connectedness *)</span>

<span class="sd">(** Every type is (-2)-connected. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isconnected_minus_two</span> <span class="nv">A</span> : IsConnected (-<span class="mi">2</span>) A
  := istrunc_truncation (-<span class="mi">2</span>) A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Every map is (-2)-connected. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isconnmap_minus_two</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  : IsConnMap (-<span class="mi">2</span>) f
  := <span class="kr">fun</span> <span class="nv">b</span> =&gt; isconnected_minus_two _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Immediate</span> isconnected_minus_two : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Immediate</span> isconnmap_minus_two : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** 0-connectedness *)</span>

<span class="sd">(** To be 0-connected is the same as to be (-1)-connected and that any two points are merely equal.  TODO: This should also be generalized to separated subuniverses (CORS Remark 2.35).  *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk3b"><span class="kn">Definition</span> <span class="nf">merely_path_is0connected</span> `{Univalence}
           (A : <span class="kt">Type</span>) `{IsConnected <span class="mi">0</span> A} (x y : A)
  : merely (x = y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** This follows immediately from [isconnected_paths] above. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply center.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The converse holds when [A] is merely inhabited. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk3d"><span class="kn">Definition</span> <span class="nf">is0connected_merely_allpath</span> `{Univalence}
           (A : <span class="kt">Type</span>) `{mA : merely A}
           (p : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span>:A), merely (x = y))
  : IsConnected <span class="mi">0</span> A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, merely (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, merely (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk3f"><span class="nb">apply</span> (isconnected_isconnected_allpath _ _ (mA:=mA)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, merely (x = y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected (Tr (-<span class="mi">1</span>)) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk40"><span class="nb">intros</span> x y; <span class="nb">hnf</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mA</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, merely (x = y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Tr (-<span class="mi">1</span>) (x = y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_inhabited_hprop _ (p x y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The path component of a point [x : X] is connected. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk41"><span class="kn">Instance</span> <span class="nf">is0connected_component</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : X)
  : IsConnected <span class="mi">0</span> { z : X &amp; merely (z = x) }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) {z : X &amp; merely (z = x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr <span class="mi">0</span>) {z : X &amp; merely (z = x)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk43"><span class="nb">apply</span> (Build_Contr _ (tr (x; tr idpath))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : Trunc <span class="mi">0</span> {z : X &amp; merely (z = x)},
tr (x; tr <span class="mi">1</span>) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk44">rapply Trunc_ind; <span class="nb">intros</span> [Z p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, Z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>merely (Z = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tr (x; tr <span class="mi">1</span>) = tr (Z; p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk45">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, Z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Z = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tr (x; tr <span class="mi">1</span>) = tr (Z; tr p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk46"><span class="nb">apply</span> (ap tr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, Z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Z = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x; tr <span class="mi">1</span>) = (Z; tr p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk47">rapply path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, Z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Z = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x; tr <span class="mi">1</span>).<span class="mi">1</span> = (Z; tr p).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> p^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any two points in a path component are merely equal.  This follows from [merely_path_is0connected], but this proof doesn&#39;t need univalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk48"><span class="kn">Definition</span> <span class="nf">merely_path_component</span> {<span class="nv">X</span> : <span class="kt">Type</span>} {<span class="nv">x</span> : X}
  (<span class="nv">z1</span> <span class="nv">z2</span> : { z : X &amp; merely (z = x) })
  : merely (z1 = z2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>z1, z2</var><span class="hyp-type"><b>: </b><span>{z : X &amp; merely (z = x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (z1 = z2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>z1, z2</var><span class="hyp-type"><b>: </b><span>{z : X &amp; merely (z = x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (z1 = z2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk4a"><span class="nb">destruct</span> z1 <span class="kr">as</span> [z1 p1], z2 <span class="kr">as</span> [z2 p2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z1</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>merely (z1 = x)</span></span></span><br><span><var>z2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>merely (z2 = x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely ((z1; p1) = (z2; p2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk4b">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z1, z2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>z2 = x</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>z1 = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely ((z1; tr p1) = (z2; tr p2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk4c"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z1, z2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>z2 = x</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>z1 = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(z1; tr p1) = (z2; tr p2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk4d"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z1, z2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>z2 = x</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>z1 = x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">z1 = z2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p1 @ p2^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The path component of a point [x : X] is equivalent to the image of the constant map [Unit -&gt; X] at [x]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk4e"><span class="kn">Definition</span> <span class="nf">equiv_component_image_unit</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : X)
  : { z : X &amp; merely (z = x) } &lt;~&gt; image (Tr (-<span class="mi">1</span>)) (unit_name x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{z : X &amp; merely (z = x)} &lt;~&gt;
image (Tr (-<span class="mi">1</span>)) (unit_name x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{z : X &amp; merely (z = x)} &lt;~&gt;
image (Tr (-<span class="mi">1</span>)) (unit_name x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk50"><span class="nb">unfold</span> image; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{z : X &amp; Tr (-<span class="mi">1</span>) (z = x)} &lt;~&gt;
{b : X &amp; Tr (-<span class="mi">1</span>) (hfiber (unit_name x) b)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk51"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> z; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (z = x) &lt;~&gt; Tr (-<span class="mi">1</span>) (hfiber (unit_name x) z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk52"><span class="nb">apply</span> Trunc_functor_equiv; <span class="nb">unfold</span> hfiber.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">z = x &lt;~&gt; {_ : Unit &amp; x = z}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk53"><span class="nb">refine</span> ((equiv_contr_sigma _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">z = x &lt;~&gt; x = z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** 0-connected types are indecomposable *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk54"><span class="kn">Instance</span> <span class="nf">indecomposable_0connected</span> `{Univalence}
       (X : <span class="kt">Type</span>) `{IsConnected <span class="mi">0</span> X}
  : Indecomposable X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Indecomposable X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Indecomposable X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk56"><span class="nb">assert</span> (IsConnected (-<span class="mi">1</span>) X) <span class="bp">by</span> <span class="bp">exact</span> (isconnected_pred (-<span class="mi">1</span>) X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Indecomposable X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk57"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; A + B),
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk58"><hr></label><div class="goal-conclusion">~~ X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X -&gt; A + B),
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk5a"><span class="nb">intros</span> A B f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk5b"><span class="nb">assert</span> (z := center (merely X) : merely X); <span class="nb">generalize</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely X -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk5c"><span class="nb">refine</span> (Trunc_rec _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  ((<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
   (<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk5d"><hr></label><div class="goal-conclusion">X -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk5e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  ((<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
   (<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk5f"><span class="nb">apply</span> ishprop_sum; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x)) -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk60"><span class="nb">intros</span> l r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk61">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (not_is_inl_and_inr&#39; (f z) (l z) (r z)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk62">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk63"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk64"><span class="nb">remember</span> (f x) <span class="kr">as</span> y <span class="nb">eqn</span>:p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A + B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inl (f x)) +
(<span class="kr">forall</span> <span class="nv">x</span> : X, is_inr (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk65"><span class="nb">destruct</span> y <span class="kr">as</span> [a|b]; [ <span class="nb">left</span> | <span class="nb">right</span> ]; <span class="nb">intros</span> x&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = inl a</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (f x&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>merely X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = inr b</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk66"><hr></label><div class="goal-conclusion">is_inr (f x&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk67"><span class="kp">all</span>:<span class="nb">assert</span> (q := merely_path_is0connected X x x&#39;);
        strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = inl a</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (f x&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = inr b</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk68"><hr></label><div class="goal-conclusion">is_inr (f x&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk69"><span class="kp">all</span>:<span class="nb">refine</span> (transport _ (ap f q) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = inl a</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_inl (f x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A + B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = inr b</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>x = x&#39;</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk6a"><hr></label><div class="goal-conclusion">is_inr (f x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>:<span class="bp">exact</span> (transport _ p^ tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk6b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk6c"><span class="nb">intros</span> nx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>nx</var><span class="hyp-type"><b>: </b><span>~ X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk6d"><span class="nb">apply</span> (Trunc_rec (n := -<span class="mi">1</span>) nx).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) X</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr (-<span class="mi">1</span>)) X</span></span></span><br><span><var>nx</var><span class="hyp-type"><b>: </b><span>~ X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trunc (-<span class="mi">1</span>) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (center (merely X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Truncation preserves connectedness. Note that this is for different levels. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk6e"><span class="kn">Instance</span> <span class="nf">isconnected_trunc</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">n</span> <span class="nv">m</span> : trunc_index) `{IsConnected n X}
  : IsConnected n (Tr m X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk6f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr n) (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk70"><span class="nb">unfold</span> IsConnected.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Tr n (Tr m X))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_equiv&#39; _ (Trunc_swap n m X)^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Wedge_Incl_Conn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Connectivity of the wedge into the product *)</span>

<span class="sd">(** A very useful form of the key lemma [istrunc_extension_along_conn] is the connectivity of the wedge into the product, for a pair of pointed spaces.  In fact this can be formulated without mentioning the wedge per se (so, without requiring HIT‚Äôs), since the statement only needs to talk about maps out of the wedge.  The version involving the wedge itself is deduced in Homotopy/Wedge.v.</span>

<span class="sd">Once again, we believe that the type of the conclusion is an hprop (though we do not prove it) ‚Äî essentially because it is wrapping up an elimination principle and its corresponding computation rule ‚Äî and so we make the proof of this result opaque. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence}
  {m n : trunc_index}
  {A : <span class="kt">Type</span>} (a0 : A) `{IsConnected m.+<span class="mi">1</span> A}
  {B : <span class="kt">Type</span>} (b0 : B) `{IsConnected n.+<span class="mi">1</span> B}
  (P : A -&gt; B -&gt; <span class="kt">Type</span>) {HP : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, IsTrunc (m +<span class="mi">2</span>+ n) (P a b)}
  (f_a0 : <span class="kr">forall</span> <span class="nv">b</span>:B, P a0 b)
  (f_b0 : <span class="kr">forall</span> <span class="nv">a</span>:A, P a b0)
  (f_a0b0 : f_a0 b0 = f_b0 a0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk71"><span class="kn">Corollary</span> <span class="nf">isconn_wedge_incl</span>
  : { f : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P a b
  &amp; { e_a0 : <span class="kr">forall</span> <span class="nv">b</span>, f a0 b = f_a0 b
  &amp; { e_b0 : <span class="kr">forall</span> <span class="nv">a</span>, f a b0 = f_b0 a
  &amp; e_b0 a0 = (e_a0 b0) @ f_a0b0 }}}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b &amp;
{e_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, f a0 b = f_a0 b &amp;
{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, f a b0 = f_b0 a &amp;
e_b0 a0 = e_a0 b0 @ f_a0b0}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b &amp;
{e_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, f a0 b = f_a0 b &amp;
{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, f a b0 = f_b0 a &amp;
e_b0 a0 = e_a0 b0 @ f_a0b0}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk73"><span class="nb">assert</span> (goal_as_extension :
    ExtensionAlong (unit_name a0)
      (<span class="kr">fun</span> <span class="nv">a</span> =&gt; ExtensionAlong (unit_name b0) (P a) (unit_name (f_b0 a)))
      (unit_name (f_a0 ; (unit_name f_a0b0)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (unit_name a0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ExtensionAlong (unit_name b0) (P a)
     (unit_name (f_b0 a)))
  (unit_name (f_a0; unit_name f_a0b0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>goal_as_extension</var><span class="hyp-type"><b>: </b><span>ExtensionAlong (unit_name a0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ExtensionAlong (unit_name b0)
     (P a) (unit_name (f_b0 a)))
  (<span class="kr">fun</span> <span class="nv">x</span> : Unit =&gt;
   (f_a0; unit_name f_a0b0))</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk74"><hr></label><div class="goal-conclusion">{f : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b &amp;
{e_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, f a0 b = f_a0 b &amp;
{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, f a b0 = f_b0 a &amp;
e_b0 a0 = e_a0 b0 @ f_a0b0}}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk75">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExtensionAlong (unit_name a0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ExtensionAlong (unit_name b0) (P a)
     (unit_name (f_b0 a)))
  (unit_name (f_a0; unit_name f_a0b0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk76"><span class="nb">apply</span> (extension_conn_map_elim m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr m) (unit_name a0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk77"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : A,
In (Tr m)
  (ExtensionAlong (unit_name b0) 
     (P b) (unit_name (f_b0 b)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk78">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr m) (unit_name a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (conn_point_incl a0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk79">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : A,
In (Tr m)
  (ExtensionAlong (unit_name b0) (P b)
     (unit_name (f_b0 b)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk7a"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Tr m)
  (ExtensionAlong (unit_name b0) (P a)
     (unit_name (f_b0 a)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk7b"><span class="nb">apply</span> (istrunc_extension_along_conn (n := n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) (unit_name b0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="connectedness-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="connectedness-v-chk7c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk7d">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) (unit_name b0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (conn_point_incl b0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk7e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : B, IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> HP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>goal_as_extension</var><span class="hyp-type"><b>: </b><span>ExtensionAlong (unit_name a0)
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ExtensionAlong (unit_name b0)
     (P a) (unit_name (f_b0 a)))
  (<span class="kr">fun</span> <span class="nv">x</span> : Unit =&gt;
   (f_a0; unit_name f_a0b0))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b &amp;
{e_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, f a0 b = f_a0 b &amp;
{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, f a b0 = f_b0 a &amp;
e_b0 a0 = e_a0 b0 @ f_a0b0}}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk80"><span class="nb">destruct</span> goal_as_extension <span class="kr">as</span> [f_eb name_ea_eab].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>name_ea_eab</var><span class="hyp-type"><b>: </b><span>Unit -&gt;
f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b &amp;
{e_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, f a0 b = f_a0 b &amp;
{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, f a b0 = f_b0 a &amp;
e_b0 a0 = e_a0 b0 @ f_a0b0}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk81"><span class="nb">assert</span> (ea_eab := name_ea_eab tt); <span class="nb">clear</span> name_ea_eab.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b &amp;
{e_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, f a0 b = f_a0 b &amp;
{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, f a b0 = f_b0 a &amp;
e_b0 a0 = e_a0 b0 @ f_a0b0}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk82"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">a</span> =&gt; pr1 (f_eb a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{e_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, (f_eb a0).<span class="mi">1</span> b = f_a0 b &amp;
{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, (f_eb a).<span class="mi">1</span> b0 = f_b0 a &amp;
e_b0 a0 = e_a0 b0 @ f_a0b0}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk83"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">b</span> =&gt; apD10 (ea_eab ..<span class="mi">1</span>) b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{e_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, (f_eb a).<span class="mi">1</span> b0 = f_b0 a &amp;
e_b0 a0 = apD10 ea_eab ..<span class="mi">1</span> b0 @ f_a0b0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk84"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">a</span> =&gt; pr2 (f_eb a) tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f_eb a0).<span class="mi">2</span> tt = apD10 ea_eab ..<span class="mi">1</span> b0 @ f_a0b0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* The last component is essentially (g&#39; ..2), wrapped in a bit of path-algebra. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk85"><span class="nb">apply</span> moveL_Mp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD10 ea_eab ..<span class="mi">1</span> b0)^ @ (f_eb a0).<span class="mi">2</span> tt = f_a0b0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk86">rhs_V napply (apD10 (ea_eab ..<span class="mi">2</span>) tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD10 ea_eab ..<span class="mi">1</span> b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
transport
  (<span class="kr">fun</span> <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt;
   Unit -&gt; s b0 = f_b0 a0) ea_eab ..<span class="mi">1</span> (f_eb a0).<span class="mi">2</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk87"><span class="nb">set</span> (ea := ea_eab ..<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br><span><var>ea</var><span><span class="hyp-body"><b>:= </b><span>ea_eab ..<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>(f_eb a0).<span class="mi">1</span> = (f_a0; unit_name f_a0b0).<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD10 ea b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
transport
  (<span class="kr">fun</span> <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt;
   Unit -&gt; s b0 = f_b0 a0) ea (f_eb a0).<span class="mi">2</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk88"><span class="nb">generalize</span> ea; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea_eab</var><span class="hyp-type"><b>: </b><span>f_eb a0 = (f_a0; unit_name f_a0b0)</span></span></span><br><span><var>ea</var><span><span class="hyp-body"><b>:= </b><span>ea_eab ..<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>(f_eb a0).<span class="mi">1</span> = (f_a0; unit_name f_a0b0).<span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ea</span> : (f_eb a0).<span class="mi">1</span> = f_a0,
(apD10 ea b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
transport
  (<span class="kr">fun</span> <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt;
   Unit -&gt; s b0 = f_b0 a0) ea (f_eb a0).<span class="mi">2</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk89"><span class="nb">clear</span> ea_eab ea.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ea</span> : (f_eb a0).<span class="mi">1</span> = f_a0,
(apD10 ea b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
transport
  (<span class="kr">fun</span> <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt;
   Unit -&gt; s b0 = f_b0 a0) ea (f_eb a0).<span class="mi">2</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk8a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea</var><span class="hyp-type"><b>: </b><span>(f_eb a0).<span class="mi">1</span> = f_a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD10 ea b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
transport
  (<span class="kr">fun</span> <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt;
   Unit -&gt; s b0 = f_b0 a0) ea (f_eb a0).<span class="mi">2</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk8b"><span class="nb">rewrite</span> transport_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea</var><span class="hyp-type"><b>: </b><span>(f_eb a0).<span class="mi">1</span> = f_a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD10 ea b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt; x b0 = f_b0 a0) ea
  ((f_eb a0).<span class="mi">2</span>
     (transport (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt; Unit)
        ea^ tt))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk8c"><span class="nb">rewrite</span> transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea</var><span class="hyp-type"><b>: </b><span>(f_eb a0).<span class="mi">1</span> = f_a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD10 ea b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt; x b0 = f_b0 a0) ea
  ((f_eb a0).<span class="mi">2</span> tt)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk8d"><span class="nb">rewrite</span> transport_paths_Fl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br><span><var>f_eb</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
ExtensionAlong (unit_name b0) 
  (P y) (unit_name (f_b0 y))</span></span></span><br><span><var>ea</var><span class="hyp-type"><b>: </b><span>(f_eb a0).<span class="mi">1</span> = f_a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD10 ea b0)^ @ (f_eb a0).<span class="mi">2</span> tt =
(ap (<span class="kr">fun</span> <span class="nv">x</span> : <span class="kr">forall</span> <span class="nv">y</span> : B, P a0 y =&gt; x b0) ea)^ @
(f_eb a0).<span class="mi">2</span> tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> <span class="mi">1</span>%path.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** It is easier to apply the above result with its components separated. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wedge_incl_elim</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P a b
  := isconn_wedge_incl.<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wedge_incl_comp1</span> : <span class="kr">forall</span> <span class="nv">b</span>, wedge_incl_elim a0 b = f_a0 b
  := isconn_wedge_incl.<span class="mi">2</span>.<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wedge_incl_comp2</span> : <span class="kr">forall</span> <span class="nv">a</span>, wedge_incl_elim a b0 = f_b0 a
  := isconn_wedge_incl.<span class="mi">2</span>.<span class="mi">2</span>.<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wedge_incl_comp3</span>
  : wedge_incl_comp2 a0 = (wedge_incl_comp1 b0) @ f_a0b0
  := isconn_wedge_incl.<span class="mi">2</span>.<span class="mi">2</span>.<span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Wedge_Incl_Conn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk8e"><span class="kn">Definition</span> <span class="nf">wedge_incl_elim_uncurried</span> `{Univalence}
  {m n : trunc_index}
  {A : <span class="kt">Type</span>} (a0 : A) `{IsConnected m.+<span class="mi">1</span> A}
  {B : <span class="kt">Type</span>} (b0 : B) `{IsConnected n.+<span class="mi">1</span> B}
  (P : A -&gt; B -&gt; <span class="kt">Type</span>) {HP : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, IsTrunc (m +<span class="mi">2</span>+ n) (P a b)}
  (fs : {f_a0 : <span class="kr">forall</span> <span class="nv">b</span>:B, P a0 b
        &amp; { f_b0 : <span class="kr">forall</span> <span class="nv">a</span>:A, P a b0
        &amp; f_a0 b0 = f_b0 a0 }})
  : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>{f_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b &amp;
{f_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, P a b0 &amp; f_a0 b0 = f_b0 a0}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk8f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>fs</var><span class="hyp-type"><b>: </b><span>{f_a0 : <span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b &amp;
{f_b0 : <span class="kr">forall</span> <span class="nv">a</span> : A, P a b0 &amp; f_a0 b0 = f_b0 a0}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="connectedness-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="connectedness-v-chk90"><span class="nb">destruct</span> fs <span class="kr">as</span> [f_a0 [f_b0 f_a0b0]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr m.+<span class="mi">1</span>) A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr n.+<span class="mi">1</span>) B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; <span class="kt">Type</span></span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), IsTrunc (m +<span class="mi">2</span>+ n) (P a b)</span></span></span><br><span><var>f_a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, P a0 b</span></span></span><br><span><var>f_b0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P a b0</span></span></span><br><span><var>f_a0b0</var><span class="hyp-type"><b>: </b><span>f_a0 b0 = f_b0 a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B), P a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (wedge_incl_elim _ _ _ _ _ f_a0b0).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
