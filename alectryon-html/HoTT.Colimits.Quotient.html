<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Quotient.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HSet.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> TruncType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.GraphQuotient.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The set-quotient of a type by a relation</span>

<span class="sd">We aim to model:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">Inductive Quotient R : Type :=</span>
<span class="sd">   | class_of R : A -&gt; Quotient R</span>
<span class="sd">   | qglue : forall x y, (R x y) -&gt; class_of R x = class_of R y</span>
<span class="sd">   | ishset_quotient : IsHSet (Quotient R)</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">We do this by defining the quotient as a 0-truncated graph quotient. </span>

<span class="sd">Some results require additional assumptions, for example, that the relation be hprop-valued, or that the relation be reflexive, transitive or symmetric.</span>

<span class="sd">Throughout this file [a], [b] and [c] are elements of [A], [R] is a relation on [A], [x], [y] and [z] are elements of [Quotient R], [p] is a proof of [R a b].</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Quotient</span>@{i j k} {A : <span class="kt">Type</span>@{i}} (R : Relation@{i j} A) : <span class="kt">Type</span>@{k}
  := Trunc@{k} <span class="mi">0</span> (GraphQuotient@{i j k} R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">class_of</span>@{i j k} {A : <span class="kt">Type</span>@{i}} (R : Relation@{i j} A)
  : A -&gt; Quotient@{i j k} R := tr o gq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">qglue</span>@{i j k} {A : <span class="kt">Type</span>@{i}} {R : Relation@{i j} A} {a b : A}
  : R a b -&gt; class_of@{i j k} R a = class_of R b
  := <span class="kr">fun</span> <span class="nv">p</span> =&gt; ap tr (gqglue p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ishset_quotient</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A)
  : IsHSet (Quotient R) := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk1"><span class="kn">Definition</span> <span class="nf">Quotient_ind</span>@{i j k l} {A : <span class="kt">Type</span>@{i}} (R : Relation@{i j} A)
  (P : Quotient@{i j k} R -&gt; <span class="kt">Type</span>@{l}) {sP : <span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)}
  (pclass : <span class="kr">forall</span> <span class="nv">a</span>, P (class_of R a))
  (peq : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> (<span class="nv">H</span> : R a b), qglue H # pclass a = pclass b)
  : <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk3">rapply Trunc_ind; srapply GraphQuotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt; P (tr x)) (gq a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk4"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">s</span> : R a b),
transport (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt; P (tr x))
  (gqglue s) (<span class="nl">?gq&#39;</span> a) = 
<span class="nl">?gq&#39;</span> b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt; P (tr x)) (gq a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pclass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">s</span> : R a b),
transport (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt; P (tr x))
  (gqglue s) (pclass a) = pclass b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk7"><span class="nb">intros</span> a b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt; P (tr x))
  (gqglue p) (pclass a) = pclass b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk8">lhs napply (transport_compose P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (ap tr (gqglue p)) (pclass a) = pclass b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (peq a b p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk9"><span class="kn">Definition</span> <span class="nf">Quotient_ind_beta_qglue</span>@{i j k l}
  {A : <span class="kt">Type</span>@{i}} (R : Relation@{i j} A)
  (P : Quotient@{i j k} R -&gt; <span class="kt">Type</span>@{l}) {sP : <span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)}
  (pclass : <span class="kr">forall</span> <span class="nv">a</span>, P (class_of R a))
  (peq : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> (<span class="nv">H</span> : R a b), qglue H # pclass a = pclass b)
  (a b : A) (p : R a b)
  : apD (Quotient_ind@{i j k l} R P pclass peq) (qglue p) = peq a b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Quotient_ind R P pclass peq) (qglue p) =
peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Quotient_ind R P pclass peq) (qglue p) =
peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb">lhs napply apD_compose&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_compose P tr (gqglue p)
   (Quotient_ind R P pclass peq (tr (gq a))))^ @
apD
  (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt;
   Quotient_ind R P pclass peq (tr x)) (gqglue p) =
peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc"><span class="nb">unfold</span> Quotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_compose P tr (gqglue p)
   (Trunc_ind P
      (GraphQuotient_ind
         (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt; P (tr x)) pclass
         (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a b) =&gt;
          transport_compose P tr (gqglue p) (pclass a) @
          peq a b p)) (tr (gq a))))^ @
apD
  (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt;
   Trunc_ind P
     (GraphQuotient_ind
        (<span class="kr">fun</span> <span class="nv">x0</span> : GraphQuotient R =&gt; P (tr x0)) pclass
        (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a b) =&gt;
         transport_compose P tr (gqglue p) (pclass a) @
         peq a b p)) (tr x)) (gqglue p) = peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd">nrefine (ap _ (GraphQuotient_ind_beta_gqglue _ pclass
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">p0</span> =&gt; transport_compose P tr _ _ @ peq a b p0) _ _ _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Quotient R, IsHSet (P x)</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (pclass a) = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_compose P tr (gqglue p)
   (Trunc_ind P
      (GraphQuotient_ind
         (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt; P (tr x)) pclass
         (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a b) =&gt;
          transport_compose P tr (gqglue p) (pclass a) @
          peq a b p)) (tr (gq a))))^ @
(transport_compose P tr (gqglue p) (pclass a) @
 peq a b p) = peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply concat_V_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke"><span class="kn">Definition</span> <span class="nf">Quotient_rec</span>@{i j k l}
  {A : <span class="kt">Type</span>@{i}} (R : Relation@{i j} A)
  (P : <span class="kt">Type</span>@{l}) `{IsHSet P} (pclass : A -&gt; P)
  (peq : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b -&gt; pclass a = pclass b)
  : Quotient@{i j k} R -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient R -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient R -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk10">srapply Trunc_rec; snapply GraphQuotient_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk11"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; <span class="nl">?c</span> a = <span class="nl">?c</span> b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> pclass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> peq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk14"><span class="kn">Definition</span> <span class="nf">Quotient_rec_beta_qglue</span> @{i j k l}
  {A : <span class="kt">Type</span>@{i}} (R : Relation@{i j} A)
  (P : <span class="kt">Type</span>@{l}) `{IsHSet P} (pclass : A -&gt; P)
  (peq : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b -&gt; pclass a = pclass b)
  (a b : A) (p : R a b)
  : ap (Quotient_rec@{i j k l} R P pclass peq) (qglue p) = peq a b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Quotient_rec R P pclass peq) (qglue p) = peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Quotient_rec R P pclass peq) (qglue p) = peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk16">lhs_V napply (ap_compose tr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet P</span></span></span><br><span><var>pclass</var><span class="hyp-type"><b>: </b><span>A -&gt; P</span></span></span><br><span><var>peq</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; pclass a = pclass b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (<span class="kr">fun</span> <span class="nv">x</span> : GraphQuotient R =&gt;
   Quotient_rec R P pclass peq (tr x)) (gqglue p) =
peq a b p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">snapply GraphQuotient_rec_beta_gqglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Quotient : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> class_of : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> qglue : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Quotient_ind_beta_qglue : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Quotient_rec_beta_qglue : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A / R&quot;</span> := (Quotient (A:=A) R).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Quotient induction into an hprop. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk17"><span class="kn">Definition</span> <span class="nf">Quotient_ind_hprop</span> {<span class="nv">A</span> : <span class="kt">Type</span>@{i}} (<span class="nv">R</span> : Relation@{i j} A)
  (<span class="nv">P</span> : A / R -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)}
  (dclass : <span class="kr">forall</span> <span class="nv">a</span>, P (class_of R a))
  : <span class="kr">forall</span> <span class="nv">x</span>, P x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A / R, IsHProp (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A / R, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A / R, IsHProp (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A / R, P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk19">srapply (Quotient_ind R P dclass).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A / R, IsHProp (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, P (class_of R a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport P (qglue H) (dclass a) = dclass b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> x y p; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk1a"><span class="kn">Definition</span> <span class="nf">Quotient_ind2_hprop</span> {<span class="nv">A</span> : <span class="kt">Type</span>@{i}} (<span class="nv">R</span> : Relation@{i j} A)
  (<span class="nv">P</span> : A / R -&gt; A / R -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHProp (P x y)}
  (dclass : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (class_of R a) (class_of R b))
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_mere_relation (A / R) P</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, P x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk1b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_mere_relation (A / R) P</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, P x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk1c"><span class="nb">intros</span> x; srapply Quotient_ind_hprop; <span class="nb">intros</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_mere_relation (A / R) P</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x (class_of R b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk1d"><span class="nb">revert</span> x; srapply Quotient_ind_hprop; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_mere_relation (A / R) P</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>b, a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b)) (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (dclass a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk1e"><span class="kn">Definition</span> <span class="nf">Quotient_ind3_hprop</span> {<span class="nv">A</span> : <span class="kt">Type</span>@{i}} (<span class="nv">R</span> : Relation@{i j} A)
  (<span class="nv">P</span> : A / R -&gt; A / R -&gt; A / R -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, IsHProp (P x y z)}
  (dclass : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>, P (class_of R a) (class_of R b) (class_of R c))
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, P x y z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A / R, IsHProp (P x y z)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A,
P (class_of R a) (class_of R b)
  (class_of R c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A / R, P x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A / R, IsHProp (P x y z)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A,
P (class_of R a) (class_of R b)
  (class_of R c)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A / R, P x y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk20"><span class="nb">intros</span> x; srapply Quotient_ind2_hprop; <span class="nb">intros</span> b c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A / R, IsHProp (P x y z)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A,
P (class_of R a) (class_of R b)
  (class_of R c)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x (class_of R b) (class_of R c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk21"><span class="nb">revert</span> x; srapply Quotient_ind_hprop; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A / R, IsHProp (P x y z)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A,
P (class_of R a) (class_of R b)
  (class_of R c)</span></span></span><br><span><var>b, c, a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b) (class_of R c))
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (dclass a b c).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk22"><span class="kn">Definition</span> <span class="nf">Quotient_ind2</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A)
  (<span class="nv">P</span> : A / R -&gt; A / R -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHSet (P x y)}
  (dclass : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, P (class_of R a) (class_of R b))
  (dequiv_l : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> (<span class="nv">p</span> : R a a&#39;),
    transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P x _) (qglue p) (dclass a b) = dclass a&#39; b)
  (dequiv_r : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> (<span class="nv">p</span> : R b b&#39;), qglue p # dclass a b = dclass a b&#39;)
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, P x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, P x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, P x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk24"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : A / R, P x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk25">srapply Quotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, P x (class_of R a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk26"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H0</span> : R a b),
transport (P x) (qglue H0) (<span class="nl">?pclass</span> a) = <span class="nl">?pclass</span> b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk27">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, P x (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk28"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x (class_of R b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk29"><span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A / R, P x (class_of R b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk2a">srapply Quotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b)) (class_of R a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk2b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b0</span> : A) (<span class="nv">H0</span> : R a b0),
transport (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue H0) (<span class="nl">?pclass</span> a) = 
<span class="nl">?pclass</span> b0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk2c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b)) (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk2d"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b, a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b)) (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (dclass a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk2e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b0</span> : A) (<span class="nv">H</span> : R a b0),
transport (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue H) ((<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; dclass a0 b) a) =
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; dclass a0 b) b0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk2f"><span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b0</span> : A) (<span class="nv">H</span> : R a b0),
transport (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue H) (dclass a b) = dclass b0 b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk30"><span class="nb">intros</span> a a&#39; p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b, a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = dclass a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> dequiv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H0</span> : R a b),
transport (P x) (qglue H0)
  ((<span class="kr">fun</span> <span class="nv">b0</span> : A =&gt;
    Quotient_ind R
      (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b0))
      (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; dclass a0 b0)
      ((<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a0 a&#39;) =&gt;
        dequiv_l a0 a&#39; b0 p)
       :
       <span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">b1</span> : A) (<span class="nv">H</span> : R a0 b1),
       transport
         (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b0))
         (qglue H) ((<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; dclass a1 b0) a0) =
       (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; dclass a1 b0) b1) x) a) =
(<span class="kr">fun</span> <span class="nv">b0</span> : A =&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b0))
   (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; dclass a0 b0)
   ((<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a0 a&#39;) =&gt;
     dequiv_l a0 a&#39; b0 p)
    :
    <span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">b1</span> : A) (<span class="nv">H</span> : R a0 b1),
    transport (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b0))
      (qglue H) ((<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; dclass a1 b0) a0) =
    (<span class="kr">fun</span> <span class="nv">a1</span> : A =&gt; dclass a1 b0) b1) x) b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk32"><span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H0</span> : R a b),
transport (P x) (qglue H0)
  (Quotient_ind R
     (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R a))
     (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; dclass a0 a)
     (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a0 a&#39;) =&gt;
      dequiv_l a0 a&#39; a p) x) =
Quotient_ind R (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; dclass a0 b)
  (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a0 a&#39;) =&gt; dequiv_l a0 a&#39; b p)
  x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk33"><span class="nb">intros</span> b b&#39; p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R b b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (P x) (qglue p)
  (Quotient_ind R
     (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
     (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; dclass a b)
     (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a a&#39;) =&gt; dequiv_l a a&#39; b p)
     x) =
Quotient_ind R (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b&#39;))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; dclass a b&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a a&#39;) =&gt; dequiv_l a a&#39; b&#39; p)
  x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk34"><span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R b b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A / R,
transport (P x) (qglue p)
  (Quotient_ind R
     (<span class="kr">fun</span> <span class="nv">x0</span> : A / R =&gt; P x0 (class_of R b))
     (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; dclass a b)
     (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a a&#39;) =&gt; dequiv_l a a&#39; b p)
     x) =
Quotient_ind R
  (<span class="kr">fun</span> <span class="nv">x0</span> : A / R =&gt; P x0 (class_of R b&#39;))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; dclass a b&#39;)
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> : A) (<span class="nv">p</span> : R a a&#39;) =&gt; dequiv_l a a&#39; b&#39; p)
  x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk35">srapply Quotient_ind_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A / R -&gt; A / R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R, IsHSet (P x y)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
P (class_of R a) (class_of R b)</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt; P x (class_of R b))
  (qglue p) (dclass a b) = 
dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport (P (class_of R a)) 
  (qglue p) (dclass a b) = 
dclass a b&#39;</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R b b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
transport (P (class_of R a)) (qglue p) (dclass a b) =
dclass a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> a; <span class="bp">by</span> <span class="nb">apply</span> dequiv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk36"><span class="kn">Definition</span> <span class="nf">Quotient_rec2</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A) (<span class="nv">B</span> : <span class="kt">Type</span>) `{IsHSet B}
  (dclass : A -&gt; A -&gt; B)
  (dequiv_l : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span>, R a a&#39; -&gt; dclass a b = dclass a&#39; b)
  (dequiv_r : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span>, R b b&#39; -&gt; dclass a b = dclass a b&#39;)
  : A / R -&gt; A / R -&gt; B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; A / R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; A / R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk38">srapply Quotient_ind2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
(<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> : A / R =&gt; B) (class_of R a) (class_of R b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk39"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> : A / R =&gt; B) x (class_of R b)) 
  (qglue p) (<span class="nl">?dclass</span> a b) = 
<span class="nl">?dclass</span> a&#39; b</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk3a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport ((<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> : A / R =&gt; B) (class_of R a))
  (qglue p) (<span class="nl">?dclass</span> a b) = 
<span class="nl">?dclass</span> a b&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
(<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> : A / R =&gt; B) (class_of R a) (class_of R b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> dclass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk3c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : R a a&#39;),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> : A / R =&gt; B) x (class_of R b)) (qglue p)
  (dclass a b) = dclass a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk3d"><span class="nb">intros</span>; lhs napply transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br><span><var>a, a', b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dclass a b = dclass a&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> dequiv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A) (<span class="nv">p</span> : R b b&#39;),
transport ((<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> : A / R =&gt; B) (class_of R a))
  (qglue p) (dclass a b) = dclass a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk3f"><span class="nb">intros</span>; lhs napply transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv_l</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a&#39;</span> <span class="nv">b</span> : A,
R a a&#39; -&gt; dclass a b = dclass a&#39; b</span></span></span><br><span><var>dequiv_r</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span> : A,
R b b&#39; -&gt; dclass a b = dclass a b&#39;</span></span></span><br><span><var>a, b, b'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R b b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dclass a b = dclass a b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> dequiv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Equiv</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence} {A : <span class="kt">Type</span>} (R : Relation A) `{is_mere_relation _ R}
    `{Transitive _ R} `{Symmetric _ R} `{Reflexive _ R}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The proposition of being in a given class in a quotient. This requires [Univalence] so that we know that [HProp] is a set. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk40"><span class="kn">Definition</span> <span class="nf">in_class</span> : A / R -&gt; A -&gt; HProp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; A -&gt; HProp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; A -&gt; HProp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk42"><span class="nb">intros</span> x b; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; HProp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk43">srapply Quotient_rec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; HProp</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk44"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b0</span> : A, R a b0 -&gt; <span class="nl">?pclass</span> a = <span class="nl">?pclass</span> b0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk45"><span class="mi">1</span>: <span class="nb">intro</span> a; <span class="bp">exact</span> (Build_HProp (R a b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b0</span> : A,
R a b0 -&gt;
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Build_HProp (R a0 b)) a =
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; Build_HProp (R a0 b)) b0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk46"><span class="nb">intros</span> a c p; <span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b, a, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_HProp (R a b) = Build_HProp (R c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk47"><span class="nb">apply</span> path_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b, a, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_HProp (R a b) &lt;~&gt; Build_HProp (R c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk48">srapply equiv_iff_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b, a, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b -&gt; R c b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b, a, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a c</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk49"><hr></label><div class="goal-conclusion">R c b -&gt; R a b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk4a"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="nb">transitivity</span> (<span class="nb">symmetry</span> _ _ p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>b, a, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R c b -&gt; R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="nb">transitivity</span> p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Being in a class is decidable if the relation is decidable. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk4b">#[export] <span class="kn">Instance</span> <span class="nf">decidable_in_class</span> `{<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, Decidable (R a b)}
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">a</span>, Decidable (in_class x a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, Decidable (R a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : A / R) (<span class="nv">a</span> : A), Decidable (in_class x a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk4c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, Decidable (R a b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : A / R) (<span class="nv">a</span> : A), Decidable (in_class x a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply Quotient_ind_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** If [a] is in a class [x], then the class of [a] is equal to [x]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk4d"><span class="kn">Lemma</span> <span class="nf">path_in_class_of</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">a</span>, in_class x a -&gt; x = class_of R a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : A / R) (<span class="nv">a</span> : A),
in_class x a -&gt; x = class_of R a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : A / R) (<span class="nv">a</span> : A),
in_class x a -&gt; x = class_of R a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk4f">srapply Quotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 <span class="kr">forall</span> <span class="nv">a0</span> : A, in_class x a0 -&gt; x = class_of R a0)
  (class_of R a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk50"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H3</span> : R a b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   <span class="kr">forall</span> <span class="nv">a0</span> : A, in_class x a0 -&gt; x = class_of R a0)
  (qglue H3) (<span class="nl">?pclass</span> a) = 
<span class="nl">?pclass</span> b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk51">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 <span class="kr">forall</span> <span class="nv">a0</span> : A, in_class x a0 -&gt; x = class_of R a0)
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk52"><span class="nb">intros</span> a b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>in_class (class_of R a) b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (qglue p).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk53">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   <span class="kr">forall</span> <span class="nv">a0</span> : A, in_class x a0 -&gt; x = class_of R a0)
  (qglue H)
  ((<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    (<span class="kr">fun</span> (<span class="nv">b0</span> : A) (<span class="nv">p</span> : in_class (class_of R a0) b0) =&gt;
     qglue p)
    :
    (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
     <span class="kr">forall</span> <span class="nv">a1</span> : A, in_class x a1 -&gt; x = class_of R a1)
      (class_of R a0)) a) =
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
 (<span class="kr">fun</span> (<span class="nv">b0</span> : A) (<span class="nv">p</span> : in_class (class_of R a0) b0) =&gt;
  qglue p)
 :
 (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
  <span class="kr">forall</span> <span class="nv">a1</span> : A, in_class x a1 -&gt; x = class_of R a1)
   (class_of R a0)) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk54"><span class="nb">intros</span> a b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   <span class="kr">forall</span> <span class="nv">a</span> : A, in_class x a -&gt; x = class_of R a)
  (qglue p)
  ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">p</span> : in_class (class_of R a) b) =&gt;
     qglue p)
    :
    (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
     <span class="kr">forall</span> <span class="nv">a0</span> : A, in_class x a0 -&gt; x = class_of R a0)
      (class_of R a)) a) =
(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
 (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">p</span> : in_class (class_of R a) b) =&gt;
  qglue p)
 :
 (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
  <span class="kr">forall</span> <span class="nv">a0</span> : A, in_class x a0 -&gt; x = class_of R a0)
   (class_of R a)) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk55">funext ? ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>in_class (class_of R b) x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   <span class="kr">forall</span> <span class="nv">a</span> : A, in_class x a -&gt; x = class_of R a)
  (qglue p)
  (<span class="kr">fun</span> (<span class="nv">b</span> : A) (<span class="nv">p</span> : in_class (class_of R a) b) =&gt;
   qglue p) x x0 = qglue x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> hset_path2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk56"><span class="kn">Lemma</span> <span class="nf">related_quotient_paths</span> (<span class="nv">a</span> <span class="nv">b</span> : A)
    : class_of R a = class_of R b -&gt; R a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R b -&gt; R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R b -&gt; R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk58"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>class_of R a = class_of R b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk59"><span class="nb">change</span> (in_class (class_of R a) b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>class_of R a = class_of R b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_class (class_of R a) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk5a"><span class="nb">destruct</span> p^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>class_of R b = class_of R b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_class (class_of R b) b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbv</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Theorem 10.1.8. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk5b"><span class="kn">Theorem</span> <span class="nf">path_quotient</span> (<span class="nv">a</span> <span class="nv">b</span> : A)
    : R a b &lt;~&gt; (class_of R a = class_of R b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b &lt;~&gt; class_of R a = class_of R b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b &lt;~&gt; class_of R a = class_of R b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk5d"><span class="nb">apply</span> equiv_iff_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b -&gt; class_of R a = class_of R b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk5e"><hr></label><div class="goal-conclusion">class_of R a = class_of R b -&gt; R a b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b -&gt; class_of R a = class_of R b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> qglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R b -&gt; R a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> related_quotient_paths.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The map [class_of : A -&gt; A/R] is a surjection. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk61">#[export] <span class="kn">Instance</span> <span class="nf">issurj_class_of</span> : IsSurjection (class_of R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) (class_of R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) (class_of R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk63"><span class="nb">apply</span> BuildIsSurjection.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : A / R, merely (hfiber (class_of R) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk64">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 trunctype_type (merely (hfiber (class_of R) x)))
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk65"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 trunctype_type (merely (hfiber (class_of R) x)))
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk66"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (class_of R) (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">a</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The universal property of the quotient.  This is Lemma 6.10.3. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk67"><span class="kn">Theorem</span> <span class="nf">equiv_quotient_ump</span> (<span class="nv">B</span> : <span class="kt">Type</span>) `{IsHSet B}
    : (A / R -&gt; B) &lt;~&gt; {f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b -&gt; f a = f b}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A / R -&gt; B) &lt;~&gt;
{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A / R -&gt; B) &lt;~&gt;
{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk69">srapply equiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A / R -&gt; B) -&gt;
{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk6a"><hr></label><div class="goal-conclusion">{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b} -&gt;
A / R -&gt; B</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk6b"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk6c"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk6d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A / R -&gt; B) -&gt;
{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk6e"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A / R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk6f"><span class="kr">exists</span> (<span class="nv">compose</span> <span class="nv">f</span> (class_of R)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A / R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
R a b -&gt; f (class_of R a) = f (class_of R b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk70"><span class="nb">intros</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A / R -&gt; B</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> qglue.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk71">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b} -&gt;
A / R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk72"><span class="nb">intros</span> [f H&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Quotient_rec _ _ _ H&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk73">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : A / R -&gt; B =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f (class_of R x);
 <span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b) =&gt; ap11 <span class="mi">1</span> (qglue H)))
o (<span class="kr">fun</span>
     <span class="nv">X</span> : {f : A -&gt; B &amp;
         <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b} =&gt;
   (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B)
      (<span class="nv">H&#39;</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b) =&gt;
    Quotient_rec R B f H&#39;) X.<span class="mi">1</span> X.<span class="mi">2</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk74"><span class="nb">intros</span> [f Hf].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; Quotient_rec R B f Hf (class_of R x);
<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b) =&gt; ap11 <span class="mi">1</span> (qglue H)) =
(f; Hf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_sigma_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk75">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">X</span> : {f : A -&gt; B &amp;
       <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b} =&gt;
 (<span class="kr">fun</span> (<span class="nv">f</span> : A -&gt; B)
    (<span class="nv">H&#39;</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; f a = f b) =&gt;
  Quotient_rec R B f H&#39;) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o (<span class="kr">fun</span> <span class="nv">f</span> : A / R -&gt; B =&gt;
   (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f (class_of R x);
   <span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b) =&gt; ap11 <span class="mi">1</span> (qglue H))) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk76"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A / R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_rec R B (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f (class_of R x))
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b) =&gt; ap11 <span class="mi">1</span> (qglue H)) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk77"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A / R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_rec R B (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f (class_of R x))
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b) =&gt; ap11 <span class="mi">1</span> (qglue H)) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk78">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_mere_relation0</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A / R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 Quotient_rec R B (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; f (class_of R x0))
   (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a0 b) =&gt; ap11 <span class="mi">1</span> (qglue H)) x =
 f x) (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** TODO: The equivalence with VVquotient [A//R].</span>
<span class="sd">  10.1.10.</span>
<span class="sd">    Equivalence Relations are effective and there is an equivalence [A/R&lt;~&gt;A//R].</span>

<span class="sd">    This will need propositional resizing if we don&#39;t want to raise the universe level.</span>
<span class="sd">*)</span>
<span class="sd">(**</span>
<span class="sd">  The theory of canonical quotients is developed by C.Cohen:</span>
<span class="sd">  http://perso.crans.org/cohen/work/quotients/</span>
<span class="sd"> *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Equiv</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Functoriality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* TODO: Develop a notion of set with Relation and use that instead of manually adding Relation preserving conditions. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk79"><span class="kn">Definition</span> <span class="nf">Quotient_functor</span>
    {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A)
    {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">S</span> : Relation B)
    (<span class="nv">f</span> : A -&gt; B) (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b -&gt; S (f a) (f b))
    : Quotient R -&gt; Quotient S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; S (f a) (f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; B / S</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; S (f a) (f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; B / S</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk7b"><span class="nb">refine</span> (Quotient_rec R _ (class_of S o f) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; S (f a) (f b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A,
R a b -&gt; class_of S (f a) = class_of S (f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk7c"><span class="nb">intros</span> a b p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; S (f a) (f b)</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of S (f a) = class_of S (f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> qglue, fresp, p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk7d"><span class="kn">Definition</span> <span class="nf">Quotient_functor_idmap</span>
    {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">R</span> : Relation A}
    : Quotient_functor R R idmap (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; idmap) == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R R idmap (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; idmap) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk7e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R R idmap (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; idmap) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply Quotient_ind_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk7f"><span class="kn">Definition</span> <span class="nf">Quotient_functor_compose</span>
    {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">R</span> : Relation A}
    {<span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">S</span> : Relation B}
    {<span class="nv">C</span> : <span class="kt">Type</span>} {<span class="nv">T</span> : Relation C}
    (<span class="nv">f</span> : A -&gt; B) (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b -&gt; S (f a) (f b))
    (<span class="nv">g</span> : B -&gt; C) (<span class="nv">gresp</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, S a b -&gt; T (g a) (g b))
    : Quotient_functor R T (g o f) (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; (gresp _ _) o (fresp a b))
    == Quotient_functor S T g gresp o Quotient_functor R S f fresp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Relation C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; S (f a) (f b)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>gresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : B, S a b -&gt; T (g a) (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R T (g o f)
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; gresp (f a) (f b) o fresp a b) ==
Quotient_functor S T g gresp
o Quotient_functor R S f fresp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>Relation C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b -&gt; S (f a) (f b)</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>gresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : B, S a b -&gt; T (g a) (g b)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R T (g o f)
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; gresp (f a) (f b) o fresp a b) ==
Quotient_functor S T g gresp
o Quotient_functor R S f fresp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply Quotient_ind_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A)
          {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">S</span> : Relation B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk81">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_quotient_functor</span> (<span class="nv">f</span> : A -&gt; B)
    (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b &lt;-&gt; S (f a) (f b)) `{IsEquiv _ _ f}
    : IsEquiv (Quotient_functor R S f (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; fst (fresp a b))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (Quotient_functor R S f
     (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; fst (fresp a b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (Quotient_functor R S f
     (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; fst (fresp a b)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk83">srapply (isequiv_adjointify _ (Quotient_functor S R f^-<span class="mi">1</span> _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : B, S a b -&gt; R (f^-<span class="mi">1</span> a) (f^-<span class="mi">1</span> b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk84" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk84"><hr></label><div class="goal-conclusion">Quotient_functor R S f
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; fst (fresp a b))
o Quotient_functor S R f^-<span class="mi">1</span> <span class="nl">?fresp</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk85" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk85"><hr></label><div class="goal-conclusion">Quotient_functor S R f^-<span class="mi">1</span> <span class="nl">?fresp</span>
o Quotient_functor R S f
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; fst (fresp a b)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk86">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : B, S a b -&gt; R (f^-<span class="mi">1</span> a) (f^-<span class="mi">1</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk87"><span class="nb">intros</span> a b s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>S a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (f^-<span class="mi">1</span> a) (f^-<span class="mi">1</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk88"><span class="nb">apply</span> (snd (fresp _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>S a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (f (f^-<span class="mi">1</span> a)) (f (f^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> eisretr; <span class="bp">exact</span> s).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk89">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Quotient_functor R S f
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; fst (fresp a b))
o Quotient_functor S R f^-<span class="mi">1</span>
    (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : B) (<span class="nv">s</span> : S a b) =&gt;
     snd (fresp (f^-<span class="mi">1</span> a) (f^-<span class="mi">1</span> b))
       (isequiv_quotient_functor_subproof f H a b s)) ==
idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk8a"><hr></label><div class="goal-conclusion">Quotient_functor S R f^-<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">a</span> <span class="nv">b</span> : B) (<span class="nv">s</span> : S a b) =&gt;
   snd (fresp (f^-<span class="mi">1</span> a) (f^-<span class="mi">1</span> b))
     (isequiv_quotient_functor_subproof f H a b s))
o Quotient_functor R S f
    (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; fst (fresp a b)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk8b"><span class="kp">all</span>: srapply Quotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : B,
(<span class="kr">fun</span> <span class="nv">x</span> : B / S =&gt;
 (Quotient_functor R S f
    (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : A =&gt; fst (fresp a0 b))
  o Quotient_functor S R f^-<span class="mi">1</span>
      (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b</span> : B) (<span class="nv">s</span> : S a0 b) =&gt;
       snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b))
         (isequiv_quotient_functor_subproof f H a0 b s)))
   x = idmap x) (class_of S a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk8c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : B) (<span class="nv">H0</span> : S a b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : B / S =&gt;
   (Quotient_functor R S f
      (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b0</span> : A =&gt; fst (fresp a0 b0))
    o Quotient_functor S R f^-<span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b0</span> : B) (<span class="nv">s</span> : S a0 b0) =&gt;
         snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b0))
           (isequiv_quotient_functor_subproof f H a0
              b0 s))) x = 
   idmap x) (qglue H0) (<span class="nl">?pclass</span> a) = 
<span class="nl">?pclass</span> b</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk8d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 (Quotient_functor S R f^-<span class="mi">1</span>
    (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b</span> : B) (<span class="nv">s</span> : S a0 b) =&gt;
     snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b))
       (isequiv_quotient_functor_subproof f H a0 b s))
  o Quotient_functor R S f
      (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : A =&gt; fst (fresp a0 b))) x = 
 idmap x) (class_of R a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk8e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H0</span> : R a b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   (Quotient_functor S R f^-<span class="mi">1</span>
      (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b0</span> : B) (<span class="nv">s</span> : S a0 b0) =&gt;
       snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b0))
         (isequiv_quotient_functor_subproof f H a0 b0
            s))
    o Quotient_functor R S f
        (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b0</span> : A =&gt; fst (fresp a0 b0))) x =
   idmap x) (qglue H0) (<span class="nl">?pclass0</span> a) = 
<span class="nl">?pclass0</span> b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk8f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : B,
(<span class="kr">fun</span> <span class="nv">x</span> : B / S =&gt;
 (Quotient_functor R S f
    (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : A =&gt; fst (fresp a0 b))
  o Quotient_functor S R f^-<span class="mi">1</span>
      (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b</span> : B) (<span class="nv">s</span> : S a0 b) =&gt;
       snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b))
         (isequiv_quotient_functor_subproof f H a0 b s)))
   x = idmap x) (class_of S a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk90"><span class="nb">intros</span> b; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of S (f (f^-<span class="mi">1</span> b)) = class_of S b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk91">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : B) (<span class="nv">H0</span> : S a b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : B / S =&gt;
   (Quotient_functor R S f
      (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b0</span> : A =&gt; fst (fresp a0 b0))
    o Quotient_functor S R f^-<span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b0</span> : B) (<span class="nv">s</span> : S a0 b0) =&gt;
         snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b0))
           (isequiv_quotient_functor_subproof f H a0
              b0 s))) x = idmap x) (qglue H0)
  ((<span class="kr">fun</span> <span class="nv">b0</span> : B =&gt;
    ap (class_of S) (eisretr f b0)
    :
    (<span class="kr">fun</span> <span class="nv">x</span> : B / S =&gt;
     (Quotient_functor R S f
        (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b1</span> : A =&gt; fst (fresp a0 b1))
      o Quotient_functor S R f^-<span class="mi">1</span>
          (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b1</span> : B) (<span class="nv">s</span> : S a0 b1) =&gt;
           snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b1))
             (isequiv_quotient_functor_subproof f H a0
                b1 s))) x = idmap x) (class_of S b0))
     a) =
(<span class="kr">fun</span> <span class="nv">b0</span> : B =&gt;
 ap (class_of S) (eisretr f b0)
 :
 (<span class="kr">fun</span> <span class="nv">x</span> : B / S =&gt;
  (Quotient_functor R S f
     (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b1</span> : A =&gt; fst (fresp a0 b1))
   o Quotient_functor S R f^-<span class="mi">1</span>
       (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b1</span> : B) (<span class="nv">s</span> : S a0 b1) =&gt;
        snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b1))
          (isequiv_quotient_functor_subproof f H a0 b1
             s))) x = idmap x) (class_of S b0)) b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk92">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 (Quotient_functor S R f^-<span class="mi">1</span>
    (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b</span> : B) (<span class="nv">s</span> : S a0 b) =&gt;
     snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b))
       (isequiv_quotient_functor_subproof f H a0 b s))
  o Quotient_functor R S f
      (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> : A =&gt; fst (fresp a0 b))) x = idmap x)
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk93"><span class="nb">intros</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R (f^-<span class="mi">1</span> (f a)) = class_of R a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk94">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, R a b &lt;-&gt; S (f a) (f b)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H0</span> : R a b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   (Quotient_functor S R f^-<span class="mi">1</span>
      (<span class="kr">fun</span> (<span class="nv">a0</span> <span class="nv">b0</span> : B) (<span class="nv">s</span> : S a0 b0) =&gt;
       snd (fresp (f^-<span class="mi">1</span> a0) (f^-<span class="mi">1</span> b0))
         (isequiv_quotient_functor_subproof f H a0 b0
            s))
    o Quotient_functor R S f
        (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b0</span> : A =&gt; fst (fresp a0 b0))) x =
   idmap x) (qglue H0)
  ((<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
    ap (class_of R) (eissect f a0)
    :
    (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
     (Quotient_functor S R f^-<span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">a1</span> <span class="nv">b0</span> : B) (<span class="nv">s</span> : S a1 b0) =&gt;
         snd (fresp (f^-<span class="mi">1</span> a1) (f^-<span class="mi">1</span> b0))
           (isequiv_quotient_functor_subproof f H a1
              b0 s))
      o Quotient_functor R S f
          (<span class="kr">fun</span> <span class="nv">a1</span> <span class="nv">b0</span> : A =&gt; fst (fresp a1 b0))) x =
     idmap x) (class_of R a0)) a) =
(<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt;
 ap (class_of R) (eissect f a0)
 :
 (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
  (Quotient_functor S R f^-<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">a1</span> <span class="nv">b0</span> : B) (<span class="nv">s</span> : S a1 b0) =&gt;
      snd (fresp (f^-<span class="mi">1</span> a1) (f^-<span class="mi">1</span> b0))
        (isequiv_quotient_functor_subproof f H a1 b0 s))
   o Quotient_functor R S f
       (<span class="kr">fun</span> <span class="nv">a1</span> <span class="nv">b0</span> : A =&gt; fst (fresp a1 b0))) x =
  idmap x) (class_of R a0)) b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_quotient_functor</span> (<span class="nv">f</span> : A -&gt; B) `{IsEquiv _ _ f}
    (fresp : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b &lt;-&gt; S (f a) (f b))
    : Quotient R &lt;~&gt; Quotient S
    := Build_Equiv _ _ (Quotient_functor R S f (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; fst (fresp a b))) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_quotient_functor&#39;</span> (<span class="nv">f</span> : A &lt;~&gt; B)
    (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, R a b &lt;-&gt; S (f a) (f b))
    : Quotient R &lt;~&gt; Quotient S
    := equiv_quotient_functor f fresp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Functoriality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Kernel</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Quotients of kernels of maps to sets give a surjection/mono factorization. *)</span>

  <span class="sd">(** Because the statement uses nested Sigma types, we need several variables to serve as [max] and [u+1]. We write [ar] for [max(a,r)], [ar&#39;] for [ar+1], etc. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">Universes a r ar ar&#39; b ab abr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Constraint</span> <span class="nf">a</span> &lt;= ar, r &lt;= ar, ar &lt; ar&#39;, a &lt;= ab, b &lt;= ab, ab &lt;= abr, ar &lt;= abr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A function we want to factor. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>@{a}} {<span class="nv">B</span> : <span class="kt">Type</span>@{b}} `{IsHSet B} (f : A -&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A mere Relation equivalent to its kernel. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">R</span> : Relation@{a r} A)
          (<span class="nv">is_ker</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x = f y &lt;~&gt; R x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The factorization theorem.  An advantage of stating it as one bundled result is that it is easier to state variations as we do below.  Disadvantages are that it requires more universe variables and that each piece of the answer depends on [Funext] and all of the universe variables, even when these aren&#39;t needed for that piece.  Below we will clean up the universe variables slightly, so we make this version [Local]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk95"><span class="kn">Local Definition</span> <span class="nf">quotient_kernel_factor_internal</span>
    : <span class="kr">exists</span> (<span class="nv">C</span> : <span class="kt">Type</span>@{ar}) (<span class="nv">e</span> : A -&gt; C) (<span class="nv">m</span> : C -&gt; B),
      IsHSet C * IsSurjection e * IsEmbedding m * (f = m o e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk97"><span class="kr">exists</span> (<span class="nv">Quotient</span> <span class="nv">R</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{e : A -&gt; A / R &amp;
{m : A / R -&gt; B &amp;
IsHSet (A / R) *
ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x)))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk98"><span class="kr">exists</span> (<span class="nv">class_of</span> <span class="nv">R</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : A / R -&gt; B &amp;
IsHSet (A / R) *
ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) (class_of R) *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (class_of R x)))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk99">srefine (_;_).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk9a"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">m</span> : A / R -&gt; B =&gt;
 IsHSet (A / R) *
 ReflectiveSubuniverse.IsConnMap 
   (Tr (-<span class="mi">1</span>)) (class_of R) * 
 IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (class_of R x))))
  <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk9b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A / R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk9c"><span class="nb">refine</span> (Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> =&gt; B) f _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H</span> : R a b),
transport (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) (qglue H) (f a) = f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk9d"><span class="nb">intros</span> x y p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) (qglue p) (f x) = f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk9e">lhs napply transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((is_ker x y)^-<span class="mi">1</span> p).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk9f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">m</span> : A / R -&gt; B =&gt;
 IsHSet (A / R) *
 ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>))
   (class_of R) * IsEmbedding m *
 (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (class_of R x))))
  (Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
     (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
      transport_const (qglue p) (f x) @
      (is_ker x y)^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka0"><span class="kp">repeat</span> <span class="nb">split</span>; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
     (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
      transport_const (qglue p) (f x) @
      (is_ker x y)^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka1"><span class="nb">intro</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  (hfiber
     (Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
        (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
         transport_const (qglue p) (f x) @
         (is_ker x y)^-<span class="mi">1</span> p)) u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka2"><span class="nb">apply</span> hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
(<span class="nv">x</span> : hfiber
       (Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
          (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
           transport_const (qglue p) (f x) @
           (is_ker x y)^-<span class="mi">1</span> p)) u)
(<span class="nv">y</span> : hfiber
       (Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
          (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x0 y) =&gt;
           transport_const (qglue p) (f x0) @
           (is_ker x0 y)^-<span class="mi">1</span> p)) u), x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka3"><span class="nb">intros</span> [x q] [y p&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) x = u</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) y = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x; q) = (y; p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka4"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) x = u</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A / R</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) y = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka5"><span class="nb">revert</span> x y q p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A / R,
Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
   transport_const (qglue p) (f x0) @
   (is_ker x0 y0)^-<span class="mi">1</span> p) x = u -&gt;
Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
   transport_const (qglue p) (f x0) @
   (is_ker x0 y0)^-<span class="mi">1</span> p) y = u -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka6">srapply Quotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : A / R,
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y0)^-<span class="mi">1</span> p) x = u -&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y0)^-<span class="mi">1</span> p) y = u -&gt; x = y)
  (class_of R a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="quotient-v-chka7"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">H0</span> : R a b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : A / R,
   Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
     (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
      transport_const (qglue p) (f x0) @
      (is_ker x0 y0)^-<span class="mi">1</span> p) x = u -&gt;
   Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
     (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
      transport_const (qglue p) (f x0) @
      (is_ker x0 y0)^-<span class="mi">1</span> p) y = u -&gt; 
   x = y) (qglue H0) (<span class="nl">?pclass</span> a) = 
<span class="nl">?pclass</span> b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka8"><span class="mi">2</span>: <span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : A / R,
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y0)^-<span class="mi">1</span> p) x = u -&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y0)^-<span class="mi">1</span> p) y = u -&gt; x = y)
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chka9"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : A / R,
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y0)^-<span class="mi">1</span> p) x = u -&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">p</span> : R x0 y0) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y0)^-<span class="mi">1</span> p) y = u -&gt; x = y)
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkaa">srapply Quotient_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x0 y) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y)^-<span class="mi">1</span> p) (class_of R a) = u -&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x0 y) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y)^-<span class="mi">1</span> p) x = u -&gt; class_of R a = x)
  (class_of R a0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chkab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="quotient-v-chkab"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a0</span> <span class="nv">b</span> : A) (<span class="nv">H0</span> : R a0 b),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
   Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
     (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x0 y) =&gt;
      transport_const (qglue p) (f x0) @
      (is_ker x0 y)^-<span class="mi">1</span> p) 
     (class_of R a) = u -&gt;
   Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
     (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x0 y) =&gt;
      transport_const (qglue p) (f x0) @
      (is_ker x0 y)^-<span class="mi">1</span> p) x = u -&gt; 
   class_of R a = x) (qglue H0) 
  (<span class="nl">?pclass</span> a0) = <span class="nl">?pclass</span> b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkac"><span class="mi">2</span>: <span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a0</span> : A,
(<span class="kr">fun</span> <span class="nv">x</span> : A / R =&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x0 y) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y)^-<span class="mi">1</span> p) (class_of R a) = u -&gt;
 Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x0 y) =&gt;
    transport_const (qglue p) (f x0) @
    (is_ker x0 y)^-<span class="mi">1</span> p) x = u -&gt; class_of R a = x)
  (class_of R a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkad"><span class="nb">intros</span> a&#39; p p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) (class_of R a) = u</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) (class_of R a&#39;) = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkae"><span class="nb">apply</span> qglue, is_ker.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) (class_of R a) = u</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>Quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : A / R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">p</span> : R x y) =&gt;
   transport_const (qglue p) (f x) @
   (is_ker x y)^-<span class="mi">1</span> p) (class_of R a&#39;) = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p @ p&#39;^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** We clean up the universe variables here, using only those declared in this Section. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quotient_kernel_factor_general</span>@{|}
    := <span class="kn">Eval</span> <span class="nb">unfold</span> quotient_kernel_factor_internal <span class="kr">in</span>
      quotient_kernel_factor_internal@{ar&#39; ar abr abr ab abr abr}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Kernel</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A common special case of [quotient_kernel_factor] is when we define [R] to be [f x = f y].  Then universes [r] and [b] are unified. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkaf"><span class="kn">Definition</span> <span class="nf">quotient_kernel_factor</span>@{a b ab ab&#39; | a &lt;= ab, b &lt;= ab, ab &lt; ab&#39;}
  `{Funext} {A : <span class="kt">Type</span>@{a}} {B : <span class="kt">Type</span>@{b}} `{IsHSet B} (f : A -&gt; B)
  : <span class="kr">exists</span> (<span class="nv">C</span> : <span class="kt">Type</span>@{ab}) (<span class="nv">e</span> : A -&gt; C) (<span class="nv">m</span> : C -&gt; B),
      IsHSet C * IsSurjection e * IsEmbedding m * (f = m o e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (quotient_kernel_factor_general@{a b ab ab&#39; b ab ab}
           f (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; f a = f b) (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; equiv_idmap)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If we use propositional resizing, we can replace [f x = f y] with a proposition [R x y] in universe [a], so that the universe of [C] is the same as the universe of [A]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb1"><span class="kn">Definition</span> <span class="nf">quotient_kernel_factor_small</span>@{a a&#39; b ab | a &lt; a&#39;, a &lt;= ab, b &lt;= ab}
  `{Funext} `{PropResizing}
  {A : <span class="kt">Type</span>@{a}} {B : <span class="kt">Type</span>@{b}} `{IsHSet B} (f : A -&gt; B)
  : <span class="kr">exists</span> (<span class="nv">C</span> : <span class="kt">Type</span>@{a}) (<span class="nv">e</span> : A -&gt; C) (<span class="nv">m</span> : C -&gt; B),
      IsHSet C * IsSurjection e * IsEmbedding m * (f = m o e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (quotient_kernel_factor_general@{a a a a&#39; b ab ab}
           f (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; smalltype@{a b} (f a = f b))
           (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; (equiv_smalltype _)^-<span class="mi">1</span>%equiv)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
