<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Core.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaf6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaf6"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types WildCat.Core WildCat.<span class="kn">Universe</span> <span class="nf">HFiber</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** Users of this file almost always want to be able to write [Tr n] for both a [Modality] and a [ReflectiveSubuniverse], so they want the coercion [modality_to_reflective_subuniverse]: *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> (coercions) Modalities.Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Truncations of types *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> X n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The definition *)</span>

<span class="sd">(** The definition of [Trunc n], the n-truncation of a type.</span>

<span class="sd">If Coq supported higher inductive types natively, we would construct this as something like:</span>

<span class="sd">   Inductive Trunc n (A : Type) : Type :=</span>
<span class="sd">   | tr : A -&gt; Trunc n A</span>
<span class="sd">   | istrunc_truncation : forall (f : Sphere n.+1 -&gt; Trunc n A)</span>
<span class="sd">       (x : Sphere n.+1), f x = f North.</span>

<span class="sd">However, while we are faking our higher-inductives anyway, we can take some shortcuts, rather than translating the definition above.  Firstly, we directly posit a ‚Äúconstructor‚Äù giving truncatedness, rather than rephrasing it in terms of maps of spheres.  Secondly, we omit the ‚Äúcomputation rule‚Äù for this constructor, since it is implied by truncatedness of the result type (and, for essentially that reason, is never wanted in practice anyway).</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Export</span> Trunc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Cumulative</span> Private <span class="kn">Inductive</span> <span class="nf">Trunc</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">A</span> :<span class="kt">Type</span>) : <span class="kt">Type</span> :=
    tr : A -&gt; Trunc n A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> tr {n A} a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Because [IsTrunc] is cumulative, we can use only one universe variable here. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaf7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaf7">#[export] <span class="kn">Instance</span> <span class="nf">istrunc_truncation</span>@{i} (n : trunc_index) (A : <span class="kt">Type</span>@{i})
    : IsTrunc@{i} n (Trunc@{i} n A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (Trunc n A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_ind</span> {<span class="nv">n</span> <span class="nv">A</span>}
    (<span class="nv">P</span> : Trunc n A -&gt; <span class="kt">Type</span>) {<span class="nv">Pt</span> : <span class="kr">forall</span> <span class="nv">aa</span>, IsTrunc n (P aa)}
    : (<span class="kr">forall</span> <span class="nv">a</span>, P (tr a)) -&gt; (<span class="kr">forall</span> <span class="nv">aa</span>, P aa)
    := <span class="kr">fun</span> <span class="nv">f</span> <span class="nv">aa</span> =&gt; <span class="kr">match</span> aa <span class="kr">with</span> tr a =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; f a <span class="kr">end</span> Pt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Trunc</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The non-dependent version of the eliminator. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_rec</span> {<span class="nv">n</span> <span class="nv">A</span> <span class="nv">X</span>} `{IsTrunc n X}
  : (A -&gt; X) -&gt; (Trunc n A -&gt; X)
  := Trunc_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_rec_tr</span> <span class="nv">n</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
  : Trunc_rec (A:=A) (tr (n:=n)) == idmap
  := Trunc_ind _ (<span class="kr">fun</span> <span class="nv">a</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Tactic to remove truncations in hypotheses if possible *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">strip_truncations</span> :=
  <span class="kp">progress</span> <span class="kp">repeat</span>
    <span class="kr">match goal with</span>
    | [ T : _ |- _ ]
      =&gt; revert_opaque T;
        <span class="nb">refine</span> (@Trunc_ind _ _ _ _ _);
        <span class="c">(* Ensure that we didn&#39;t generate more than one subgoal, i.e. that the goal was appropriately truncated: *)</span>
        [];
        <span class="nb">intro</span> T
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** See [strip_reflections] and [strip_modalities] for generalizations to other reflective subuniverses and modalities.  We provide this version because it sometimes needs fewer universes (due to the cumulativity of [Trunc]).  However, that same cumulativity sometimes causes free universe variables.  For a hypothesis of type [Trunc@{i} X], we can use [Trunc_ind@{i j}], but sometimes Coq uses [Trunc_ind@{k j}] with [i &lt;= k] and [k] otherwise free.  In these cases, [strip_reflections] and/or [strip_modalities] may generate fewer universe variables. *)</span>

<span class="sd">(** ** [Trunc] is a modality *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaf8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaf8"><span class="kn">Definition</span> <span class="nf">Tr</span> (<span class="nv">n</span> : trunc_index) : Modality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Modality</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaf9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaf9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Modality</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkafa" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkafa">srapply (Build_Modality (<span class="kr">fun</span> <span class="nv">A</span> =&gt; IsTrunc n A)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
IsTrunc n T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; IsTrunc n U</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkafb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkafb"><hr></label><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkafc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkafc"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsTrunc n (<span class="nl">?Goal0</span> T)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkafd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkafd"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, T -&gt; <span class="nl">?Goal0</span> T</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkafe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkafe"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : <span class="nl">?Goal0</span> A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">oa</span> : <span class="nl">?Goal0</span> A, IsTrunc n (B oa)) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, B (<span class="nl">?Goal2</span> A a)) -&gt;
<span class="kr">forall</span> <span class="nv">z</span> : <span class="nl">?Goal0</span> A, B z</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkaff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkaff"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : <span class="nl">?Goal0</span> A -&gt; <span class="kt">Type</span>)
(<span class="nv">B_inO</span> : <span class="kr">forall</span> <span class="nv">oa</span> : <span class="nl">?Goal0</span> A, IsTrunc n (B oa))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B (<span class="nl">?Goal2</span> A a)) (<span class="nv">a</span> : A),
<span class="nl">?Goal3</span> A B B_inO f (<span class="nl">?Goal2</span> A a) = f a</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkb00" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkb00"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt; <span class="kr">forall</span> <span class="nv">z</span> <span class="nv">z&#39;</span> : A, IsTrunc n (z = z&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb01" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb01">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
IsTrunc n T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; IsTrunc n U</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> A B ? f ?; <span class="bp">exact</span> (istrunc_isequiv_istrunc A f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb02" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb02">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Trunc n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb03" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb03">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsTrunc n (Trunc n T)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> istrunc_truncation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb04" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb04">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, T -&gt; Trunc n T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> A; <span class="bp">exact</span> tr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb05" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb05">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : Trunc n A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A, IsTrunc n (B oa)) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, B ((<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; tr) A a)) -&gt;
<span class="kr">forall</span> <span class="nv">z</span> : Trunc n A, B z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb06" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb06"><span class="nb">intros</span> A B ? f oa; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>Trunc n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A, IsTrunc n (B oa)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B (tr a)</span></span></span><br><span><var>oa</var><span class="hyp-type"><b>: </b><span>Trunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B oa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Trunc_ind B f oa).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb07" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb07">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : Trunc n A -&gt; <span class="kt">Type</span>)
(<span class="nv">B_inO</span> : <span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A, IsTrunc n (B oa))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B ((<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; tr) A a))
(<span class="nv">a</span> : A),
(<span class="kr">fun</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">B0</span> : Trunc n A0 -&gt; <span class="kt">Type</span>)
   (<span class="nv">B_inO0</span> : <span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A0, IsTrunc n (B0 oa))
   (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">a0</span> : A0,
         B0 ((<span class="kr">fun</span> <span class="nv">A1</span> : <span class="kt">Type</span> =&gt; tr) A0 a0))
   (<span class="nv">oa</span> : Trunc n A0) =&gt; Trunc_ind B0 f0 oa : B0 oa) A
  B B_inO f ((<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; tr) A a) = f a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb08" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb08">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt; <span class="kr">forall</span> <span class="nv">z</span> <span class="nv">z&#39;</span> : A, IsTrunc n (z = z&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@istrunc_paths&#39; n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We don&#39;t usually declare modalities as coercions, but this particular one is convenient so that lemmas about (for instance) connected maps can be applied to truncation modalities without the user/reader needing to be (particularly) aware of the general notion of modality. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Tr</span> : trunc_index &gt;-&gt; Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** However, if the coercion is not printed, then we get things like [Tr (-1) X] being printed as [(-1) X], which is terribly confusing.  So we tell Coq to always print this coercion.  This does mean that although the user can type things like [IsConnected n X], it will always be displayed back as [IsConnected (Tr n) X]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Add Printing Coercion</span> Tr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">TruncationModality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">n</span> : trunc_index).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trunc_iff_isequiv_truncation</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : IsTrunc n A &lt;-&gt; IsEquiv (@tr n A)
    := inO_iff_isequiv_to_O (Tr n) A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">isequiv_tr</span> <span class="nv">A</span> `{IsTrunc n A} : IsEquiv (@tr n A)
    := fst (trunc_iff_isequiv_truncation A) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_tr</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsTrunc n A}
    : A &lt;~&gt; Tr n A
  := Build_Equiv _ _ (@tr n A) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">untrunc_istrunc</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{IsTrunc n A}
    : Tr n A -&gt; A
    := (@tr n A)^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Functoriality *)</span>

  <span class="sd">(** Since a modality lives on a single universe, by default if we simply define [Trunc_functor] to be [O_functor] then it would force [X] and [Y] to live in the same universe.  But since we defined [Trunc] as a cumulative inductive, if we add universe annotations we can make [Trunc_functor] more universe-polymorphic than [O_functor] is.  This is sometimes useful.  *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor</span>@{i j k | i &lt;= k, j &lt;= k} {X : <span class="kt">Type</span>@{i}} {Y : <span class="kt">Type</span>@{j}} (f : X -&gt; Y)
    : Tr@{i} n X -&gt; Tr@{j} n Y
    := O_functor@{k k k} (Tr n) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">is0functor_Tr</span> : Is0Functor (Tr n)
    := Build_Is0Functor _ _ _ _ (Tr n) (@Trunc_functor).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">Trunc_functor_isequiv</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>}
    (<span class="nv">f</span> : X -&gt; Y) `{IsEquiv _ _ f}
    : IsEquiv (Trunc_functor f)
    := isequiv_O_functor (Tr n) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor_equiv</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X &lt;~&gt; Y)
    : Tr n X &lt;~&gt; Tr n Y
    := equiv_O_functor (Tr n) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor_compose</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">g</span> : Y -&gt; Z)
    : Trunc_functor (g o f) == Trunc_functor g o Trunc_functor f
    := O_functor_compose (Tr n) f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>)
    : @Trunc_functor X X idmap == idmap
    := O_functor_idmap (Tr n) X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_Trunc_prod_cmp</span> {<span class="nv">X</span> <span class="nv">Y</span>}
    : Tr n (X * Y) &lt;~&gt; Tr n X * Tr n Y
    := equiv_O_prod_cmp (Tr n) X Y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb09" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb09">#[export] <span class="kn">Instance</span> <span class="nf">is1functor_Tr</span> : Is1Functor (Tr n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb0a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb0a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb0b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb0b"><span class="nb">apply</span> Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap (Tr n) f $== fmap (Tr n) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkb0c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkb0c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, fmap (Tr n) (Id a) $== Id (Tr n a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chkb0d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chkb0d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (Tr n) (g $o f) $==
fmap (Tr n) g $o fmap (Tr n) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb0e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb0e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap (Tr n) f $== fmap (Tr n) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> @O_functor_homotopy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb0f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb0f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, fmap (Tr n) (Id a) $== Id (Tr n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> @Trunc_functor_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb10" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (Tr n) (g $o f) $==
fmap (Tr n) g $o fmap (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> @Trunc_functor_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">TruncationModality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We have to teach Coq to translate back and forth between [IsTrunc n] and [In (Tr n)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb11" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb11"><span class="kn">Instance</span> <span class="nf">inO_tr_istrunc</span> {<span class="nv">n</span> : trunc_index} (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsTrunc n A}
  : In (Tr n) A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Tr n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb12" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Tr n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Having both of these as [Instance]s would cause infinite loops. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb13" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb13"><span class="kn">Definition</span> <span class="nf">istrunc_inO_tr</span> {<span class="nv">n</span> : trunc_index} (<span class="nv">A</span> : <span class="kt">Type</span>) `{In (Tr n) A}
  : IsTrunc n A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Tr n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb14" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Tr n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Instead, we make the latter an immediate instance, but with high cost (i.e. low priority) so that it doesn&#39;t override the ordinary lemmas about truncation.  Unfortunately, [Hint Immediate] doesn&#39;t allow specifying a cost, so we use [Hint Extern] instead. *)</span>
<span class="sd">(** Hint Immediate istrunc_inO_tr : typeclass_instances. *)</span>
<span class="sd">(** See https://github.com/coq/coq/issues/11697 *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">1000</span> (IsTrunc _ _) =&gt; <span class="nb">simple apply</span> istrunc_inO_tr; <span class="kp">solve</span> [ <span class="nb">trivial</span> ] : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** This doesn&#39;t seem to be quite the same as [Hint Immediate] with a different cost either, though.  *)</span>

<span class="sd">(** Unfortunately, this isn&#39;t perfect; Coq still can&#39;t always find [In n] hypotheses in the context when it wants [IsTrunc].  You can always apply [istrunc_inO_tr] explicitly, but sometimes it also works to just [pose] it into the context (at the risk of causing loops in typeclass search). *)</span>

<span class="sd">(** We do the same for [IsTruncMap n] and [MapIn (Tr n)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb15" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb15"><span class="kn">Instance</span> <span class="nf">mapinO_tr_istruncmap</span> {<span class="nv">n</span> : trunc_index} {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; B) `{IsTruncMap n A B f}
  : MapIn (Tr n) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb16" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb17" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb17"><span class="kn">Definition</span> <span class="nf">istruncmap_mapinO_tr</span> {<span class="nv">n</span> : trunc_index} {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; B) `{MapIn (Tr n) _ _ f}
  : IsTruncMap n f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb18" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Immediate</span> istruncmap_mapinO_tr : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** How stability and decidability interact with truncation *)</span>

<span class="sd">(** For [n &gt;= -1], a stable type is logically equivalent to its [n]-truncation. (It follows that this is true for decidable types as well.) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb19" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb19"><span class="kn">Definition</span> <span class="nf">trunc_inhabited_iff_inhabited_stable</span> (<span class="nv">n</span> : trunc_index) {<span class="nv">A</span>} {<span class="nv">A_stable</span> : Stable A}
  : Tr n.+<span class="mi">1</span> A &lt;-&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n.+<span class="mi">1</span> A &lt;-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb1a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n.+<span class="mi">1</span> A &lt;-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb1b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb1b">nrefine (_, tr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n.+<span class="mi">1</span> A -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb1c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb1c"><span class="nb">intro</span> ma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb1d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb1d"><span class="nb">apply</span> stable; <span class="nb">intro</span> na.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>Tr n.+<span class="mi">1</span> A</span></span></span><br><span><var>na</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb1e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb1e">strip_truncations.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br><span><var>na</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (na ma).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The most common case involves [Tr (-1)], so we give it its own name. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">merely_inhabited_iff_inhabited_stable</span> {<span class="nv">A</span>} {<span class="nv">A_stable</span> : Stable A}
  : Tr (-<span class="mi">1</span>) A &lt;-&gt; A
  := trunc_inhabited_iff_inhabited_stable (-<span class="mi">2</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb1f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb1f"><span class="kn">Instance</span> <span class="nf">decidable_trunc_decidable</span> (<span class="nv">n</span> : trunc_index) {<span class="nv">A</span>} {<span class="nv">A_decidable</span> : Decidable A}
  : Decidable (Tr n.+<span class="mi">1</span> A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_decidable</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (Tr n.+<span class="mi">1</span> A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb20" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_decidable</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable (Tr n.+<span class="mi">1</span> A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb21" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb21">rapply decidable_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_decidable</var><span class="hyp-type"><b>: </b><span>Decidable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A &lt;-&gt; Tr n.+<span class="mi">1</span> A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; rapply trunc_inhabited_iff_inhabited_stable.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** A few special things about the (-2)-truncation *)</span>

<span class="sd">(** The type of contractible types is contractible. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb22" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb22"><span class="kn">Definition</span> <span class="nf">contr_tr_minus_two</span>@{u su | u &lt; su} `{Univalence}
  : Contr (Type_@{u su} (Tr (-<span class="mi">2</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Type_ (Tr (-<span class="mi">2</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb23" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (Type_ (Tr (-<span class="mi">2</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb24" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb24"><span class="nb">apply</span> (Build_Contr _ (exist@{su su} _ (Unit : <span class="kt">Type</span>@{u}) (inO_tr_istrunc _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : {x : _ &amp; In (Tr (-<span class="mi">2</span>)) x},
(Unit; inO_tr_istrunc Unit) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb25" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb25"><span class="nb">intros</span> [C ContrC].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ContrC</var><span class="hyp-type"><b>: </b><span>In (Tr (-<span class="mi">2</span>)) C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Unit; inO_tr_istrunc Unit) = (C; ContrC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb26" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb26"><span class="nb">apply</span> equiv_path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ContrC</var><span class="hyp-type"><b>: </b><span>In (Tr (-<span class="mi">2</span>)) C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Unit; inO_tr_istrunc Unit).<span class="mi">1</span> = (C; ContrC).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb27" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb27"><span class="nb">apply</span> path_universe_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ContrC</var><span class="hyp-type"><b>: </b><span>In (Tr (-<span class="mi">2</span>)) C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Unit; inO_tr_istrunc Unit).<span class="mi">1</span> &lt;~&gt; (C; ContrC).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> equiv_contr_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** A few special things about the (-1)-truncation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> trunc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We define [merely A] to be an inhabitant of the universe [hProp] of hprops, rather than a type.  We can always treat it as a type because there is a coercion, but this means that if we need an element of [hProp] then we don&#39;t need a separate name for it. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">merely</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}) : HProp@{i} := Build_HProp (Tr (-<span class="mi">1</span>) A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hexists</span> {<span class="nv">X</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">Type</span>) : HProp := merely (sig P).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hor</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>) : HProp := merely (P + Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> hprop_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A \/ B&quot;</span> := (hor A B) : hprop_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">himage</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) := image (Tr (-<span class="mi">1</span>)) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Surjections *)</span>

<span class="sd">(** Surjections are the (-1)-connected maps, but they can be characterized more simply since an inhabited hprop is automatically contractible. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">IsSurjection</span> := (IsConnMap (Tr (-<span class="mi">1</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb28" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb28"><span class="kn">Definition</span> <span class="nf">BuildIsSurjection</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B)
  : (<span class="kr">forall</span> <span class="nv">b</span>, merely (hfiber f b)) -&gt; IsSurjection f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B, merely (hfiber f b)) -&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb29" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B, merely (hfiber f b)) -&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb2a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb2a"><span class="nb">intros</span> H b; <span class="nb">refine</span> (contr_inhabited_hprop _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, merely (hfiber f b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A family of types is pointwise merely inhabited if and only if the corresponding fibration is surjective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb2b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb2b"><span class="kn">Lemma</span> <span class="nf">iff_merely_issurjection</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> <span class="nv">x</span>, merely (P x)) &lt;-&gt; IsSurjection (pr1 : {x : X &amp; P x} -&gt; X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;-&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb2c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;-&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb2d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb2d"><span class="nb">refine</span> (iff_compose _ (iff_forall_inO_mapinO_pr1 (Conn _) P)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : X, In (Conn (Tr (-<span class="mi">1</span>))) (P a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb2e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb2e"><span class="nb">apply</span> iff_functor_forall; <span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (P a) &lt;-&gt; In (Conn (Tr (-<span class="mi">1</span>))) (P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="bp">exact</span> (iff_contr_hprop (Tr (-<span class="mi">1</span>) (P a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb2f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb2f"><span class="kn">Lemma</span> <span class="nf">equiv_merely_issurjection</span> `{Funext} {X : <span class="kt">Type</span>} (P : X -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> <span class="nv">x</span>, merely (P x)) &lt;~&gt; IsSurjection (pr1 : {x : X &amp; P x} -&gt; X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;~&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb30" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb30"><span class="kn">Proof</span>. <span class="c">(* Can also be proved from equiv_forall_inO_mapinO_pr1. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;~&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_iff_hprop_uncurried (iff_merely_issurjection P)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Surjections cancel on the right *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb31" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb31"><span class="kn">Lemma</span> <span class="nf">cancelR_issurjection</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
      (<span class="nv">isconn</span> : IsSurjection (g o f))
  : IsSurjection g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb32" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb33" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb33"><span class="nb">intro</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) (hfiber g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb34" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb34">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb35" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb35">rapply (Trunc_functor _ (X:= (hfiber (g o f) c))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c -&gt; hfiber g c</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkb36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><label class="goal-separator" for="core-v-chkb36"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb37" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb37">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c -&gt; hfiber g c</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb38" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb38"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (f a) = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber g c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f a; p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb39" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb39">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> center, isconn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Retractions are surjective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb3a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb3a"><span class="kn">Definition</span> <span class="nf">issurj_retr</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} {<span class="nv">r</span> : X -&gt; Y} (<span class="nv">s</span> : Y -&gt; X) (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">y</span>:Y, r (s y) = y)
  : IsSurjection r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb3b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb3b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb3c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb3c"><span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) (hfiber r y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb3d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb3d">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber r y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tr (s y; h y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Embeddings *)</span>

<span class="sd">(** For any point in the image of an embedding, the fibers are contractible. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb3e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb3e"><span class="kn">Instance</span> <span class="nf">contr_hfiber_emb</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">a</span> : A) (<span class="nv">f</span> : A -&gt; B)
  `{IsEmbedding f}
  : Contr (hfiber f (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber f (f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb3f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (hfiber f (f a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb40" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb40">srapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f (f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (a; idpath (f a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Since embeddings are the (-1)-truncated maps, a map that is both a surjection and an embedding is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb41" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb41"><span class="kn">Definition</span> <span class="nf">isequiv_surj_emb</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B)
  `{IsSurjection f} `{IsEmbedding f}
  : IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb42" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (@isequiv_conn_ino_map (Tr (-<span class="mi">1</span>))); <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** As a corollary, it follows that if [i o f] is an equivalence and [i] is an embedding, then [f] is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb43" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb43"><span class="kn">Definition</span> <span class="nf">isequiv_isequiv_compose_embedding</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span> : <span class="kt">Type</span>}
  {<span class="nv">f</span> : X -&gt; Y} (<span class="nv">i</span> : Y -&gt; Z) `{IsEmbedding i}
  `{!IsEquiv (i o f)}
  : IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (i o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb44" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb44"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (i o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb45" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb45">rapply (cancelL_isequiv i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (i o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb46" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb46"><span class="nb">refine</span> (isequiv_surj_emb i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding i</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv (i o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply (cancelR_issurjection f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [X] is a set and [f : Y -&gt; Z] is a surjection, then [- o f] is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb47" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb47"><span class="kn">Definition</span> <span class="nf">isembedding_precompose_surjection_hset</span> `{Funext} {X Y Z : <span class="kt">Type</span>}
  `{IsHSet X} (f : Y -&gt; Z) `{IsSurjection f}
  : IsEmbedding (<span class="kr">fun</span> <span class="nv">phi</span> : Z -&gt; X =&gt; phi o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (<span class="kr">fun</span> <span class="nv">phi</span> : Z -&gt; X =&gt; phi o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb48" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (<span class="kr">fun</span> <span class="nv">phi</span> : Z -&gt; X =&gt; phi o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb49" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb49"><span class="nb">intros</span> phi; <span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
(<span class="nv">x</span> : hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
       phi)
(<span class="nv">y</span> : hfiber
       (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x0</span> : Y) =&gt; phi (f x0)) phi),
Contr (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb4a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb4a"><span class="nb">intros</span> g0 g1; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (g0 = g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb4b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb4b">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g0 = g1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb4c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb4c"><span class="nb">apply</span> path_sigma_hprop, equiv_path_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g0.<span class="mi">1</span> == g1.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb4d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb4d">rapply conn_map_elim; <span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g0.<span class="mi">1</span> (f y) = g1.<span class="mi">1</span> (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap10 (g0.<span class="mi">2</span> @ g1.<span class="mi">2</span>^) y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We next prove that [paths : X -&gt; (X -&gt; Type)] is an embedding. This was proved by Escard√≥ as Lemma 15 in &quot;Injective types in univalent mathematics&quot;, but we give an argument similar to the proof of Theorem 2.25 of CORS. *)</span>

<span class="sd">(** This will be an inverse to [ap paths].  We&#39;ll want to show that it is an embedding, so we&#39;ll construct it out of pieces that are clearly equivalences, except for one step, [equiv_fun]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb4e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb4e"><span class="kn">Definition</span> <span class="nf">ap_paths_inverse</span> `{Univalence} {X : <span class="kt">Type</span>} (x1 x2 : X)
  : paths x1 = paths x2 -&gt; x1 = x2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paths x1 = paths x2 -&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb4f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paths x1 = paths x2 -&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb50" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb50"><span class="nb">refine</span> (_ o @equiv_ap10 _ X <span class="kt">Type</span> (paths x1) (paths x2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paths x1 == paths x2 -&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb51" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb51"><span class="nb">refine</span> (_ o equiv_functor_forall_id (<span class="kr">fun</span> <span class="nv">y</span> =&gt; equiv_equiv_path (x1 = y) (x2 = y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : X, x1 = a &lt;~&gt; x2 = a) -&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb52" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb52"><span class="nb">refine</span> (_ o functor_forall_id (<span class="kr">fun</span> <span class="nv">y</span> =&gt; @equiv_fun (x1 = y) (x2 = y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : X, x1 = a -&gt; x2 = a) -&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb53" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb53"><span class="nb">refine</span> (_ o (equiv_paths_ind x1 (<span class="kr">fun</span> <span class="nv">y</span> <span class="nv">p</span> =&gt; x2 = y))^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x2 = x1 -&gt; x1 = x2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_path_inverse x2 x1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A Yoneda-like embedding for path types: [paths : X -&gt; (X -&gt; Type)] is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb54" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb54"><span class="kn">Definition</span> <span class="nf">isembedding_paths</span> `{Univalence} {X : <span class="kt">Type</span>@{u}} : IsEmbedding (@paths X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding paths</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb55" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding paths</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* To show that [paths] is an embedding, it suffices to show that [ap paths : x1 = x2 -&gt; (paths x1) = (paths x2)] is an equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb56" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb56">snapply isembedding_isequiv_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, IsEquiv (ap paths)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb57" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb57"><span class="nb">intros</span> x1 x2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (ap paths)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* And for that, it suffices to show that [i o (ap paths)] is an equivalence for a well-chosen embedding [i]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb58" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb58">snapply (isequiv_isequiv_compose_embedding (ap_paths_inverse x1 x2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (ap_paths_inverse x1 x2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkb59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="core-v-chkb59"><hr></label><div class="goal-conclusion">IsEquiv (ap_paths_inverse x1 x2 o ap paths)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb5a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb5a">- <span class="c">(* [ap_paths_inverse x1 x2] is an embedding since it is a composite of four equivalences and one embedding.  We can group these into three parts. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (ap_paths_inverse x1 x2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb5b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb5b"><span class="nb">unfold</span> ap_paths_inverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (<span class="kr">fun</span> <span class="nv">x</span> : paths x1 = paths x2 =&gt;
   equiv_path_inverse x2 x1
     ((equiv_paths_ind x1
         (<span class="kr">fun</span> (<span class="nv">y</span> : X) (<span class="nv">_</span> : x1 = y) =&gt; x2 = y))^-<span class="mi">1</span>%equiv
        (functor_forall_id (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; equiv_fun)
           (equiv_functor_forall_id
              (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt;
               equiv_equiv_path (x1 = y) (x2 = y))
              (equiv_ap10 (paths x1) (paths x2) x)))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb5c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb5c">nrefine (mapinO_compose (O:=Tr (-<span class="mi">1</span>)) _ (equiv_path_inverse x2 x1 oE _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : paths x1 = paths x2 =&gt;
   functor_forall_id (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; equiv_fun)
     (equiv_functor_forall_id
        (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt;
         equiv_equiv_path (x1 = y) (x2 = y))
        (equiv_ap10 (paths x1) (paths x2) x)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkb5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="core-v-chkb5d"><hr></label><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>))
  (equiv_path_inverse x2 x1
   oE (equiv_paths_ind x1
         (<span class="kr">fun</span> (<span class="nv">y</span> : X) (<span class="nv">_</span> : x1 = y) =&gt; x2 = y))^-<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb5e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb5e"><span class="mi">2</span>: <span class="bp">exact</span> _. <span class="c">(* The second part is an equivalence, so it&#39;s an embedding. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : paths x1 = paths x2 =&gt;
   functor_forall_id (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; equiv_fun)
     (equiv_functor_forall_id
        (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt;
         equiv_equiv_path (x1 = y) (x2 = y))
        (equiv_ap10 (paths x1) (paths x2) x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb5f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb5f">nrefine (mapinO_compose _ (functor_forall_id _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : paths x1 = paths x2 =&gt;
   equiv_functor_forall_id
     (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; equiv_equiv_path (x1 = y) (x2 = y))
     (equiv_ap10 (paths x1) (paths x2) x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkb60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><label class="goal-separator" for="core-v-chkb60"><hr></label><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>))
  (functor_forall_id (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; equiv_fun))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb61" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb61"><span class="mi">1</span>: <span class="bp">exact</span> _. <span class="c">(* The first part is an equivalence, so it&#39;s an embedding. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>))
  (functor_forall_id (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; equiv_fun))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb62" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb62">rapply mapinO_functor_forall_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : X, MapIn (Tr (-<span class="mi">1</span>)) equiv_fun</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb63" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb63"><span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>)) equiv_fun</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> isembedding_equiv_fun.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb64" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb64">- <span class="c">(* The composite is an equivalence because it is homotopic to the identity. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (ap_paths_inverse x1 x2 o ap paths)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb65" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb65"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : x1 = x2 =&gt;
   ap_paths_inverse x1 x2 (ap paths x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb66" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb66">srapply (isequiv_homotopic idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">idmap ==
(<span class="kr">fun</span> <span class="nv">x</span> : x1 = x2 =&gt;
 ap_paths_inverse x1 x2 (ap paths x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb67" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb67"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x1, x2</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = ap_paths_inverse x1 x1 (ap paths <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Iterated truncations *)</span>

<span class="sd">(** Compare to [O_leq_Tr] and [O_strong_leq_Tr] in SeparatedTrunc.v. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb68" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb68"><span class="kn">Definition</span> <span class="nf">O_leq_Tr_leq</span> {<span class="nv">n</span> <span class="nv">m</span> : trunc_index} (<span class="nv">Hmn</span> : m &lt;= n)
  : O_leq (Tr m) (Tr n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>Hmn</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_leq (Tr m) (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb69" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>Hmn</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_leq (Tr m) (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> A; rapply istrunc_leq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb6a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb6a"><span class="kn">Definition</span> <span class="nf">Trunc_min</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">X</span> : Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb6b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb6b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb6c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb6c"><span class="nb">destruct</span> (trunc_index_min_path n m) <span class="kr">as</span> [p|q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkb6d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = m</span></span></span><br></div><label class="goal-separator" for="core-v-chkb6d"><hr></label><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb6e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb6e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb6f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb6f"><span class="nb">assert</span> (l := trunc_index_min_leq_right n m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = n</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb70" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb70"><span class="nb">destruct</span> p^; <span class="nb">clear</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb71" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb71">snapply (Build_Equiv _ _ (Trunc_functor _ tr)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Trunc_functor n tr)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb72" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb72">napply O_inverts_conn_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) tr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb73" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb73">rapply (conn_map_O_leq _ (Tr m)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_leq (Tr n) (Tr m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply O_leq_Tr_leq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb74" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb74">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb75" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb75"><span class="nb">assert</span> (l := trunc_index_min_leq_left n m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = m</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb76" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb76"><span class="nb">destruct</span> q^; <span class="nb">clear</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr m X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb77" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb77">srapply equiv_tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">srapply istrunc_leq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb78" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb78"><span class="kn">Definition</span> <span class="nf">Trunc_swap</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">X</span> : Tr n (Tr m X) &lt;~&gt; Tr m (Tr n X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n (Tr m X) &lt;~&gt; Tr m (Tr n X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb79" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n (Tr m X) &lt;~&gt; Tr m (Tr n X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkb7a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkb7a"><span class="nb">refine</span> (Trunc_min m n _ oE equiv_transport (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Tr k _) _ oE (Trunc_min n m _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trunc_index_min n m = trunc_index_min m n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> trunc_index_min_swap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If you are looking for a theorem about truncation, you may want to read the note &quot;Finding Theorems&quot; in &quot;STYLE.md&quot;. *)</span></span></pre>
</div>
</div></body>
</html>
